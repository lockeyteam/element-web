import{U as y,E as Xe,a as $,C as fe,R as b,H as W,D as me,b as I,K as et,c as tt,d as st,S as it,e as rt,T as nt,f as ot,g as at,P as ct,h as we,Q as ke,V as C,i as ut,j,k as O,B as V,l as ht,L as ve,O as dt,m as gt,n as lt,o as yt,p as Se,q as Ne,r as be,s as pt,M as ft,t as _,u as Re,v as q,w as Ae,x as Le,y as xe,z as mt,A as ge,F as wt,G as kt,I as re,J as vt}from"./matrix-sdk-crypto-wasm-D9e1T4vy.js";import{d as St,g as bt,l as h,K as te,L as $e,e as E,D as se,E as S,H,T as F,h as g,j as p,k as he,m as ie,n as Rt,o as Kt,s as D,p as Z,q as Fe,r as Ge,u as Je,v as We,w as x,I as A,M as je,A as Et,x as Mt,y as de,z as It,U as Ke,B as Q,S as Ee,F as Me,G as ne,J as Ie,N as v,O as k,P as X,Q as T,R as G,V as K,W as Ct}from"./index-K2xIZ1TO.js";try{let e=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},t=(new e.Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="859ae741-c133-4977-a72e-91755c44d3f2",e._sentryDebugIdIdentifier="sentry-dbid-859ae741-c133-4977-a72e-91755c44d3f2")}catch{}var P=(e=>(e.Change="change",e))(P||{}),m=(e=>(e[e.Unsent=1]="Unsent",e[e.Requested=2]="Requested",e[e.Ready=3]="Ready",e[e.Started=4]="Started",e[e.Cancelled=5]="Cancelled",e[e.Done=6]="Done",e))(m||{}),le=(e=>(e.Cancel="cancel",e.ShowSas="show_sas",e.ShowReciprocateQr="show_reciprocate_qr",e))(le||{});const oe=[139,1];function Ce(e){var t;const s=new Uint8Array(oe.length+e.length+1);s.set(oe,0),s.set(e,oe.length);let i=0;for(let e=0;e<s.length-1;++e)i^=s[e];return s[s.length-1]=i,null==(t=St.encode(s).match(/.{1,4}/g))?void 0:t.join(" ")}const _t=256;async function He(e,t,s,i=_t){if(!globalThis.crypto.subtle||!TextEncoder)throw new Error("Password-based backup is not available on this platform");const n=await globalThis.crypto.subtle.importKey("raw",(new TextEncoder).encode(e),{name:"PBKDF2"},!1,["deriveBits"]),r=await globalThis.crypto.subtle.deriveBits({name:"PBKDF2",salt:(new TextEncoder).encode(t),iterations:s,hash:"SHA-512"},n,i);return new Uint8Array(r)}var ae,_e,R=(e=>(e.Sas="m.sas.v1",e.ShowQrCode="m.qr_code.show.v1",e.ScanQrCode="m.qr_code.scan.v1",e.Reciprocate="m.reciprocate.v1",e))(R||{});function Dt(){if(_e)return ae;_e=1;for(var e=/[\\\"\x00-\x1F]/g,t={},s=0;s<32;++s)t[String.fromCharCode(s)]="\\U"+("0000"+s.toString(16)).slice(-4).toUpperCase();function i(s){return e.lastIndex=0,s.replace(e,(function(e){return t[e]}))}function n(e){switch(typeof e){case"string":return'"'+i(e)+'"';case"number":return isFinite(e)?e:"null";case"boolean":return e;case"object":return null===e?"null":Array.isArray(e)?function(e){for(var t="[",s="",i=0;i<e.length;++i)s+=t,t=",",s+=n(e[i]);return","!=t?"[]":s+"]"}(e):function(e){var t="{",s="",r=Object.keys(e);r.sort();for(var o=0;o<r.length;++o){var a=r[o];s+=t+'"'+i(a)+'":',t=",",s+=n(e[a])}return","!=t?"{}":s+"}"}(e);default:throw new Error("Cannot stringify: "+typeof e)}}return t["\b"]="\\b",t["\t"]="\\t",t["\n"]="\\n",t["\f"]="\\f",t["\r"]="\\r",t['"']='\\"',t["\\"]="\\\\",ae={stringify:n}}var Bt=Dt();const Ot=bt(Bt);class qt{constructor(e,t,s,i,n){this.olmMachine=e,this.keyClaimManager=t,this.outgoingRequestManager=s,this.room=i,this.encryptionSettings=n,this.lazyLoadedMembersResolved=!1,this.currentEncryptionPromise=Promise.resolve(),this.prefixedLogger=h.getChild(`[${i.roomId} encryption]`);const r=i.getJoinedMembers();this.olmMachine.updateTrackedUsers(r.map((e=>new y(e.userId)))).catch((e=>this.prefixedLogger.error("Error initializing tracked users",e)))}onCryptoEvent(e){if(JSON.stringify(this.encryptionSettings)!=JSON.stringify(e))throw new Error("Cannot reconfigure an active RoomEncryptor")}onRoomMembership(e){(e.membership==te.Join||e.membership==te.Invite&&this.room.shouldEncryptForInvitedMembers())&&this.olmMachine.updateTrackedUsers([new y(e.userId)]).catch((e=>{this.prefixedLogger.error("Unable to update tracked users",e)}))}async prepareForEncryption(e,t){await this.encryptEvent(null,e,t)}encryptEvent(e,t,s){const i=new $e(this.prefixedLogger,e?e.getTxnId()??"":"prepareForEncryption"),n=this.currentEncryptionPromise.catch((()=>{})).then((async()=>{await E(i,"ensureEncryptionSession",(async()=>{await this.ensureEncryptionSession(i,t,s)})),e&&await E(i,"encryptEventInner",(async()=>{await this.encryptEventInner(i,e)}))}));return this.currentEncryptionPromise=n,n}async ensureEncryptionSession(e,t,s){if("m.megolm.v1.aes-sha2"!==this.encryptionSettings.algorithm)throw new Error(`Cannot encrypt in ${this.room.roomId} for unsupported algorithm '${this.encryptionSettings.algorithm}'`);e.debug("Starting encryption");const i=await this.room.getEncryptionTargetMembers();this.lazyLoadedMembersResolved?(e.debug("Processing outgoing requests in background"),this.outgoingRequestManager.doProcessOutgoingRequests()):(await E(this.prefixedLogger,"loadMembersIfNeeded: updateTrackedUsers",(async()=>{await this.olmMachine.updateTrackedUsers(i.map((e=>new y(e.userId))))})),e.debug("Updated tracked users"),this.lazyLoadedMembersResolved=!0,e.debug("Processing outgoing requests"),await E(this.prefixedLogger,"doProcessOutgoingRequests",(async()=>{await this.outgoingRequestManager.doProcessOutgoingRequests()}))),e.debug(`Encrypting for users (shouldEncryptForInvitedMembers: ${this.room.shouldEncryptForInvitedMembers()}):`,i.map((e=>`${e.userId} (${e.membership})`)));const n=i.map((e=>new y(e.userId)));await E(this.prefixedLogger,"ensureSessionsForUsers",(async()=>{await this.keyClaimManager.ensureSessionsForUsers(e,n)}));const r=new Xe;switch(r.historyVisibility=Tt(this.room.getHistoryVisibility()),r.algorithm=$.MegolmV1AesSha2,"number"==typeof this.encryptionSettings.rotation_period_ms&&(r.rotationPeriod=BigInt(1e3*this.encryptionSettings.rotation_period_ms)),"number"==typeof this.encryptionSettings.rotation_period_msgs&&(r.rotationPeriodMessages=BigInt(this.encryptionSettings.rotation_period_msgs)),s.kind){case se.AllDevicesIsolationMode:{const e=this.room.getBlacklistUnverifiedDevices()??t;r.sharingStrategy=fe.deviceBasedStrategy(e,s.errorOnVerifiedUserProblems)}break;case se.OnlySignedDevicesIsolationMode:r.sharingStrategy=fe.identityBasedStrategy()}await E(this.prefixedLogger,"shareRoomKey",(async()=>{const e=await this.olmMachine.shareRoomKey(new b(this.room.roomId),n,r);if(e)for(const t of e)await this.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(t)}))}async forceDiscardSession(){await this.olmMachine.invalidateGroupSession(new b(this.room.roomId))&&this.prefixedLogger.info("Discarded existing group session")}async encryptEventInner(e,t){e.debug("Encrypting actual message content");const s=await this.olmMachine.encryptRoomEvent(new b(this.room.roomId),t.getType(),JSON.stringify(t.getContent()));t.makeEncrypted(S.RoomMessageEncrypted,JSON.parse(s),this.olmMachine.identityKeys.curve25519.toBase64(),this.olmMachine.identityKeys.ed25519.toBase64()),e.debug("Encrypted event successfully")}}function Tt(e){switch(e){case H.Invited:return W.Invited;case H.Joined:return W.Joined;case H.Shared:return W.Shared;case H.WorldReadable:return W.WorldReadable}}const L="/_matrix/client/unstable/org.matrix.msc3814.v1",ce="org.matrix.msc3814",Ut=6048e5;class Pt extends F{constructor(e,t,s,i,n){super(),this.logger=e,this.olmMachine=t,this.http=s,this.outgoingRequestProcessor=i,this.secretStorage=n}async cacheKey(e){await this.olmMachine.dehydratedDevices().saveDehydratedDeviceKey(e),this.emit(g.DehydrationKeyCached)}async isSupported(){try{await this.http.authedRequest(p.Get,"/dehydrated_device",void 0,void 0,{prefix:L})}catch(e){const t=e;if("M_UNRECOGNIZED"===t.errcode)return!1;if("M_NOT_FOUND"===t.errcode)return!0;throw e}return!0}async start(e={}){if("boolean"==typeof e&&(e={createNewKey:e}),!e.onlyIfKeyCached||await this.olmMachine.dehydratedDevices().getDehydratedDeviceKey()){if(this.stop(),!1!==e.rehydrate)try{await this.rehydrateDeviceIfAvailable()}catch(e){this.logger.info("dehydration: Error rehydrating device:",e),this.emit(g.RehydrationError,e.message)}e.createNewKey&&await this.resetKey(),await this.scheduleDeviceDehydration()}}async isKeyStored(){return!!await this.secretStorage.isStored(ce)}async resetKey(){const e=me.createRandomKey();return await this.secretStorage.store(ce,e.toBase64()),await this.cacheKey(e),e}async getKey(e){const t=await this.olmMachine.dehydratedDevices().getDehydratedDeviceKey();if(t)return t;const s=await this.secretStorage.get(ce);if(void 0===s)return e?await this.resetKey():null;const i=he(s);try{const e=me.createKeyFromArray(i);return await this.cacheKey(e),e}finally{i.fill(0)}}async rehydrateDeviceIfAvailable(){const e=await this.getKey(!1);if(!e)return!1;let t;try{t=await this.http.authedRequest(p.Get,"/dehydrated_device",void 0,void 0,{prefix:L})}catch(e){const t=e;if("M_NOT_FOUND"===t.errcode||"M_UNRECOGNIZED"===t.errcode)return this.logger.info("dehydration: No dehydrated device"),!1;throw t}this.logger.info("dehydration: dehydrated device found"),this.emit(g.RehydrationStarted);const s=await this.olmMachine.dehydratedDevices().rehydrate(e,new I(t.device_id),JSON.stringify(t.device_data));this.logger.info("dehydration: device rehydrated");let i,n=0,r=0;const o=ie("/dehydrated_device/$device_id/events",{$device_id:t.device_id});for(;;){const e=await this.http.authedRequest(p.Post,o,void 0,i?{next_batch:i}:{},{prefix:L});if(0===e.events.length)break;n+=e.events.length,i=e.next_batch;r+=(await s.receiveEvents(JSON.stringify(e.events))).length,this.emit(g.RehydrationProgress,r,n)}return this.logger.info(`dehydration: received ${r} room keys from ${n} to-device events`),this.emit(g.RehydrationCompleted),!0}async createAndUploadDehydratedDevice(){const e=await this.getKey(!0),t=await this.olmMachine.dehydratedDevices().create();this.emit(g.DehydratedDeviceCreated);const s=await t.keysForUpload("Dehydrated device",e);await this.outgoingRequestProcessor.makeOutgoingRequest(s),this.emit(g.DehydratedDeviceUploaded),this.logger.info("dehydration: uploaded device")}async scheduleDeviceDehydration(){this.stop(),await this.createAndUploadDehydratedDevice(),this.intervalId=setInterval((()=>{this.createAndUploadDehydratedDevice().catch((e=>{this.emit(g.DehydratedDeviceRotationError,e.message),this.logger.error("Error creating dehydrated device:",e)}))}),Ut)}stop(){this.intervalId&&(clearInterval(this.intervalId),this.intervalId=void 0)}async delete(){this.stop();try{await this.http.authedRequest(p.Delete,"/dehydrated_device",void 0,{},{prefix:L})}catch(e){const t=e;if("M_UNRECOGNIZED"===t.errcode)return;if("M_NOT_FOUND"===t.errcode)return;throw e}}}class Vt{constructor(e,t){this.olmMachine=e,this.http=t}async makeOutgoingRequest(e,t){let s;if(e instanceof et)s=await this.requestWithRetry(p.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof tt)s=await this.requestWithRetry(p.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof st)s=await this.requestWithRetry(p.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof it)s=await this.requestWithRetry(p.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof rt)s=await this.requestWithRetry(p.Put,"/_matrix/client/v3/room_keys/keys",{version:e.version},e.body);else if(e instanceof nt)s=await this.sendToDeviceRequest(e);else if(e instanceof ot){const t=`/_matrix/client/v3/rooms/${encodeURIComponent(e.room_id)}/send/${encodeURIComponent(e.event_type)}/${encodeURIComponent(e.txn_id)}`;s=await this.requestWithRetry(p.Put,t,{},e.body)}else{if(e instanceof at)return void await this.makeRequestWithUIA(p.Post,"/_matrix/client/v3/keys/device_signing/upload",{},e.body,t);if(e instanceof ct){const t=L+"/dehydrated_device";return void await this.rawJsonRequest(p.Put,t,{},e.body)}h.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),s=""}if(e.id)try{await E(h,`Mark Request as sent ${e.type}`,(async()=>{await this.olmMachine.markRequestAsSent(e.id,e.type,s)}))}catch(e){if(!(e instanceof Error)||"Attempt to use a moved value"!==e.message&&"null pointer passed to rust"!==e.message)throw e;h.log(`Ignoring error '${e.message}': client is likely shutting down`)}else h.trace(`Outgoing request type:${e.type} does not have an ID`)}async sendToDeviceRequest(e){const t=JSON.parse(e.body),s=[];for(const[e,i]of Object.entries(t.messages))for(const[t,n]of Object.entries(i))s.push(`${e}/${t} (msgid ${n[Rt]})`);h.info(`Sending batch of to-device messages. type=${e.event_type} txnid=${e.txn_id}`,s);const i=`/_matrix/client/v3/sendToDevice/${encodeURIComponent(e.event_type)}/`+encodeURIComponent(e.txn_id);return await this.requestWithRetry(p.Put,i,{},e.body)}async makeRequestWithUIA(e,t,s,i,n){if(!n)return await this.requestWithRetry(e,t,s,i);const r=JSON.parse(i),o=await n((async i=>{const n={...r};null!==i&&(n.auth=i);const o=await this.requestWithRetry(e,t,s,JSON.stringify(n));return JSON.parse(o)}));return JSON.stringify(o)}async requestWithRetry(e,t,s,i){let n=0;for(;;)try{return await this.rawJsonRequest(e,t,s,i)}catch(e){n++;const t=Kt(e,n,!0);if(t<0)throw e;await D(t)}}async rawJsonRequest(e,t,s,i){return await this.http.authedRequest(e,t,s,i,{json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:""})}}class Nt{constructor(e,t){this.olmMachine=e,this.outgoingRequestProcessor=t,this.stopped=!1,this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e,t){const s=this.currentClaimPromise.catch((()=>{})).then((()=>this.ensureSessionsForUsersInner(e,t)));return this.currentClaimPromise=s,s}async ensureSessionsForUsersInner(e,t){if(this.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");e.info("Checking for missing Olm sessions");const s=await this.olmMachine.getMissingSessions(t.map((e=>e.clone())));s&&(e.info("Making /keys/claim request"),await this.outgoingRequestProcessor.makeOutgoingRequest(s)),e.info("Olm sessions prepared")}}function At(e,t){const s=new Map;for(const[t,i]of e.keys.entries())s.set(t.toString(),i.toBase64());let i=Z.Unverified;e.isBlacklisted()?i=Z.Blocked:e.isVerified()&&(i=Z.Verified);const n=new Map,r=e.signatures.get(t);if(r){const e=new Map;for(const[t,s]of r.entries())s.isValid()&&s.signature&&e.set(t,s.signature.toBase64());n.set(t.toString(),e)}const o=e.algorithms,a=new Set;return o.forEach((e=>{switch(e){case $.MegolmV1AesSha2:a.add("m.megolm.v1.aes-sha2");break;case $.OlmV1Curve25519AesSha2:default:a.add("m.olm.v1.curve25519-aes-sha2")}})),new Fe({deviceId:e.deviceId.toString(),userId:t.toString(),keys:s,algorithms:Array.from(a),verified:i,signatures:n,displayName:e.displayName,dehydrated:e.isDehydrated})}function Lt(e){return new Map(Object.entries(e).map((([e,t])=>[e,xt(t)])))}function xt(e){var t;const s=new Map(Object.entries(e.keys)),i=null==(t=e.unsigned)?void 0:t.device_display_name,n=new Map;if(e.signatures)for(const t in e.signatures)n.set(t,new Map(Object.entries(e.signatures[t])));return new Fe({deviceId:e.device_id,userId:e.user_id,keys:s,algorithms:e.algorithms,verified:Z.Unverified,signatures:n,displayName:i})}class $t{constructor(e,t,s){this.olmMachine=e,this.outgoingRequestProcessor=t,this.secretStorage=s}async bootstrapCrossSigning(e){if(e.setupNewCrossSigning)return void await this.resetCrossSigning(e.authUploadDeviceSigningKeys);const t=await this.olmMachine.crossSigningStatus(),s=await this.secretStorage.get("m.cross_signing.master"),i=await this.secretStorage.get("m.cross_signing.self_signing"),n=await this.secretStorage.get("m.cross_signing.user_signing"),r=!!(s&&i&&n),o=t.hasMaster&&t.hasUserSigning&&t.hasSelfSigning;if(h.log("bootstrapCrossSigning: starting",{setupNewCrossSigning:e.setupNewCrossSigning,olmDeviceHasMaster:t.hasMaster,olmDeviceHasUserSigning:t.hasUserSigning,olmDeviceHasSelfSigning:t.hasSelfSigning,privateKeysInSecretStorage:r}),o)await this.secretStorage.hasKey()?r?h.log("bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing"):(h.log("bootstrapCrossSigning: Olm device has private keys: exporting to secret storage"),await this.exportCrossSigningKeysToStorage()):h.warn("bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.");else if(r){h.log("bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally");const e=await this.olmMachine.importCrossSigningKeys(s,i,n);if(!e.hasMaster||!e.hasSelfSigning||!e.hasUserSigning)throw new Error("importCrossSigningKeys failed to import the keys");const t=await this.olmMachine.getDevice(this.olmMachine.userId,this.olmMachine.deviceId);try{const e=await t.verify();await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{t.free()}}else h.log("bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys"),await this.resetCrossSigning(e.authUploadDeviceSigningKeys);h.log("bootstrapCrossSigning: complete")}async resetCrossSigning(e){const t=await this.olmMachine.bootstrapCrossSigning(!0);await this.secretStorage.hasKey()?(h.log("resetCrossSigning: exporting private keys to secret storage"),await this.exportCrossSigningKeysToStorage()):h.warn("resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet."),h.log("resetCrossSigning: publishing public keys to server");for(const s of[t.uploadKeysRequest,t.uploadSigningKeysRequest,t.uploadSignaturesRequest])s&&await this.outgoingRequestProcessor.makeOutgoingRequest(s,e)}async exportCrossSigningKeysToStorage(){const e=await this.olmMachine.exportCrossSigningKeys();null!=e&&e.masterKey?await this.secretStorage.store("m.cross_signing.master",e.masterKey):h.error("Cannot export MSK to secret storage, private key unknown"),null!=e&&e.self_signing_key?await this.secretStorage.store("m.cross_signing.self_signing",e.self_signing_key):h.error("Cannot export SSK to secret storage, private key unknown"),null!=e&&e.userSigningKey?await this.secretStorage.store("m.cross_signing.user_signing",e.userSigningKey):h.error("Cannot export USK to secret storage, private key unknown")}}async function De(e){return Qe(e,["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"])}async function Qe(e,t){const s=await e.getDefaultKeyId();if(!s)return!1;for(const i of t){if(!(s in(await e.isStored(i)||{})))return!1}return!0}class U extends F{constructor(e,t,s,i){super(),this.olmMachine=e,this.inner=t,this.outgoingRequestProcessor=s,this.supportedVerificationMethods=i,this._accepting=!1,this._cancelling=!1,this.reEmitter=new Ge(this);const n=new WeakRef(this);t.registerChangesCallback((async()=>{var e;return null==(e=n.deref())?void 0:e.onChange()}))}onChange(){const e=this.inner.getVerification();e instanceof we?void 0===this._verifier||this._verifier instanceof Be?this.setVerifier(new Oe(e,this,this.outgoingRequestProcessor)):this._verifier instanceof Oe&&this._verifier.replaceInner(e):e instanceof ke&&void 0===this._verifier&&this.setVerifier(new Be(e,this.outgoingRequestProcessor)),this.emit(P.Change)}setVerifier(e){this._verifier&&this.reEmitter.stopReEmitting(this._verifier,[P.Change]),this._verifier=e,this.reEmitter.reEmit(this._verifier,[P.Change])}get transactionId(){return this.inner.flowId}get roomId(){var e;return null==(e=this.inner.roomId)?void 0:e.toString()}get initiatedByMe(){return this.inner.weStarted()}get otherUserId(){return this.inner.otherUserId.toString()}get otherDeviceId(){var e;return null==(e=this.inner.otherDeviceId)?void 0:e.toString()}async getOtherDevice(){const e=this.inner.otherDeviceId;if(e)return await this.olmMachine.getDevice(this.inner.otherUserId,e,5)}get isSelfVerification(){return this.inner.isSelfVerification()}get phase(){const e=this.inner.phase();switch(e){case C.Created:case C.Requested:return m.Requested;case C.Ready:return this._accepting?m.Requested:m.Ready;case C.Transitioned:if(!this._verifier)throw new Error("VerificationRequest: inner phase == Transitioned but no verifier!");return this._verifier.verificationPhase;case C.Done:return m.Done;case C.Cancelled:return m.Cancelled}throw new Error(`Unknown verification phase ${e}`)}get pending(){if(this.inner.isPassive())return!1;const e=this.phase;return e!==m.Done&&e!==m.Cancelled}get accepting(){return this._accepting}get declining(){return this._cancelling}get timeout(){return this.inner.timeRemainingMillis()}get methods(){throw new Error("not implemented")}get chosenMethod(){if(this.phase!==m.Started)return null;const e=this.inner.getVerification();return e instanceof we?R.Sas:e instanceof ke?R.Reciprocate:null}otherPartySupportsMethod(e){const t=this.inner.theirSupportedMethods;if(void 0===t)return!1;const s=ze[e];return t.some((e=>e===s))}async accept(){if(this.inner.phase()!==C.Requested||this._accepting)throw new Error(`Cannot accept a verification request in phase ${this.phase}`);this._accepting=!0;try{const e=this.inner.acceptWithMethods(this.supportedVerificationMethods.map(ee));e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{this._accepting=!1}this.emit(P.Change)}async cancel(e){if(!this._cancelling){this._cancelling=!0;try{const e=this.inner.cancel();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{this._cancelling=!1}}}beginKeyVerification(e,t){throw new Error("not implemented")}async startVerification(e){if(e!==R.Sas)throw new Error(`Unsupported verification method ${e}`);if(!await this.getOtherDevice())throw new Error("startVerification(): other device is unknown");const t=await this.inner.startSas();if(t){const[,e]=t;await this.outgoingRequestProcessor.makeOutgoingRequest(e)}if(!this._verifier)throw new Error("Still no verifier after startSas() call");return this._verifier}async scanQRCode(e){const t=ut.fromBytes(e),s=await this.inner.scanQrCode(t);if(!this._verifier)throw new Error("Still no verifier after scanQrCode() call");const i=s.reciprocate();return i&&await this.outgoingRequestProcessor.makeOutgoingRequest(i),this._verifier}get verifier(){return this.phase===m.Started?this._verifier:void 0}getQRCodeBytes(){throw new Error("getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.")}async generateQRCode(){if(!await this.getOtherDevice())throw new Error("generateQRCode(): other device is unknown");const e=await this.inner.generateQrCode();if(e)return e.toBytes()}get cancellationCode(){var e;return(null==(e=this.inner.cancelInfo)?void 0:e.cancelCode())??null}get cancellingUserId(){const e=this.inner.cancelInfo;if(e)return e.cancelledbyUs()?this.olmMachine.userId.toString():this.inner.otherUserId.toString()}}class Ye extends F{constructor(e,t){super(),this.inner=e,this.outgoingRequestProcessor=t,this.completionDeferred=We();const s=new WeakRef(this);e.registerChangesCallback((async()=>{var e;return null==(e=s.deref())?void 0:e.onChange()})),this.completionDeferred.promise.catch((()=>null))}onChange(){if(this.inner.isDone())this.completionDeferred.resolve(void 0);else if(this.inner.isCancelled()){const e=this.inner.cancelInfo();this.completionDeferred.reject(new Error(`Verification cancelled by ${e.cancelledbyUs()?"us":"them"} with code ${e.cancelCode()}: ${e.reason()}`))}this.emit(P.Change)}get hasBeenCancelled(){return this.inner.isCancelled()}get userId(){return this.inner.otherUserId.toString()}cancel(e){const t=this.inner.cancel();t&&this.outgoingRequestProcessor.makeOutgoingRequest(t)}getShowSasCallbacks(){return null}getReciprocateQrCodeCallbacks(){return null}}class Be extends Ye{constructor(e,t){super(e,t),this.callbacks=null}onChange(){null===this.callbacks&&this.inner.hasBeenScanned()&&(this.callbacks={confirm:()=>{this.confirmScanning()},cancel:()=>this.cancel()}),super.onChange()}async verify(){null!==this.callbacks&&this.emit(le.ShowReciprocateQr,this.callbacks),await this.completionDeferred.promise}get verificationPhase(){switch(this.inner.state()){case O.Created:return m.Ready;case O.Scanned:case O.Confirmed:case O.Reciprocated:return m.Started;case O.Done:return m.Done;case O.Cancelled:return m.Cancelled;default:throw new Error(`Unknown qr code state ${this.inner.state()}`)}}getReciprocateQrCodeCallbacks(){return this.callbacks}async confirmScanning(){const e=this.inner.confirmScanning();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}}class Oe extends Ye{constructor(e,t,s){super(e,s),this.callbacks=null}async verify(){await this.sendAccept(),await this.completionDeferred.promise}async sendAccept(){const e=this.inner.accept();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}onChange(){if(super.onChange(),null===this.callbacks){const e=this.inner.emoji(),t=this.inner.decimals();if(void 0===e&&void 0===t)return;const s={};e&&(s.emoji=e.map((e=>[e.symbol,e.description]))),t&&(s.decimal=[t[0],t[1],t[2]]),this.callbacks={sas:s,confirm:async()=>{const e=await this.inner.confirm();for(const t of e)await this.outgoingRequestProcessor.makeOutgoingRequest(t)},mismatch:()=>{const e=this.inner.cancelWithCode("m.mismatched_sas");e&&this.outgoingRequestProcessor.makeOutgoingRequest(e)},cancel:()=>{const e=this.inner.cancelWithCode("m.user");e&&this.outgoingRequestProcessor.makeOutgoingRequest(e)}},this.emit(le.ShowSas,this.callbacks)}}get verificationPhase(){return m.Started}getShowSasCallbacks(){return this.callbacks}replaceInner(e){if(this.inner!=e){this.inner=e;const t=new WeakRef(this);e.registerChangesCallback((async()=>{var e;return null==(e=t.deref())?void 0:e.onChange()})),this.sendAccept(),this.onChange()}}}const ze={[R.Sas]:j.SasV1,[R.ScanQrCode]:j.QrCodeScanV1,[R.ShowQrCode]:j.QrCodeShowV1,[R.Reciprocate]:j.ReciprocateV1};function ee(e){const t=ze[e];if(void 0===t)throw new Error(`Unknown verification method ${e}`);return t}function Ft(e){switch(e.getType()){case S.KeyVerificationCancel:case S.KeyVerificationDone:case S.KeyVerificationMac:case S.KeyVerificationStart:case S.KeyVerificationKey:case S.KeyVerificationReady:case S.KeyVerificationAccept:return!0;case S.RoomMessage:return e.getContent().msgtype===Je.KeyVerificationRequest;default:return!1}}class Gt extends F{constructor(e,t,s){super(),this.olmMachine=e,this.http=t,this.outgoingRequestProcessor=s,this.checkedForBackup=!1,this.serverBackupInfo=void 0,this.activeBackupVersion=null,this.stopped=!1,this.backupKeysLoopRunning=!1,this.keyBackupCheckInProgress=null}stop(){this.stopped=!0}async getActiveBackupVersion(){return await this.olmMachine.isBackupEnabled()?this.activeBackupVersion:null}async getServerBackupInfo(){return await this.checkKeyBackupAndEnable(!1),this.serverBackupInfo}async isKeyBackupTrusted(e){const t=await this.olmMachine.verifyBackup(e),s=await this.olmMachine.getBackupKeys(),i=null==s?void 0:s.decryptionKey;return{matchesDecryptionKey:!!i&&qe(e,i),trusted:t.trusted()}}checkKeyBackupAndEnable(e){return!e&&this.checkedForBackup?Promise.resolve(null):(this.keyBackupCheckInProgress||(this.keyBackupCheckInProgress=this.doCheckKeyBackup().finally((()=>{this.keyBackupCheckInProgress=null}))),this.keyBackupCheckInProgress)}async handleBackupSecretReceived(e){let t;try{t=await this.requestKeyBackupVersion()}catch(e){return h.warn("handleBackupSecretReceived: Error checking for latest key backup",e),!1}if(null==t||!t.version)return h.warn("handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup"),!1;try{const s=V.fromBase64(e);return qe(t,s)?(h.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache."),await this.saveBackupDecryptionKey(s,t.version),!0):(h.warn("handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup."),!1)}catch(e){h.warn("handleBackupSecretReceived: Invalid backup decryption key",e)}return!1}async saveBackupDecryptionKey(e,t){await this.olmMachine.saveBackupDecryptionKey(e,t),this.emit(g.KeyBackupDecryptionKeyCached,t)}async importRoomKeys(e,t){await this.importRoomKeysAsJson(JSON.stringify(e),t)}async importRoomKeysAsJson(e,t){await this.olmMachine.importExportedRoomKeys(e,((e,s)=>{var i;const n={total:Number(s),successes:Number(e),stage:A.LoadKeys,failures:0};null==(i=null==t?void 0:t.progressCallback)||i.call(t,n)}))}async importBackedUpRoomKeys(e,t,s){const i=new Map;for(const t of e){const e=new b(t.room_id);i.has(e)||i.set(e,new Map),i.get(e).set(t.session_id,t)}await this.olmMachine.importBackedUpRoomKeys(i,((e,t,i)=>{var n;const r={total:Number(t),successes:Number(e),stage:A.LoadKeys,failures:Number(i)};null==(n=null==s?void 0:s.progressCallback)||n.call(s,r)}),t)}async doCheckKeyBackup(){let e;h.log("Checking key backup status...");try{e=await this.requestKeyBackupVersion()}catch(e){return h.warn("Error checking for active key backup",e),this.serverBackupInfo=void 0,null}this.checkedForBackup=!0,e&&!e.version&&(h.warn("active backup lacks a useful 'version'; ignoring it"),e=void 0),this.serverBackupInfo=e;const t=await this.getActiveBackupVersion();if(!e)return null!==t?(h.log("No key backup present on server: disabling key backup"),await this.disableKeyBackup()):h.log("No key backup present on server: not enabling key backup"),null;const s=await this.isKeyBackupTrusted(e);return s.matchesDecryptionKey||s.trusted?null===t?(h.log(`Found usable key backup v${e.version}: enabling key backups`),await this.enableKeyBackup(e)):t!==e.version?(h.log(`On backup version ${t} but found version ${e.version}: switching.`),await this.disableKeyBackup(),await this.enableKeyBackup(e)):h.log(`Backup version ${e.version} still current`):null!==t?(h.log("Key backup present on server but not trusted: disabling key backup"),await this.disableKeyBackup()):h.log("Key backup present on server but not trusted: not enabling key backup"),{backupInfo:e,trustInfo:s}}async enableKeyBackup(e){await this.olmMachine.enableBackupV1(e.auth_data.public_key,e.version),this.activeBackupVersion=e.version,this.emit(g.KeyBackupStatus,!0),this.backupKeysLoop()}async maybeUploadKey(){null!=this.activeBackupVersion&&this.backupKeysLoop()}async disableKeyBackup(){await this.olmMachine.disableBackup(),this.activeBackupVersion=null,this.emit(g.KeyBackupStatus,!1)}async backupKeysLoop(e=1e4){if(this.backupKeysLoopRunning)return void h.log("Backup loop already running");this.backupKeysLoopRunning=!0,h.log(`Backup: Starting keys upload loop for backup version:${this.activeBackupVersion}.`);const t=Math.random()*e;await D(t);try{let e=0,t=null,s=!0;for(;!this.stopped;){let i;try{i=await E(h,"BackupRoomKeys: Get keys to backup from rust crypto-sdk",(async()=>await this.olmMachine.backupRoomKeys()))}catch(e){h.error("Backup: Failed to get keys to backup from rust crypto-sdk",e)}if(!i||this.stopped||!this.activeBackupVersion)return h.log(`Backup: Ending loop for version ${this.activeBackupVersion}.`),void(i||this.emit(g.KeyBackupSessionsRemaining,0));try{if(await this.outgoingRequestProcessor.makeOutgoingRequest(i),e=0,this.stopped)break;if(!s&&null===t)try{const e=await this.olmMachine.roomKeyCounts();t=e.total-e.backedUp}catch(e){h.error("Backup: Failed to get key counts from rust crypto-sdk",e)}if(null!==t){this.emit(g.KeyBackupSessionsRemaining,t);const e=this.keysCountInBatch(i);t=Math.max(t-e,0)}}catch(t){if(e++,h.error("Backup: Error processing backup request for rust crypto-sdk",t),t instanceof je){const e=t.data.errcode;if("M_NOT_FOUND"==e||"M_WRONG_ROOM_KEYS_VERSION"==e){h.log(`Backup: Failed to upload keys to current vesion: ${e}.`);try{await this.disableKeyBackup()}catch(e){h.error("Backup: An error occurred while disabling key backup:",e)}return this.emit(g.KeyBackupFailed,t.data.errcode),this.backupKeysLoopRunning=!1,void this.checkKeyBackupAndEnable(!0)}if(t.isRateLimitError())try{const e=t.getRetryAfterMs();if(e&&e>0){await D(e);continue}}catch(e){h.warn("Backup: An error occurred while retrieving a rate-limit retry delay",e)}}await D(1e3*Math.pow(2,Math.min(e-1,4)))}s=!1}}finally{this.backupKeysLoopRunning=!1}}keysCountInBatch(e){return Te(JSON.parse(e.body))}async requestKeyBackupVersion(e){return await Ze(this.http,e)}async setupKeyBackup(e){await this.deleteAllKeyBackupVersions();const t=V.createRandomKey(),s=t.megolmV1PublicKey,i={public_key:s.publicKeyBase64};await e(i);const n=await this.http.authedRequest(p.Post,"/room_keys/version",void 0,{algorithm:s.algorithm,auth_data:i},{prefix:x.V3});return await this.saveBackupDecryptionKey(t,n.version),{version:n.version,algorithm:s.algorithm,authData:i,decryptionKey:t}}async deleteAllKeyBackupVersions(){var e,t;let s=(null==(e=await this.requestKeyBackupVersion())?void 0:e.version)??null;for(;null!=s;)await this.deleteKeyBackupVersion(s),s=(null==(t=await this.requestKeyBackupVersion())?void 0:t.version)??null}async deleteKeyBackupVersion(e){h.debug(`deleteKeyBackupVersion v:${e}`);const t=ie("/room_keys/version/$version",{$version:e});await this.http.authedRequest(p.Delete,t,void 0,void 0,{prefix:x.V3}),this.activeBackupVersion===e&&(this.serverBackupInfo=null,await this.disableKeyBackup())}createBackupDecryptor(e){return new Jt(e)}async restoreKeyBackup(e,t,s){const i=await this.downloadKeyBackup(e);return this.importKeyBackup(i,e,t,s)}downloadKeyBackup(e){return this.http.authedRequest(p.Get,"/room_keys/keys",{version:e},void 0,{prefix:x.V3})}async importKeyBackup(e,t,s,i){var n;const r=Te(e);let o=0,a=0;null==(n=null==i?void 0:i.progressCallback)||n.call(i,{total:r,successes:o,stage:A.LoadKeys,failures:a});const c=async e=>{var n;const c=[];for(const t of e.keys())(await s.decryptSessions(e.get(t))).forEach((e=>{e.room_id=t,c.push(e)}));try{await this.importBackedUpRoomKeys(c,t),o+=c.length}catch(e){a+=c.length,h.error("Error importing keys from backup",e)}null==(n=null==i?void 0:i.progressCallback)||n.call(i,{total:r,successes:o,stage:A.LoadKeys,failures:a})};let g=0,u=new Map;for(const[t,s]of Object.entries(e.rooms))if(s.sessions){u.set(t,{});for(const[e,i]of Object.entries(s.sessions)){u.get(t)[e]=i,g+=1,g>=200&&(await c(u),u=new Map,u.set(t,{}),g=0)}}return g>0&&await c(u),{total:r,imported:o}}}function qe(e,t){var s;return"m.megolm_backup.v1.curve25519-aes-sha2"!==e.algorithm?(h.warn("backupMatchesPrivateKey: Unsupported backup algorithm",e.algorithm),!1):(null==(s=e.auth_data)?void 0:s.public_key)===t.megolmV1PublicKey.publicKeyBase64}class Jt{constructor(e){this.decryptionKey=e,this.sourceTrusted=!1}async decryptSessions(e){const t=[];for(const[s,i]of Object.entries(e))try{const e=JSON.parse(this.decryptionKey.decryptV1(i.session_data.ephemeral,i.session_data.mac,i.session_data.ciphertext));e.session_id=s,t.push(e)}catch(e){h.log("Failed to decrypt megolm session from backup",e,i)}return t}free(){this.decryptionKey.free()}}async function Ze(e,t){try{const s=t?ie("/room_keys/version/$version",{$version:t}):"/room_keys/version";return await e.authedRequest(p.Get,s,void 0,void 0,{prefix:x.V3})}catch(e){if("M_NOT_FOUND"===e.errcode)return null;throw e}}function ue(e,t){return t.auth_data.public_key===e.megolmV1PublicKey.publicKeyBase64}function Te(e){let t=0;for(const{sessions:s}of Object.values(e.rooms))t+=Object.keys(s).length;return t}class Wt{constructor(e,t,s){this.logger=e,this.olmMachine=t,this.outgoingRequestProcessor=s,this.stopped=!1,this.outgoingRequestLoopRunning=!1}stop(){this.stopped=!0}doProcessOutgoingRequests(){this.nextLoopDeferred||(this.nextLoopDeferred=We());const e=this.nextLoopDeferred.promise;return this.outgoingRequestLoopRunning||this.outgoingRequestLoop().catch((e=>{this.logger.error("Uncaught error in outgoing request loop",e)})),e}async outgoingRequestLoop(){if(this.outgoingRequestLoopRunning)throw new Error("Cannot run two outgoing request loops");this.outgoingRequestLoopRunning=!0;try{for(;!this.stopped&&this.nextLoopDeferred;){const e=this.nextLoopDeferred;this.nextLoopDeferred=void 0,await this.processOutgoingRequests().then(e.resolve,e.reject)}}finally{this.outgoingRequestLoopRunning=!1}this.nextLoopDeferred&&this.nextLoopDeferred.reject(new Error("OutgoingRequestsManager was stopped"))}async processOutgoingRequests(){if(this.stopped)return;const e=await this.olmMachine.outgoingRequests();for(const t of e){if(this.stopped)return;try{await E(this.logger,`Make outgoing request ${t.type}`,(async()=>{await this.outgoingRequestProcessor.makeOutgoingRequest(t)}))}catch(e){this.logger.error(`Failed to process outgoing request ${t.type}: ${e}`)}}}}const Y=5e3;class N extends Error{constructor(e){super(`Failed to get key from backup: ${e}`),this.code=e,this.name="KeyDownloadError"}}class Ue extends Error{constructor(e){super("Failed to get key from backup: rate limited"),this.retryMillis=e,this.name="KeyDownloadRateLimitError"}}class jt{constructor(e,t,s,i){this.olmMachine=t,this.http=s,this.backupManager=i,this.stopped=!1,this.configuration=null,this.sessionLastCheckAttemptedTime=new Map,this.downloadLoopRunning=!1,this.queuedRequests=[],this.hasConfigurationProblem=!1,this.currentBackupVersionCheck=null,this.onBackupStatusChanged=()=>{this.hasConfigurationProblem=!1,this.configuration=null,this.getOrCreateBackupConfiguration().then((e=>{e&&this.downloadKeysLoop()}))},this.logger=e.getChild("[PerSessionKeyBackupDownloader]"),i.on(g.KeyBackupStatus,this.onBackupStatusChanged),i.on(g.KeyBackupFailed,this.onBackupStatusChanged),i.on(g.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isKeyBackupDownloadConfigured(){return null!==this.configuration}async getServerBackupInfo(){return await this.backupManager.getServerBackupInfo()}onDecryptionKeyMissingError(e,t){this.isAlreadyInQueue(e,t)?this.logger.trace(`Not checking key backup for session ${t} as it is already queued`):this.wasRequestedRecently(t)?this.logger.trace(`Not checking key backup for session ${t} as it was already requested recently`):(this.queuedRequests.push({roomId:e,megolmSessionId:t}),this.downloadKeysLoop())}stop(){this.stopped=!0,this.backupManager.off(g.KeyBackupStatus,this.onBackupStatusChanged),this.backupManager.off(g.KeyBackupFailed,this.onBackupStatusChanged),this.backupManager.off(g.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isAlreadyInQueue(e,t){return this.queuedRequests.some((s=>s.roomId==e&&s.megolmSessionId==t))}markAsNotFoundInBackup(e){const t=Date.now();this.sessionLastCheckAttemptedTime.set(e,t),this.sessionLastCheckAttemptedTime.size>100&&(this.sessionLastCheckAttemptedTime=new Map(Array.from(this.sessionLastCheckAttemptedTime).filter(((e,s)=>Math.max(t-s,0)<Y))))}wasRequestedRecently(e){const t=this.sessionLastCheckAttemptedTime.get(e);return!!t&&Math.max(Date.now()-t,0)<Y}async getBackupDecryptionKey(){try{return await this.olmMachine.getBackupKeys()}catch{return null}}async requestRoomKeyFromBackup(e,t,s){const i=ie("/room_keys/keys/$roomId/$sessionId",{$roomId:t,$sessionId:s});return await this.http.authedRequest(p.Get,i,{version:e},void 0,{prefix:x.V3})}async downloadKeysLoop(){if(!this.downloadLoopRunning&&!this.hasConfigurationProblem){this.downloadLoopRunning=!0;try{for(;this.queuedRequests.length>0;){const e=this.queuedRequests[0];try{const t=await this.getOrCreateBackupConfiguration();if(!t)return void(this.downloadLoopRunning=!1);const s=await this.queryKeyBackup(e.roomId,e.megolmSessionId,t);if(this.stopped)return;try{await this.decryptAndImport(e,s,t)}catch(t){this.logger.error(`Error while decrypting and importing key backup for session ${e.megolmSessionId}`,t)}this.queuedRequests.shift()}catch(t){if(t instanceof N)switch(t.code){case"MISSING_DECRYPTION_KEY":this.markAsNotFoundInBackup(e.megolmSessionId),this.queuedRequests.shift();break;case"NETWORK_ERROR":await D(Y);break;case"STOPPED":return void(this.downloadLoopRunning=!1)}else t instanceof Ue&&await D(t.retryMillis)}}}finally{this.downloadLoopRunning=!1}}}async queryKeyBackup(e,t,s){if(this.logger.debug(`Checking key backup for session ${t}`),this.stopped)throw new N("STOPPED");try{const i=await this.requestRoomKeyFromBackup(s.backupVersion,e,t);return this.logger.debug(`Got key from backup for sessionId:${t}`),i}catch(e){if(this.stopped)throw new N("STOPPED");if(this.logger.info(`No luck requesting key backup for session ${t}: ${e}`),e instanceof je){if("M_NOT_FOUND"==e.data.errcode)throw new N("MISSING_DECRYPTION_KEY");if(e.isRateLimitError()){let t;try{t=e.getRetryAfterMs()??void 0}catch(e){this.logger.warn("Error while retrieving a rate-limit retry delay",e)}throw t&&t>0&&this.logger.info(`Rate limited by server, waiting ${t}ms`),new Ue(t??Y)}}throw new N("NETWORK_ERROR")}}async decryptAndImport(e,t,s){const i={[e.megolmSessionId]:t},n=await s.decryptor.decryptSessions(i);for(const t of n)t.room_id=e.roomId;await this.backupManager.importBackedUpRoomKeys(n,s.backupVersion)}async getOrCreateBackupConfiguration(){if(this.configuration)return this.configuration;if(this.hasConfigurationProblem)return null;if(null!=this.currentBackupVersionCheck)return this.logger.debug("Already checking server version, use current promise"),await this.currentBackupVersionCheck;this.currentBackupVersionCheck=this.internalCheckFromServer();try{return await this.currentBackupVersionCheck}finally{this.currentBackupVersionCheck=null}}async internalCheckFromServer(){let e=null;try{e=await this.backupManager.getServerBackupInfo()}catch(e){return this.logger.debug(`Backup: error while checking server version: ${e}`),this.hasConfigurationProblem=!0,null}if(this.logger.debug(`Got current backup version from server: ${null==e?void 0:e.version}`),"m.megolm_backup.v1.curve25519-aes-sha2"!=(null==e?void 0:e.algorithm))return this.logger.info(`Unsupported algorithm ${null==e?void 0:e.algorithm}`),this.hasConfigurationProblem=!0,null;if(null==e||!e.version)return this.logger.info("No current key backup"),this.hasConfigurationProblem=!0,null;const t=await this.backupManager.getActiveBackupVersion();if(null==t||e.version!=t)return this.logger.info(`The current backup version on the server (${e.version}) is not trusted. Version we are currently backing up to: ${t}`),this.hasConfigurationProblem=!0,null;const s=await this.getBackupDecryptionKey();if(null==s||!s.decryptionKey)return this.logger.debug("Not checking key backup for session (no decryption key)"),this.hasConfigurationProblem=!0,null;if(t!=s.backupVersion)return this.logger.debug(`Version for which we have a decryption key (${s.backupVersion}) doesn't match the version we are backing up to (${t})`),this.hasConfigurationProblem=!0,null;if(e.auth_data.public_key!=s.decryptionKey.megolmV1PublicKey.publicKeyBase64)return this.logger.debug("Key backup on server does not match our decryption key"),this.hasConfigurationProblem=!0,null;const i=this.backupManager.createBackupDecryptor(s.decryptionKey);return this.hasConfigurationProblem=!1,this.configuration={decryptor:i,backupVersion:t},this.configuration}}function Ht(e,t){if(!e.private_key_salt||!e.private_key_iterations)throw new Error("Salt and/or iterations not found: this backup cannot be restored with a passphrase");return He(t,e.private_key_salt,e.private_key_iterations,e.private_key_bits)}const Pe=[R.Sas,R.ScanQrCode,R.ShowQrCode,R.Reciprocate];class Qt extends F{constructor(e,t,s,i,n,r,o){super(),this.logger=e,this.olmMachine=t,this.http=s,this.userId=i,this.secretStorage=r,this.cryptoCallbacks=o,this.RECOVERY_KEY_DERIVATION_ITERATIONS=5e5,this._trustCrossSignedDevices=!0,this.deviceIsolationMode=new Et(!1),this.stopped=!1,this.roomEncryptors={},this.reemitter=new Ge(this),this.globalBlacklistUnverifiedDevices=!1,this._supportedVerificationMethods=Pe,this.outgoingRequestProcessor=new Vt(t,s),this.outgoingRequestsManager=new Wt(this.logger,t,this.outgoingRequestProcessor),this.keyClaimManager=new Nt(t,this.outgoingRequestProcessor),this.backupManager=new Gt(t,s,this.outgoingRequestProcessor),this.perSessionBackupDownloader=new jt(this.logger,this.olmMachine,this.http,this.backupManager),this.dehydratedDeviceManager=new Pt(this.logger,t,s,this.outgoingRequestProcessor,r),this.eventDecryptor=new Yt(this.logger,t,this.perSessionBackupDownloader),this.reemitter.reEmit(this.backupManager,[g.KeyBackupStatus,g.KeyBackupSessionsRemaining,g.KeyBackupFailed,g.KeyBackupDecryptionKeyCached]),this.reemitter.reEmit(this.dehydratedDeviceManager,[g.DehydratedDeviceCreated,g.DehydratedDeviceUploaded,g.RehydrationStarted,g.RehydrationProgress,g.RehydrationCompleted,g.RehydrationError,g.DehydrationKeyCached,g.DehydratedDeviceRotationError]),this.crossSigningIdentity=new $t(t,this.outgoingRequestProcessor,r),this.checkKeyBackupAndEnable()}getOlmMachineOrThrow(){if(this.stopped)throw new Mt;return this.olmMachine}set globalErrorOnUnknownDevices(e){}get globalErrorOnUnknownDevices(){return!1}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.backupManager.stop(),this.outgoingRequestsManager.stop(),this.perSessionBackupDownloader.stop(),this.dehydratedDeviceManager.stop(),this.olmMachine.close())}async encryptEvent(e,t){const s=e.getRoomId(),i=this.roomEncryptors[s];if(!i)throw new Error(`Cannot encrypt event in unconfigured room ${s}`);await i.encryptEvent(e,this.globalBlacklistUnverifiedDevices,this.deviceIsolationMode)}async decryptEvent(e){if(!e.getRoomId())throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");return await this.eventDecryptor.attemptEventDecryption(e,this.deviceIsolationMode)}async getBackupDecryptor(e,t){if(!(t instanceof Uint8Array))throw new Error("getBackupDecryptor: expects Uint8Array");if("m.megolm_backup.v1.curve25519-aes-sha2"!=e.algorithm)throw new Error(`getBackupDecryptor: Unsupported algorithm ${e.algorithm}`);const s=V.fromBase64(de(t));if(!ue(s,e))throw new Error("getBackupDecryptor: key backup on server does not match the decryption key");return this.backupManager.createBackupDecryptor(s)}async importBackedUpRoomKeys(e,t,s){return await this.backupManager.importBackedUpRoomKeys(e,t,s)}getVersion(){const e=ht();return`Rust SDK ${e.matrix_sdk_crypto} (${e.git_sha}), Vodozemac ${e.vodozemac}`}setDeviceIsolationMode(e){this.deviceIsolationMode=e}async isEncryptionEnabledInRoom(e){const t=await this.olmMachine.getRoomSettings(new b(e));return!(null==t||!t.algorithm)}async getOwnDeviceKeys(){const e=this.olmMachine.identityKeys;return{ed25519:e.ed25519.toBase64(),curve25519:e.curve25519.toBase64()}}prepareToEncrypt(e){const t=this.roomEncryptors[e.roomId];t&&t.prepareForEncryption(this.globalBlacklistUnverifiedDevices,this.deviceIsolationMode)}forceDiscardSession(e){var t;return null==(t=this.roomEncryptors[e])?void 0:t.forceDiscardSession()}async exportRoomKeys(){const e=await this.olmMachine.exportRoomKeys((()=>!0));return JSON.parse(e)}async exportRoomKeysAsJson(){return await this.olmMachine.exportRoomKeys((()=>!0))}async importRoomKeys(e,t){return await this.backupManager.importRoomKeys(e,t)}async importRoomKeysAsJson(e,t){return await this.backupManager.importRoomKeysAsJson(e,t)}async userHasCrossSigningKeys(e=this.userId,t=!1){var s;const i=await this.olmMachine.trackedUsers();let n;for(const t of i)if(e===t.toString()){n=t;break}if(void 0!==n){if(e===this.userId){const e=this.olmMachine.queryKeysForUsers([n.clone()]);await this.outgoingRequestProcessor.makeOutgoingRequest(e)}const t=await this.olmMachine.getIdentity(n);return null==t||t.free(),void 0!==t}if(t){const t=null==(s=(await this.downloadDeviceList(new Set([e]))).master_keys)?void 0:s[e];return!!t&&!!Object.values(t.keys)[0]}return!1}async getUserDeviceInfo(e,t=!1){const s=new Map,i=await this.getOlmMachineOrThrow().trackedUsers(),n=new Set;i.forEach((e=>n.add(e.toString())));const r=new Set;for(const t of e)n.has(t)?s.set(t,await this.getUserDevices(t)):r.add(t);if(t&&r.size>=1){const e=await this.downloadDeviceList(r);Object.entries(e.device_keys).forEach((([e,t])=>s.set(e,Lt(t))))}return s}async getUserDevices(e){const t=new y(e),s=await this.olmMachine.getUserDevices(t,1);try{const e=s.devices();try{return new Map(e.map((e=>[e.deviceId.toString(),At(e,t)])))}finally{e.forEach((e=>e.free()))}}finally{s.free()}}async downloadDeviceList(e){const t={device_keys:{}};return e.forEach((e=>t.device_keys[e]=[])),await this.http.authedRequest(p.Post,"/_matrix/client/v3/keys/query",void 0,t,{prefix:""})}getTrustCrossSignedDevices(){return this._trustCrossSignedDevices}setTrustCrossSignedDevices(e){this._trustCrossSignedDevices=e}async setDeviceVerified(e,t,s=!0){const i=await this.olmMachine.getDevice(new y(e),new I(t));if(!i)throw new Error(`Unknown device ${e}|${t}`);try{await i.setLocalTrust(s?ve.Verified:ve.Unset)}finally{i.free()}}async crossSignDevice(e){const t=await this.olmMachine.getDevice(new y(this.userId),new I(e));if(!t)throw new Error(`Unknown device ${e}`);try{const e=await t.verify();await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{t.free()}}async getDeviceVerificationStatus(e,t){const s=await this.olmMachine.getDevice(new y(e),new I(t));if(!s)return null;try{return new It({signedByOwner:s.isCrossSignedByOwner(),crossSigningVerified:s.isCrossSigningTrusted(),localVerified:s.isLocallyTrusted(),trustCrossSignedDevices:this._trustCrossSignedDevices})}finally{s.free()}}async getUserVerificationStatus(e){const t=await this.getOlmMachineOrThrow().getIdentity(new y(e));if(void 0===t)return new Ke(!1,!1,!1);const s=t.isVerified(),i=t.wasPreviouslyVerified(),n=t instanceof dt&&t.identityNeedsUserApproval();return t.free(),new Ke(s,i,!1,n)}async pinCurrentUserIdentity(e){const t=await this.getOlmMachineOrThrow().getIdentity(new y(e));if(void 0===t)throw new Error("Cannot pin identity of unknown user");if(t instanceof gt)throw new Error("Cannot pin identity of own user");await t.pinCurrentMasterKey()}async withdrawVerificationRequirement(e){const t=await this.getOlmMachineOrThrow().getIdentity(new y(e));if(void 0===t)throw new Error("Cannot withdraw verification of unknown user");await t.withdrawVerification()}async isCrossSigningReady(){const{privateKeysInSecretStorage:e,privateKeysCachedLocally:t}=await this.getCrossSigningStatus(),s=!!t.masterKey&&!!t.selfSigningKey&&!!t.userSigningKey,i=await this.getOwnIdentity();return!(null==i||!i.isVerified())&&(s||e)}async getCrossSigningKeyId(e=Q.Master){const t=await this.olmMachine.getIdentity(new y(this.userId));if(!t)return null;try{const s=await this.olmMachine.crossSigningStatus();if(!(s.hasMaster&&s.hasUserSigning&&s.hasSelfSigning&&t.isVerified()))return null;let i;switch(e){case Q.Master:i=t.masterKey;break;case Q.SelfSigning:i=t.selfSigningKey;break;case Q.UserSigning:i=t.userSigningKey;break;default:return null}const n=JSON.parse(i);return Object.values(n.keys)[0]}finally{t.free()}}async bootstrapCrossSigning(e){await this.crossSigningIdentity.bootstrapCrossSigning(e)}async isSecretStorageReady(){const e=["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"];return null!=await this.backupManager.getActiveBackupVersion()&&e.push("m.megolm_backup.v1"),Qe(this.secretStorage,e)}async bootstrapSecretStorage({createSecretStorageKey:e,setupNewSecretStorage:t,setupNewKeyBackup:s}={}){const i=t||!await this.secretStorageHasAESKey();if(i){if(!e)throw new Error("unable to create a new secret storage key, createSecretStorageKey is not set");this.logger.info("bootstrapSecretStorage: creating new secret storage key");const t=await e();if(!t)throw new Error("createSecretStorageKey() callback did not return a secret storage key");await this.addSecretStorageKeyToSecretStorage(t)}const n=await this.olmMachine.exportCrossSigningKeys();n&&void 0!==n.masterKey&&void 0!==n.self_signing_key&&void 0!==n.userSigningKey&&(i||!await De(this.secretStorage))&&(this.logger.info("bootstrapSecretStorage: cross-signing keys not yet exported; doing so now."),await this.secretStorage.store("m.cross_signing.master",n.masterKey),await this.secretStorage.store("m.cross_signing.user_signing",n.userSigningKey),await this.secretStorage.store("m.cross_signing.self_signing",n.self_signing_key)),s?await this.resetKeyBackup():await this.saveBackupKeyToStorage()}async saveBackupKeyToStorage(){const e=await this.backupManager.getServerBackupInfo();if(!e||!e.version)return void h.info("Not saving backup key to secret storage: no backup info");const t=await this.olmMachine.getBackupKeys();if(!t.decryptionKey)return void h.info("Not saving backup key to secret storage: no backup key");if(!ue(t.decryptionKey,e))return void h.info("Not saving backup key to secret storage: decryption key does not match backup info");const s=t.decryptionKey.toBase64();await this.secretStorage.store("m.megolm_backup.v1",s)}async addSecretStorageKeyToSecretStorage(e){var t,s,i,n;const r=await this.secretStorage.addKey(Ee,{passphrase:null==(t=e.keyInfo)?void 0:t.passphrase,name:null==(s=e.keyInfo)?void 0:s.name,key:e.privateKey});await this.secretStorage.setDefaultKeyId(r.keyId),null==(n=(i=this.cryptoCallbacks).cacheSecretStorageKey)||n.call(i,r.keyId,r.keyInfo,e.privateKey)}async secretStorageHasAESKey(){const e=await this.secretStorage.getKey();if(!e)return!1;const[,t]=e;return t.algorithm===Ee}async getCrossSigningStatus(){const e=await this.getOlmMachineOrThrow().getIdentity(new y(this.userId)),t=!(null==e||!e.masterKey||null==e||!e.selfSigningKey||null==e||!e.userSigningKey);null==e||e.free();const s=await De(this.secretStorage),i=await this.getOlmMachineOrThrow().crossSigningStatus();return{publicKeysOnDevice:t,privateKeysInSecretStorage:s,privateKeysCachedLocally:{masterKey:!(null==i||!i.hasMaster),userSigningKey:!(null==i||!i.hasUserSigning),selfSigningKey:!(null==i||!i.hasSelfSigning)}}}async createRecoveryKeyFromPassphrase(e){if(e){const t=Me(32),s=await He(e,t,this.RECOVERY_KEY_DERIVATION_ITERATIONS);return{keyInfo:{passphrase:{algorithm:"m.pbkdf2",iterations:this.RECOVERY_KEY_DERIVATION_ITERATIONS,salt:t}},privateKey:s,encodedPrivateKey:Ce(s)}}{const e=new Uint8Array(32);return globalThis.crypto.getRandomValues(e),{privateKey:e,encodedPrivateKey:Ce(e)}}}async getEncryptionInfoForEvent(e){return this.eventDecryptor.getEncryptionInfoForEvent(e)}getVerificationRequestsToDeviceInProgress(e){return this.olmMachine.getVerificationRequests(new y(e)).filter((e=>void 0===e.roomId)).map((e=>new U(this.olmMachine,e,this.outgoingRequestProcessor,this._supportedVerificationMethods)))}findVerificationRequestDMInProgress(e,t){if(!t)throw new Error("missing userId");const s=this.olmMachine.getVerificationRequests(new y(t)).find((t=>{var s;return(null==(s=t.roomId)?void 0:s.toString())===e}));if(s)return new U(this.olmMachine,s,this.outgoingRequestProcessor,this._supportedVerificationMethods)}async requestVerificationDM(e,t){const s=await this.olmMachine.getIdentity(new y(e));if(!s)throw new Error(`unknown userId ${e}`);try{const e=this._supportedVerificationMethods.map((e=>ee(e))),i=await s.verificationRequestContent(e),n=await this.sendVerificationRequestContent(t,i),r=await s.requestVerification(new b(t),new lt(n),e);return new U(this.olmMachine,r,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{s.free()}}async sendVerificationRequestContent(e,t){const s=Me(32),{event_id:i}=await this.http.authedRequest(p.Put,`/_matrix/client/v3/rooms/${encodeURIComponent(e)}/send/m.room.message/${encodeURIComponent(s)}`,void 0,t,{prefix:""});return i}setSupportedVerificationMethods(e){this._supportedVerificationMethods=e??Pe}async requestOwnUserVerification(){const e=await this.olmMachine.getIdentity(new y(this.userId));if(void 0===e)throw new Error("cannot request verification for this device when there is no existing cross-signing key");try{const[t,s]=await e.requestVerification(this._supportedVerificationMethods.map(ee));return await this.outgoingRequestProcessor.makeOutgoingRequest(s),new U(this.olmMachine,t,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{e.free()}}async requestDeviceVerification(e,t){const s=await this.olmMachine.getDevice(new y(e),new I(t));if(!s)throw new Error("Not a known device");try{const[e,t]=s.requestVerification(this._supportedVerificationMethods.map(ee));return await this.outgoingRequestProcessor.makeOutgoingRequest(t),new U(this.olmMachine,e,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{s.free()}}async getSessionBackupPrivateKey(){const e=await this.olmMachine.getBackupKeys();return e.decryptionKey?he(e.decryptionKey.toBase64()):null}async storeSessionBackupPrivateKey(e,t){const s=de(e);if(!t)throw new Error("storeSessionBackupPrivateKey: version is required");await this.backupManager.saveBackupDecryptionKey(V.fromBase64(s),t)}async loadSessionBackupPrivateKeyFromSecretStorage(){const e=await this.secretStorage.get("m.megolm_backup.v1");if(!e)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: missing decryption key in secret storage");const t=await this.backupManager.getServerBackupInfo();if(!t||!t.version)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: unable to get backup version");const s=V.fromBase64(e);if(!ue(s,t))throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: decryption key does not match backup info");await this.backupManager.saveBackupDecryptionKey(s,t.version)}async getActiveSessionBackupVersion(){return await this.backupManager.getActiveBackupVersion()}async getKeyBackupInfo(){return await this.backupManager.getServerBackupInfo()||null}async isKeyBackupTrusted(e){return await this.backupManager.isKeyBackupTrusted(e)}async checkKeyBackupAndEnable(){return await this.backupManager.checkKeyBackupAndEnable(!0)}async deleteKeyBackupVersion(e){await this.backupManager.deleteKeyBackupVersion(e)}async resetKeyBackup(){const e=await this.backupManager.setupKeyBackup((e=>this.signObject(e)));await this.secretStorageHasAESKey()&&await this.secretStorage.store("m.megolm_backup.v1",e.decryptionKey.toBase64()),this.checkKeyBackupAndEnable()}async disableKeyStorage(){const e=await this.getKeyBackupInfo();null!=e&&e.version?await this.deleteKeyBackupVersion(e.version):h.error("Can't delete key backup version: no version available"),await this.deleteSecretStorage(),await this.dehydratedDeviceManager.delete()}async signObject(e){const t=new Map(Object.entries(e.signatures||{})),s=e.unsigned;delete e.signatures,delete e.unsigned;const i=t.get(this.userId)||{},n=Ot.stringify(e),r=await this.olmMachine.sign(n),o=JSON.parse(r.asJSON());t.set(this.userId,{...i,...o[this.userId]}),void 0!==s&&(e.unsigned=s),e.signatures=Object.fromEntries(t.entries())}async restoreKeyBackupWithPassphrase(e,t){const s=await this.backupManager.getServerBackupInfo();if(null==s||!s.version)throw new Error("No backup info available");const i=await Ht(s.auth_data,e);return await this.storeSessionBackupPrivateKey(i,s.version),this.restoreKeyBackup(t)}async restoreKeyBackup(e){var t;const s=await this.olmMachine.getBackupKeys(),{decryptionKey:i,backupVersion:n}=s;if(!i||!n)throw new Error("No decryption key found in crypto store");const r=he(i.toBase64()),o=await this.backupManager.requestKeyBackupVersion(n);if(!o)throw new Error(`Backup version to restore ${n} not found on server`);const a=await this.getBackupDecryptor(o,r);try{return null==(t=null==e?void 0:e.progressCallback)||t.call(e,{stage:A.Fetch}),await this.backupManager.restoreKeyBackup(n,a,e)}finally{a.free()}}async isDehydrationSupported(){return await this.dehydratedDeviceManager.isSupported()}async startDehydration(e={}){if(!await this.isCrossSigningReady()||!await this.isSecretStorageReady())throw new Error("Device dehydration requires cross-signing and secret storage to be set up");return await this.dehydratedDeviceManager.start(e||{})}async importSecretsBundle(e){const t=yt.from_json(e);await this.getOlmMachineOrThrow().importSecretsBundle(t)}async exportSecretsBundle(){const e=await this.getOlmMachineOrThrow().exportSecretsBundle(),t=e.to_json();return e.free(),t}async encryptToDeviceMessages(e,t,s){const i=new $e(this.logger,"encryptToDeviceMessages"),n=new Set(t.map((({userId:e})=>e)));await this.keyClaimManager.ensureSessionsForUsers(i,Array.from(n).map((e=>new y(e))));const r={batch:[],eventType:S.RoomMessageEncrypted};return await Promise.all(t.map((async({userId:t,deviceId:i})=>{const n=await this.olmMachine.getDevice(new y(t),new I(i));if(n){const o=JSON.parse(await n.encryptToDeviceEvent(e,s));r.batch.push({deviceId:i,userId:t,payload:o})}else this.logger.warn(`encryptToDeviceMessages: unknown device ${t}:${i}`)}))),r}async resetEncryption(e){this.logger.debug("resetEncryption: resetting encryption"),this.dehydratedDeviceManager.delete(),await this.backupManager.deleteAllKeyBackupVersions(),this.deleteSecretStorage(),await this.crossSigningIdentity.bootstrapCrossSigning({setupNewCrossSigning:!0,authUploadDeviceSigningKeys:e}),await this.resetKeyBackup(),this.logger.debug("resetEncryption: ended")}async deleteSecretStorage(){await this.secretStorage.store("m.cross_signing.master",null),await this.secretStorage.store("m.cross_signing.self_signing",null),await this.secretStorage.store("m.cross_signing.user_signing",null),await this.secretStorage.store("m.megolm_backup.v1",null);const e=await this.secretStorage.getDefaultKeyId();e&&await this.secretStorage.store(`m.secret_storage.key.${e}`,null),await this.secretStorage.setDefaultKeyId(null)}async receiveSyncChanges({events:e,oneTimeKeysCounts:t=new Map,unusedFallbackKeys:s,devices:i=new Se}){const n=await E(h,"receiveSyncChanges",(async()=>await this.olmMachine.receiveSyncChanges(e?JSON.stringify(e):"[]",i,t,s)));return JSON.parse(n)}async preprocessToDeviceMessages(e){const t=await this.receiveSyncChanges({events:e});for(const e of t)if(e.type===S.KeyVerificationRequest){const t=e.sender,s=e.content.transaction_id;s&&t&&this.onIncomingKeyVerificationRequest(t,s)}return t}async processKeyCounts(e,t){const s=e&&new Map(Object.entries(e)),i=t&&new Set(t);(void 0!==s||void 0!==i)&&await this.receiveSyncChanges({oneTimeKeysCounts:s,unusedFallbackKeys:i})}async processDeviceLists(e){var t,s;const i=new Se(null==(t=e.changed)?void 0:t.map((e=>new y(e))),null==(s=e.left)?void 0:s.map((e=>new y(e))));await this.receiveSyncChanges({devices:i})}async onCryptoEvent(e,t){const s=t.getContent(),i=new Ne;if("m.megolm.v1.aes-sha2"!==s.algorithm)return void this.logger.warn(`Room ${e.roomId}: ignoring crypto event with invalid algorithm ${s.algorithm}`);i.algorithm=$.MegolmV1AesSha2;try{i.sessionRotationPeriodMs=s.rotation_period_ms,i.sessionRotationPeriodMessages=s.rotation_period_msgs,await this.olmMachine.setRoomSettings(new b(e.roomId),i)}catch(t){return void this.logger.warn(`Room ${e.roomId}: ignoring crypto event which caused error: ${t}`)}const n=this.roomEncryptors[e.roomId];n?n.onCryptoEvent(s):this.roomEncryptors[e.roomId]=new qt(this.olmMachine,this.keyClaimManager,this.outgoingRequestsManager,e,s)}onSyncCompleted(e){this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{this.logger.warn("onSyncCompleted: Error processing outgoing requests",e)}))}onIncomingKeyVerificationRequest(e,t){const s=this.olmMachine.getVerificationRequest(new y(e),t);s?this.emit(g.VerificationRequestReceived,new U(this.olmMachine,s,this.outgoingRequestProcessor,this._supportedVerificationMethods)):this.logger.info(`Ignoring just-received verification request ${t} which did not start a rust-side verification`)}onRoomMembership(e,t,s){const i=this.roomEncryptors[e.getRoomId()];i&&i.onRoomMembership(t)}async onRoomKeysUpdated(e){for(const t of e)this.onRoomKeyUpdated(t);this.backupManager.maybeUploadKey()}onRoomKeyUpdated(e){if(this.stopped)return;this.logger.debug(`Got update for session ${e.sessionId} from sender ${e.senderKey.toBase64()} in ${e.roomId.toString()}`);const t=this.eventDecryptor.getEventsPendingRoomKey(e.roomId.toString(),e.sessionId);if(0!==t.length){this.logger.debug("Retrying decryption on events:",t.map((e=>`${e.getId()}`)));for(const e of t)e.attemptDecryption(this,{isRetry:!0}).catch((t=>{this.logger.info(`Still unable to decrypt event ${e.getId()} after receiving key`)}))}}async onRoomKeysWithheld(e){for(const t of e){this.logger.debug(`Got withheld message for session ${t.sessionId} in ${t.roomId.toString()}`);const e=this.eventDecryptor.getEventsPendingRoomKey(t.roomId.toString(),t.sessionId);if(0===e.length)return;this.logger.debug("Retrying decryption on events:",e.map((e=>`${e.getId()}`)));for(const t of e)t.attemptDecryption(this,{isRetry:!0}).catch((e=>{}))}}async onUserIdentityUpdated(e){const t=await this.getUserVerificationStatus(e.toString());this.emit(g.UserTrustStatusChanged,e.toString(),t),e.toString()===this.userId&&(this.emit(g.KeysChanged,{}),await this.checkKeyBackupAndEnable())}async onDevicesUpdated(e){this.emit(g.WillUpdateDevices,e,!1),this.emit(g.DevicesUpdated,e,!1)}async handleSecretReceived(e,t){return this.logger.debug(`onReceiveSecret: Received secret ${e}`),"m.megolm_backup.v1"===e&&await this.backupManager.handleBackupSecretReceived(t)}async checkSecrets(e){const t=await this.olmMachine.getSecretsFromInbox(e);for(const s of t)if(await this.handleSecretReceived(e,s))break;await this.olmMachine.deleteSecretsFromInbox(e)}async onLiveEventFromSync(e){if(e.isState()||e.getUnsigned().transaction_id)return;const t=async t=>{Ft(e)&&await this.onKeyVerificationEvent(t)};if(e.isDecryptionFailure()||e.isEncrypted()){const s=setTimeout((()=>e.off(ne.Decrypted,i)),3e5),i=(n,r)=>{r||(clearTimeout(s),e.off(ne.Decrypted,i),t(n))};e.on(ne.Decrypted,i)}else await t(e)}async onKeyVerificationEvent(e){const t=e.getRoomId();if(!t)throw new Error("missing roomId in the event");this.logger.debug(`Incoming verification event ${e.getId()} type ${e.getType()} from ${e.getSender()}`),await this.olmMachine.receiveVerificationEvent(JSON.stringify({event_id:e.getId(),type:e.getType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getContent(),origin_server_ts:e.getTs()}),new b(t)),e.getType()===S.RoomMessage&&e.getContent().msgtype===Je.KeyVerificationRequest&&this.onIncomingKeyVerificationRequest(e.getSender(),e.getId()),this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{this.logger.warn("onKeyVerificationRequest: Error processing outgoing requests",e)}))}async getOwnIdentity(){return await this.olmMachine.getIdentity(new y(this.userId))}}class Yt{constructor(e,t,s){this.logger=e,this.olmMachine=t,this.perSessionBackupDownloader=s,this.eventsPendingKey=new Ie((()=>new Ie((()=>new Set))))}async attemptEventDecryption(e,t){let s;switch(this.addEventToPendingList(e),t.kind){case se.AllDevicesIsolationMode:s=be.Untrusted;break;case se.OnlySignedDevicesIsolationMode:s=be.CrossSignedOrLegacy}try{const t=await this.olmMachine.decryptRoomEvent(Ve(e),new b(e.getRoomId()),new pt(s));return this.removeEventFromPendingList(e),{clearEvent:JSON.parse(t.event),claimedEd25519Key:t.senderClaimedEd25519Key,senderCurve25519Key:t.senderCurve25519Key,forwardingCurve25519KeyChain:t.forwardingCurve25519KeyChain}}catch(t){if(!(t instanceof ft))throw new v(k.UNKNOWN_ERROR,"Unknown error");this.onMegolmDecryptionError(e,t,await this.perSessionBackupDownloader.getServerBackupInfo())}}onMegolmDecryptionError(e,t,s){const i=e.getWireContent(),n={sender_key:i.sender_key,session_id:i.session_id};if(t.code===_.MissingRoomKey||t.code===_.UnknownMessageIndex){this.perSessionBackupDownloader.onDecryptionKeyMissingError(e.getRoomId(),i.session_id);const t=e.getMembershipAtEvent();if(t&&t!==te.Join&&t!==te.Invite)throw new v(k.HISTORICAL_MESSAGE_USER_NOT_JOINED,"This message was sent when we were not a member of the room.",n);if(e.getTs()<=this.olmMachine.deviceCreationTimeMs)throw null===s?new v(k.HISTORICAL_MESSAGE_NO_KEY_BACKUP,"This message was sent before this device logged in, and there is no key backup on the server.",n):this.perSessionBackupDownloader.isKeyBackupDownloadConfigured()?new v(k.HISTORICAL_MESSAGE_WORKING_BACKUP,"This message was sent before this device logged in. Key backup is working, but we still do not (yet) have the key.",n):new v(k.HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED,"This message was sent before this device logged in, and key backup is not working.",n)}if(t.maybe_withheld){const e="The sender has disabled encrypting to unverified devices."===t.maybe_withheld?k.MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE:k.MEGOLM_KEY_WITHHELD;throw new v(e,t.maybe_withheld,n)}switch(t.code){case _.MissingRoomKey:throw new v(k.MEGOLM_UNKNOWN_INBOUND_SESSION_ID,"The sender's device has not sent us the keys for this message.",n);case _.UnknownMessageIndex:throw new v(k.OLM_UNKNOWN_MESSAGE_INDEX,"The sender's device has not sent us the keys for this message at this index.",n);case _.SenderIdentityVerificationViolation:throw this.removeEventFromPendingList(e),new v(k.SENDER_IDENTITY_PREVIOUSLY_VERIFIED,"The sender identity is unverified, but was previously verified.");case _.UnknownSenderDevice:throw this.removeEventFromPendingList(e),new v(k.UNKNOWN_SENDER_DEVICE,"The sender device is not known.");case _.UnsignedSenderDevice:throw this.removeEventFromPendingList(e),new v(k.UNSIGNED_SENDER_DEVICE,"The sender identity is not cross-signed.");default:throw new v(k.UNKNOWN_ERROR,t.description,n)}}async getEncryptionInfoForEvent(e){if(!e.getClearContent()||e.isDecryptionFailure())return null;if(null!==e.status)return{shieldColour:X.NONE,shieldReason:null};const t=await this.olmMachine.getRoomEventEncryptionInfo(Ve(e),new b(e.getRoomId()));return zt(this.logger,t)}getEventsPendingRoomKey(e,t){const s=this.eventsPendingKey.get(e);if(!s)return[];const i=s.get(t);return i?[...i]:[]}addEventToPendingList(e){const t=e.getRoomId();t&&this.eventsPendingKey.getOrCreate(t).getOrCreate(e.getWireContent().session_id).add(e)}removeEventFromPendingList(e){const t=e.getRoomId();if(!t)return;const s=this.eventsPendingKey.getOrCreate(t);if(!s)return;const i=s.get(e.getWireContent().session_id);i&&(i.delete(e),0===i.size&&(s.delete(e.getWireContent().session_id),0===s.size&&this.eventsPendingKey.delete(t)))}}function Ve(e){return JSON.stringify({event_id:e.getId(),type:e.getWireType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getWireContent(),origin_server_ts:e.getTs()})}function zt(e,t){if(void 0===t)return null;const s=t.shieldState(!1);let i,n;switch(s.color){case Re.Grey:i=X.GREY;break;case Re.None:i=X.NONE;break;default:i=X.RED}switch(s.code){case void 0:case null:n=null;break;case q.AuthenticityNotGuaranteed:n=T.AUTHENTICITY_NOT_GUARANTEED;break;case q.UnknownDevice:n=T.UNKNOWN_DEVICE;break;case q.UnsignedDevice:n=T.UNSIGNED_DEVICE;break;case q.UnverifiedIdentity:n=T.UNVERIFIED_IDENTITY;break;case q.SentInClear:n=T.SENT_IN_CLEAR;break;case q.VerificationViolation:n=T.VERIFICATION_VIOLATION}return{shieldColour:i,shieldReason:n}}async function Zt(e){var t;const{logger:s,legacyStore:i}=e;if(await Ae(),new Le(xe.Debug).turnOn(),!await i.containsData())return;await i.startup();let n=null;if(await i.doTxn("readonly",[G.STORE_ACCOUNT],(e=>{i.getAccount(e,(e=>{n=e}))})),!n)return void s.debug("Legacy crypto store is not set up (no account found). Not migrating.");let r=await i.getMigrationState();if(r>=K.MEGOLM_SESSIONS_MIGRATED)return;const o=await es(s,i),a=await ts(s,i),c=1+o+a;s.info(`Migrating data from legacy crypto store. ${o} olm sessions and ${a} megolm sessions to migrate.`);let h=0;function g(t){var s;h+=t,null==(s=e.legacyMigrationProgressListener)||s.call(e,h,c)}g(0);const u=(new TextEncoder).encode(e.legacyPickleKey);r===K.NOT_STARTED&&(s.info("Migrating data from legacy crypto store. Step 1: base data"),await Xt(e.http,e.userId,e.deviceId,i,u,e.storeHandle,s),r=K.INITIAL_DATA_MIGRATED,await i.setMigrationState(r)),g(1),r===K.INITIAL_DATA_MIGRATED&&(s.info(`Migrating data from legacy crypto store. Step 2: olm sessions (${o} sessions to migrate).`),await ss(s,i,u,e.storeHandle,g),r=K.OLM_SESSIONS_MIGRATED,await i.setMigrationState(r)),r===K.OLM_SESSIONS_MIGRATED&&(s.info(`Migrating data from legacy crypto store. Step 3: megolm sessions (${a} sessions to migrate).`),await is(s,i,u,e.storeHandle,g),r=K.MEGOLM_SESSIONS_MIGRATED,await i.setMigrationState(r)),null==(t=e.legacyMigrationProgressListener)||t.call(e,-1,-1),s.info("Migration from legacy crypto store complete")}async function Xt(e,t,s,i,n,r,o){var a;const c=new mt;c.userId=new y(t),c.deviceId=new I(s),await i.doTxn("readonly",[G.STORE_ACCOUNT],(e=>i.getAccount(e,(e=>{c.pickledAccount=e??""}))));const h=await z(i,n,"m.megolm_backup.v1");if(h){let t=!1,s=null;for(;!t;)try{s=await Ze(e),t=!0}catch(e){o.info("Failed to get backup version during migration, retrying in 2 seconds",e),await D(2e3)}if(s&&"m.megolm_backup.v1.curve25519-aes-sha2"==s.algorithm)try{const e=V.fromBase64(h),t=null==(a=s.auth_data)?void 0:a.public_key;e.megolmV1PublicKey.publicKeyBase64==t?(c.backupVersion=s.version,c.backupRecoveryKey=h):o.debug("The backup key to migrate does not match the active backup version",`Cached pub key: ${e.megolmV1PublicKey.publicKeyBase64}`,`Active pub key: ${t}`)}catch(e){o.warn("Failed to check if the backup key to migrate matches the active backup version",e)}}c.privateCrossSigningMasterKey=await z(i,n,"master"),c.privateCrossSigningSelfSigningKey=await z(i,n,"self_signing"),c.privateCrossSigningUserSigningKey=await z(i,n,"user_signing"),await ge.migrateBaseData(c,n,r)}async function es(e,t){let s;return e.debug("Counting olm sessions to be migrated"),await t.doTxn("readonly",[G.STORE_SESSIONS],(e=>t.countEndToEndSessions(e,(e=>s=e)))),s}async function ts(e,t){return e.debug("Counting megolm sessions to be migrated"),await t.countEndToEndInboundGroupSessions()}async function ss(e,t,s,i,n){for(;;){const r=await t.getEndToEndSessionsBatch();if(null===r)return;e.debug(`Migrating batch of ${r.length} olm sessions`);const o=[];for(const e of r){const t=new wt;t.senderKey=e.deviceKey,t.pickle=e.session,t.lastUseTime=t.creationTime=new Date(e.lastReceivedMessageTs),o.push(t)}await ge.migrateOlmSessions(o,s,i),await t.deleteEndToEndSessionsBatch(r),n(r.length)}}async function is(e,t,s,i,n){for(var r;;){const o=await t.getEndToEndInboundGroupSessionsBatch();if(null===o)return;e.debug(`Migrating batch of ${o.length} megolm sessions`);const a=[];for(const e of o){const t=e.sessionData,s=new kt;s.pickle=t.session,s.roomId=new b(t.room_id),s.senderKey=e.senderKey,s.senderSigningKey=null==(r=t.keysClaimed)?void 0:r.ed25519,s.backedUp=!e.needsBackup,s.imported=!0===t.untrusted,a.push(s)}await ge.migrateMegolmSessions(a,s,i),await t.deleteEndToEndInboundGroupSessionsBatch(o),n(o.length)}}async function rs({logger:e,legacyStore:t,olmMachine:s}){if(!await t.containsData()||await t.getMigrationState()>=K.ROOM_SETTINGS_MIGRATED)return;let i={};await t.doTxn("readwrite",[G.STORE_ROOMS],(e=>{t.getEndToEndRooms(e,(e=>{i=e}))})),e.debug(`Migrating ${Object.keys(i).length} sets of room settings`);for(const[t,n]of Object.entries(i))try{const i=new Ne;if("m.megolm.v1.aes-sha2"!==n.algorithm){e.warn(`Room ${t}: ignoring room with invalid algorithm ${n.algorithm}`);continue}i.algorithm=$.MegolmV1AesSha2,i.sessionRotationPeriodMs=n.rotation_period_ms,i.sessionRotationPeriodMessages=n.rotation_period_msgs,await s.setRoomSettings(new b(t),i)}catch(s){e.warn(`Room ${t}: ignoring settings ${JSON.stringify(n)} which caused error ${s}`)}e.debug("Completed room settings migration"),await t.setMigrationState(K.ROOM_SETTINGS_MIGRATED)}async function z(e,t,s){const i=await new Promise((t=>{e.doTxn("readonly",[G.STORE_ACCOUNT],(i=>{e.getSecretStorePrivateKey(i,t,s)}))}));return i&&i.ciphertext&&i.iv&&i.mac?await Ct(i,t,s):i instanceof Uint8Array?de(i):void 0}async function ns(e){const{legacyCryptoStore:t,rustCrypto:s,logger:i}=e,n=await s.getOwnIdentity();if(!n||n.isVerified())return;const r=await os(t);if(!r)return;const o=JSON.parse(n.masterKey);if(!o.keys||0===Object.keys(o.keys).length)return void i.error("Post Migration | Unexpected error: no master key in the rust session.");const a=Object.values(o.keys)[0];a&&a==r&&(i.info(`Post Migration: Migrating legacy trusted MSK: ${r} to locally verified.`),await n.verify())}async function os(e){let t=null;return await e.doTxn("readonly","account",(s=>{e.getCrossSigningKeys(s,(e=>{const s=null==e?void 0:e.master;s&&0!=Object.keys(s.keys).length&&(t=Object.values(s.keys)[0])}))})),t}async function hs(e){const{logger:t}=e;let s;t.debug("Initialising Rust crypto-sdk WASM artifact"),await Ae(),new Le(xe.Debug).turnOn(),t.debug("Opening Rust CryptoStore"),s=e.storePrefix?e.storeKey?await re.openWithKey(e.storePrefix,e.storeKey):await re.open(e.storePrefix,e.storePassphrase):await re.open(),e.legacyCryptoStore&&await Zt({legacyStore:e.legacyCryptoStore,storeHandle:s,...e});const i=await as(t,e.http,e.userId,e.deviceId,e.secretStorage,e.cryptoCallbacks,s,e.legacyCryptoStore);return s.free(),t.debug("Completed rust crypto-sdk setup"),i}async function as(e,t,s,i,n,r,o,a){e.debug("Init OlmMachine");const c=await vt.initFromStore(new y(s),new I(i),o);a&&await rs({logger:e,legacyStore:a,olmMachine:c}),c.roomKeyRequestsEnabled=!1;const h=new Qt(e,c,t,s,i,n,r);if(await c.registerRoomKeyUpdatedCallback((e=>h.onRoomKeysUpdated(e))),await c.registerRoomKeysWithheldCallback((e=>h.onRoomKeysWithheld(e))),await c.registerUserIdentityUpdatedCallback((e=>h.onUserIdentityUpdated(e))),await c.registerDevicesUpdatedCallback((e=>h.onDevicesUpdated(e))),h.checkSecrets("m.megolm_backup.v1"),await c.registerReceiveSecretCallback(((e,t)=>h.checkSecrets(e))),await c.outgoingRequests(),a&&await a.containsData()&&await a.getMigrationState()<K.INITIAL_OWN_KEY_QUERY_DONE){e.debug("Performing initial key query after migration");let t=!1;for(;!t;)try{await h.userHasCrossSigningKeys(s),t=!0}catch(t){e.error("Failed to check for cross-signing keys after migration, retrying",t)}await ns({legacyCryptoStore:a,rustCrypto:h,logger:e}),await a.setMigrationState(K.INITIAL_OWN_KEY_QUERY_DONE)}return h}export{hs as initRustCrypto};