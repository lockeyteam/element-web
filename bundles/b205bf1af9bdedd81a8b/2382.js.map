{"version":3,"file":"bundles/b205bf1af9bdedd81a8b/2382.js","mappings":"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","sources":["webpack://element-web/./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","webpack://element-web/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","webpack://element-web/./node_modules/base-x/src/esm/index.js","webpack://element-web/./node_modules/content-type/index.js","webpack://element-web/./node_modules/events/events.js","webpack://element-web/./node_modules/jwt-decode/build/cjs/index.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/ExtensibleEvents.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/IPartialEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/InvalidEventError.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/NamespacedMap.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/NamespacedValue.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/EmoteEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/ExtensibleEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/MessageEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/NoticeEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/PollEndEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/PollResponseEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/PollStartEvent.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/message_types.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/poll_types.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/events/relationship_types.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/index.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/interpreters/legacy/MRoomMessage.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/interpreters/modern/MMessage.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/interpreters/modern/MPoll.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/types.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/utility/MessageMatchers.js","webpack://element-web/./node_modules/matrix-events-sdk/lib/utility/events.js","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/membership.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/ReEmitter.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/ToDeviceMessageQueue.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/base64.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/common-crypto/CryptoBackend.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/content-repo.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto-api/key-passphrase.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/digest.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/event-mapper.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/feature.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/filter-component.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/errors.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/refresh.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/fetch.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/interface.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/method.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/prefix.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/utils.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/indexeddb-helpers.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/EncryptionManager.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/IKeyTransport.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/MembershipManagerActionScheduler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/MembershipManager.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/RTCEncryptionManager.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/RoomKeyTransport.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/ToDeviceKeyTransport.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/utils.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/MSC3089Branch.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/MSC3089TreeSpace.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/compare-event-ordering.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/event-context.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/event-status.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/invites-ignorer-types.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/read-receipt.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/relations-container.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/room-receipts.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/room-sticky-events.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/room-summary.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/oidc/discovery.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/oidc/error.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/pushprocessor.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/realtime-callbacks.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/rust-crypto/constants.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/scheduler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/sliding-sync-sdk.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/store/indexeddb-local-backend.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/store/stub.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/thread-utils.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/utils/encryptAESSecretStorageItem.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/utils/internal/deriveKeys.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/utils/roomVersion.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/audioContext.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/callEventHandler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/callEventTypes.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/groupCallEventHandler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/callFeedStatsReporter.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/connectionStats.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/connectionStatsBuilder.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/transportStatsBuilder.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/media/mediaSsrcHandler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/media/mediaTrackHandler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/media/mediaTrackStats.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/media/mediaTrackStatsHandler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/valueFormatter.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/trackStatsBuilder.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/connectionStatsReportBuilder.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/callStatsReportGatherer.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/statsReportEmitter.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/groupCallStats.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/summaryStatsReportGatherer.ts","webpack://element-web/./node_modules/oidc-client-ts/src/index.ts","webpack://element-web/./node_modules/oidc-client-ts/src/utils/Logger.ts","webpack://element-web/./node_modules/oidc-client-ts/src/utils/JwtUtils.ts","webpack://element-web/./node_modules/oidc-client-ts/src/utils/CryptoUtils.ts","webpack://element-web/./node_modules/oidc-client-ts/src/utils/Event.ts","webpack://element-web/./node_modules/oidc-client-ts/src/utils/PopupUtils.ts","webpack://element-web/./node_modules/oidc-client-ts/src/utils/Timer.ts","webpack://element-web/./node_modules/oidc-client-ts/src/utils/UrlUtils.ts","webpack://element-web/./node_modules/oidc-client-ts/src/errors/ErrorResponse.ts","webpack://element-web/./node_modules/oidc-client-ts/src/errors/ErrorTimeout.ts","webpack://element-web/./node_modules/oidc-client-ts/src/AccessTokenEvents.ts","webpack://element-web/./node_modules/oidc-client-ts/src/CheckSessionIFrame.ts","webpack://element-web/./node_modules/oidc-client-ts/src/InMemoryWebStorage.ts","webpack://element-web/./node_modules/oidc-client-ts/src/errors/ErrorDPoPNonce.ts","webpack://element-web/./node_modules/oidc-client-ts/src/JsonService.ts","webpack://element-web/./node_modules/oidc-client-ts/src/MetadataService.ts","webpack://element-web/./node_modules/oidc-client-ts/src/WebStorageStateStore.ts","webpack://element-web/./node_modules/oidc-client-ts/src/OidcClientSettings.ts","webpack://element-web/./node_modules/oidc-client-ts/src/UserInfoService.ts","webpack://element-web/./node_modules/oidc-client-ts/src/TokenClient.ts","webpack://element-web/./node_modules/oidc-client-ts/src/ResponseValidator.ts","webpack://element-web/./node_modules/oidc-client-ts/src/State.ts","webpack://element-web/./node_modules/oidc-client-ts/src/SigninState.ts","webpack://element-web/./node_modules/oidc-client-ts/src/SigninRequest.ts","webpack://element-web/./node_modules/oidc-client-ts/src/SigninResponse.ts","webpack://element-web/./node_modules/oidc-client-ts/src/SignoutRequest.ts","webpack://element-web/./node_modules/oidc-client-ts/src/SignoutResponse.ts","webpack://element-web/./node_modules/oidc-client-ts/src/ClaimsService.ts","webpack://element-web/./node_modules/oidc-client-ts/src/DPoPStore.ts","webpack://element-web/./node_modules/oidc-client-ts/src/OidcClient.ts","webpack://element-web/./node_modules/oidc-client-ts/src/SessionMonitor.ts","webpack://element-web/./node_modules/oidc-client-ts/src/User.ts","webpack://element-web/./node_modules/oidc-client-ts/src/navigators/AbstractChildWindow.ts","webpack://element-web/./node_modules/oidc-client-ts/src/UserManagerSettings.ts","webpack://element-web/./node_modules/oidc-client-ts/src/navigators/IFrameWindow.ts","webpack://element-web/./node_modules/oidc-client-ts/src/navigators/IFrameNavigator.ts","webpack://element-web/./node_modules/oidc-client-ts/src/navigators/PopupWindow.ts","webpack://element-web/./node_modules/oidc-client-ts/src/navigators/PopupNavigator.ts","webpack://element-web/./node_modules/oidc-client-ts/src/navigators/RedirectNavigator.ts","webpack://element-web/./node_modules/oidc-client-ts/src/UserManagerEvents.ts","webpack://element-web/./node_modules/oidc-client-ts/src/SilentRenewService.ts","webpack://element-web/./node_modules/oidc-client-ts/src/RefreshState.ts","webpack://element-web/./node_modules/oidc-client-ts/src/UserManager.ts","webpack://element-web/./node_modules/oidc-client-ts/src/Version.ts","webpack://element-web/./node_modules/oidc-client-ts/package.json","webpack://element-web/./node_modules/oidc-client-ts/src/IndexedDbDPoPStore.ts","webpack://element-web/./node_modules/sdp-transform/lib/grammar.js","webpack://element-web/./node_modules/sdp-transform/lib/index.js","webpack://element-web/./node_modules/sdp-transform/lib/parser.js","webpack://element-web/./node_modules/sdp-transform/lib/writer.js","webpack://element-web/./node_modules/uuid/dist/native.js","webpack://element-web/./node_modules/uuid/dist/rng.js","webpack://element-web/./node_modules/uuid/dist/stringify.js","webpack://element-web/./node_modules/uuid/dist/v4.js"],"sourcesContent":["import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nexport { _objectWithoutProperties as default };","function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nexport { _objectWithoutPropertiesLoose as default };","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (psz < source.length) {\n      // Find code of next character\n      const charCode = source.charCodeAt(psz)\n      // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n      // Decode character\n      let carry = BASE_MAP[charCode]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/ // eslint-disable-line no-control-regex\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.slice(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value.charCodeAt(0) === 0x22 /* \" */) {\n        // remove quotes\n        value = value.slice(1, -1)\n\n        // remove escapes\n        if (value.indexOf('\\\\') !== -1) {\n          value = value.replace(QESC_REGEXP, '$1')\n        }\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.jwtDecode = exports.InvalidTokenError = void 0;\nclass InvalidTokenError extends Error {\n}\nexports.InvalidTokenError = InvalidTokenError;\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nfunction jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\nexports.jwtDecode = jwtDecode;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtensibleEvents = void 0;\n\nvar _NamespacedMap = require(\"./NamespacedMap\");\n\nvar _InvalidEventError = require(\"./InvalidEventError\");\n\nvar _MRoomMessage = require(\"./interpreters/legacy/MRoomMessage\");\n\nvar _MMessage = require(\"./interpreters/modern/MMessage\");\n\nvar _message_types = require(\"./events/message_types\");\n\nvar _poll_types = require(\"./events/poll_types\");\n\nvar _MPoll = require(\"./interpreters/modern/MPoll\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Utility class for parsing and identifying event types in a renderable form. An\n * instance of this class can be created to change rendering preference depending\n * on use-case.\n */\nvar ExtensibleEvents = /*#__PURE__*/function () {\n  function ExtensibleEvents() {\n    _classCallCheck(this, ExtensibleEvents);\n\n    _defineProperty(this, \"interpreters\", new _NamespacedMap.NamespacedMap([// Remember to add your unit test when adding to this! (\"known events\" test description)\n    [_MRoomMessage.LEGACY_M_ROOM_MESSAGE, _MRoomMessage.parseMRoomMessage], [_message_types.M_MESSAGE, _MMessage.parseMMessage], [_message_types.M_EMOTE, _MMessage.parseMMessage], [_message_types.M_NOTICE, _MMessage.parseMMessage], [_poll_types.M_POLL_START, _MPoll.parseMPoll], [_poll_types.M_POLL_RESPONSE, _MPoll.parseMPoll], [_poll_types.M_POLL_END, _MPoll.parseMPoll]]));\n\n    _defineProperty(this, \"_unknownInterpretOrder\", [_message_types.M_MESSAGE]);\n  }\n  /**\n   * Gets the default instance for all extensible event parsing.\n   */\n\n\n  _createClass(ExtensibleEvents, [{\n    key: \"unknownInterpretOrder\",\n    get:\n    /**\n     * Gets the order the internal processor will use for unknown primary\n     * event types.\n     */\n    function get() {\n      var _this$_unknownInterpr;\n\n      return (_this$_unknownInterpr = this._unknownInterpretOrder) !== null && _this$_unknownInterpr !== void 0 ? _this$_unknownInterpr : [];\n    }\n    /**\n     * Sets the order the internal processor will use for unknown primary\n     * event types.\n     * @param {NamespacedValue<string, string>[]} val The parsing order.\n     */\n    ,\n    set: function set(val) {\n      this._unknownInterpretOrder = val;\n    }\n    /**\n     * Gets the order the internal processor will use for unknown primary\n     * event types.\n     */\n\n  }, {\n    key: \"registerInterpreter\",\n    value:\n    /**\n     * Registers a primary event type interpreter. Note that the interpreter might be\n     * called with non-primary events if the event is being parsed as a fallback.\n     * @param {NamespacedValue<string, string>} wireEventType The event type.\n     * @param {EventInterpreter} interpreter The interpreter.\n     */\n    function registerInterpreter(wireEventType, interpreter) {\n      this.interpreters.set(wireEventType, interpreter);\n    }\n    /**\n     * Registers a primary event type interpreter. Note that the interpreter might be\n     * called with non-primary events if the event is being parsed as a fallback.\n     * @param {NamespacedValue<string, string>} wireEventType The event type.\n     * @param {EventInterpreter} interpreter The interpreter.\n     */\n\n  }, {\n    key: \"parse\",\n    value:\n    /**\n     * Parses an event, trying the primary event type first. If the primary type is not known\n     * then the content will be inspected to find the most suitable fallback.\n     *\n     * If the parsing failed or was a completely unknown type, this will return falsy.\n     * @param {IPartialEvent<object>} wireFormat The event to parse.\n     * @returns {Optional<ExtensibleEvent>} The parsed extensible event.\n     */\n    function parse(wireFormat) {\n      try {\n        if (this.interpreters.hasNamespaced(wireFormat.type)) {\n          return this.interpreters.getNamespaced(wireFormat.type)(wireFormat);\n        }\n\n        var _iterator = _createForOfIteratorHelper(this.unknownInterpretOrder),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var tryType = _step.value;\n\n            if (this.interpreters.has(tryType)) {\n              var val = this.interpreters.get(tryType)(wireFormat);\n              if (val) return val;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return null; // cannot be parsed\n      } catch (e) {\n        if (e instanceof _InvalidEventError.InvalidEventError) {\n          return null; // fail parsing and move on\n        }\n\n        throw e; // re-throw everything else\n      }\n    }\n    /**\n     * Parses an event, trying the primary event type first. If the primary type is not known\n     * then the content will be inspected to find the most suitable fallback.\n     *\n     * If the parsing failed or was a completely unknown type, this will return falsy.\n     * @param {IPartialEvent<object>} wireFormat The event to parse.\n     * @returns {Optional<ExtensibleEvent>} The parsed extensible event.\n     */\n\n  }], [{\n    key: \"defaultInstance\",\n    get: function get() {\n      return ExtensibleEvents._defaultInstance;\n    }\n  }, {\n    key: \"unknownInterpretOrder\",\n    get: function get() {\n      return ExtensibleEvents.defaultInstance.unknownInterpretOrder;\n    }\n    /**\n     * Sets the order the internal processor will use for unknown primary\n     * event types.\n     * @param {NamespacedValue<string, string>[]} val The parsing order.\n     */\n    ,\n    set: function set(val) {\n      ExtensibleEvents.defaultInstance.unknownInterpretOrder = val;\n    }\n  }, {\n    key: \"registerInterpreter\",\n    value: function registerInterpreter(wireEventType, interpreter) {\n      ExtensibleEvents.defaultInstance.registerInterpreter(wireEventType, interpreter);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(wireFormat) {\n      return ExtensibleEvents.defaultInstance.parse(wireFormat);\n    }\n  }]);\n\n  return ExtensibleEvents;\n}();\n\nexports.ExtensibleEvents = ExtensibleEvents;\n\n_defineProperty(ExtensibleEvents, \"_defaultInstance\", new ExtensibleEvents());","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InvalidEventError = void 0;\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Thrown when an event is unforgivably unparsable.\n */\nvar InvalidEventError = /*#__PURE__*/function (_Error) {\n  _inherits(InvalidEventError, _Error);\n\n  var _super = _createSuper(InvalidEventError);\n\n  function InvalidEventError(message) {\n    _classCallCheck(this, InvalidEventError);\n\n    return _super.call(this, message);\n  }\n\n  return _createClass(InvalidEventError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.InvalidEventError = InvalidEventError;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NamespacedMap = void 0;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * A `Map` implementation which accepts a NamespacedValue as a key, and arbitrary value. The\n * namespaced value must be a string type.\n */\nvar NamespacedMap = /*#__PURE__*/function () {\n  // protected to make tests happy for access\n\n  /**\n   * Creates a new map with optional seed data.\n   * @param {Array<[NS, V]>} initial The seed data.\n   */\n  function NamespacedMap(initial) {\n    _classCallCheck(this, NamespacedMap);\n\n    _defineProperty(this, \"internalMap\", new Map());\n\n    if (initial) {\n      var _iterator = _createForOfIteratorHelper(initial),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var val = _step.value;\n          this.set(val[0], val[1]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Gets a value from the map. If the value does not exist under\n   * either namespace option, falsy is returned.\n   * @param {NS} key The key.\n   * @returns {Optional<V>} The value, or falsy.\n   */\n\n\n  _createClass(NamespacedMap, [{\n    key: \"get\",\n    value: function get(key) {\n      if (key.name && this.internalMap.has(key.name)) {\n        return this.internalMap.get(key.name);\n      }\n\n      if (key.altName && this.internalMap.has(key.altName)) {\n        return this.internalMap.get(key.altName);\n      }\n\n      return null;\n    }\n    /**\n     * Sets a value in the map.\n     * @param {NS} key The key.\n     * @param {V} val The value.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, val) {\n      if (key.name) {\n        this.internalMap.set(key.name, val);\n      }\n\n      if (key.altName) {\n        this.internalMap.set(key.altName, val);\n      }\n    }\n    /**\n     * Determines if any of the valid namespaced values are present\n     * in the map.\n     * @param {NS} key The key.\n     * @returns {boolean} True if present.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return !!this.get(key);\n    }\n    /**\n     * Removes all the namespaced values from the map.\n     * @param {NS} key The key.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      if (key.name) {\n        this.internalMap[\"delete\"](key.name);\n      }\n\n      if (key.altName) {\n        this.internalMap[\"delete\"](key.altName);\n      }\n    }\n    /**\n     * Determines if the map contains a specific namespaced value\n     * instead of the parent NS type.\n     * @param {string} key The key.\n     * @returns {boolean} True if present.\n     */\n\n  }, {\n    key: \"hasNamespaced\",\n    value: function hasNamespaced(key) {\n      return this.internalMap.has(key);\n    }\n    /**\n     * Gets a specific namespaced value from the map instead of the\n     * parent NS type. Returns falsy if not found.\n     * @param {string} key The key.\n     * @returns {Optional<V>} The value, or falsy.\n     */\n\n  }, {\n    key: \"getNamespaced\",\n    value: function getNamespaced(key) {\n      return this.internalMap.get(key);\n    }\n  }]);\n\n  return NamespacedMap;\n}();\n\nexports.NamespacedMap = NamespacedMap;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnstableValue = exports.NamespacedValue = void 0;\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents a simple Matrix namespaced value. This will assume that if a stable prefix\n * is provided that the stable prefix should be used when representing the identifier.\n */\nvar NamespacedValue = /*#__PURE__*/function () {\n  // Stable is optional, but one of the two parameters is required, hence the weird-looking types.\n  // Goal is to have developers explicitly say there is no stable value (if applicable).\n  function NamespacedValue(stable, unstable) {\n    _classCallCheck(this, NamespacedValue);\n\n    this.stable = stable;\n    this.unstable = unstable;\n\n    if (!this.unstable && !this.stable) {\n      throw new Error(\"One of stable or unstable values must be supplied\");\n    }\n  }\n\n  _createClass(NamespacedValue, [{\n    key: \"name\",\n    get: function get() {\n      if (this.stable) {\n        return this.stable;\n      }\n\n      return this.unstable;\n    }\n  }, {\n    key: \"altName\",\n    get: function get() {\n      if (!this.stable) {\n        return null;\n      }\n\n      return this.unstable;\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(val) {\n      return !!this.name && this.name === val || !!this.altName && this.altName === val;\n    } // this desperately wants https://github.com/microsoft/TypeScript/pull/26349 at the top level of the class\n    // so we can instantiate `NamespacedValue<string, _, _>` as a default type for that namespace.\n\n  }, {\n    key: \"findIn\",\n    value: function findIn(obj) {\n      var val;\n\n      if (this.name) {\n        val = obj === null || obj === void 0 ? void 0 : obj[this.name];\n      }\n\n      if (!val && this.altName) {\n        val = obj === null || obj === void 0 ? void 0 : obj[this.altName];\n      }\n\n      return val;\n    }\n  }, {\n    key: \"includedIn\",\n    value: function includedIn(arr) {\n      var included = false;\n\n      if (this.name) {\n        included = arr.includes(this.name);\n      }\n\n      if (!included && this.altName) {\n        included = arr.includes(this.altName);\n      }\n\n      return included;\n    }\n  }]);\n\n  return NamespacedValue;\n}();\n/**\n * Represents a namespaced value which prioritizes the unstable value over the stable\n * value.\n */\n\n\nexports.NamespacedValue = NamespacedValue;\n\nvar UnstableValue = /*#__PURE__*/function (_NamespacedValue) {\n  _inherits(UnstableValue, _NamespacedValue);\n\n  var _super = _createSuper(UnstableValue);\n\n  // Note: Constructor difference is that `unstable` is *required*.\n  function UnstableValue(stable, unstable) {\n    var _this;\n\n    _classCallCheck(this, UnstableValue);\n\n    _this = _super.call(this, stable, unstable);\n\n    if (!_this.unstable) {\n      throw new Error(\"Unstable value must be supplied\");\n    }\n\n    return _this;\n  }\n\n  _createClass(UnstableValue, [{\n    key: \"name\",\n    get: function get() {\n      return this.unstable;\n    }\n  }, {\n    key: \"altName\",\n    get: function get() {\n      return this.stable;\n    }\n  }]);\n\n  return UnstableValue;\n}(NamespacedValue);\n\nexports.UnstableValue = UnstableValue;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EmoteEvent = void 0;\n\nvar _MessageEvent2 = require(\"./MessageEvent\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _events = require(\"../utility/events\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// Emote events are just decorated message events\n\n/**\n * Represents an emote. This is essentially a MessageEvent with\n * emote characteristics considered.\n */\nvar EmoteEvent = /*#__PURE__*/function (_MessageEvent) {\n  _inherits(EmoteEvent, _MessageEvent);\n\n  var _super = _createSuper(EmoteEvent);\n\n  function EmoteEvent(wireFormat) {\n    _classCallCheck(this, EmoteEvent);\n\n    return _super.call(this, wireFormat);\n  }\n\n  _createClass(EmoteEvent, [{\n    key: \"isEmote\",\n    get: function get() {\n      return true; // override\n    }\n  }, {\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _message_types.M_EMOTE) || _get(_getPrototypeOf(EmoteEvent.prototype), \"isEquivalentTo\", this).call(this, primaryEventType);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var message = _get(_getPrototypeOf(EmoteEvent.prototype), \"serialize\", this).call(this);\n\n      message.content['msgtype'] = \"m.emote\";\n      return message;\n    }\n    /**\n     * Creates a new EmoteEvent from text and HTML.\n     * @param {string} text The text.\n     * @param {string} html Optional HTML.\n     * @returns {MessageEvent} The representative message event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(text, html) {\n      var _content;\n\n      return new EmoteEvent({\n        type: _message_types.M_EMOTE.name,\n        content: (_content = {}, _defineProperty(_content, _message_types.M_TEXT.name, text), _defineProperty(_content, _message_types.M_HTML.name, html), _content)\n      });\n    }\n  }]);\n\n  return EmoteEvent;\n}(_MessageEvent2.MessageEvent);\n\nexports.EmoteEvent = EmoteEvent;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtensibleEvent = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents an Extensible Event in Matrix.\n */\nvar ExtensibleEvent = /*#__PURE__*/function () {\n  function ExtensibleEvent(wireFormat) {\n    _classCallCheck(this, ExtensibleEvent);\n\n    this.wireFormat = wireFormat;\n  }\n  /**\n   * Shortcut to wireFormat.content\n   */\n\n\n  _createClass(ExtensibleEvent, [{\n    key: \"wireContent\",\n    get: function get() {\n      return this.wireFormat.content;\n    }\n    /**\n     * Serializes the event into a format which can be used to send the\n     * event to the room.\n     * @returns {IPartialEvent<object>} The serialized event.\n     */\n\n  }]);\n\n  return ExtensibleEvent;\n}();\n\nexports.ExtensibleEvent = ExtensibleEvent;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageEvent = void 0;\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nvar _types = require(\"../types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _events = require(\"../utility/events\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a message event. Message events are the simplest form of event with\n * just text (optionally of different mimetypes, like HTML).\n *\n * Message events can additionally be an Emote or Notice, though typically those\n * are represented as EmoteEvent and NoticeEvent respectively.\n */\nvar MessageEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(MessageEvent, _ExtensibleEvent);\n\n  var _super = _createSuper(MessageEvent);\n\n  /**\n   * The default text for the event.\n   */\n\n  /**\n   * The default HTML for the event, if provided.\n   */\n\n  /**\n   * All the different renderings of the message. Note that this is the same\n   * format as an m.message body but may contain elements not found directly\n   * in the event content: this is because this is interpreted based off the\n   * other information available in the event.\n   */\n\n  /**\n   * Creates a new MessageEvent from a pure format. Note that the event is\n   * *not* parsed here: it will be treated as a literal m.message primary\n   * typed event.\n   * @param {IPartialEvent<M_MESSAGE_EVENT_CONTENT>} wireFormat The event.\n   */\n  function MessageEvent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, MessageEvent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"text\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"html\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderings\", void 0);\n\n    var mmessage = _message_types.M_MESSAGE.findIn(_this.wireContent);\n\n    var mtext = _message_types.M_TEXT.findIn(_this.wireContent);\n\n    var mhtml = _message_types.M_HTML.findIn(_this.wireContent);\n\n    if ((0, _types.isProvided)(mmessage)) {\n      if (!Array.isArray(mmessage)) {\n        throw new _InvalidEventError.InvalidEventError(\"m.message contents must be an array\");\n      }\n\n      var text = mmessage.find(function (r) {\n        return !(0, _types.isProvided)(r.mimetype) || r.mimetype === \"text/plain\";\n      });\n      var html = mmessage.find(function (r) {\n        return r.mimetype === \"text/html\";\n      });\n      if (!text) throw new _InvalidEventError.InvalidEventError(\"m.message is missing a plain text representation\");\n      _this.text = text.body;\n      _this.html = html === null || html === void 0 ? void 0 : html.body;\n      _this.renderings = mmessage;\n    } else if ((0, _types.isOptionalAString)(mtext)) {\n      _this.text = mtext;\n      _this.html = mhtml;\n      _this.renderings = [{\n        body: mtext,\n        mimetype: \"text/plain\"\n      }];\n\n      if (_this.html) {\n        _this.renderings.push({\n          body: _this.html,\n          mimetype: \"text/html\"\n        });\n      }\n    } else {\n      throw new _InvalidEventError.InvalidEventError(\"Missing textual representation for event\");\n    }\n\n    return _this;\n  }\n  /**\n   * Gets whether this message is considered an \"emote\". Note that a message\n   * might be an emote and notice at the same time: while technically possible,\n   * the event should be interpreted as one or the other.\n   */\n\n\n  _createClass(MessageEvent, [{\n    key: \"isEmote\",\n    get: function get() {\n      return _message_types.M_EMOTE.matches(this.wireFormat.type) || (0, _types.isProvided)(_message_types.M_EMOTE.findIn(this.wireFormat.content));\n    }\n    /**\n     * Gets whether this message is considered a \"notice\". Note that a message\n     * might be an emote and notice at the same time: while technically possible,\n     * the event should be interpreted as one or the other.\n     */\n\n  }, {\n    key: \"isNotice\",\n    get: function get() {\n      return _message_types.M_NOTICE.matches(this.wireFormat.type) || (0, _types.isProvided)(_message_types.M_NOTICE.findIn(this.wireFormat.content));\n    }\n  }, {\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _message_types.M_MESSAGE);\n    }\n  }, {\n    key: \"serializeMMessageOnly\",\n    value: function serializeMMessageOnly() {\n      var messageRendering = _defineProperty({}, _message_types.M_MESSAGE.name, this.renderings); // Use the shorthand if it's just a simple text event\n\n\n      if (this.renderings.length === 1) {\n        var mime = this.renderings[0].mimetype;\n\n        if (mime === undefined || mime === \"text/plain\") {\n          messageRendering = _defineProperty({}, _message_types.M_TEXT.name, this.renderings[0].body);\n        }\n      }\n\n      return messageRendering;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var _this$html;\n\n      return {\n        type: \"m.room.message\",\n        content: _objectSpread(_objectSpread({}, this.serializeMMessageOnly()), {}, {\n          body: this.text,\n          msgtype: \"m.text\",\n          format: this.html ? \"org.matrix.custom.html\" : undefined,\n          formatted_body: (_this$html = this.html) !== null && _this$html !== void 0 ? _this$html : undefined\n        })\n      };\n    }\n    /**\n     * Creates a new MessageEvent from text and HTML.\n     * @param {string} text The text.\n     * @param {string} html Optional HTML.\n     * @returns {MessageEvent} The representative message event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(text, html) {\n      var _content;\n\n      return new MessageEvent({\n        type: _message_types.M_MESSAGE.name,\n        content: (_content = {}, _defineProperty(_content, _message_types.M_TEXT.name, text), _defineProperty(_content, _message_types.M_HTML.name, html), _content)\n      });\n    }\n  }]);\n\n  return MessageEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.MessageEvent = MessageEvent;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoticeEvent = void 0;\n\nvar _MessageEvent2 = require(\"./MessageEvent\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _events = require(\"../utility/events\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// Notice events are just decorated message events\n\n/**\n * Represents a notice. This is essentially a MessageEvent with\n * notice characteristics considered.\n */\nvar NoticeEvent = /*#__PURE__*/function (_MessageEvent) {\n  _inherits(NoticeEvent, _MessageEvent);\n\n  var _super = _createSuper(NoticeEvent);\n\n  function NoticeEvent(wireFormat) {\n    _classCallCheck(this, NoticeEvent);\n\n    return _super.call(this, wireFormat);\n  }\n\n  _createClass(NoticeEvent, [{\n    key: \"isNotice\",\n    get: function get() {\n      return true; // override\n    }\n  }, {\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _message_types.M_NOTICE) || _get(_getPrototypeOf(NoticeEvent.prototype), \"isEquivalentTo\", this).call(this, primaryEventType);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var message = _get(_getPrototypeOf(NoticeEvent.prototype), \"serialize\", this).call(this);\n\n      message.content['msgtype'] = \"m.notice\";\n      return message;\n    }\n    /**\n     * Creates a new NoticeEvent from text and HTML.\n     * @param {string} text The text.\n     * @param {string} html Optional HTML.\n     * @returns {MessageEvent} The representative message event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(text, html) {\n      var _content;\n\n      return new NoticeEvent({\n        type: _message_types.M_NOTICE.name,\n        content: (_content = {}, _defineProperty(_content, _message_types.M_TEXT.name, text), _defineProperty(_content, _message_types.M_HTML.name, html), _content)\n      });\n    }\n  }]);\n\n  return NoticeEvent;\n}(_MessageEvent2.MessageEvent);\n\nexports.NoticeEvent = NoticeEvent;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollEndEvent = void 0;\n\nvar _poll_types = require(\"./poll_types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _relationship_types = require(\"./relationship_types\");\n\nvar _MessageEvent = require(\"./MessageEvent\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _events = require(\"../utility/events\");\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a poll end/closure event.\n */\nvar PollEndEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(PollEndEvent, _ExtensibleEvent);\n\n  var _super = _createSuper(PollEndEvent);\n\n  /**\n   * The poll start event ID referenced by the response.\n   */\n\n  /**\n   * The closing message for the event.\n   */\n\n  /**\n   * Creates a new PollEndEvent from a pure format. Note that the event is *not*\n   * parsed here: it will be treated as a literal m.poll.response primary typed event.\n   * @param {IPartialEvent<M_POLL_END_EVENT_CONTENT>} wireFormat The event.\n   */\n  function PollEndEvent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, PollEndEvent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"pollEventId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"closingMessage\", void 0);\n\n    var rel = _this.wireContent[\"m.relates_to\"];\n\n    if (!_relationship_types.REFERENCE_RELATION.matches(rel === null || rel === void 0 ? void 0 : rel.rel_type) || typeof (rel === null || rel === void 0 ? void 0 : rel.event_id) !== \"string\") {\n      throw new _InvalidEventError.InvalidEventError(\"Relationship must be a reference to an event\");\n    }\n\n    _this.pollEventId = rel.event_id;\n    _this.closingMessage = new _MessageEvent.MessageEvent(_this.wireFormat);\n    return _this;\n  }\n\n  _createClass(PollEndEvent, [{\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _poll_types.M_POLL_END);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        type: _poll_types.M_POLL_END.name,\n        content: _objectSpread(_defineProperty({\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: this.pollEventId\n          }\n        }, _poll_types.M_POLL_END.name, {}), this.closingMessage.serialize().content)\n      };\n    }\n    /**\n     * Creates a new PollEndEvent from a poll event ID.\n     * @param {string} pollEventId The poll start event ID.\n     * @param {string} message A closing message, typically revealing the top answer.\n     * @returns {PollStartEvent} The representative poll closure event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(pollEventId, message) {\n      var _content;\n\n      return new PollEndEvent({\n        type: _poll_types.M_POLL_END.name,\n        content: (_content = {\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: pollEventId\n          }\n        }, _defineProperty(_content, _poll_types.M_POLL_END.name, {}), _defineProperty(_content, _message_types.M_TEXT.name, message), _content)\n      });\n    }\n  }]);\n\n  return PollEndEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.PollEndEvent = PollEndEvent;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollResponseEvent = void 0;\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nvar _poll_types = require(\"./poll_types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _relationship_types = require(\"./relationship_types\");\n\nvar _events = require(\"../utility/events\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a poll response event.\n */\nvar PollResponseEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(PollResponseEvent, _ExtensibleEvent);\n\n  var _super = _createSuper(PollResponseEvent);\n\n  /**\n   * Creates a new PollResponseEvent from a pure format. Note that the event is *not*\n   * parsed here: it will be treated as a literal m.poll.response primary typed event.\n   *\n   * To validate the response against a poll, call `validateAgainst` after creation.\n   * @param {IPartialEvent<M_POLL_RESPONSE_EVENT_CONTENT>} wireFormat The event.\n   */\n  function PollResponseEvent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, PollResponseEvent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"internalAnswerIds\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"internalSpoiled\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"pollEventId\", void 0);\n\n    var rel = _this.wireContent[\"m.relates_to\"];\n\n    if (!_relationship_types.REFERENCE_RELATION.matches(rel === null || rel === void 0 ? void 0 : rel.rel_type) || typeof (rel === null || rel === void 0 ? void 0 : rel.event_id) !== \"string\") {\n      throw new _InvalidEventError.InvalidEventError(\"Relationship must be a reference to an event\");\n    }\n\n    _this.pollEventId = rel.event_id;\n\n    _this.validateAgainst(null);\n\n    return _this;\n  }\n  /**\n   * Validates the poll response using the poll start event as a frame of reference. This\n   * is used to determine if the vote is spoiled, whether the answers are valid, etc.\n   * @param {PollStartEvent} poll The poll start event.\n   */\n\n\n  _createClass(PollResponseEvent, [{\n    key: \"answerIds\",\n    get:\n    /**\n     * The provided answers for the poll. Note that this may be falsy/unpredictable if\n     * the `spoiled` property is true.\n     */\n    function get() {\n      return this.internalAnswerIds;\n    }\n    /**\n     * The poll start event ID referenced by the response.\n     */\n\n  }, {\n    key: \"spoiled\",\n    get:\n    /**\n     * Whether the vote is spoiled.\n     */\n    function get() {\n      return this.internalSpoiled;\n    }\n  }, {\n    key: \"validateAgainst\",\n    value: function validateAgainst(poll) {\n      var response = _poll_types.M_POLL_RESPONSE.findIn(this.wireContent);\n\n      if (!Array.isArray(response === null || response === void 0 ? void 0 : response.answers)) {\n        this.internalSpoiled = true;\n        this.internalAnswerIds = [];\n        return;\n      }\n\n      var answers = response.answers;\n\n      if (answers.some(function (a) {\n        return typeof a !== \"string\";\n      }) || answers.length === 0) {\n        this.internalSpoiled = true;\n        this.internalAnswerIds = [];\n        return;\n      }\n\n      if (poll) {\n        if (answers.some(function (a) {\n          return !poll.answers.some(function (pa) {\n            return pa.id === a;\n          });\n        })) {\n          this.internalSpoiled = true;\n          this.internalAnswerIds = [];\n          return;\n        }\n\n        answers = answers.slice(0, poll.maxSelections);\n      }\n\n      this.internalAnswerIds = answers;\n      this.internalSpoiled = false;\n    }\n  }, {\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _poll_types.M_POLL_RESPONSE);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        type: _poll_types.M_POLL_RESPONSE.name,\n        content: _defineProperty({\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: this.pollEventId\n          }\n        }, _poll_types.M_POLL_RESPONSE.name, {\n          answers: this.spoiled ? undefined : this.answerIds\n        })\n      };\n    }\n    /**\n     * Creates a new PollResponseEvent from a set of answers. To spoil the vote, pass an empty\n     * answers array.\n     * @param {string} answers The user's answers. Should be valid from a poll's answer IDs.\n     * @param {string} pollEventId The poll start event ID.\n     * @returns {PollStartEvent} The representative poll response event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(answers, pollEventId) {\n      return new PollResponseEvent({\n        type: _poll_types.M_POLL_RESPONSE.name,\n        content: _defineProperty({\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: pollEventId\n          }\n        }, _poll_types.M_POLL_RESPONSE.name, {\n          answers: answers\n        })\n      });\n    }\n  }]);\n\n  return PollResponseEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.PollResponseEvent = PollResponseEvent;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollStartEvent = exports.PollAnswerSubevent = void 0;\n\nvar _poll_types = require(\"./poll_types\");\n\nvar _MessageEvent2 = require(\"./MessageEvent\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _NamespacedValue = require(\"../NamespacedValue\");\n\nvar _events = require(\"../utility/events\");\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a poll answer. Note that this is represented as a subtype and is\n * not registered as a parsable event - it is implied for usage exclusively\n * within the PollStartEvent parsing.\n */\nvar PollAnswerSubevent = /*#__PURE__*/function (_MessageEvent) {\n  _inherits(PollAnswerSubevent, _MessageEvent);\n\n  var _super = _createSuper(PollAnswerSubevent);\n\n  /**\n   * The answer ID.\n   */\n  function PollAnswerSubevent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, PollAnswerSubevent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    var id = wireFormat.content.id;\n\n    if (!id || typeof id !== \"string\") {\n      throw new _InvalidEventError.InvalidEventError(\"Answer ID must be a non-empty string\");\n    }\n\n    _this.id = id;\n    return _this;\n  }\n\n  _createClass(PollAnswerSubevent, [{\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        type: \"org.matrix.sdk.poll.answer\",\n        content: _objectSpread({\n          id: this.id\n        }, this.serializeMMessageOnly())\n      };\n    }\n    /**\n     * Creates a new PollAnswerSubevent from ID and text.\n     * @param {string} id The answer ID (unique within the poll).\n     * @param {string} text The text.\n     * @returns {PollAnswerSubevent} The representative answer.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(id, text) {\n      return new PollAnswerSubevent({\n        type: \"org.matrix.sdk.poll.answer\",\n        content: _defineProperty({\n          id: id\n        }, _message_types.M_TEXT.name, text)\n      });\n    }\n  }]);\n\n  return PollAnswerSubevent;\n}(_MessageEvent2.MessageEvent);\n/**\n * Represents a poll start event.\n */\n\n\nexports.PollAnswerSubevent = PollAnswerSubevent;\n\nvar PollStartEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(PollStartEvent, _ExtensibleEvent);\n\n  var _super2 = _createSuper(PollStartEvent);\n\n  /**\n   * The question being asked, as a MessageEvent node.\n   */\n\n  /**\n   * The interpreted kind of poll. Note that this will infer a value that is known to the\n   * SDK rather than verbatim - this means unknown types will be represented as undisclosed\n   * polls.\n   *\n   * To get the raw kind, use rawKind.\n   */\n\n  /**\n   * The true kind as provided by the event sender. Might not be valid.\n   */\n\n  /**\n   * The maximum number of selections a user is allowed to make.\n   */\n\n  /**\n   * The possible answers for the poll.\n   */\n\n  /**\n   * Creates a new PollStartEvent from a pure format. Note that the event is *not*\n   * parsed here: it will be treated as a literal m.poll.start primary typed event.\n   * @param {IPartialEvent<M_POLL_START_EVENT_CONTENT>} wireFormat The event.\n   */\n  function PollStartEvent(wireFormat) {\n    var _this2;\n\n    _classCallCheck(this, PollStartEvent);\n\n    _this2 = _super2.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this2), \"question\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"kind\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"rawKind\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"maxSelections\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"answers\", void 0);\n\n    var poll = _poll_types.M_POLL_START.findIn(_this2.wireContent);\n\n    if (!poll.question) {\n      throw new _InvalidEventError.InvalidEventError(\"A question is required\");\n    }\n\n    _this2.question = new _MessageEvent2.MessageEvent({\n      type: \"org.matrix.sdk.poll.question\",\n      content: poll.question\n    });\n    _this2.rawKind = poll.kind;\n\n    if (_poll_types.M_POLL_KIND_DISCLOSED.matches(_this2.rawKind)) {\n      _this2.kind = _poll_types.M_POLL_KIND_DISCLOSED;\n    } else {\n      _this2.kind = _poll_types.M_POLL_KIND_UNDISCLOSED; // default & assumed value\n    }\n\n    _this2.maxSelections = Number.isFinite(poll.max_selections) && poll.max_selections > 0 ? poll.max_selections : 1;\n\n    if (!Array.isArray(poll.answers)) {\n      throw new _InvalidEventError.InvalidEventError(\"Poll answers must be an array\");\n    }\n\n    var answers = poll.answers.slice(0, 20).map(function (a) {\n      return new PollAnswerSubevent({\n        type: \"org.matrix.sdk.poll.answer\",\n        content: a\n      });\n    });\n\n    if (answers.length <= 0) {\n      throw new _InvalidEventError.InvalidEventError(\"No answers available\");\n    }\n\n    _this2.answers = answers;\n    return _this2;\n  }\n\n  _createClass(PollStartEvent, [{\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _poll_types.M_POLL_START);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var _content2;\n\n      return {\n        type: _poll_types.M_POLL_START.name,\n        content: (_content2 = {}, _defineProperty(_content2, _poll_types.M_POLL_START.name, {\n          question: this.question.serialize().content,\n          kind: this.rawKind,\n          max_selections: this.maxSelections,\n          answers: this.answers.map(function (a) {\n            return a.serialize().content;\n          })\n        }), _defineProperty(_content2, _message_types.M_TEXT.name, \"\".concat(this.question.text, \"\\n\").concat(this.answers.map(function (a, i) {\n          return \"\".concat(i + 1, \". \").concat(a.text);\n        }).join(\"\\n\"))), _content2)\n      };\n    }\n    /**\n     * Creates a new PollStartEvent from question, answers, and metadata.\n     * @param {string} question The question to ask.\n     * @param {string} answers The answers. Should be unique within each other.\n     * @param {KNOWN_POLL_KIND|string} kind The kind of poll.\n     * @param {number} maxSelections The maximum number of selections. Must be 1 or higher.\n     * @returns {PollStartEvent} The representative poll start event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(question, answers, kind) {\n      var _content3;\n\n      var maxSelections = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      return new PollStartEvent({\n        type: _poll_types.M_POLL_START.name,\n        content: (_content3 = {}, _defineProperty(_content3, _message_types.M_TEXT.name, question), _defineProperty(_content3, _poll_types.M_POLL_START.name, {\n          question: _defineProperty({}, _message_types.M_TEXT.name, question),\n          kind: kind instanceof _NamespacedValue.NamespacedValue ? kind.name : kind,\n          max_selections: maxSelections,\n          answers: answers.map(function (a) {\n            return _defineProperty({\n              id: makeId()\n            }, _message_types.M_TEXT.name, a);\n          })\n        }), _content3)\n      });\n    }\n  }]);\n\n  return PollStartEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.PollStartEvent = PollStartEvent;\nvar LETTERS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\nfunction makeId() {\n  return _toConsumableArray(Array(16)).map(function () {\n    return LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));\n  }).join('');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.M_TEXT = exports.M_NOTICE = exports.M_MESSAGE = exports.M_HTML = exports.M_EMOTE = void 0;\n\nvar _NamespacedValue = require(\"../NamespacedValue\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * The namespaced value for m.message\n */\nvar M_MESSAGE = new _NamespacedValue.UnstableValue(\"m.message\", \"org.matrix.msc1767.message\");\n/**\n * An m.message event rendering\n */\n\nexports.M_MESSAGE = M_MESSAGE;\n\n/**\n * The namespaced value for m.text\n */\nvar M_TEXT = new _NamespacedValue.UnstableValue(\"m.text\", \"org.matrix.msc1767.text\");\n/**\n * The content for an m.text event\n */\n\nexports.M_TEXT = M_TEXT;\n\n/**\n * The namespaced value for m.html\n */\nvar M_HTML = new _NamespacedValue.UnstableValue(\"m.html\", \"org.matrix.msc1767.html\");\n/**\n * The content for an m.html event\n */\n\nexports.M_HTML = M_HTML;\n\n/**\n * The namespaced value for m.emote\n */\nvar M_EMOTE = new _NamespacedValue.UnstableValue(\"m.emote\", \"org.matrix.msc1767.emote\");\n/**\n * The event definition for an m.emote event (in content)\n */\n\nexports.M_EMOTE = M_EMOTE;\n\n/**\n * The namespaced value for m.notice\n */\nvar M_NOTICE = new _NamespacedValue.UnstableValue(\"m.notice\", \"org.matrix.msc1767.notice\");\n/**\n * The event definition for an m.notice event (in content)\n */\n\nexports.M_NOTICE = M_NOTICE;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.M_POLL_START = exports.M_POLL_RESPONSE = exports.M_POLL_KIND_UNDISCLOSED = exports.M_POLL_KIND_DISCLOSED = exports.M_POLL_END = void 0;\n\nvar _NamespacedValue = require(\"../NamespacedValue\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Identifier for a disclosed poll.\n */\nvar M_POLL_KIND_DISCLOSED = new _NamespacedValue.UnstableValue(\"m.poll.disclosed\", \"org.matrix.msc3381.poll.disclosed\");\n/**\n * Identifier for an undisclosed poll.\n */\n\nexports.M_POLL_KIND_DISCLOSED = M_POLL_KIND_DISCLOSED;\nvar M_POLL_KIND_UNDISCLOSED = new _NamespacedValue.UnstableValue(\"m.poll.undisclosed\", \"org.matrix.msc3381.poll.undisclosed\");\n/**\n * Any poll kind.\n */\n\nexports.M_POLL_KIND_UNDISCLOSED = M_POLL_KIND_UNDISCLOSED;\n\n/**\n * The namespaced value for m.poll.start\n */\nvar M_POLL_START = new _NamespacedValue.UnstableValue(\"m.poll.start\", \"org.matrix.msc3381.poll.start\");\n/**\n * The m.poll.start type within event content\n */\n\nexports.M_POLL_START = M_POLL_START;\n\n/**\n * The namespaced value for m.poll.response\n */\nvar M_POLL_RESPONSE = new _NamespacedValue.UnstableValue(\"m.poll.response\", \"org.matrix.msc3381.poll.response\");\n/**\n * The m.poll.response type within event content\n */\n\nexports.M_POLL_RESPONSE = M_POLL_RESPONSE;\n\n/**\n * The namespaced value for m.poll.end\n */\nvar M_POLL_END = new _NamespacedValue.UnstableValue(\"m.poll.end\", \"org.matrix.msc3381.poll.end\");\n/**\n * The event definition for an m.poll.end event (in content)\n */\n\nexports.M_POLL_END = M_POLL_END;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.REFERENCE_RELATION = void 0;\n\nvar _NamespacedValue = require(\"../NamespacedValue\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * The namespaced value for an m.reference relation\n */\nvar REFERENCE_RELATION = new _NamespacedValue.NamespacedValue(\"m.reference\");\n/**\n * Represents any relation type\n */\n\nexports.REFERENCE_RELATION = REFERENCE_RELATION;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ExtensibleEvents = require(\"./ExtensibleEvents\");\n\nObject.keys(_ExtensibleEvents).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ExtensibleEvents[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _ExtensibleEvents[key];\n    }\n  });\n});\n\nvar _IPartialEvent = require(\"./IPartialEvent\");\n\nObject.keys(_IPartialEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _IPartialEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _IPartialEvent[key];\n    }\n  });\n});\n\nvar _InvalidEventError = require(\"./InvalidEventError\");\n\nObject.keys(_InvalidEventError).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _InvalidEventError[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _InvalidEventError[key];\n    }\n  });\n});\n\nvar _NamespacedValue = require(\"./NamespacedValue\");\n\nObject.keys(_NamespacedValue).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _NamespacedValue[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _NamespacedValue[key];\n    }\n  });\n});\n\nvar _NamespacedMap = require(\"./NamespacedMap\");\n\nObject.keys(_NamespacedMap).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _NamespacedMap[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _NamespacedMap[key];\n    }\n  });\n});\n\nvar _types = require(\"./types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _MessageMatchers = require(\"./utility/MessageMatchers\");\n\nObject.keys(_MessageMatchers).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MessageMatchers[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MessageMatchers[key];\n    }\n  });\n});\n\nvar _events = require(\"./utility/events\");\n\nObject.keys(_events).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _events[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _events[key];\n    }\n  });\n});\n\nvar _MRoomMessage = require(\"./interpreters/legacy/MRoomMessage\");\n\nObject.keys(_MRoomMessage).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MRoomMessage[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MRoomMessage[key];\n    }\n  });\n});\n\nvar _MMessage = require(\"./interpreters/modern/MMessage\");\n\nObject.keys(_MMessage).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MMessage[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MMessage[key];\n    }\n  });\n});\n\nvar _MPoll = require(\"./interpreters/modern/MPoll\");\n\nObject.keys(_MPoll).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MPoll[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MPoll[key];\n    }\n  });\n});\n\nvar _relationship_types = require(\"./events/relationship_types\");\n\nObject.keys(_relationship_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _relationship_types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _relationship_types[key];\n    }\n  });\n});\n\nvar _ExtensibleEvent = require(\"./events/ExtensibleEvent\");\n\nObject.keys(_ExtensibleEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ExtensibleEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _ExtensibleEvent[key];\n    }\n  });\n});\n\nvar _message_types = require(\"./events/message_types\");\n\nObject.keys(_message_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _message_types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _message_types[key];\n    }\n  });\n});\n\nvar _MessageEvent = require(\"./events/MessageEvent\");\n\nObject.keys(_MessageEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _MessageEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _MessageEvent[key];\n    }\n  });\n});\n\nvar _EmoteEvent = require(\"./events/EmoteEvent\");\n\nObject.keys(_EmoteEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _EmoteEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _EmoteEvent[key];\n    }\n  });\n});\n\nvar _NoticeEvent = require(\"./events/NoticeEvent\");\n\nObject.keys(_NoticeEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _NoticeEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _NoticeEvent[key];\n    }\n  });\n});\n\nvar _poll_types = require(\"./events/poll_types\");\n\nObject.keys(_poll_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _poll_types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _poll_types[key];\n    }\n  });\n});\n\nvar _PollStartEvent = require(\"./events/PollStartEvent\");\n\nObject.keys(_PollStartEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _PollStartEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _PollStartEvent[key];\n    }\n  });\n});\n\nvar _PollResponseEvent = require(\"./events/PollResponseEvent\");\n\nObject.keys(_PollResponseEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _PollResponseEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _PollResponseEvent[key];\n    }\n  });\n});\n\nvar _PollEndEvent = require(\"./events/PollEndEvent\");\n\nObject.keys(_PollEndEvent).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _PollEndEvent[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _PollEndEvent[key];\n    }\n  });\n});","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGACY_M_ROOM_MESSAGE = void 0;\nexports.parseMRoomMessage = parseMRoomMessage;\n\nvar _MessageEvent = require(\"../../events/MessageEvent\");\n\nvar _NoticeEvent = require(\"../../events/NoticeEvent\");\n\nvar _EmoteEvent = require(\"../../events/EmoteEvent\");\n\nvar _NamespacedValue = require(\"../../NamespacedValue\");\n\nvar _message_types = require(\"../../events/message_types\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar LEGACY_M_ROOM_MESSAGE = new _NamespacedValue.NamespacedValue(\"m.room.message\");\nexports.LEGACY_M_ROOM_MESSAGE = LEGACY_M_ROOM_MESSAGE;\n\nfunction parseMRoomMessage(wireEvent) {\n  var _wireEvent$content, _wireEvent$content2, _wireEvent$content3;\n\n  if (_message_types.M_MESSAGE.findIn(wireEvent.content) || _message_types.M_TEXT.findIn(wireEvent.content)) {\n    // We know enough about the event to coerce it into the right type\n    return new _MessageEvent.MessageEvent(wireEvent);\n  }\n\n  var msgtype = (_wireEvent$content = wireEvent.content) === null || _wireEvent$content === void 0 ? void 0 : _wireEvent$content.msgtype;\n  var text = (_wireEvent$content2 = wireEvent.content) === null || _wireEvent$content2 === void 0 ? void 0 : _wireEvent$content2.body;\n  var html = ((_wireEvent$content3 = wireEvent.content) === null || _wireEvent$content3 === void 0 ? void 0 : _wireEvent$content3.format) === \"org.matrix.custom.html\" ? wireEvent.content.formatted_body : null;\n\n  if (msgtype === \"m.text\") {\n    var _objectSpread2;\n\n    return new _MessageEvent.MessageEvent(_objectSpread(_objectSpread({}, wireEvent), {}, {\n      content: _objectSpread(_objectSpread({}, wireEvent.content), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, _message_types.M_TEXT.name, text), _defineProperty(_objectSpread2, _message_types.M_HTML.name, html), _objectSpread2))\n    }));\n  } else if (msgtype === \"m.notice\") {\n    var _objectSpread3;\n\n    return new _NoticeEvent.NoticeEvent(_objectSpread(_objectSpread({}, wireEvent), {}, {\n      content: _objectSpread(_objectSpread({}, wireEvent.content), {}, (_objectSpread3 = {}, _defineProperty(_objectSpread3, _message_types.M_TEXT.name, text), _defineProperty(_objectSpread3, _message_types.M_HTML.name, html), _objectSpread3))\n    }));\n  } else if (msgtype === \"m.emote\") {\n    var _objectSpread4;\n\n    return new _EmoteEvent.EmoteEvent(_objectSpread(_objectSpread({}, wireEvent), {}, {\n      content: _objectSpread(_objectSpread({}, wireEvent.content), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, _message_types.M_TEXT.name, text), _defineProperty(_objectSpread4, _message_types.M_HTML.name, html), _objectSpread4))\n    }));\n  } else {\n    // TODO: Handle other types\n    return null;\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseMMessage = parseMMessage;\n\nvar _MessageEvent = require(\"../../events/MessageEvent\");\n\nvar _message_types = require(\"../../events/message_types\");\n\nvar _EmoteEvent = require(\"../../events/EmoteEvent\");\n\nvar _NoticeEvent = require(\"../../events/NoticeEvent\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nfunction parseMMessage(wireEvent) {\n  if (_message_types.M_EMOTE.matches(wireEvent.type)) {\n    return new _EmoteEvent.EmoteEvent(wireEvent);\n  } else if (_message_types.M_NOTICE.matches(wireEvent.type)) {\n    return new _NoticeEvent.NoticeEvent(wireEvent);\n  } // default: return a generic message\n\n\n  return new _MessageEvent.MessageEvent(wireEvent);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseMPoll = parseMPoll;\n\nvar _poll_types = require(\"../../events/poll_types\");\n\nvar _PollStartEvent = require(\"../../events/PollStartEvent\");\n\nvar _PollResponseEvent = require(\"../../events/PollResponseEvent\");\n\nvar _PollEndEvent = require(\"../../events/PollEndEvent\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nfunction parseMPoll(wireEvent) {\n  if (_poll_types.M_POLL_START.matches(wireEvent.type)) {\n    return new _PollStartEvent.PollStartEvent(wireEvent);\n  } else if (_poll_types.M_POLL_RESPONSE.matches(wireEvent.type)) {\n    return new _PollResponseEvent.PollResponseEvent(wireEvent);\n  } else if (_poll_types.M_POLL_END.matches(wireEvent.type)) {\n    return new _PollEndEvent.PollEndEvent(wireEvent);\n  }\n\n  return null; // not a poll event\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isOptionalAString = isOptionalAString;\nexports.isProvided = isProvided;\n\n/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents an optional type: can either be T or a falsy value.\n */\n\n/**\n * Determines if the given optional string is a defined string.\n * @param {Optional<string>} s The input string.\n * @returns {boolean} True if the input is a defined string.\n */\nfunction isOptionalAString(s) {\n  return isProvided(s) && typeof s === 'string';\n}\n/**\n * Determines if the given optional was provided a value.\n * @param {Optional<T>} s The optional to test.\n * @returns {boolean} True if the value is defined.\n */\n\n\nfunction isProvided(s) {\n  return s !== null && s !== undefined;\n}\n/**\n * Represents either just T1, just T2, or T1 and T2 mixed.\n */","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LegacyMsgType = void 0;\nexports.isEventLike = isEventLike;\n\nvar _message_types = require(\"../events/message_types\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents a legacy m.room.message msgtype\n */\nvar LegacyMsgType;\n/**\n * Determines if the given partial event looks similar enough to the given legacy msgtype\n * to count as that message type.\n * @param {IPartialEvent<EitherAnd<IPartialLegacyContent, M_MESSAGE_EVENT_CONTENT>>} event The event.\n * @param {LegacyMsgType} msgtype The message type to compare for.\n * @returns {boolean} True if the event appears to look similar enough to the msgtype.\n */\n\nexports.LegacyMsgType = LegacyMsgType;\n\n(function (LegacyMsgType) {\n  LegacyMsgType[\"Text\"] = \"m.text\";\n  LegacyMsgType[\"Notice\"] = \"m.notice\";\n  LegacyMsgType[\"Emote\"] = \"m.emote\";\n})(LegacyMsgType || (exports.LegacyMsgType = LegacyMsgType = {}));\n\nfunction isEventLike(event, msgtype) {\n  var content = event.content;\n\n  if (msgtype === LegacyMsgType.Text) {\n    return _message_types.M_MESSAGE.matches(event.type) || event.type === \"m.room.message\" && (content === null || content === void 0 ? void 0 : content['msgtype']) === \"m.text\";\n  } else if (msgtype === LegacyMsgType.Emote) {\n    return _message_types.M_EMOTE.matches(event.type) || event.type === \"m.room.message\" && (content === null || content === void 0 ? void 0 : content['msgtype']) === \"m.emote\";\n  } else if (msgtype === LegacyMsgType.Notice) {\n    return _message_types.M_NOTICE.matches(event.type) || event.type === \"m.room.message\" && (content === null || content === void 0 ? void 0 : content['msgtype']) === \"m.notice\";\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEventTypeSame = isEventTypeSame;\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents a potentially namespaced event type.\n */\n\n/**\n * Determines if two event types are the same, including namespaces.\n * @param {EventType} given The given event type. This will be compared\n * against the expected type.\n * @param {EventType} expected The expected event type.\n * @returns {boolean} True if the given type matches the expected type.\n */\nfunction isEventTypeSame(given, expected) {\n  if (typeof given === \"string\") {\n    if (typeof expected === \"string\") {\n      return expected === given;\n    } else {\n      return expected.matches(given);\n    }\n  } else {\n    if (typeof expected === \"string\") {\n      return given.matches(expected);\n    } else {\n      var expectedNs = expected;\n      var givenNs = given;\n      return expectedNs.matches(givenNs.name) || expectedNs.matches(givenNs.altName);\n    }\n  }\n}","/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Well-known values (from the spec or MSCs) that are allowed in the\n * {@link Membership} type.\n */\nexport enum KnownMembership {\n    /**\n     * The user has been banned from the room, and is no longer allowed to join\n     * it until they are un-banned from the room (by having their membership\n     * state set to a value other than ban).\n     */\n    Ban = \"ban\",\n    /**\n     * The user has been invited to join a room, but has not yet joined it.\n     * They may not participate in the room until they join.\n     * */\n    Invite = \"invite\",\n    /**\n     * The user has joined the room (possibly after accepting an invite), and\n     * may participate in it.\n     */\n    Join = \"join\",\n    /**\n     * The user has knocked on the room, requesting permission to participate.\n     * They may not participate in the room until they join.\n     */\n    Knock = \"knock\",\n    /**\n     * The user was once joined to the room, but has since left (possibly by\n     * choice, or possibly by being kicked).\n     */\n    Leave = \"leave\",\n}\n\n/**\n * The membership state for a user in a room [1]. A value from\n * {@link KnownMembership} should be used where available, but all string values\n * are allowed to provide flexibility for upcoming spec changes or proposals.\n *\n * [1] https://spec.matrix.org/latest/client-server-api/#mroommember\n */\nexport type Membership = KnownMembership | string;\n","/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017 Vector Creations Ltd\nCopyright 2017 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// eslint-disable-next-line no-restricted-imports\nimport { type EventEmitter } from \"events\";\n\nimport { type ListenerMap, type TypedEventEmitter } from \"./models/typed-event-emitter.ts\";\n\nexport class ReEmitter {\n    public constructor(private readonly target: EventEmitter) {}\n\n    // Map from emitter to event name to re-emitter\n    private reEmitters = new WeakMap<EventEmitter, Map<string, (...args: any[]) => void>>();\n\n    public reEmit(source: EventEmitter, eventNames: string[]): void {\n        let reEmittersByEvent = this.reEmitters.get(source);\n        if (!reEmittersByEvent) {\n            reEmittersByEvent = new Map();\n            this.reEmitters.set(source, reEmittersByEvent);\n        }\n\n        for (const eventName of eventNames) {\n            if (reEmittersByEvent.has(eventName)) continue;\n\n            // We include the source as the last argument for event handlers which may need it,\n            // such as read receipt listeners on the client class which won't have the context\n            // of the room.\n            const forSource = (...args: any[]): void => {\n                // EventEmitter special cases 'error' to make the emit function throw if no\n                // handler is attached, which sort of makes sense for making sure that something\n                // handles an error, but for re-emitting, there could be a listener on the original\n                // source object so the test doesn't really work. We *could* try to replicate the\n                // same logic and throw if there is no listener on either the source or the target,\n                // but this behaviour is fairly undesireable for us anyway: the main place we throw\n                // 'error' events is for calls, where error events are usually emitted some time\n                // later by a different part of the code where 'emit' throwing because the app hasn't\n                // added an error handler isn't terribly helpful. (A better fix in retrospect may\n                // have been to just avoid using the event name 'error', but backwards compat...)\n                if (eventName === \"error\" && this.target.listenerCount(\"error\") === 0) return;\n                this.target.emit(eventName, ...args, source);\n            };\n            source.on(eventName, forSource);\n            reEmittersByEvent.set(eventName, forSource);\n        }\n    }\n\n    public stopReEmitting(source: EventEmitter, eventNames: string[]): void {\n        const reEmittersByEvent = this.reEmitters.get(source);\n        if (!reEmittersByEvent) return; // We were never re-emitting these events in the first place\n\n        for (const eventName of eventNames) {\n            source.off(eventName, reEmittersByEvent.get(eventName)!);\n            reEmittersByEvent.delete(eventName);\n        }\n\n        if (reEmittersByEvent.size === 0) this.reEmitters.delete(source);\n    }\n}\n\nexport class TypedReEmitter<Events extends string, Arguments extends ListenerMap<Events>> extends ReEmitter {\n    public constructor(target: TypedEventEmitter<Events, Arguments>) {\n        super(target);\n    }\n\n    public reEmit<ReEmittedEvents extends string, T extends Events & ReEmittedEvents>(\n        source: TypedEventEmitter<ReEmittedEvents, any>,\n        eventNames: T[],\n    ): void {\n        super.reEmit(source, eventNames);\n    }\n\n    public stopReEmitting<ReEmittedEvents extends string, T extends Events & ReEmittedEvents>(\n        source: TypedEventEmitter<ReEmittedEvents, any>,\n        eventNames: T[],\n    ): void {\n        super.stopReEmitting(source, eventNames);\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ToDeviceMessageId } from \"./@types/event.ts\";\nimport { type Logger } from \"./logger.ts\";\nimport { type MatrixClient, ClientEvent } from \"./client.ts\";\nimport { type MatrixError } from \"./http-api/index.ts\";\nimport {\n    type IndexedToDeviceBatch,\n    type ToDeviceBatch,\n    type ToDeviceBatchWithTxnId,\n    type ToDevicePayload,\n} from \"./models/ToDeviceMessage.ts\";\nimport { MatrixScheduler } from \"./scheduler.ts\";\nimport { SyncState } from \"./sync.ts\";\nimport { MapWithDefault } from \"./utils.ts\";\n\nconst MAX_BATCH_SIZE = 20;\n\n/**\n * Maintains a queue of outgoing to-device messages, sending them\n * as soon as the homeserver is reachable.\n */\nexport class ToDeviceMessageQueue {\n    private sending = false;\n    private running = true;\n    private retryTimeout: ReturnType<typeof setTimeout> | null = null;\n    private retryAttempts = 0;\n\n    public constructor(\n        private client: MatrixClient,\n        private readonly logger: Logger,\n    ) {}\n\n    public start(): void {\n        this.running = true;\n        this.sendQueue();\n        this.client.on(ClientEvent.Sync, this.onResumedSync);\n    }\n\n    public stop(): void {\n        this.running = false;\n        if (this.retryTimeout !== null) clearTimeout(this.retryTimeout);\n        this.retryTimeout = null;\n        this.client.removeListener(ClientEvent.Sync, this.onResumedSync);\n    }\n\n    public async queueBatch(batch: ToDeviceBatch): Promise<void> {\n        const batches: ToDeviceBatchWithTxnId[] = [];\n        for (let i = 0; i < batch.batch.length; i += MAX_BATCH_SIZE) {\n            const batchWithTxnId = {\n                eventType: batch.eventType,\n                batch: batch.batch.slice(i, i + MAX_BATCH_SIZE),\n                txnId: this.client.makeTxnId(),\n            };\n            batches.push(batchWithTxnId);\n            const msgmap = batchWithTxnId.batch.map(\n                (msg) => `${msg.userId}/${msg.deviceId} (msgid ${msg.payload[ToDeviceMessageId]})`,\n            );\n            this.logger.info(\n                `Enqueuing batch of to-device messages. type=${batch.eventType} txnid=${batchWithTxnId.txnId}`,\n                msgmap,\n            );\n        }\n\n        await this.client.store.saveToDeviceBatches(batches);\n        this.sendQueue();\n    }\n\n    public sendQueue = async (): Promise<void> => {\n        if (this.retryTimeout !== null) clearTimeout(this.retryTimeout);\n        this.retryTimeout = null;\n\n        if (this.sending || !this.running) return;\n\n        this.logger.debug(\"Attempting to send queued to-device messages\");\n\n        this.sending = true;\n        let headBatch: IndexedToDeviceBatch | null;\n        try {\n            while (this.running) {\n                headBatch = await this.client.store.getOldestToDeviceBatch();\n                if (headBatch === null) break;\n                await this.sendBatch(headBatch);\n                await this.client.store.removeToDeviceBatch(headBatch.id);\n                this.retryAttempts = 0;\n            }\n\n            // Make sure we're still running after the async tasks: if not, stop.\n            if (!this.running) return;\n\n            this.logger.debug(\"All queued to-device messages sent\");\n        } catch (e) {\n            ++this.retryAttempts;\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            // eslint-disable-next-line new-cap\n            const retryDelay = MatrixScheduler.RETRY_BACKOFF_RATELIMIT(null, this.retryAttempts, <MatrixError>e);\n            if (retryDelay === -1) {\n                // the scheduler function doesn't differentiate between fatal errors and just getting\n                // bored and giving up for now\n                if (Math.floor((<MatrixError>e).httpStatus! / 100) === 4) {\n                    this.logger.error(\"Fatal error when sending to-device message - dropping to-device batch!\", e);\n                    await this.client.store.removeToDeviceBatch(headBatch!.id);\n                } else {\n                    this.logger.info(\"Automatic retry limit reached for to-device messages.\");\n                }\n                return;\n            }\n\n            this.logger.info(`Failed to send batch of to-device messages. Will retry in ${retryDelay}ms`, e);\n            this.retryTimeout = setTimeout(this.sendQueue, retryDelay);\n        } finally {\n            this.sending = false;\n        }\n    };\n\n    /**\n     * Attempts to send a batch of to-device messages.\n     */\n    private async sendBatch(batch: IndexedToDeviceBatch): Promise<void> {\n        const contentMap: MapWithDefault<string, Map<string, ToDevicePayload>> = new MapWithDefault(() => new Map());\n        for (const item of batch.batch) {\n            contentMap.getOrCreate(item.userId).set(item.deviceId, item.payload);\n        }\n\n        this.logger.info(\n            `Sending batch of ${batch.batch.length} to-device messages with ID ${batch.id} and txnId ${batch.txnId}`,\n        );\n\n        await this.client.sendToDevice(batch.eventType, contentMap, batch.txnId);\n    }\n\n    /**\n     * Listen to sync state changes and automatically resend any pending events\n     * once syncing is resumed\n     */\n    private onResumedSync = (state: SyncState | null, oldState: SyncState | null): void => {\n        if (state === SyncState.Syncing && oldState !== SyncState.Syncing) {\n            this.logger.info(`Resuming queue after resumed sync`);\n            this.sendQueue();\n        }\n    };\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Base64 encoding and decoding utilities\n */\n\nfunction toBase64(uint8Array: Uint8Array, options: Uint8ArrayToBase64Options): string {\n    if (typeof uint8Array.toBase64 === \"function\") {\n        // Currently this is only supported in Firefox,\n        // but we match the options in the hope in the future we can rely on it for all environments.\n        // https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.tobase64\n        return uint8Array.toBase64(options);\n    }\n\n    let base64 = btoa(uint8Array.reduce((acc, current) => acc + String.fromCharCode(current), \"\"));\n    if (options.omitPadding) {\n        base64 = base64.replace(/={1,2}$/, \"\");\n    }\n    if (options.alphabet === \"base64url\") {\n        base64 = base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n\n    return base64;\n}\n\n/**\n * Encode a typed array of uint8 as base64.\n * @param uint8Array - The data to encode.\n * @returns The base64.\n */\nexport function encodeBase64(uint8Array: Uint8Array): string {\n    return toBase64(uint8Array, { alphabet: \"base64\", omitPadding: false });\n}\n\n/**\n * Encode a typed array of uint8 as unpadded base64.\n * @param uint8Array - The data to encode.\n * @returns The unpadded base64.\n */\nexport function encodeUnpaddedBase64(uint8Array: Uint8Array): string {\n    return toBase64(uint8Array, { alphabet: \"base64\", omitPadding: true });\n}\n\n/**\n * Encode a typed array of uint8 as unpadded base64 using the URL-safe encoding.\n * @param uint8Array - The data to encode.\n * @returns The unpadded base64.\n */\nexport function encodeUnpaddedBase64Url(uint8Array: Uint8Array): string {\n    return toBase64(uint8Array, { alphabet: \"base64url\", omitPadding: true });\n}\n\nfunction fromBase64(base64: string, options: Uint8ArrayFromBase64Options): Uint8Array {\n    if (typeof Uint8Array.fromBase64 === \"function\") {\n        // Currently this is only supported in Firefox,\n        // but we match the options in the hope in the future we can rely on it for all environments.\n        // https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.frombase64\n        return Uint8Array.fromBase64(base64, options);\n    }\n\n    return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));\n}\n\n/**\n * Decode a base64 (or base64url) string to a typed array of uint8.\n * @param base64 - The base64 to decode.\n * @returns The decoded data.\n */\nexport function decodeBase64(base64: string): Uint8Array {\n    // The function requires us to select an alphabet, but we don't know if base64url was used so we convert.\n    return fromBase64(base64.replace(/-/g, \"+\").replace(/_/g, \"/\"), { alphabet: \"base64\", lastChunkHandling: \"loose\" });\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type { IDeviceLists, IToDeviceEvent, ReceivedToDeviceMessage } from \"../sync-accumulator.ts\";\nimport { type IClearEvent, type MatrixEvent } from \"../models/event.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { type CryptoApi, type DecryptionFailureCode, type ImportRoomKeysOpts } from \"../crypto-api/index.ts\";\nimport { type KeyBackupInfo, type KeyBackupSession } from \"../crypto-api/keybackup.ts\";\nimport { type IMegolmSessionData } from \"../@types/crypto.ts\";\n\n/**\n * Common interface for the crypto implementations\n *\n * @internal\n */\nexport interface CryptoBackend extends SyncCryptoCallbacks, CryptoApi {\n    /**\n     * Whether sendMessage in a room with unknown and unverified devices\n     * should throw an error and not send the message. This has 'Global' for\n     * symmetry with setGlobalBlacklistUnverifiedDevices but there is currently\n     * no room-level equivalent for this setting.\n     *\n     * @remarks This has no effect in Rust Crypto; it exists only for the sake of\n     * the accessors in MatrixClient.\n     */\n    globalErrorOnUnknownDevices: boolean;\n\n    /**\n     * Shut down any background processes related to crypto\n     */\n    stop(): void;\n\n    /**\n     * Encrypt an event according to the configuration of the room.\n     *\n     * @param event -  event to be sent\n     *\n     * @param room - destination room.\n     *\n     * @returns Promise which resolves when the event has been\n     *     encrypted, or null if nothing was needed\n     */\n    encryptEvent(event: MatrixEvent, room: Room): Promise<void>;\n\n    /**\n     * Decrypt a received event\n     *\n     * @returns a promise which resolves once we have finished decrypting.\n     * Rejects with an error if there is a problem decrypting the event.\n     */\n    decryptEvent(event: MatrixEvent): Promise<EventDecryptionResult>;\n\n    /**\n     * Get a backup decryptor capable of decrypting megolm session data encrypted with the given backup information.\n     * @param backupInfo - The backup information\n     * @param privKey - The private decryption key.\n     */\n    getBackupDecryptor(backupInfo: KeyBackupInfo, privKey: Uint8Array): Promise<BackupDecryptor>;\n\n    /**\n     * Import a list of room keys restored from backup\n     *\n     * @param keys - a list of session export objects\n     * @param backupVersion - the version of the backup these keys came from.\n     * @param opts - options object\n     * @returns a promise which resolves once the keys have been imported\n     */\n    importBackedUpRoomKeys(keys: IMegolmSessionData[], backupVersion: string, opts?: ImportRoomKeysOpts): Promise<void>;\n\n    /**\n     * Having accepted an invite for the given room from the given user, attempt to\n     * find information about a room key bundle and, if found, download the\n     * bundle and import the room keys, as per {@link https://github.com/matrix-org/matrix-spec-proposals/pull/4268|MSC4268}.\n     *\n     * @param roomId - The room we were invited to, for which we want to check if a room\n     *   key bundle was received.\n     *\n     * @param inviter - The user who invited us to the room and is expected to have\n     *   sent the room key bundle.\n     *\n     * @returns `true` if the key bundle was successfuly downloaded and imported.\n     */\n    maybeAcceptKeyBundle(roomId: string, inviter: string): Promise<boolean>;\n\n    /**\n     * Mark a room as pending a key bundle under MSC4268. The backend will listen for room key bundle messages, and if\n     * it sees one matching the room specified, it will automatically import it as long as the message author's ID matches\n     * the inviter's ID.\n     *\n     * @param roomId - The room we were invited to, for which we did not receive a key bundle before accepting the invite.\n     * @param inviterId - The user who invited us to the room and is expected to send the room key bundle.\n     */\n    markRoomAsPendingKeyBundle(roomId: string, inviterId: string): void;\n}\n\n/** The methods which crypto implementations should expose to the Sync api\n *\n * @internal\n */\nexport interface SyncCryptoCallbacks {\n    /**\n     * Called by the /sync loop whenever there are incoming to-device messages.\n     *\n     * The implementation may preprocess the received messages (eg, decrypt them) and return an\n     * updated list of messages for dispatch to the rest of the system.\n     *\n     * Note that, unlike {@link ClientEvent.ToDeviceEvent} events, this is called on the raw to-device\n     * messages, rather than the results of any decryption attempts.\n     *\n     * @param events - the received to-device messages\n     * @returns A list of preprocessed to-device messages. This will not map 1:1 to the input list, as some messages may be invalid or\n     * failed to decrypt, and so will be omitted from the output list.\n     *\n     */\n    preprocessToDeviceMessages(events: IToDeviceEvent[]): Promise<ReceivedToDeviceMessage[]>;\n\n    /**\n     * Called by the /sync loop when one time key counts and unused fallback key details are received.\n     *\n     * @param oneTimeKeysCounts - the received one time key counts\n     * @param unusedFallbackKeys - the received unused fallback keys\n     */\n    processKeyCounts(oneTimeKeysCounts?: Record<string, number>, unusedFallbackKeys?: string[]): Promise<void>;\n\n    /**\n     * Handle the notification from /sync that device lists have\n     * been changed.\n     *\n     * @param deviceLists - device_lists field from /sync\n     */\n    processDeviceLists(deviceLists: IDeviceLists): Promise<void>;\n\n    /**\n     * Called by the /sync loop whenever an m.room.encryption event is received.\n     *\n     * This is called before RoomStateEvents are emitted for any of the events in the /sync\n     * response (even if the other events technically happened first). This works around a problem\n     * if the client uses a RoomStateEvent (typically a membership event) as a trigger to send a message\n     * in a new room (or one where encryption has been newly enabled): that would otherwise leave the\n     * crypto layer confused because it expects crypto to be set up, but it has not yet been.\n     *\n     * @param room - in which the event was received\n     * @param event - encryption event to be processed\n     */\n    onCryptoEvent(room: Room, event: MatrixEvent): Promise<void>;\n\n    /**\n     * Called by the /sync loop after each /sync response is processed.\n     *\n     * Used to complete batch processing, or to initiate background processes\n     *\n     * @param syncState - information about the completed sync.\n     */\n    onSyncCompleted(syncState: OnSyncCompletedData): void;\n\n    /**\n     * Mark all tracked users' device lists as dirty.\n     *\n     * This method will cause additional `/keys/query` requests on the server, so should be used only\n     * when the client has desynced tracking device list deltas from the server.\n     * In MSC4186: Simplified Sliding Sync, this can happen when the server expires the connection.\n     */\n    markAllTrackedUsersAsDirty(): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface OnSyncCompletedData {\n    /**\n     * The 'next_batch' result from /sync, which will become the 'since' token for the next call to /sync.\n     */\n    nextSyncToken?: string;\n\n    /**\n     * True if we are working our way through a backlog of events after connecting.\n     */\n    catchingUp?: boolean;\n}\n\n/**\n * The result of a (successful) call to {@link CryptoBackend.decryptEvent}\n */\nexport interface EventDecryptionResult {\n    /**\n     * The plaintext payload for the event (typically containing <tt>type</tt> and <tt>content</tt> fields).\n     */\n    clearEvent: IClearEvent;\n    /**\n     * List of curve25519 keys involved in telling us about the senderCurve25519Key and claimedEd25519Key.\n     * See {@link MatrixEvent#getForwardingCurve25519KeyChain}.\n     */\n    forwardingCurve25519KeyChain?: string[];\n    /**\n     * Key owned by the sender of this event.  See {@link MatrixEvent#getSenderKey}.\n     */\n    senderCurve25519Key?: string;\n    /**\n     * ed25519 key claimed by the sender of this event. See {@link MatrixEvent#getClaimedEd25519Key}.\n     */\n    claimedEd25519Key?: string;\n    /**\n     * Whether the keys for this event have been received via an unauthenticated source (eg via key forwards, or\n     * restored from backup)\n     */\n    untrusted?: boolean;\n}\n\n/**\n * Responsible for decrypting megolm session data retrieved from a remote backup.\n * The result of {@link CryptoBackend#getBackupDecryptor}.\n */\nexport interface BackupDecryptor {\n    /**\n     * Whether keys retrieved from this backup can be trusted.\n     *\n     * Depending on the backup algorithm, keys retrieved from the backup can be trusted or not.\n     * If false, keys retrieved from the backup  must be considered unsafe (authenticity cannot be guaranteed).\n     * It could be by design (deniability) or for some technical reason (eg asymmetric encryption).\n     */\n    readonly sourceTrusted: boolean;\n\n    /**\n     *\n     * Decrypt megolm session data retrieved from backup.\n     *\n     * @param ciphertexts - a Record of sessionId to session data.\n     *\n     * @returns An array of decrypted `IMegolmSessionData`\n     */\n    decryptSessions(ciphertexts: Record<string, KeyBackupSession>): Promise<IMegolmSessionData[]>;\n\n    /**\n     * Free any resources held by this decryptor.\n     *\n     * Should be called once the decryptor is no longer needed.\n     */\n    free(): void;\n}\n\n/**\n * Exception thrown when decryption fails\n *\n * @param code - Reason code for the failure.\n *\n * @param msg - user-visible message describing the problem\n *\n * @param details - key/value pairs reported in the logs but not shown\n *   to the user.\n */\nexport class DecryptionError extends Error {\n    public readonly detailedString: string;\n\n    public constructor(\n        public readonly code: DecryptionFailureCode,\n        msg: string,\n        details?: Record<string, string | Error>,\n    ) {\n        super(msg);\n        this.name = \"DecryptionError\";\n        this.detailedString = detailedStringForDecryptionError(this, details);\n    }\n}\n\nfunction detailedStringForDecryptionError(err: DecryptionError, details?: Record<string, string | Error>): string {\n    let result = err.name + \"[msg: \" + err.message;\n\n    if (details) {\n        result +=\n            \", \" +\n            Object.keys(details)\n                .map((k) => k + \": \" + details[k])\n                .join(\", \");\n    }\n\n    result += \"]\";\n\n    return result;\n}\n","/*\nCopyright 2015 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// Validation based on https://spec.matrix.org/v1.12/appendices/#server-name\n// We do not use the validation described in https://spec.matrix.org/v1.12/client-server-api/#security-considerations-5\n// as it'd wrongly make all MXCs invalid due to not allowing `[].:` in server names.\nconst serverNameRegex =\n    /^(?:(?:\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|(?:\\[[\\dA-Fa-f:.]{2,45}])|(?:[A-Za-z\\d\\-.]{1,255}))(?::\\d{1,5})?$/;\nfunction validateServerName(serverName: string): boolean {\n    const matches = serverNameRegex.exec(serverName);\n    return matches?.[0] === serverName;\n}\n\n// Validation based on https://spec.matrix.org/v1.12/client-server-api/#security-considerations-5\nconst mediaIdRegex = /^[\\w-]+$/;\nfunction validateMediaId(mediaId: string): boolean {\n    const matches = mediaIdRegex.exec(mediaId);\n    return matches?.[0] === mediaId;\n}\n\n/**\n * Get the HTTP URL for an MXC URI.\n * @param baseUrl - The base homeserver url which has a content repo.\n * @param mxc - The mxc:// URI.\n * @param width - The desired width of the thumbnail.\n * @param height - The desired height of the thumbnail.\n * @param resizeMethod - The thumbnail resize method to use, either\n * \"crop\" or \"scale\".\n * @param allowDirectLinks - If true, return any non-mxc URLs\n * directly. Fetching such URLs will leak information about the user to\n * anyone they share a room with. If false, will return the emptry string\n * for such URLs.\n * @param allowRedirects - If true, the caller supports the URL being 307 or\n * 308 redirected to another resource upon request. If false, redirects\n * are not expected. Implied `true` when `useAuthentication` is `true`.\n * @param useAuthentication - If true, the caller supports authenticated\n * media and wants an authentication-required URL. Note that server support\n * for authenticated media will *not* be checked - it is the caller's responsibility\n * to do so before calling this function. Note also that `useAuthentication`\n * implies `allowRedirects`. Defaults to false (unauthenticated endpoints).\n * @returns The complete URL to the content, may be an empty string if the provided mxc is not valid.\n */\nexport function getHttpUriForMxc(\n    baseUrl: string,\n    mxc?: string,\n    width?: number,\n    height?: number,\n    resizeMethod?: string,\n    allowDirectLinks = false,\n    allowRedirects?: boolean,\n    useAuthentication?: boolean,\n): string {\n    if (typeof mxc !== \"string\" || !mxc) {\n        return \"\";\n    }\n    if (!mxc.startsWith(\"mxc://\")) {\n        if (allowDirectLinks) {\n            return mxc;\n        } else {\n            return \"\";\n        }\n    }\n\n    const [serverName, mediaId, ...rest] = mxc.slice(6).split(\"/\");\n    if (rest.length > 0 || !validateServerName(serverName) || !validateMediaId(mediaId)) {\n        return \"\";\n    }\n\n    if (useAuthentication) {\n        allowRedirects = true; // per docs (MSC3916 always expects redirects)\n\n        // Dev note: MSC3916 removes `allow_redirect` entirely, but\n        // for explicitness we set it here. This makes it slightly more obvious to\n        // callers, hopefully.\n    }\n\n    let prefix: string;\n    const isThumbnailRequest = !!width || !!height || !!resizeMethod;\n    const verb = isThumbnailRequest ? \"thumbnail\" : \"download\";\n    if (useAuthentication) {\n        prefix = `/_matrix/client/v1/media/${verb}`;\n    } else {\n        prefix = `/_matrix/media/v3/${verb}`;\n    }\n\n    const url = new URL(`${prefix}/${serverName}/${mediaId}`, baseUrl);\n\n    if (width) {\n        url.searchParams.set(\"width\", Math.round(width).toString());\n    }\n    if (height) {\n        url.searchParams.set(\"height\", Math.round(height).toString());\n    }\n    if (resizeMethod) {\n        url.searchParams.set(\"method\", resizeMethod);\n    }\n\n    if (typeof allowRedirects === \"boolean\") {\n        // We add this after, so we don't convert everything to a thumbnail request.\n        url.searchParams.set(\"allow_redirect\", JSON.stringify(allowRedirects));\n    }\n\n    return url.href;\n}\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst DEFAULT_BIT_SIZE = 256;\n\n/**\n * Derive a recovery key from a passphrase and salt using PBKDF2.\n * @see https://spec.matrix.org/v1.11/client-server-api/#deriving-keys-from-passphrases\n *\n * @param passphrase - The passphrase to derive the key from\n * @param salt - The salt to use in the derivation\n * @param iterations - The number of iterations to use in the derivation\n * @param numBits - The number of bits to derive\n */\nexport async function deriveRecoveryKeyFromPassphrase(\n    passphrase: string,\n    salt: string,\n    iterations: number,\n    numBits = DEFAULT_BIT_SIZE,\n): Promise<Uint8Array> {\n    if (!globalThis.crypto.subtle || !TextEncoder) {\n        throw new Error(\"Password-based backup is not available on this platform\");\n    }\n\n    const key = await globalThis.crypto.subtle.importKey(\n        \"raw\",\n        new TextEncoder().encode(passphrase),\n        { name: \"PBKDF2\" },\n        false,\n        [\"deriveBits\"],\n    );\n\n    const keybits = await globalThis.crypto.subtle.deriveBits(\n        {\n            name: \"PBKDF2\",\n            salt: new TextEncoder().encode(salt),\n            iterations: iterations,\n            hash: \"SHA-512\",\n        },\n        key,\n        numBits,\n    );\n\n    return new Uint8Array(keybits);\n}\n","/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Computes a SHA-256 hash of a string (after utf-8 encoding) and returns it as an ArrayBuffer.\n *\n * @param plaintext The string to hash\n * @returns An Uint8Array containing the SHA-256 hash of the input string\n * @throws If the subtle crypto API is not available, for example if the code is running\n *         in a web page with an insecure context (eg. served over plain HTTP).\n */\nexport async function sha256(plaintext: string): Promise<Uint8Array> {\n    if (!globalThis.crypto.subtle) {\n        throw new Error(\"Crypto.subtle is not available: insecure context?\");\n    }\n    const utf8 = new TextEncoder().encode(plaintext);\n\n    const digest = await globalThis.crypto.subtle.digest(\"SHA-256\", utf8);\n\n    return new Uint8Array(digest);\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixClient } from \"./client.ts\";\nimport { type IEvent, MatrixEvent, MatrixEventEvent } from \"./models/event.ts\";\nimport { RelationType } from \"./@types/event.ts\";\n\nexport type EventMapper = (obj: Partial<IEvent>) => MatrixEvent;\n\nexport interface MapperOpts {\n    // don't re-emit events emitted on an event mapped by this mapper on the client\n    preventReEmit?: boolean;\n    // decrypt event proactively\n    decrypt?: boolean;\n}\n\nexport function eventMapperFor(client: MatrixClient, options: MapperOpts): EventMapper {\n    let preventReEmit = Boolean(options.preventReEmit);\n    const decrypt = options.decrypt !== false;\n\n    function mapper(plainOldJsObject: Partial<IEvent>): MatrixEvent {\n        const room = client.getRoom(plainOldJsObject.room_id);\n\n        let event: MatrixEvent | undefined;\n        // If the event is already known to the room, let's re-use the model rather than duplicating.\n        // We avoid doing this to state events as they may be forward or backwards looking which tweaks behaviour.\n        if (room && plainOldJsObject.state_key === undefined) {\n            event = room.findEventById(plainOldJsObject.event_id!);\n        }\n\n        if (!event || event.status) {\n            event = new MatrixEvent(plainOldJsObject);\n        } else {\n            // merge the latest unsigned data from the server\n            event.setUnsigned({ ...event.getUnsigned(), ...plainOldJsObject.unsigned });\n            // prevent doubling up re-emitters\n            preventReEmit = true;\n        }\n\n        // if there is a complete edit bundled alongside the event, perform the replacement.\n        // (prior to MSC3925, events were automatically replaced on the server-side. MSC3925 proposes that that doesn't\n        // happen automatically but the server does provide us with the whole content of the edit event.)\n        const bundledEdit = event.getServerAggregatedRelation<Partial<IEvent>>(RelationType.Replace);\n        if (bundledEdit?.content) {\n            const replacement = mapper(bundledEdit);\n            // XXX: it's worth noting that the spec says we should only respect encrypted edits if, once decrypted, the\n            //   replacement has a `m.new_content` property. The problem is that we haven't yet decrypted the replacement\n            //   (it should be happening in the background), so we can't enforce this. Possibly we should for decryption\n            //   to complete, but that sounds a bit racy. For now, we just assume it's ok.\n            event.makeReplaced(replacement);\n        }\n\n        const thread = room?.findThreadForEvent(event);\n        if (thread) {\n            event.setThread(thread);\n        }\n\n        if (event.isEncrypted()) {\n            if (!preventReEmit) {\n                client.reEmitter.reEmit(event, [MatrixEventEvent.Decrypted]);\n            }\n            if (decrypt) {\n                client.decryptEventIfNeeded(event);\n            }\n        }\n\n        if (!preventReEmit) {\n            client.reEmitter.reEmit(event, [MatrixEventEvent.Replaced, MatrixEventEvent.VisibilityChange]);\n            room?.reEmitter.reEmit(event, [MatrixEventEvent.BeforeRedaction]);\n        }\n        return event;\n    }\n\n    return mapper;\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IServerVersions } from \"./client.ts\";\n\nexport enum ServerSupport {\n    Stable,\n    Unstable,\n    Unsupported,\n}\n\nexport enum Feature {\n    Thread = \"Thread\",\n    ThreadUnreadNotifications = \"ThreadUnreadNotifications\",\n    /**\n     * @deprecated this is now exposed as a capability not a feature\n     */\n    LoginTokenRequest = \"LoginTokenRequest\",\n    RelationBasedRedactions = \"RelationBasedRedactions\",\n    AccountDataDeletion = \"AccountDataDeletion\",\n    RelationsRecursion = \"RelationsRecursion\",\n    IntentionalMentions = \"IntentionalMentions\",\n}\n\ntype FeatureSupportCondition = {\n    unstablePrefixes?: string[];\n    matrixVersion?: string;\n};\n\nconst featureSupportResolver: Record<string, FeatureSupportCondition> = {\n    [Feature.Thread]: {\n        unstablePrefixes: [\"org.matrix.msc3440\"],\n        matrixVersion: \"v1.3\",\n    },\n    [Feature.ThreadUnreadNotifications]: {\n        unstablePrefixes: [\"org.matrix.msc3771\", \"org.matrix.msc3773\"],\n        matrixVersion: \"v1.4\",\n    },\n    [Feature.LoginTokenRequest]: {\n        unstablePrefixes: [\"org.matrix.msc3882\"],\n    },\n    [Feature.RelationBasedRedactions]: {\n        unstablePrefixes: [\"org.matrix.msc3912\"],\n    },\n    [Feature.AccountDataDeletion]: {\n        unstablePrefixes: [\"org.matrix.msc3391\"],\n    },\n    [Feature.RelationsRecursion]: {\n        unstablePrefixes: [\"org.matrix.msc3981\"],\n        matrixVersion: \"v1.10\",\n    },\n    [Feature.IntentionalMentions]: {\n        unstablePrefixes: [\"org.matrix.msc3952_intentional_mentions\"],\n        matrixVersion: \"v1.7\",\n    },\n};\n\nexport async function buildFeatureSupportMap(versions: IServerVersions): Promise<Map<Feature, ServerSupport>> {\n    const supportMap = new Map<Feature, ServerSupport>();\n    for (const [feature, supportCondition] of Object.entries(featureSupportResolver)) {\n        const supportMatrixVersion = versions.versions?.includes(supportCondition.matrixVersion || \"\") ?? false;\n        const supportUnstablePrefixes =\n            supportCondition.unstablePrefixes?.every((unstablePrefix) => {\n                return versions.unstable_features?.[unstablePrefix] === true;\n            }) ?? false;\n        if (supportMatrixVersion) {\n            supportMap.set(feature as Feature, ServerSupport.Stable);\n        } else if (supportUnstablePrefixes) {\n            supportMap.set(feature as Feature, ServerSupport.Unstable);\n        } else {\n            supportMap.set(feature as Feature, ServerSupport.Unsupported);\n        }\n    }\n    return supportMap;\n}\n","/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type RelationType } from \"./@types/event.ts\";\nimport { type MatrixEvent } from \"./models/event.ts\";\nimport { FILTER_RELATED_BY_REL_TYPES, FILTER_RELATED_BY_SENDERS, THREAD_RELATION_TYPE } from \"./models/thread.ts\";\n\n/**\n * Checks if a value matches a given field value, which may be a * terminated\n * wildcard pattern.\n * @param actualValue -  The value to be compared\n * @param filterValue -  The filter pattern to be compared\n * @returns true if the actualValue matches the filterValue\n */\nfunction matchesWildcard(actualValue: string, filterValue: string): boolean {\n    if (filterValue.endsWith(\"*\")) {\n        const typePrefix = filterValue.slice(0, -1);\n        return actualValue.slice(0, typePrefix.length) === typePrefix;\n    } else {\n        return actualValue === filterValue;\n    }\n}\n\n/* eslint-disable camelcase */\nexport interface IFilterComponent {\n    \"types\"?: string[];\n    \"not_types\"?: string[];\n    \"rooms\"?: string[];\n    \"not_rooms\"?: string[];\n    \"senders\"?: string[];\n    \"not_senders\"?: string[];\n    \"contains_url\"?: boolean;\n    \"limit\"?: number;\n    \"related_by_senders\"?: Array<RelationType | string>;\n    \"related_by_rel_types\"?: string[];\n\n    // Unstable values\n    \"io.element.relation_senders\"?: Array<RelationType | string>;\n    \"io.element.relation_types\"?: string[];\n}\n/* eslint-enable camelcase */\n\n/**\n * FilterComponent is a section of a Filter definition which defines the\n * types, rooms, senders filters etc to be applied to a particular type of resource.\n * This is all ported over from synapse's Filter object.\n *\n * N.B. that synapse refers to these as 'Filters', and what js-sdk refers to as\n * 'Filters' are referred to as 'FilterCollections'.\n */\nexport class FilterComponent {\n    public constructor(\n        private filterJson: IFilterComponent,\n        public readonly userId?: string | undefined | null,\n    ) {}\n\n    /**\n     * Checks with the filter component matches the given event\n     * @param event - event to be checked against the filter\n     * @returns true if the event matches the filter\n     */\n    public check(event: MatrixEvent): boolean {\n        const bundledRelationships = event.getUnsigned()?.[\"m.relations\"] || {};\n        const relations: Array<string | RelationType> = Object.keys(bundledRelationships);\n        // Relation senders allows in theory a look-up of any senders\n        // however clients can only know about the current user participation status\n        // as sending a whole list of participants could be proven problematic in terms\n        // of performance\n        // This should be improved when bundled relationships solve that problem\n        const relationSenders: string[] = [];\n        if (this.userId && bundledRelationships?.[THREAD_RELATION_TYPE.name]?.current_user_participated) {\n            relationSenders.push(this.userId);\n        }\n\n        return this.checkFields(\n            event.getRoomId(),\n            event.getSender(),\n            event.getType(),\n            event.getContent() ? event.getContent().url !== undefined : false,\n            relations,\n            relationSenders,\n        );\n    }\n\n    /**\n     * Converts the filter component into the form expected over the wire\n     */\n    public toJSON(): object {\n        return Object.fromEntries(\n            Object.entries({\n                types: this.filterJson.types,\n                not_types: this.filterJson.not_types,\n                rooms: this.filterJson.rooms,\n                not_rooms: this.filterJson.not_rooms,\n                senders: this.filterJson.senders,\n                not_senders: this.filterJson.not_senders,\n                contains_url: this.filterJson.contains_url,\n                [FILTER_RELATED_BY_SENDERS.name]: this.filterJson[FILTER_RELATED_BY_SENDERS.name],\n                [FILTER_RELATED_BY_REL_TYPES.name]: this.filterJson[FILTER_RELATED_BY_REL_TYPES.name],\n            }).filter(([_key, value]) => value),\n        );\n    }\n\n    /**\n     * Checks whether the filter component matches the given event fields.\n     * @param roomId -        the roomId for the event being checked\n     * @param sender -        the sender of the event being checked\n     * @param eventType -     the type of the event being checked\n     * @param containsUrl -  whether the event contains a content.url field\n     * @param relationTypes -  whether has aggregated relation of the given type\n     * @param relationSenders - whether one of the relation is sent by the user listed\n     * @returns true if the event fields match the filter\n     */\n    private checkFields(\n        roomId: string | undefined,\n        sender: string | undefined,\n        eventType: string,\n        containsUrl: boolean,\n        relationTypes: Array<RelationType | string>,\n        relationSenders: string[],\n    ): boolean {\n        const literalKeys = {\n            rooms: function (v: string): boolean {\n                return roomId === v;\n            },\n            senders: function (v: string): boolean {\n                return sender === v;\n            },\n            types: function (v: string): boolean {\n                return matchesWildcard(eventType, v);\n            },\n        } as const;\n\n        for (const name in literalKeys) {\n            const matchFunc = literalKeys[<keyof typeof literalKeys>name];\n            const notName = \"not_\" + name;\n            const disallowedValues = this.filterJson[<`not_${keyof typeof literalKeys}`>notName];\n            if (disallowedValues?.some(matchFunc)) {\n                return false;\n            }\n\n            const allowedValues = this.filterJson[name as keyof typeof literalKeys];\n            if (allowedValues && !allowedValues.some(matchFunc)) {\n                return false;\n            }\n        }\n\n        const containsUrlFilter = this.filterJson.contains_url;\n        if (containsUrlFilter !== undefined && containsUrlFilter !== containsUrl) {\n            return false;\n        }\n\n        const relationTypesFilter = this.filterJson[FILTER_RELATED_BY_REL_TYPES.name];\n        if (relationTypesFilter !== undefined) {\n            if (!this.arrayMatchesFilter(relationTypesFilter, relationTypes)) {\n                return false;\n            }\n        }\n\n        const relationSendersFilter = this.filterJson[FILTER_RELATED_BY_SENDERS.name];\n        if (relationSendersFilter !== undefined) {\n            if (!this.arrayMatchesFilter(relationSendersFilter, relationSenders)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private arrayMatchesFilter(filter: any[], values: any[]): boolean {\n        return (\n            values.length > 0 &&\n            filter.every((value) => {\n                return values.includes(value);\n            })\n        );\n    }\n\n    /**\n     * Filters a list of events down to those which match this filter component\n     * @param events -  Events to be checked against the filter component\n     * @returns events which matched the filter component\n     */\n    public filter(events: MatrixEvent[]): MatrixEvent[] {\n        return events.filter(this.check, this);\n    }\n\n    /**\n     * Returns the limit field for a given filter component, providing a default of\n     * 10 if none is otherwise specified. Cargo-culted from Synapse.\n     * @returns the limit for this filter component.\n     */\n    public limit(): number {\n        return this.filterJson.limit !== undefined ? this.filterJson.limit : 10;\n    }\n}\n","/*\nCopyright 2022 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IMatrixApiError as IWidgetMatrixError } from \"matrix-widget-api\";\n\nimport { type IUsageLimit } from \"../@types/partials.ts\";\nimport { type MatrixEvent } from \"../models/event.ts\";\n\ninterface IErrorJson extends Partial<IUsageLimit> {\n    [key: string]: any; // extensible\n    errcode?: string;\n    error?: string;\n}\n\n/**\n * Construct a generic HTTP error. This is a JavaScript Error with additional information\n * specific to HTTP responses.\n * @param msg - The error message to include.\n * @param httpStatus - The HTTP response status code.\n * @param httpHeaders - The HTTP response headers.\n */\nexport class HTTPError extends Error {\n    public constructor(\n        msg: string,\n        public readonly httpStatus?: number,\n        public readonly httpHeaders?: Headers,\n    ) {\n        super(msg);\n    }\n\n    /**\n     * Check if this error was due to rate-limiting on the server side (and should therefore be retried after a delay).\n     *\n     * If this returns `true`, {@link getRetryAfterMs} can be called to retrieve the server-side\n     * recommendation for the retry period.\n     *\n     * @returns Whether this error is due to rate-limiting.\n     */\n    public isRateLimitError(): boolean {\n        return this.httpStatus === 429;\n    }\n\n    /**\n     * @returns The recommended delay in milliseconds to wait before retrying\n     * the request that triggered this error, or null if no delay is recommended.\n     * @throws Error if the recommended delay is an invalid value.\n     * @see {@link safeGetRetryAfterMs} for a version of this check that doesn't throw.\n     */\n    public getRetryAfterMs(): number | null {\n        const retryAfter = this.httpHeaders?.get(\"Retry-After\");\n        if (retryAfter != null) {\n            if (/^\\d+$/.test(retryAfter)) {\n                const ms = Number.parseInt(retryAfter) * 1000;\n                if (!Number.isFinite(ms)) {\n                    throw new Error(\"Retry-After header integer value is too large\");\n                }\n                return ms;\n            }\n            const date = new Date(retryAfter);\n            if (date.toUTCString() !== retryAfter) {\n                throw new Error(\"Retry-After header value is not a valid HTTP-date or non-negative decimal integer\");\n            }\n            return date.getTime() - Date.now();\n        }\n        return null;\n    }\n}\n\nexport class MatrixError extends HTTPError {\n    // The Matrix 'errcode' value, e.g. \"M_FORBIDDEN\".\n    public readonly errcode?: string;\n    // The raw Matrix error JSON used to construct this object.\n    public data: IErrorJson;\n\n    /**\n     * Construct a Matrix error. This is a JavaScript Error with additional\n     * information specific to the standard Matrix error response.\n     * @param errorJson - The Matrix error JSON returned from the homeserver.\n     * @param httpStatus - The numeric HTTP status code given\n     * @param httpHeaders - The HTTP response headers given\n     */\n    public constructor(\n        errorJson: IErrorJson = {},\n        httpStatus?: number,\n        public url?: string,\n        public event?: MatrixEvent,\n        httpHeaders?: Headers,\n    ) {\n        let message = errorJson.error || \"Unknown message\";\n        if (httpStatus) {\n            message = `[${httpStatus}] ${message}`;\n        }\n        if (url) {\n            message = `${message} (${url})`;\n        }\n        super(`MatrixError: ${message}`, httpStatus, httpHeaders);\n        this.errcode = errorJson.errcode;\n        this.name = errorJson.errcode || \"Unknown error code\";\n        this.data = errorJson;\n    }\n\n    public isRateLimitError(): boolean {\n        return (\n            this.errcode === \"M_LIMIT_EXCEEDED\" ||\n            ((this.errcode === \"M_UNKNOWN\" || this.errcode === undefined) && super.isRateLimitError())\n        );\n    }\n\n    public getRetryAfterMs(): number | null {\n        const headerValue = super.getRetryAfterMs();\n        if (headerValue !== null) {\n            return headerValue;\n        }\n        // Note: retry_after_ms is deprecated as of spec version v1.10\n        if (this.errcode === \"M_LIMIT_EXCEEDED\" && \"retry_after_ms\" in this.data) {\n            if (!Number.isInteger(this.data.retry_after_ms)) {\n                throw new Error(\"retry_after_ms is not an integer\");\n            }\n            return this.data.retry_after_ms;\n        }\n        return null;\n    }\n\n    /**\n     * @returns this error expressed as a JSON payload\n     * for use by Widget API error responses.\n     */\n    public asWidgetApiErrorData(): IWidgetMatrixError {\n        const headers: Record<string, string> = {};\n        if (this.httpHeaders) {\n            for (const [name, value] of this.httpHeaders) {\n                headers[name] = value;\n            }\n        }\n        return {\n            http_status: this.httpStatus ?? 400,\n            http_headers: headers,\n            url: this.url ?? \"\",\n            response: {\n                errcode: this.errcode ?? \"M_UNKNOWN\",\n                error: this.data.error ?? \"Unknown message\",\n                ...this.data,\n            },\n        };\n    }\n\n    /**\n     * @returns a new {@link MatrixError} from a JSON payload\n     * received from Widget API error responses.\n     */\n    public static fromWidgetApiErrorData(data: IWidgetMatrixError): MatrixError {\n        return new MatrixError(data.response, data.http_status, data.url, undefined, new Headers(data.http_headers));\n    }\n}\n\n/**\n * @returns The recommended delay in milliseconds to wait before retrying the request.\n * @param error - The error to check for a retry delay.\n * @param defaultMs - The delay to use if the error was not due to rate-limiting or if no valid delay is recommended.\n */\nexport function safeGetRetryAfterMs(error: unknown, defaultMs: number): number {\n    if (!(error instanceof HTTPError) || !error.isRateLimitError()) {\n        return defaultMs;\n    }\n    try {\n        return error.getRetryAfterMs() ?? defaultMs;\n    } catch {\n        return defaultMs;\n    }\n}\n\n/**\n * Construct a ConnectionError. This is a JavaScript Error indicating\n * that a request failed because of some error with the connection, either\n * CORS was not correctly configured on the server, the server didn't response,\n * the request timed out, or the internet connection on the client side went down.\n */\nexport class ConnectionError extends Error {\n    public constructor(message: string, cause?: Error) {\n        super(message + (cause ? `: ${cause.message}` : \"\"));\n    }\n\n    public get name(): string {\n        return \"ConnectionError\";\n    }\n}\n\n/**\n * Construct a TokenRefreshError. This indicates that a request failed due to the token being expired,\n * and attempting to refresh said token also failed but in a way which was not indicative of token invalidation.\n * Assumed to be a temporary failure.\n */\nexport class TokenRefreshError extends Error {\n    public constructor(cause?: Error) {\n        super(cause?.message ?? \"\");\n    }\n\n    public get name(): string {\n        return \"TokenRefreshError\";\n    }\n}\n\n/**\n * Construct a TokenRefreshError. This indicates that a request failed due to the token being expired,\n * and attempting to refresh said token failed in a way indicative of token invalidation.\n */\nexport class TokenRefreshLogoutError extends Error {\n    public constructor(cause?: Error) {\n        super(cause?.message ?? \"\");\n    }\n\n    public get name(): string {\n        return \"TokenRefreshLogoutError\";\n    }\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MatrixError, TokenRefreshLogoutError } from \"./errors.ts\";\nimport { type IHttpOpts } from \"./interface.ts\";\nimport { sleep } from \"../utils.ts\";\n\n/**\n * This is an internal module. See {@link MatrixHttpApi} for the public class.\n */\n\nexport const enum TokenRefreshOutcome {\n    Success = \"success\",\n    Failure = \"failure\",\n    Logout = \"logout\",\n}\n\ninterface Snapshot {\n    accessToken: string;\n    refreshToken?: string;\n    expiry?: Date;\n}\n\n// If the token expires in less than this time amount of time, we will eagerly refresh it before making the intended request.\nconst REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS = 500;\n// If we get an unknown token error and the token expires in less than this time amount of time, we will refresh it before making the intended request.\n// Otherwise, we will error as the token should not have expired yet and we need to avoid retrying indefinitely.\nconst REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS = 60 * 1000;\n\ntype Opts = Pick<IHttpOpts, \"tokenRefreshFunction\" | \"logger\" | \"refreshToken\" | \"accessToken\">;\n\n/**\n * This class is responsible for managing the access token and refresh token for authenticated requests.\n * It will automatically refresh the access token when it is about to expire, and will handle unknown token errors.\n */\nexport class TokenRefresher {\n    public constructor(private readonly opts: Opts) {}\n\n    /**\n     * Promise used to block authenticated requests during a token refresh to avoid repeated expected errors.\n     * @private\n     */\n    private tokenRefreshPromise?: Promise<TokenRefreshOutcome>;\n\n    private latestTokenRefreshExpiry?: Date;\n\n    /**\n     * This function is called before every request to ensure that the access token is valid.\n     * @returns a snapshot containing the access token and other properties which must be passed to the handleUnknownToken\n     *     handler if an M_UNKNOWN_TOKEN error is encountered.\n     */\n    public async prepareForRequest(): Promise<Snapshot> {\n        // Ensure our token is refreshed before we build the headers/params\n        await this.refreshIfNeeded();\n\n        return {\n            accessToken: this.opts.accessToken!,\n            refreshToken: this.opts.refreshToken,\n            expiry: this.latestTokenRefreshExpiry,\n        };\n    }\n\n    private async refreshIfNeeded(): Promise<unknown> {\n        if (this.tokenRefreshPromise) {\n            return this.tokenRefreshPromise;\n        }\n        // If we don't know the token expiry, we can't eagerly refresh\n        if (!this.latestTokenRefreshExpiry) return;\n\n        const expiresIn = this.latestTokenRefreshExpiry.getTime() - Date.now();\n        if (expiresIn <= REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS) {\n            await this._handleUnknownToken();\n        }\n    }\n\n    /**\n     * This function is called when an M_UNKNOWN_TOKEN error is encountered.\n     * It will attempt to refresh the access token if it is unknown, and will return a TokenRefreshOutcome.\n     * @param snapshot - the snapshot returned by prepareForRequest\n     * @param attempt - the number of attempts made for this request so far\n     * @returns a TokenRefreshOutcome indicating the result of the refresh attempt\n     */\n    public async handleUnknownToken(snapshot: Snapshot, attempt: number): Promise<TokenRefreshOutcome> {\n        return this._handleUnknownToken(snapshot, attempt);\n    }\n\n    /* eslint-disable @typescript-eslint/naming-convention */\n    private async _handleUnknownToken(): Promise<TokenRefreshOutcome>;\n    private async _handleUnknownToken(snapshot: Snapshot, attempt: number): Promise<TokenRefreshOutcome>;\n    private async _handleUnknownToken(snapshot?: Snapshot, attempt?: number): Promise<TokenRefreshOutcome> {\n        if (snapshot?.expiry) {\n            // If our token is unknown, but it should not have expired yet, then we should not refresh\n            const expiresIn = snapshot.expiry.getTime() - Date.now();\n            // If it still has plenty of time left on the clock, we assume something else must be wrong and\n            // do not refresh. Otherwise if it's expired, or will soon, we try refreshing.\n            if (expiresIn >= REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS) {\n                return TokenRefreshOutcome.Logout;\n            }\n        }\n\n        if (!snapshot || snapshot?.accessToken === this.opts.accessToken) {\n            // If we have a snapshot, but the access token is the same as the current one then a refresh\n            // did not happen behind us but one may be ongoing anyway\n            this.tokenRefreshPromise ??= this.doTokenRefresh(attempt);\n\n            try {\n                return await this.tokenRefreshPromise;\n            } finally {\n                this.tokenRefreshPromise = undefined;\n            }\n        }\n\n        // We may end up here if the token was refreshed in the background due to another request\n        return TokenRefreshOutcome.Success;\n    }\n\n    /**\n     * Attempt to refresh access tokens.\n     * On success, sets new access and refresh tokens in opts.\n     * @returns Promise that resolves to a boolean - true when token was refreshed successfully\n     */\n    private async doTokenRefresh(attempt?: number): Promise<TokenRefreshOutcome> {\n        if (!this.opts.refreshToken || !this.opts.tokenRefreshFunction) {\n            this.opts.logger?.error(\"Unable to refresh token - no refresh token or refresh function\");\n            return TokenRefreshOutcome.Logout;\n        }\n\n        if (attempt && attempt > 1) {\n            // Exponential backoff to ensure we don't trash the server, up to 2^5 seconds\n            await sleep(1000 * Math.min(32, 2 ** attempt));\n        }\n\n        try {\n            this.opts.logger?.debug(\"Attempting to refresh token\");\n            const { accessToken, refreshToken, expiry } = await this.opts.tokenRefreshFunction(this.opts.refreshToken);\n            this.opts.accessToken = accessToken;\n            this.opts.refreshToken = refreshToken;\n            this.latestTokenRefreshExpiry = expiry;\n            this.opts.logger?.debug(\"... token refresh complete, new token expiry:\", expiry);\n\n            // successfully got new tokens\n            return TokenRefreshOutcome.Success;\n        } catch (error) {\n            // If we get a TokenError or MatrixError, we should log out, otherwise assume transient\n            if (error instanceof TokenRefreshLogoutError || error instanceof MatrixError) {\n                this.opts.logger?.error(\"Failed to refresh token\", error);\n                return TokenRefreshOutcome.Logout;\n            }\n\n            this.opts.logger?.warn(\"Failed to refresh token\", error);\n            return TokenRefreshOutcome.Failure;\n        }\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixHttpApi} for the public class.\n */\n\nimport { checkObjectHasKeys, deepCopy, encodeParams } from \"../utils.ts\";\nimport { type TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { Method } from \"./method.ts\";\nimport { ConnectionError, MatrixError, TokenRefreshError } from \"./errors.ts\";\nimport {\n    type BaseRequestOpts,\n    HttpApiEvent,\n    type HttpApiEventHandlerMap,\n    type IHttpOpts,\n    type IRequestOpts,\n    type Body,\n} from \"./interface.ts\";\nimport { anySignal, parseErrorResponse, timeoutSignal } from \"./utils.ts\";\nimport { type QueryDict } from \"../utils.ts\";\nimport { TokenRefresher, TokenRefreshOutcome } from \"./refresh.ts\";\n\nexport class FetchHttpApi<O extends IHttpOpts> {\n    private abortController = new AbortController();\n    private readonly tokenRefresher: TokenRefresher;\n\n    public constructor(\n        private eventEmitter: TypedEventEmitter<HttpApiEvent, HttpApiEventHandlerMap>,\n        public readonly opts: O,\n    ) {\n        checkObjectHasKeys(opts, [\"baseUrl\", \"prefix\"]);\n        if (!opts.onlyData) {\n            throw new Error(\"Constructing FetchHttpApi without `onlyData=true` is no longer supported.\");\n        }\n        opts.useAuthorizationHeader = opts.useAuthorizationHeader ?? true;\n\n        this.tokenRefresher = new TokenRefresher(opts);\n    }\n\n    public abort(): void {\n        this.abortController.abort();\n        this.abortController = new AbortController();\n    }\n\n    public fetch(resource: URL | string, options?: RequestInit): ReturnType<typeof globalThis.fetch> {\n        if (this.opts.fetchFn) {\n            return this.opts.fetchFn(resource, options);\n        }\n        return globalThis.fetch(resource, options);\n    }\n\n    /**\n     * Sets the base URL for the identity server\n     * @param url - The new base url\n     */\n    public setIdBaseUrl(url?: string): void {\n        this.opts.idBaseUrl = url;\n    }\n\n    public idServerRequest<T extends object = Record<string, unknown>>(\n        method: Method,\n        path: string,\n        params: Record<string, string | string[]> | undefined,\n        prefix: string,\n        accessToken?: string,\n    ): Promise<T> {\n        if (!this.opts.idBaseUrl) {\n            throw new Error(\"No identity server base URL set\");\n        }\n\n        let queryParams: QueryDict | undefined = undefined;\n        let body: Record<string, string | string[]> | undefined = undefined;\n        if (method === Method.Get) {\n            queryParams = params;\n        } else {\n            body = params;\n        }\n\n        const fullUri = this.getUrl(path, queryParams, prefix, this.opts.idBaseUrl);\n\n        const opts: IRequestOpts = {\n            json: true,\n            headers: {},\n        };\n        if (accessToken) {\n            opts.headers!.Authorization = `Bearer ${accessToken}`;\n        }\n\n        return this.requestOtherUrl(method, fullUri, body, opts);\n    }\n\n    /**\n     * Perform an authorised request to the homeserver.\n     * @param method - The HTTP method e.g. \"GET\".\n     * @param path - The HTTP path <b>after</b> the supplied prefix e.g.\n     * \"/createRoom\".\n     *\n     * @param queryParams - A dict of query params (these will NOT be\n     * urlencoded). If unspecified, there will be no query params.\n     *\n     * @param body - The HTTP JSON body.\n     *\n     * @param paramOpts - additional options.\n     * When `paramOpts.doNotAttemptTokenRefresh` is true, token refresh will not be attempted\n     * when an expired token is encountered. Used to only attempt token refresh once.\n     *\n     * @returns The parsed response.\n     * @throws Error if a problem occurred. This includes network problems and Matrix-specific error JSON.\n     */\n    public authedRequest<T>(\n        method: Method,\n        path: string,\n        queryParams: QueryDict = {},\n        body?: Body,\n        paramOpts: IRequestOpts = {},\n    ): Promise<T> {\n        return this.doAuthedRequest<T>(1, method, path, queryParams, body, paramOpts);\n    }\n\n    // Wrapper around public method authedRequest to allow for tracking retry attempt counts\n    private async doAuthedRequest<T>(\n        attempt: number,\n        method: Method,\n        path: string,\n        queryParams: QueryDict,\n        body?: Body,\n        paramOpts: IRequestOpts = {},\n    ): Promise<T> {\n        // avoid mutating paramOpts so they can be used on retry\n        const opts = deepCopy(paramOpts);\n        // we have to manually copy the abortSignal over as it is not a plain object\n        opts.abortSignal = paramOpts.abortSignal;\n\n        // Take a snapshot of the current token state before we start the request so we can reference it if we error\n        const requestSnapshot = await this.tokenRefresher.prepareForRequest();\n        if (requestSnapshot.accessToken) {\n            if (this.opts.useAuthorizationHeader) {\n                if (!opts.headers) {\n                    opts.headers = {};\n                }\n                if (!opts.headers.Authorization) {\n                    opts.headers.Authorization = `Bearer ${requestSnapshot.accessToken}`;\n                }\n                if (queryParams.access_token) {\n                    delete queryParams.access_token;\n                }\n            } else if (!queryParams.access_token) {\n                queryParams.access_token = requestSnapshot.accessToken;\n            }\n        }\n\n        try {\n            const response = await this.request<T>(method, path, queryParams, body, opts);\n            return response;\n        } catch (error) {\n            if (!(error instanceof MatrixError)) {\n                throw error;\n            }\n\n            if (error.errcode === \"M_UNKNOWN_TOKEN\") {\n                const outcome = await this.tokenRefresher.handleUnknownToken(requestSnapshot, attempt);\n                if (outcome === TokenRefreshOutcome.Success) {\n                    // if we got a new token retry the request\n                    return this.doAuthedRequest(attempt + 1, method, path, queryParams, body, paramOpts);\n                }\n                if (outcome === TokenRefreshOutcome.Failure) {\n                    throw new TokenRefreshError(error);\n                }\n\n                if (!opts?.inhibitLogoutEmit) {\n                    this.eventEmitter.emit(HttpApiEvent.SessionLoggedOut, error);\n                }\n            } else if (error.errcode == \"M_CONSENT_NOT_GIVEN\") {\n                this.eventEmitter.emit(HttpApiEvent.NoConsent, error.message, error.data.consent_uri);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Perform a request to the homeserver without any credentials.\n     * @param method - The HTTP method e.g. \"GET\".\n     * @param path - The HTTP path <b>after</b> the supplied prefix e.g.\n     * \"/createRoom\".\n     *\n     * @param queryParams - A dict of query params (these will NOT be\n     * urlencoded). If unspecified, there will be no query params.\n     *\n     * @param body - The HTTP JSON body.\n     *\n     * @param opts - additional options\n     *\n     * @returns The parsed response.\n     * @throws Error if a problem occurred. This includes network problems and Matrix-specific error JSON.\n     */\n    public request<T>(\n        method: Method,\n        path: string,\n        queryParams?: QueryDict,\n        body?: Body,\n        opts?: IRequestOpts,\n    ): Promise<T> {\n        const fullUri = this.getUrl(path, queryParams, opts?.prefix, opts?.baseUrl);\n        return this.requestOtherUrl<T>(method, fullUri, body, opts);\n    }\n\n    /**\n     * Perform a request to an arbitrary URL.\n     * @param method - The HTTP method e.g. \"GET\".\n     * @param url - The HTTP URL object.\n     *\n     * @param body - The HTTP JSON body.\n     *\n     * @param opts - additional options\n     *\n     * @returns The parsed response.\n     * @throws Error if a problem occurred. This includes network problems and Matrix-specific error JSON.\n     */\n    public async requestOtherUrl<T>(\n        method: Method,\n        url: URL | string,\n        body?: Body,\n        opts: BaseRequestOpts = {},\n    ): Promise<T> {\n        if (opts.json !== undefined && opts.rawResponseBody !== undefined) {\n            throw new Error(\"Invalid call to `FetchHttpApi` sets both `opts.json` and `opts.rawResponseBody`\");\n        }\n\n        const urlForLogs = this.sanitizeUrlForLogs(url);\n\n        this.opts.logger?.debug(`FetchHttpApi: --> ${method} ${urlForLogs}`);\n\n        const headers = Object.assign({}, opts.headers || {});\n\n        const jsonResponse = !opts.rawResponseBody && opts.json !== false;\n        if (jsonResponse) {\n            if (!headers[\"Accept\"]) {\n                headers[\"Accept\"] = \"application/json\";\n            }\n        }\n\n        const timeout = opts.localTimeoutMs ?? this.opts.localTimeoutMs;\n        const keepAlive = opts.keepAlive ?? false;\n        const signals = [this.abortController.signal];\n        if (timeout !== undefined) {\n            signals.push(timeoutSignal(timeout));\n        }\n        if (opts.abortSignal) {\n            signals.push(opts.abortSignal);\n        }\n\n        // If the body is an object, encode it as JSON and set the `Content-Type` header,\n        // unless that has been explicitly inhibited by setting `opts.json: false`.\n        // We can't use getPrototypeOf here as objects made in other contexts e.g. over postMessage won't have same ref\n        let data: BodyInit;\n        if (opts.json !== false && body?.constructor?.name === Object.name) {\n            data = JSON.stringify(body);\n            if (!headers[\"Content-Type\"]) {\n                headers[\"Content-Type\"] = \"application/json\";\n            }\n        } else {\n            data = body as BodyInit;\n        }\n\n        const { signal, cleanup } = anySignal(signals);\n\n        // Set cache mode based on presence of Authorization header.\n        // Browsers/proxies do not cache responses to requests with Authorization headers.\n        // So specifying \"no-cache\" is redundant, and actually prevents caching\n        // of preflight requests in CORS scenarios. As such, we only set \"no-cache\"\n        // when there is no Authorization header.\n        const cacheMode = \"Authorization\" in headers ? undefined : \"no-cache\";\n\n        let res: Response;\n        const start = Date.now();\n        try {\n            res = await this.fetch(url, {\n                signal,\n                method,\n                body: data,\n                headers,\n                mode: \"cors\",\n                redirect: \"follow\",\n                referrer: \"\",\n                referrerPolicy: \"no-referrer\",\n                cache: cacheMode,\n                credentials: \"omit\", // we send credentials via headers\n                keepalive: keepAlive,\n                priority: opts.priority,\n            });\n\n            this.opts.logger?.debug(\n                `FetchHttpApi: <-- ${method} ${urlForLogs} [${Date.now() - start}ms ${res.status}]`,\n            );\n        } catch (e) {\n            this.opts.logger?.debug(`FetchHttpApi: <-- ${method} ${urlForLogs} [${Date.now() - start}ms ${e}]`);\n            if ((<Error>e).name === \"AbortError\") {\n                throw e;\n            }\n            throw new ConnectionError(\"fetch failed\", <Error>e);\n        } finally {\n            cleanup();\n        }\n\n        if (!res.ok) {\n            throw parseErrorResponse(res, await res.text());\n        }\n\n        if (opts.rawResponseBody) {\n            return (await res.blob()) as T;\n        } else if (jsonResponse) {\n            return await res.json();\n        } else {\n            return (await res.text()) as T;\n        }\n    }\n\n    private sanitizeUrlForLogs(url: URL | string): string {\n        try {\n            let asUrl: URL;\n            if (typeof url === \"string\") {\n                asUrl = new URL(url);\n            } else {\n                asUrl = url;\n            }\n            // Remove the values of any URL params that could contain potential secrets\n            const sanitizedQs = new URLSearchParams();\n            for (const key of asUrl.searchParams.keys()) {\n                sanitizedQs.append(key, \"xxx\");\n            }\n            const sanitizedQsString = sanitizedQs.toString();\n            const sanitizedQsUrlPiece = sanitizedQsString ? `?${sanitizedQsString}` : \"\";\n\n            return asUrl.origin + asUrl.pathname + sanitizedQsUrlPiece;\n        } catch {\n            // defensive coding for malformed url\n            return \"??\";\n        }\n    }\n    /**\n     * Form and return a homeserver request URL based on the given path params and prefix.\n     * @param path - The HTTP path <b>after</b> the supplied prefix e.g. \"/createRoom\".\n     * @param queryParams - A dict of query params (these will NOT be urlencoded).\n     * @param prefix - The full prefix to use e.g. \"/_matrix/client/v2_alpha\", defaulting to this.opts.prefix.\n     * @param baseUrl - The baseUrl to use e.g. \"https://matrix.org\", defaulting to this.opts.baseUrl.\n     * @returns URL\n     */\n    public getUrl(path: string, queryParams?: QueryDict, prefix?: string, baseUrl?: string): URL {\n        const baseUrlWithFallback = baseUrl ?? this.opts.baseUrl;\n        const baseUrlWithoutTrailingSlash = baseUrlWithFallback.endsWith(\"/\")\n            ? baseUrlWithFallback.slice(0, -1)\n            : baseUrlWithFallback;\n        const url = new URL(baseUrlWithoutTrailingSlash + (prefix ?? this.opts.prefix) + path);\n        // If there are any params, encode and append them to the URL.\n        if (this.opts.extraParams || queryParams) {\n            const mergedParams = { ...this.opts.extraParams, ...queryParams };\n            encodeParams(mergedParams, url.searchParams);\n        }\n\n        return url;\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixError } from \"./errors.ts\";\nimport { type Logger } from \"../logger.ts\";\nimport { type QueryDict } from \"../utils.ts\";\n\nexport type Body = Record<string, any> | BodyInit;\n\n/**\n * @experimental\n * Unencrypted access and (optional) refresh token\n */\nexport type AccessTokens = {\n    /**\n     * The new access token to use for authenticated requests\n     */\n    accessToken: string;\n    /**\n     * The new refresh token to use for refreshing tokens, optional\n     */\n    refreshToken?: string;\n    /**\n     * Approximate date when the access token will expire, optional\n     */\n    expiry?: Date;\n};\n\n/**\n * @experimental\n * Function that performs token refresh using the given refreshToken.\n * Returns a promise that resolves to the refreshed access and (optional) refresh tokens.\n *\n * Can be passed to HttpApi instance as {@link IHttpOpts.tokenRefreshFunction} during client creation {@link ICreateClientOpts}\n */\nexport type TokenRefreshFunction = (refreshToken: string) => Promise<AccessTokens>;\n\n/** Options object for `FetchHttpApi` and {@link MatrixHttpApi}. */\nexport interface IHttpOpts {\n    fetchFn?: typeof globalThis.fetch;\n\n    baseUrl: string;\n    idBaseUrl?: string;\n    prefix: string;\n    extraParams?: QueryDict;\n\n    accessToken?: string;\n    /**\n     * Used in conjunction with tokenRefreshFunction to attempt token refresh\n     */\n    refreshToken?: string;\n    /**\n     * Function to attempt token refresh when a possibly expired token is encountered\n     * Optional, only called when a refreshToken is present\n     */\n    tokenRefreshFunction?: TokenRefreshFunction;\n    useAuthorizationHeader?: boolean; // defaults to true\n\n    /** For historical reasons, must be set to `true`. Will eventually be removed. */\n    onlyData?: boolean;\n\n    localTimeoutMs?: number;\n\n    /** Optional logger instance. If provided, requests and responses will be logged. */\n    logger?: Logger;\n}\n\n/** Options object for `FetchHttpApi.requestOtherUrl`. */\nexport interface BaseRequestOpts extends Pick<RequestInit, \"priority\"> {\n    /**\n     * map of additional request headers\n     */\n    headers?: Record<string, string>;\n    abortSignal?: AbortSignal;\n    /**\n     * The maximum amount of time to wait before\n     * timing out the request. If not specified, there is no timeout.\n     */\n    localTimeoutMs?: number;\n    keepAlive?: boolean; // defaults to false\n\n    /**\n     * By default, we will:\n     *\n     *  *  If the `body` is an object, JSON-encode it and set `Content-Type: application/json` in the\n     *     request headers (unless overridden by {@link headers}).\n     *\n     *  * Set `Accept: application/json` in the request headers (again, unless overridden by {@link headers}).\n     *\n     *  * Parse the response as JSON and return the parsed response.\n     *\n     * Setting this to `false` inhibits all three behaviors, and the response is instead parsed as a UTF-8 string. It\n     * defaults to `true`, unless {@link rawResponseBody} is set.\n     *\n     * @deprecated Instead of setting this to `false`, set {@link rawResponseBody} to `true`.\n     */\n    json?: boolean;\n\n    /**\n     * Setting this to `true` does two things:\n     *\n     *  * Inhibits the automatic addition of `Accept: application/json` in the request headers.\n     *\n     *  * Causes the raw response to be returned as a {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob|Blob}\n     *    instead of parsing it as JSON.\n     */\n    rawResponseBody?: boolean;\n}\n\nexport interface IRequestOpts extends BaseRequestOpts {\n    /**\n     * The alternative base url to use.\n     * If not specified, uses this.opts.baseUrl\n     */\n    baseUrl?: string;\n    /**\n     * The full prefix to use e.g.\n     * \"/_matrix/client/v2_alpha\". If not specified, uses this.opts.prefix.\n     */\n    prefix?: string;\n\n    // Set to true to prevent the request function from emitting a Session.logged_out event.\n    // This is intended for use on endpoints where M_UNKNOWN_TOKEN is a valid/notable error response,\n    // such as with token refreshes.\n    inhibitLogoutEmit?: boolean;\n}\n\nexport interface IContentUri {\n    base: string;\n    path: string;\n    params: {\n        // eslint-disable-next-line camelcase\n        access_token: string;\n    };\n}\n\nexport enum HttpApiEvent {\n    SessionLoggedOut = \"Session.logged_out\",\n    NoConsent = \"no_consent\",\n}\n\nexport type HttpApiEventHandlerMap = {\n    /**\n     * Fires whenever the login session the JS SDK is using is no\n     * longer valid and the user must log in again.\n     * NB. This only fires when action is required from the user, not\n     * when then login session can be renewed by using a refresh token.\n     * @example\n     * ```\n     * matrixClient.on(\"Session.logged_out\", function(errorObj){\n     *   // show the login screen\n     * });\n     * ```\n     */\n    [HttpApiEvent.SessionLoggedOut]: (err: MatrixError) => void;\n    /**\n     * Fires when the JS SDK receives a M_CONSENT_NOT_GIVEN error in response\n     * to a HTTP request.\n     * @example\n     * ```\n     * matrixClient.on(\"no_consent\", function(message, contentUri) {\n     *     console.info(message + ' Go to ' + contentUri);\n     * });\n     * ```\n     */\n    [HttpApiEvent.NoConsent]: (message: string, consentUri: string) => void;\n};\n\nexport interface UploadProgress {\n    loaded: number;\n    total: number;\n}\n\nexport interface UploadOpts {\n    /**\n     * Name to give the file on the server. Defaults to <tt>file.name</tt>.\n     */\n    name?: string;\n    /**\n     * Content-type for the upload. Defaults to\n     *   <tt>file.type</tt>, or <tt>applicaton/octet-stream</tt>.\n     */\n    type?: string;\n    /**\n     * if false will not send the filename,\n     *   e.g for encrypted file uploads where filename leaks are undesirable.\n     *   Defaults to true.\n     */\n    includeFilename?: boolean;\n    /**\n     * Optional. Called when a chunk of\n     *    data has been uploaded, with an object containing the fields `loaded`\n     *    (number of bytes transferred) and `total` (total size, if known).\n     */\n    progressHandler?(progress: UploadProgress): void;\n    abortController?: AbortController;\n}\n\nexport interface Upload {\n    loaded: number;\n    total: number;\n    promise: Promise<UploadResponse>;\n    abortController: AbortController;\n}\n\nexport interface UploadResponse {\n    // eslint-disable-next-line camelcase\n    content_uri: string;\n}\n\nexport type FileType = XMLHttpRequestBodyInit;\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum Method {\n    Get = \"GET\",\n    Put = \"PUT\",\n    Post = \"POST\",\n    Delete = \"DELETE\",\n    Options = \"OPTIONS\",\n    Head = \"HEAD\",\n    Patch = \"PATCH\",\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum ClientPrefix {\n    /**\n     * A constant representing the URI path for Client-Server API endpoints versioned at v1.\n     */\n    V1 = \"/_matrix/client/v1\",\n    /**\n     * A constant representing the URI path for Client-Server API endpoints versioned at v3.\n     */\n    V3 = \"/_matrix/client/v3\",\n    /**\n     * A constant representing the URI path for as-yet unspecified Client-Server HTTP APIs.\n     */\n    Unstable = \"/_matrix/client/unstable\",\n}\n\nexport enum IdentityPrefix {\n    /**\n     * URI path for the v2 identity API\n     */\n    V2 = \"/_matrix/identity/v2\",\n}\n\nexport enum MediaPrefix {\n    /**\n     * A constant representing the URI path for Client-Server API Media endpoints versioned at v1.\n     */\n    V1 = \"/_matrix/media/v1\",\n    /**\n     * A constant representing the URI path for Client-Server API Media endpoints versioned at v3.\n     */\n    V3 = \"/_matrix/media/v3\",\n}\n","/*\nCopyright 2022 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { parse as parseContentType, type ParsedMediaType } from \"content-type\";\n\nimport { logger } from \"../logger.ts\";\nimport { sleep } from \"../utils.ts\";\nimport { ConnectionError, HTTPError, MatrixError, safeGetRetryAfterMs } from \"./errors.ts\";\n\n// Ponyfill for https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout\nexport function timeoutSignal(ms: number): AbortSignal {\n    const controller = new AbortController();\n    setTimeout(() => {\n        controller.abort();\n    }, ms);\n\n    return controller.signal;\n}\n\nexport function anySignal(signals: AbortSignal[]): {\n    signal: AbortSignal;\n    cleanup(): void;\n} {\n    const controller = new AbortController();\n\n    function cleanup(): void {\n        for (const signal of signals) {\n            signal.removeEventListener(\"abort\", onAbort);\n        }\n    }\n\n    function onAbort(): void {\n        controller.abort();\n        cleanup();\n    }\n\n    for (const signal of signals) {\n        if (signal.aborted) {\n            onAbort();\n            break;\n        }\n        signal.addEventListener(\"abort\", onAbort);\n    }\n\n    return {\n        signal: controller.signal,\n        cleanup,\n    };\n}\n\n/**\n * Attempt to turn an HTTP error response into a Javascript Error.\n *\n * If it is a JSON response, we will parse it into a MatrixError. Otherwise\n * we return a generic Error.\n *\n * @param response - response object\n * @param body - raw body of the response\n * @returns\n */\nexport function parseErrorResponse(response: XMLHttpRequest | Response, body?: string): Error {\n    const httpHeaders = isXhr(response)\n        ? new Headers(\n              response\n                  .getAllResponseHeaders()\n                  .trim()\n                  .split(/[\\r\\n]+/)\n                  .map((header): [string, string] => {\n                      const colonIdx = header.indexOf(\":\");\n                      return [header.substring(0, colonIdx), header.substring(colonIdx + 1)];\n                  }),\n          )\n        : response.headers;\n\n    let contentType: ParsedMediaType | null;\n    try {\n        contentType = getResponseContentType(httpHeaders);\n    } catch (e) {\n        return <Error>e;\n    }\n    if (contentType?.type === \"application/json\" && body) {\n        return new MatrixError(\n            JSON.parse(body),\n            response.status,\n            isXhr(response) ? response.responseURL : response.url,\n            undefined,\n            httpHeaders,\n        );\n    }\n    if (contentType?.type === \"text/plain\") {\n        return new HTTPError(`Server returned ${response.status} error: ${body}`, response.status, httpHeaders);\n    }\n    return new HTTPError(`Server returned ${response.status} error`, response.status, httpHeaders);\n}\n\nfunction isXhr(response: XMLHttpRequest | Response): response is XMLHttpRequest {\n    return \"getResponseHeader\" in response;\n}\n\n/**\n * extract the Content-Type header from response headers, and\n * parse it to a `{type, parameters}` object.\n *\n * returns null if no content-type header could be found.\n *\n * @param response - response object\n * @returns parsed content-type header, or null if not found\n */\nfunction getResponseContentType(headers: Headers): ParsedMediaType | null {\n    const contentType = headers.get(\"Content-Type\");\n    if (contentType === null) return null;\n\n    try {\n        return parseContentType(contentType);\n    } catch (e) {\n        throw new Error(`Error parsing Content-Type '${contentType}': ${e}`);\n    }\n}\n\n/**\n * Retries a network operation run in a callback.\n * @param maxAttempts - maximum attempts to try\n * @param callback - callback that returns a promise of the network operation. If rejected with ConnectionError, it will be retried by calling the callback again.\n * @returns the result of the network operation\n * @throws {@link ConnectionError} If after maxAttempts the callback still throws ConnectionError\n */\nexport async function retryNetworkOperation<T>(maxAttempts: number, callback: () => Promise<T>): Promise<T> {\n    let attempts = 0;\n    let lastConnectionError: ConnectionError | null = null;\n    while (attempts < maxAttempts) {\n        try {\n            if (attempts > 0) {\n                const timeout = 1000 * Math.pow(2, attempts);\n                logger.log(`network operation failed ${attempts} times, retrying in ${timeout}ms...`);\n                await sleep(timeout);\n            }\n            return await callback();\n        } catch (err) {\n            if (err instanceof ConnectionError) {\n                attempts += 1;\n                lastConnectionError = err;\n            } else {\n                throw err;\n            }\n        }\n    }\n    throw lastConnectionError;\n}\n\n/**\n * Calculate the backoff time for a request retry attempt.\n * This produces wait times of 2, 4, 8, and 16 seconds (30s total) after which we give up. If the\n * failure was due to a rate limited request, the time specified in the error is returned.\n *\n * Returns -1 if the error is not retryable, or if we reach the maximum number of attempts.\n *\n * @param err - The error thrown by the http call\n * @param attempts - The number of attempts made so far, including the one that just failed.\n * @param retryConnectionError - Whether to retry on {@link ConnectionError} (CORS, connection is down, etc.)\n */\nexport function calculateRetryBackoff(err: any, attempts: number, retryConnectionError: boolean): number {\n    if (attempts > 4) {\n        return -1; // give up\n    }\n\n    if (err instanceof ConnectionError && !retryConnectionError) {\n        return -1;\n    }\n\n    if (err.httpStatus && Math.floor(err.httpStatus / 100) === 4 && err.httpStatus !== 429) {\n        // client error; no amount of retrying will save you now (except for rate limiting which is handled below)\n        return -1;\n    }\n\n    if (err.name === \"AbortError\") {\n        // this is a client timeout, that is already very high 60s/80s\n        // we don't want to retry, as it could do it for very long\n        return -1;\n    }\n\n    // If we are trying to send an event (or similar) that is too large in any way, then retrying won't help\n    if (err.name === \"M_TOO_LARGE\") {\n        return -1;\n    }\n\n    return safeGetRetryAfterMs(err, 1000 * Math.pow(2, attempts));\n}\n","/*\nCopyright 2019 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Check if an IndexedDB database exists. The only way to do so is to try opening it, so\n * we do that and then delete it did not exist before.\n *\n * @param indexedDB - The `indexedDB` interface\n * @param dbName - The database name to test for\n * @returns Whether the database exists\n */\nexport function exists(indexedDB: IDBFactory, dbName: string): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n        let exists = true;\n        const req = indexedDB.open(dbName);\n        req.onupgradeneeded = (): void => {\n            // Since we did not provide an explicit version when opening, this event\n            // should only fire if the DB did not exist before at any version.\n            exists = false;\n        };\n        req.onblocked = (): void => reject(req.error);\n        req.onsuccess = (): void => {\n            const db = req.result;\n            db.close();\n            if (!exists) {\n                // The DB did not exist before, but has been created as part of this\n                // existence check. Delete it now to restore previous state. Delete can\n                // actually take a while to complete in some browsers, so don't wait for\n                // it. This won't block future open calls that a store might issue next to\n                // properly set up the DB.\n                indexedDB.deleteDatabase(dbName);\n            }\n            resolve(exists);\n        };\n        req.onerror = (): void => reject(req.error);\n    });\n}\n","import { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { type EncryptionConfig } from \"./MatrixRTCSession.ts\";\nimport { secureRandomBase64Url } from \"../randomstring.ts\";\nimport { decodeBase64, encodeUnpaddedBase64 } from \"../base64.ts\";\nimport { safeGetRetryAfterMs } from \"../http-api/errors.ts\";\nimport { type CallMembership } from \"./CallMembership.ts\";\nimport { type KeyTransportEventListener, KeyTransportEvents, type IKeyTransport } from \"./IKeyTransport.ts\";\nimport { isMyMembership, type ParticipantId, type Statistics } from \"./types.ts\";\nimport { getParticipantId } from \"./utils.ts\";\n\n/**\n * This interface is for testing and for making it possible to interchange the encryption manager.\n * @internal\n */\nexport interface IEncryptionManager {\n    /**\n     * Joins the encryption manager with the provided configuration.\n     *\n     * @param joinConfig - The configuration for joining encryption, or undefined\n     * if no specific configuration is provided.\n     */\n    join(joinConfig: EncryptionConfig | undefined): void;\n\n    /**\n     * Leaves the encryption manager, cleaning up any associated resources.\n     */\n    leave(): void;\n\n    /**\n     * Called from the MatrixRTCSession when the memberships in this session updated.\n     *\n     * @param oldMemberships - The previous state of call memberships before the update.\n     */\n    onMembershipsUpdate(oldMemberships: CallMembership[]): void;\n\n    /**\n     * Retrieves the encryption keys currently managed by the encryption manager.\n     *\n     * @returns A map of participant IDs to their encryption keys.\n     */\n    getEncryptionKeys(): ReadonlyMap<ParticipantId, ReadonlyArray<{ key: Uint8Array; keyIndex: number }>>;\n}\n\n/**\n * This class implements the IEncryptionManager interface,\n * and takes care of managing the encryption keys of all rtc members:\n *  - generate new keys for the local user and send them to other participants\n *  - track all keys of all other members and update livekit.\n *\n * @internal\n */\nexport class EncryptionManager implements IEncryptionManager {\n    private manageMediaKeys = false;\n    private keysEventUpdateTimeout?: ReturnType<typeof setTimeout>;\n    private makeNewKeyTimeout?: ReturnType<typeof setTimeout>;\n    private setNewKeyTimeouts = new Set<ReturnType<typeof setTimeout>>();\n\n    private get updateEncryptionKeyThrottle(): number {\n        return this.joinConfig?.updateEncryptionKeyThrottle ?? 3_000;\n    }\n\n    private get makeKeyDelay(): number {\n        return this.joinConfig?.makeKeyDelay ?? 3_000;\n    }\n\n    private get useKeyDelay(): number {\n        return this.joinConfig?.useKeyDelay ?? 5_000;\n    }\n\n    private encryptionKeys = new Map<string, Array<{ key: Uint8Array; timestamp: number }>>();\n    private lastEncryptionKeyUpdateRequest?: number;\n\n    // We use this to store the last membership fingerprints we saw, so we can proactively re-send encryption keys\n    // if it looks like a membership has been updated.\n    private lastMembershipFingerprints: Set<string> | undefined;\n\n    private latestGeneratedKeyIndex = -1;\n    private joinConfig: EncryptionConfig | undefined;\n    private logger: Logger;\n\n    public constructor(\n        private userId: string,\n        private deviceId: string,\n        private getMemberships: () => CallMembership[],\n        private transport: IKeyTransport,\n        private statistics: Statistics,\n        private onEncryptionKeysChanged: (\n            keyBin: Uint8Array,\n            encryptionKeyIndex: number,\n            participantId: string,\n        ) => void,\n        parentLogger?: Logger,\n    ) {\n        this.logger = (parentLogger ?? rootLogger).getChild(`[EncryptionManager]`);\n    }\n\n    public getEncryptionKeys(): ReadonlyMap<ParticipantId, ReadonlyArray<{ key: Uint8Array; keyIndex: number }>> {\n        const keysMap = new Map<ParticipantId, ReadonlyArray<{ key: Uint8Array; keyIndex: number }>>();\n        for (const [userId, userKeys] of this.encryptionKeys) {\n            const keys = userKeys.map((entry, index) => ({\n                key: entry.key,\n                keyIndex: index,\n            }));\n            keysMap.set(userId as ParticipantId, keys);\n        }\n        return keysMap;\n    }\n\n    private joined = false;\n\n    public join(joinConfig: EncryptionConfig): void {\n        this.joinConfig = joinConfig;\n        this.joined = true;\n        this.manageMediaKeys = this.joinConfig?.manageMediaKeys ?? this.manageMediaKeys;\n\n        this.transport.on(KeyTransportEvents.ReceivedKeys, this.onNewKeyReceived);\n\n        this.transport.start();\n        if (this.joinConfig?.manageMediaKeys) {\n            this.makeNewSenderKey();\n            this.requestSendCurrentKey();\n        }\n    }\n\n    public leave(): void {\n        // clear our encryption keys as we're done with them now (we'll\n        // make new keys if we rejoin). We leave keys for other participants\n        // as they may still be using the same ones.\n        this.encryptionKeys.set(getParticipantId(this.userId, this.deviceId), []);\n        this.transport.off(KeyTransportEvents.ReceivedKeys, this.onNewKeyReceived);\n        this.transport.stop();\n\n        if (this.makeNewKeyTimeout !== undefined) {\n            clearTimeout(this.makeNewKeyTimeout);\n            this.makeNewKeyTimeout = undefined;\n        }\n        for (const t of this.setNewKeyTimeouts) {\n            clearTimeout(t);\n        }\n        this.setNewKeyTimeouts.clear();\n\n        this.manageMediaKeys = false;\n        this.joined = false;\n    }\n\n    public onMembershipsUpdate(oldMemberships: CallMembership[]): void {\n        if (this.manageMediaKeys && this.joined) {\n            const oldMembershipIds = new Set(\n                oldMemberships\n                    .filter((m) => !isMyMembership(m, this.userId, this.deviceId))\n                    .map(getParticipantIdFromMembership),\n            );\n            const newMembershipIds = new Set(\n                this.getMemberships()\n                    .filter((m) => !isMyMembership(m, this.userId, this.deviceId))\n                    .map(getParticipantIdFromMembership),\n            );\n\n            // We can use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference\n            // for this once available\n            const anyLeft = Array.from(oldMembershipIds).some((x) => !newMembershipIds.has(x));\n            const anyJoined = Array.from(newMembershipIds).some((x) => !oldMembershipIds.has(x));\n\n            const oldFingerprints = this.lastMembershipFingerprints;\n            // always store the fingerprints of these latest memberships\n            this.storeLastMembershipFingerprints();\n\n            if (anyLeft) {\n                if (this.makeNewKeyTimeout) {\n                    // existing rotation in progress, so let it complete\n                } else {\n                    this.logger.debug(`Member(s) have left: queueing sender key rotation`);\n                    this.makeNewKeyTimeout = setTimeout(this.onRotateKeyTimeout, this.makeKeyDelay);\n                }\n            } else if (anyJoined) {\n                this.logger.debug(`New member(s) have joined: re-sending keys`);\n                this.requestSendCurrentKey();\n            } else if (oldFingerprints) {\n                // does it look like any of the members have updated their memberships?\n                const newFingerprints = this.lastMembershipFingerprints!;\n\n                // We can use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/symmetricDifference\n                // for this once available\n                const candidateUpdates =\n                    Array.from(oldFingerprints).some((x) => !newFingerprints.has(x)) ||\n                    Array.from(newFingerprints).some((x) => !oldFingerprints.has(x));\n                if (candidateUpdates) {\n                    this.logger.debug(`Member(s) have updated/reconnected: re-sending keys to everyone`);\n                    this.requestSendCurrentKey();\n                }\n            }\n        }\n    }\n\n    /**\n     * Generate a new sender key and add it at the next available index\n     * @param delayBeforeUse - If true, wait for a short period before setting the key for the\n     *                         media encryptor to use. If false, set the key immediately.\n     * @returns The index of the new key\n     */\n    private makeNewSenderKey(delayBeforeUse = false): number {\n        const encryptionKey = secureRandomBase64Url(16);\n        const encryptionKeyIndex = this.getNewEncryptionKeyIndex();\n        this.logger.info(\"Generated new key at index \" + encryptionKeyIndex);\n        this.setEncryptionKey(\n            this.userId,\n            this.deviceId,\n            encryptionKeyIndex,\n            encryptionKey,\n            Date.now(),\n            delayBeforeUse,\n        );\n        return encryptionKeyIndex;\n    }\n\n    /**\n     * Requests that we resend our current keys to the room. May send a keys event immediately\n     * or queue for alter if one has already been sent recently.\n     */\n    private requestSendCurrentKey(): void {\n        if (!this.manageMediaKeys) return;\n\n        if (\n            this.lastEncryptionKeyUpdateRequest &&\n            this.lastEncryptionKeyUpdateRequest + this.updateEncryptionKeyThrottle > Date.now()\n        ) {\n            this.logger.info(\"Last encryption key event sent too recently: postponing\");\n            if (this.keysEventUpdateTimeout === undefined) {\n                this.keysEventUpdateTimeout = setTimeout(\n                    () => void this.sendEncryptionKeysEvent(),\n                    this.updateEncryptionKeyThrottle,\n                );\n            }\n            return;\n        }\n\n        void this.sendEncryptionKeysEvent();\n    }\n\n    /**\n     * Get the known encryption keys for a given participant device.\n     *\n     * @param userId the user ID of the participant\n     * @param deviceId the device ID of the participant\n     * @returns The encryption keys for the given participant, or undefined if they are not known.\n     */\n    private getKeysForParticipant(userId: string, deviceId: string): Array<Uint8Array> | undefined {\n        return this.encryptionKeys.get(getParticipantId(userId, deviceId))?.map((entry) => entry.key);\n    }\n\n    /**\n     * Re-sends the encryption keys room event\n     */\n    private sendEncryptionKeysEvent = async (indexToSend?: number): Promise<void> => {\n        if (this.keysEventUpdateTimeout !== undefined) {\n            clearTimeout(this.keysEventUpdateTimeout);\n            this.keysEventUpdateTimeout = undefined;\n        }\n        this.lastEncryptionKeyUpdateRequest = Date.now();\n\n        if (!this.joined) return;\n\n        const myKeys = this.getKeysForParticipant(this.userId, this.deviceId);\n\n        if (!myKeys) {\n            this.logger.warn(\"Tried to send encryption keys event but no keys found!\");\n            return;\n        }\n\n        if (typeof indexToSend !== \"number\" && this.latestGeneratedKeyIndex === -1) {\n            this.logger.warn(\"Tried to send encryption keys event but no current key index found!\");\n            return;\n        }\n\n        const keyIndexToSend = indexToSend ?? this.latestGeneratedKeyIndex;\n\n        this.logger.info(\n            `Try sending encryption keys event. keyIndexToSend=${keyIndexToSend} (method parameter: ${indexToSend})`,\n        );\n        const keyToSend = myKeys[keyIndexToSend];\n\n        try {\n            this.statistics.counters.roomEventEncryptionKeysSent += 1;\n            const targets = this.getMemberships()\n                .filter((membership) => {\n                    return membership.sender != undefined;\n                })\n                .map((membership) => {\n                    return {\n                        userId: membership.sender!,\n                        deviceId: membership.deviceId,\n                        membershipTs: membership.createdTs(),\n                    };\n                });\n            await this.transport.sendKey(encodeUnpaddedBase64(keyToSend), keyIndexToSend, targets);\n            this.logger.debug(\n                `sendEncryptionKeysEvent participantId=${this.userId}:${this.deviceId} numKeys=${myKeys.length} currentKeyIndex=${this.latestGeneratedKeyIndex} keyIndexToSend=${keyIndexToSend}`,\n            );\n        } catch (error) {\n            if (this.keysEventUpdateTimeout === undefined) {\n                const resendDelay = safeGetRetryAfterMs(error, 5000);\n                this.logger.warn(`Failed to send m.call.encryption_key, retrying in ${resendDelay}`, error);\n                this.keysEventUpdateTimeout = setTimeout(() => void this.sendEncryptionKeysEvent(), resendDelay);\n            } else {\n                this.logger.info(\"Not scheduling key resend as another re-send is already pending\");\n            }\n        }\n    };\n\n    public onNewKeyReceived: KeyTransportEventListener = (userId, deviceId, keyBase64Encoded, index, timestamp) => {\n        this.logger.debug(`Received key over key transport ${userId}:${deviceId} at index ${index}`);\n        this.setEncryptionKey(userId, deviceId, index, keyBase64Encoded, timestamp);\n    };\n\n    private storeLastMembershipFingerprints(): void {\n        this.lastMembershipFingerprints = new Set(\n            this.getMemberships()\n                .filter((m) => !isMyMembership(m, this.userId, this.deviceId))\n                .map((m) => `${getParticipantIdFromMembership(m)}:${m.createdTs()}`),\n        );\n    }\n\n    private getNewEncryptionKeyIndex(): number {\n        if (this.latestGeneratedKeyIndex === -1) {\n            return 0;\n        }\n\n        // maximum key index is 255\n        return (this.latestGeneratedKeyIndex + 1) % 256;\n    }\n\n    /**\n     * Sets an encryption key at a specified index for a participant.\n     * The encryption keys for the local participant are also stored here under the\n     * user and device ID of the local participant.\n     * If the key is older than the existing key at the index, it will be ignored.\n     * @param userId - The user ID of the participant\n     * @param deviceId - Device ID of the participant\n     * @param encryptionKeyIndex - The index of the key to set\n     * @param encryptionKeyString - The string representation of the key to set in base64\n     * @param timestamp - The timestamp of the key. We assume that these are monotonic for each participant device.\n     * @param delayBeforeUse - If true, delay before emitting a key changed event. Useful when setting\n     *                         encryption keys for the local participant to allow time for the key to\n     *                         be distributed.\n     */\n    private setEncryptionKey(\n        userId: string,\n        deviceId: string,\n        encryptionKeyIndex: number,\n        encryptionKeyString: string,\n        timestamp: number,\n        delayBeforeUse = false,\n    ): void {\n        this.logger.debug(`Setting encryption key for ${userId}:${deviceId} at index ${encryptionKeyIndex}`);\n        const keyBin = decodeBase64(encryptionKeyString);\n\n        const participantId = getParticipantId(userId, deviceId);\n        if (!this.encryptionKeys.has(participantId)) {\n            this.encryptionKeys.set(participantId, []);\n        }\n        const participantKeys = this.encryptionKeys.get(participantId)!;\n\n        const existingKeyAtIndex = participantKeys[encryptionKeyIndex];\n\n        if (existingKeyAtIndex) {\n            if (existingKeyAtIndex.timestamp > timestamp) {\n                this.logger.info(\n                    `Ignoring new key at index ${encryptionKeyIndex} for ${participantId} as it is older than existing known key`,\n                );\n                return;\n            }\n\n            if (keysEqual(existingKeyAtIndex.key, keyBin)) {\n                existingKeyAtIndex.timestamp = timestamp;\n                return;\n            }\n        }\n\n        if (userId === this.userId && deviceId === this.deviceId) {\n            // It is important to already update the latestGeneratedKeyIndex here\n            // NOT IN THE `delayBeforeUse` `setTimeout`.\n            // Even though this is where we call onEncryptionKeysChanged and set the key in EC (and livekit).\n            // It needs to happen here because we will send the key before the timeout has passed and sending\n            // the key will use latestGeneratedKeyIndex as the index. if we update it in the `setTimeout` callback\n            // it will use the wrong index (index - 1)!\n            this.latestGeneratedKeyIndex = encryptionKeyIndex;\n        }\n        participantKeys[encryptionKeyIndex] = {\n            key: keyBin,\n            timestamp,\n        };\n\n        if (delayBeforeUse) {\n            const useKeyTimeout = setTimeout(() => {\n                this.setNewKeyTimeouts.delete(useKeyTimeout);\n                this.logger.info(`Delayed-emitting key changed event for ${participantId} index ${encryptionKeyIndex}`);\n\n                this.onEncryptionKeysChanged(keyBin, encryptionKeyIndex, participantId);\n            }, this.useKeyDelay);\n            this.setNewKeyTimeouts.add(useKeyTimeout);\n        } else {\n            this.onEncryptionKeysChanged(keyBin, encryptionKeyIndex, participantId);\n        }\n    }\n\n    private onRotateKeyTimeout = (): void => {\n        if (!this.manageMediaKeys) return;\n\n        this.makeNewKeyTimeout = undefined;\n        this.logger.info(\"Making new sender key for key rotation\");\n        const newKeyIndex = this.makeNewSenderKey(true);\n        // send immediately: if we're about to start sending with a new key, it's\n        // important we get it out to others as soon as we can.\n        void this.sendEncryptionKeysEvent(newKeyIndex);\n    };\n}\n\nfunction keysEqual(a: Uint8Array | undefined, b: Uint8Array | undefined): boolean {\n    if (a === b) return true;\n    return !!a && !!b && a.length === b.length && a.every((x, i) => x === b[i]);\n}\n\nconst getParticipantIdFromMembership = (m: CallMembership): string => getParticipantId(m.sender!, m.deviceId);\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type ParticipantDeviceInfo } from \"./types.ts\";\n\nexport enum KeyTransportEvents {\n    ReceivedKeys = \"received_keys\",\n    NotSupportedError = \"not_supported_error\",\n}\n\nexport type KeyTransportEventsHandlerMap = {\n    [KeyTransportEvents.ReceivedKeys]: KeyTransportEventListener;\n    [KeyTransportEvents.NotSupportedError]: () => void;\n};\n\nexport type KeyTransportEventListener = (\n    userId: string,\n    deviceId: string,\n    keyBase64Encoded: string,\n    index: number,\n    timestamp: number,\n) => void;\n\n/**\n * Generic interface for the transport used to share room keys.\n * Keys can be shared using different transports, e.g. to-device messages or room messages.\n */\nexport interface IKeyTransport {\n    /**\n     * Sends the current user media key to the given members.\n     * @param keyBase64Encoded\n     * @param index\n     * @param members - The participants that should get they key\n     */\n    sendKey(keyBase64Encoded: string, index: number, members: ParticipantDeviceInfo[]): Promise<void>;\n\n    /** Subscribe to keys from this transport. */\n    on(event: KeyTransportEvents.ReceivedKeys, listener: KeyTransportEventListener): this;\n    /** Unsubscribe from keys from this transport. */\n    off(event: KeyTransportEvents.ReceivedKeys, listener: KeyTransportEventListener): this;\n\n    /** Once start is called the underlying transport will subscribe to its transport system.\n     * Before start is called this transport will not emit any events.\n     */\n    start(): void;\n    /** Once stop is called the underlying transport will unsubscribe from its transport system.\n     * After stop is called this transport will not emit any events.\n     */\n    stop(): void;\n}\n","import { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { type EmptyObject } from \"../matrix.ts\";\nimport { sleep } from \"../utils.ts\";\nimport { MembershipActionType } from \"./MembershipManager.ts\";\n\n/** @internal */\nexport interface Action {\n    /**\n     * When this action should be executed\n     */\n    ts: number;\n    /**\n     * The state of the different loops\n     * can also be thought of as the type of the action\n     */\n    type: MembershipActionType;\n}\n\n/** @internal */\nexport type ActionUpdate =\n    | {\n          /** Replace all existing scheduled actions with this new array */\n          replace: Action[];\n      }\n    | {\n          /** Add these actions to the existing scheduled actions */\n          insert: Action[];\n      }\n    | EmptyObject;\n\n/**\n * This scheduler tracks the state of the current membership participation\n * and runs one central timer that wakes up a handler callback with the correct action + state\n * whenever necessary.\n *\n * It can also be awakened whenever a new action is added which is\n * earlier then the current \"next awake\".\n * @internal\n */\nexport class ActionScheduler {\n    private logger: Logger;\n    /**\n     * This is tracking the state of the scheduler loop.\n     * Only used to prevent starting the loop twice.\n     */\n    public running = false;\n\n    public constructor(\n        /** This is the callback called for each scheduled action (`this.addAction()`) */\n        private membershipLoopHandler: (type: MembershipActionType) => Promise<ActionUpdate>,\n        parentLogger?: Logger,\n    ) {\n        this.logger = (parentLogger ?? rootLogger).getChild(`[NewMembershipActionScheduler]`);\n    }\n\n    // function for the wakeup mechanism (in case we add an action externally and need to leave the current sleep)\n    private wakeup: (update: ActionUpdate) => void = (update: ActionUpdate): void => {\n        this.logger.error(\"Cannot call wakeup before calling `startWithJoin()`\");\n    };\n    private _actions: Action[] = [];\n    public get actions(): Action[] {\n        return this._actions;\n    }\n\n    /**\n     * This starts the main loop of the membership manager that handles event sending, delayed event sending and delayed event restarting.\n     * @param initialActions The initial actions the manager will start with. It should be enough to pass: DelayedLeaveActionType.Initial\n     * @returns Promise that resolves once all actions have run and no more are scheduled.\n     * @throws This throws an error if one of the actions throws.\n     * In most other error cases the manager will try to handle any server errors by itself.\n     */\n    public async startWithJoin(): Promise<void> {\n        if (this.running) {\n            this.logger.error(\"Cannot call startWithJoin() on NewMembershipActionScheduler while already running\");\n            return;\n        }\n        this.running = true;\n        this._actions = [{ ts: Date.now(), type: MembershipActionType.SendDelayedEvent }];\n        try {\n            while (this._actions.length > 0) {\n                // Sort so next (smallest ts) action is at the beginning\n                this._actions.sort((a, b) => a.ts - b.ts);\n                const nextAction = this._actions[0];\n                let wakeupUpdate: ActionUpdate | undefined = undefined;\n\n                // while we await for the next action, wakeup has to resolve the wakeupPromise\n                const wakeupPromise = new Promise<void>((resolve) => {\n                    this.wakeup = (update: ActionUpdate): void => {\n                        wakeupUpdate = update;\n                        resolve();\n                    };\n                });\n                if (nextAction.ts > Date.now()) await Promise.race([wakeupPromise, sleep(nextAction.ts - Date.now())]);\n\n                let handlerResult: ActionUpdate = {};\n                if (!wakeupUpdate) {\n                    this.logger.debug(\n                        `Current MembershipManager processing: ${nextAction.type}\\nQueue:`,\n                        this._actions,\n                        `\\nDate.now: \"${Date.now()}`,\n                    );\n                    try {\n                        // `this.wakeup` can also be called and sets the `wakeupUpdate` object while we are in the handler.\n                        handlerResult = await this.membershipLoopHandler(nextAction.type as MembershipActionType);\n                    } catch (e) {\n                        throw Error(`The MembershipManager shut down because of the end condition: ${e}`);\n                    }\n                }\n                // remove the processed action only after we are done processing\n                this._actions.splice(0, 1);\n                // The wakeupUpdate always wins since that is a direct external update.\n                const actionUpdate = wakeupUpdate ?? handlerResult;\n\n                if (\"replace\" in actionUpdate) {\n                    this._actions = actionUpdate.replace;\n                } else if (\"insert\" in actionUpdate) {\n                    this._actions.push(...actionUpdate.insert);\n                }\n            }\n        } finally {\n            // Set the rtc session running state since we cannot recover from here and the consumer user of the\n            // MatrixRTCSession class needs to manually rejoin.\n            this.running = false;\n        }\n\n        this.logger.debug(\"Leave MembershipManager ActionScheduler loop (no more actions)\");\n    }\n\n    public initiateJoin(): void {\n        this.wakeup?.({ replace: [{ ts: Date.now(), type: MembershipActionType.SendDelayedEvent }] });\n    }\n    public initiateLeave(): void {\n        this.wakeup?.({ replace: [{ ts: Date.now(), type: MembershipActionType.SendScheduledDelayedLeaveEvent }] });\n    }\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { AbortError } from \"p-retry\";\n\nimport { EventType, RelationType } from \"../@types/event.ts\";\nimport { type ISendEventResponse, type SendDelayedEventResponse } from \"../@types/requests.ts\";\nimport { type EmptyObject } from \"../@types/common.ts\";\nimport type { MatrixClient } from \"../client.ts\";\nimport { ConnectionError, HTTPError, MatrixError } from \"../http-api/errors.ts\";\nimport { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport {\n    type CallMembership,\n    DEFAULT_EXPIRE_DURATION,\n    type RtcMembershipData,\n    type SessionMembershipData,\n} from \"./CallMembership.ts\";\nimport { type Transport, isMyMembership, type RTCCallIntent, Status } from \"./types.ts\";\nimport {\n    type SlotDescription,\n    type MembershipConfig,\n    type SessionConfig,\n    slotDescriptionToId,\n} from \"./MatrixRTCSession.ts\";\nimport { ActionScheduler, type ActionUpdate } from \"./MembershipManagerActionScheduler.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { UnsupportedDelayedEventsEndpointError } from \"../errors.ts\";\nimport {\n    MembershipManagerEvent,\n    type IMembershipManager,\n    type MembershipManagerEventHandlerMap,\n} from \"./IMembershipManager.ts\";\n\n/* MembershipActionTypes:\nOn Join:     (1)\n                                                         \n                                         \n                   SendDelayedEvent (2)        \n                                        \n                           (3)                           \n                                                         \n                                           \n       (4)SendJoinEvent(4)          \n                                         \n                                         \n                                                    \n                      \nUpdateExpiry (s)                (s)|RestartDelayedEvent \n                      \n                                                      \n                                    \n\nOn Leave:   STOP ALL ABOVE\n                           \n            \n             SendScheduledDelayedLeaveEvent \n            \n                           (5)\n                           \n                    \n                    SendLeaveEvent\n                    \n(1) [Not found error] results in resending the delayed event\n(2) [hasMemberEvent = true] Sending the delayed event if we\n    already have a call member event results jumping to the\n    RestartDelayedEvent loop directly\n(3) [hasMemberEvent = false] if there is not call member event\n    sending it is the next step\n(4) Both (UpdateExpiry and RestartDelayedEvent) actions are\n    scheduled when successfully sending the state event\n(5) Only if delayed event sending failed (fallback)\n(s) Successful restart/resend\n*/\n\n/**\n * Call membership should always remain sticky for this amount\n * of time.\n */\nconst MEMBERSHIP_STICKY_DURATION_MS = 60 * 60 * 1000; // 60 minutes\n\n/**\n * The different types of actions the MembershipManager can take.\n * @internal\n */\nexport enum MembershipActionType {\n    SendDelayedEvent = \"SendDelayedEvent\",\n    //  -> MembershipActionType.SendJoinEvent if successful\n    //  -> DelayedLeaveActionType.SendDelayedEvent on error, retry sending the first delayed event.\n    //  -> DelayedLeaveActionType.RestartDelayedEvent on success start updating the delayed event\n\n    SendJoinEvent = \"SendJoinEvent\",\n    //  -> MembershipActionType.SendJoinEvent if we run into a rate limit and need to retry\n    //  -> MembershipActionType.Update if we successfully send the join event then schedule the expire event update\n    //  -> DelayedLeaveActionType.RestartDelayedEvent to recheck the delayed event\n\n    RestartDelayedEvent = \"RestartDelayedEvent\",\n    //  -> DelayedLeaveActionType.SendMainDelayedEvent on missing delay id but there is a rtc state event\n    //  -> DelayedLeaveActionType.SendDelayedEvent on missing delay id and there is no state event\n    //  -> DelayedLeaveActionType.RestartDelayedEvent on success we schedule the next restart\n\n    UpdateExpiry = \"UpdateExpiry\",\n    //  -> MembershipActionType.Update if the timeout has passed so the next update is required.\n\n    SendScheduledDelayedLeaveEvent = \"SendScheduledDelayedLeaveEvent\",\n    //  -> MembershipActionType.SendLeaveEvent on failure (not found) we need to send the leave manually and cannot use the scheduled delayed event\n    //  -> DelayedLeaveActionType.SendScheduledDelayedLeaveEvent on error we try again.\n\n    SendLeaveEvent = \"SendLeaveEvent\",\n    // -> MembershipActionType.SendLeaveEvent\n}\n\n/**\n * @internal\n */\nexport interface MembershipManagerState {\n    /** The delayId we got when successfully sending the delayed leave event.\n     * Gets set to undefined if the server claims it cannot find the delayed event anymore. */\n    delayId?: string;\n    /** Stores how often we have update the `expires` field.\n     * `expireUpdateIterations` * `membershipEventExpiryTimeout` resolves to the value the expires field should contain next */\n    expireUpdateIterations: number;\n    /** The time at which we send the first state event. The time the call started from the DAG point of view.\n     * This is used to compute the local sleep timestamps when to next update the member event with a new expires value. */\n    startTime: number;\n    /** The manager is in the state where its actually connected to the session. */\n    hasMemberStateEvent: boolean;\n    // There can be multiple retries at once so we need to store counters per action\n    // e.g. the send update membership and the restart delayed could be rate limited at the same time.\n    /** Retry counter for rate limits */\n    rateLimitRetries: Map<MembershipActionType, number>;\n    /** Retry counter for other errors */\n    networkErrorRetries: Map<MembershipActionType, number>;\n    /** The time at which we expect the server to send the delayed leave event. */\n    expectedServerDelayLeaveTs?: number;\n    /** This is used to track if the client expects the scheduled delayed leave event to have\n     * been sent because restarting failed during the available time.\n     * Once we resend the delayed event or successfully restarted it will get unset. */\n    probablyLeft: boolean;\n}\n\nfunction createInsertActionUpdate(type: MembershipActionType, offset?: number): ActionUpdate {\n    return {\n        insert: [{ ts: Date.now() + (offset ?? 0), type }],\n    };\n}\n\nfunction createReplaceActionUpdate(type: MembershipActionType, offset?: number): ActionUpdate {\n    return {\n        replace: [{ ts: Date.now() + (offset ?? 0), type }],\n    };\n}\n\ntype MembershipManagerClient = Pick<\n    MatrixClient,\n    | \"getUserId\"\n    | \"getDeviceId\"\n    | \"sendStateEvent\"\n    | \"_unstable_sendDelayedStateEvent\"\n    | \"_unstable_updateDelayedEvent\"\n    | \"_unstable_cancelScheduledDelayedEvent\"\n    | \"_unstable_restartScheduledDelayedEvent\"\n    | \"_unstable_sendScheduledDelayedEvent\"\n>;\n\n/**\n * This class is responsible for sending all events relating to the own membership of a matrixRTC call.\n * It has the following tasks:\n *  - Send the users leave delayed event before sending the membership\n *  - Send the users membership if the state machine is started\n *  - Check if the delayed event was canceled due to sending the membership\n *  - update the delayed event (`restart`)\n *  - Update the state event every ~5h = `DEFAULT_EXPIRE_DURATION` (so it does not get treated as expired)\n *  - When the state machine is stopped:\n *   - Disconnect the member\n *   - Stop the timer for the delay refresh\n *   - Stop the timer for updating the state event\n */\nexport class MembershipManager\n    extends TypedEventEmitter<MembershipManagerEvent, MembershipManagerEventHandlerMap>\n    implements IMembershipManager\n{\n    private activated = false;\n    private readonly logger: Logger;\n    protected callIntent: RTCCallIntent | undefined;\n\n    public isActivated(): boolean {\n        return this.activated;\n    }\n    // DEPRECATED use isActivated\n    public isJoined(): boolean {\n        return this.isActivated();\n    }\n\n    /**\n     * Puts the MembershipManager in a state where it tries to be joined.\n     * It will send delayed events and membership events\n     * @param fociPreferred the list of preferred foci to use in the joined RTC membership event.\n     * If multiSfuFocus is set, this is only needed if this client wants to publish to multiple transports simultaneously.\n     * @param multiSfuFocus the active focus to use in the joined RTC membership event. Setting this implies the\n     * membership manager will operate in a multi-SFU connection mode. If `undefined`, an `oldest_membership`\n     * transport selection will be used instead.\n     * @param onError This will be called once the membership manager encounters an unrecoverable error.\n     * This should bubble up the the frontend to communicate that the call does not work in the current environment.\n     */\n    public join(fociPreferred: Transport[], multiSfuFocus?: Transport, onError?: (error: unknown) => void): void {\n        if (this.scheduler.running) {\n            this.logger.error(\"MembershipManager is already running. Ignoring join request.\");\n            return;\n        }\n        this.fociPreferred = fociPreferred;\n        this.rtcTransport = multiSfuFocus;\n        this.leavePromiseResolvers = undefined;\n        this.activated = true;\n        this.oldStatus = this.status;\n        this.state = MembershipManager.defaultState;\n\n        this.scheduler\n            .startWithJoin()\n            .catch((e) => {\n                this.logger.error(\"MembershipManager stopped because: \", e);\n                onError?.(e);\n            })\n            .finally(() => {\n                // Should already be set to false when calling `leave` in non error cases.\n                this.activated = false;\n                // Here the scheduler is not running anymore so we the `membershipLoopHandler` is not called to emit.\n                if (this.oldStatus && this.oldStatus !== this.status) {\n                    this.emit(MembershipManagerEvent.StatusChanged, this.oldStatus, this.status);\n                }\n                if (!this.scheduler.running) {\n                    this.leavePromiseResolvers?.resolve(true);\n                    this.leavePromiseResolvers = undefined;\n                }\n            });\n    }\n\n    /**\n     * Leave from the call (Send an rtc session event with content: `{}`)\n     * @param timeout the maximum duration this promise will take to resolve\n     * @returns true if it managed to leave and false if the timeout condition happened.\n     */\n    public leave(timeout?: number): Promise<boolean> {\n        if (!this.scheduler.running) {\n            this.logger.warn(\"Called MembershipManager.leave() even though the MembershipManager is not running\");\n            return Promise.resolve(true);\n        }\n\n        // We use the promise to track if we already scheduled a leave event\n        // So we do not check scheduler.actions/scheduler.insertions\n        if (!this.leavePromiseResolvers) {\n            // reset scheduled actions so we will not do any new actions.\n            this.leavePromiseResolvers = Promise.withResolvers<boolean>();\n            this.activated = false;\n            this.scheduler.initiateLeave();\n            if (timeout) setTimeout(() => this.leavePromiseResolvers?.resolve(false), timeout);\n        }\n        return this.leavePromiseResolvers.promise;\n    }\n\n    private leavePromiseResolvers?: PromiseWithResolvers<boolean>;\n\n    public onRTCSessionMemberUpdate(memberships: CallMembership[]): Promise<void> {\n        if (!this.isActivated()) {\n            return Promise.resolve();\n        }\n        const userId = this.client.getUserId();\n        const deviceId = this.client.getDeviceId();\n        if (!userId || !deviceId) {\n            this.logger.error(\"MembershipManager.onRTCSessionMemberUpdate called without user or device id\");\n            return Promise.resolve();\n        }\n        this._ownMembership = memberships.find((m) => isMyMembership(m, userId, deviceId));\n\n        if (!this._ownMembership) {\n            // If one of these actions are scheduled or are getting inserted in the next iteration, we should already\n            // take care of our missing membership.\n            const sendingMembershipActions = [\n                MembershipActionType.SendDelayedEvent,\n                MembershipActionType.SendJoinEvent,\n            ];\n            this.logger.warn(\"Missing own membership: force re-join\");\n            this.state.hasMemberStateEvent = false;\n\n            if (this.scheduler.actions.some((a) => sendingMembershipActions.includes(a.type as MembershipActionType))) {\n                this.logger.error(\n                    \"tried adding another `SendDelayedEvent` actions even though we already have one in the Queue\\nActionQueueOnMemberUpdate:\",\n                    this.scheduler.actions,\n                );\n            } else {\n                // Only react to our own membership missing if we have not already scheduled sending a new membership DirectMembershipManagerAction.Join\n                this.scheduler.initiateJoin();\n            }\n        }\n        return Promise.resolve();\n    }\n\n    public async updateCallIntent(callIntent: RTCCallIntent): Promise<void> {\n        if (!this.activated || !this.ownMembership) {\n            throw Error(\"You cannot update your intent before joining the call\");\n        }\n        if (this.ownMembership.callIntent === callIntent) {\n            return; // No-op\n        }\n        this.callIntent = callIntent;\n        // Kick off a new membership event as a result.\n        await this.sendJoinEvent();\n    }\n\n    /**\n     * @throws if the client does not return user or device id.\n     * @param joinConfig\n     * @param room\n     * @param client\n     */\n    public constructor(\n        private readonly joinConfig: (SessionConfig & MembershipConfig) | undefined,\n        protected readonly room: Pick<Room, \"roomId\" | \"getVersion\">,\n        protected readonly client: MembershipManagerClient,\n        public readonly slotDescription: SlotDescription,\n        parentLogger?: Logger,\n    ) {\n        super();\n        this.logger = (parentLogger ?? rootLogger).getChild(`[MembershipManager]`);\n        const [userId, deviceId] = [this.client.getUserId(), this.client.getDeviceId()];\n        if (userId === null) throw Error(\"Missing userId in client\");\n        if (deviceId === null) throw Error(\"Missing deviceId in client\");\n        this.deviceId = deviceId;\n        // this needs to become a uuid so that consecutive join/leaves result in a key rotation.\n        // we keep it as a string for now for backwards compatibility.\n        this.memberId = this.makeMembershipStateKey(userId, deviceId);\n        this.state = MembershipManager.defaultState;\n        this.callIntent = joinConfig?.callIntent;\n        this.scheduler = new ActionScheduler((type): Promise<ActionUpdate> => {\n            if (this.oldStatus) {\n                // we put this at the beginning of the actions scheduler loop handle callback since it is a loop this\n                // is equivalent to running it at the end of the loop. (just after applying the status/action list changes)\n                // This order is required because this method needs to return the action updates.\n                this.logger.debug(\n                    `MembershipManager applied action changes. Status: ${this.oldStatus} -> ${this.status}`,\n                );\n                if (this.oldStatus !== this.status) {\n                    this.emit(MembershipManagerEvent.StatusChanged, this.oldStatus, this.status);\n                }\n            }\n            this.oldStatus = this.status;\n            this.logger.debug(`MembershipManager before processing action. status=${this.oldStatus}`);\n            return this.membershipLoopHandler(type);\n        }, this.logger);\n    }\n\n    private _ownMembership?: CallMembership;\n    public get ownMembership(): CallMembership | undefined {\n        return this._ownMembership;\n    }\n\n    // scheduler\n    private oldStatus?: Status;\n    private scheduler: ActionScheduler;\n\n    // MembershipManager mutable state.\n    private state: MembershipManagerState;\n    private static get defaultState(): MembershipManagerState {\n        return {\n            hasMemberStateEvent: false,\n            delayId: undefined,\n\n            startTime: 0,\n            rateLimitRetries: new Map(),\n            networkErrorRetries: new Map(),\n            expireUpdateIterations: 1,\n            probablyLeft: false,\n        };\n    }\n    // Membership Event static parameters:\n    protected deviceId: string;\n    protected memberId: string;\n    protected rtcTransport?: Transport;\n    /** @deprecated This will be removed in favor or rtcTransport becoming a list of actively used transports */\n    private fociPreferred?: Transport[];\n\n    // Config:\n    private delayedLeaveEventDelayMsOverride?: number;\n\n    private get networkErrorRetryMs(): number {\n        return this.joinConfig?.networkErrorRetryMs ?? 3_000;\n    }\n    private get membershipEventExpiryMs(): number {\n        return this.joinConfig?.membershipEventExpiryMs ?? DEFAULT_EXPIRE_DURATION;\n    }\n    private get membershipEventExpiryHeadroomMs(): number {\n        return this.joinConfig?.membershipEventExpiryHeadroomMs ?? 5_000;\n    }\n    private computeNextExpiryActionTs(iteration: number): number {\n        return (\n            this.state.startTime +\n            Math.min(this.membershipEventExpiryMs, MEMBERSHIP_STICKY_DURATION_MS) * iteration -\n            this.membershipEventExpiryHeadroomMs\n        );\n    }\n    protected get delayedLeaveEventDelayMs(): number {\n        return this.delayedLeaveEventDelayMsOverride ?? this.joinConfig?.delayedLeaveEventDelayMs ?? 8_000;\n    }\n    private get delayedLeaveEventRestartMs(): number {\n        return this.joinConfig?.delayedLeaveEventRestartMs ?? 5_000;\n    }\n    private get maximumRateLimitRetryCount(): number {\n        return this.joinConfig?.maximumRateLimitRetryCount ?? 10;\n    }\n    private get maximumNetworkErrorRetryCount(): number {\n        return this.joinConfig?.maximumNetworkErrorRetryCount ?? 10;\n    }\n    private get delayedLeaveEventRestartLocalTimeoutMs(): number {\n        return this.joinConfig?.delayedLeaveEventRestartLocalTimeoutMs ?? 2000;\n    }\n\n    // LOOP HANDLER:\n    private async membershipLoopHandler(type: MembershipActionType): Promise<ActionUpdate> {\n        switch (type) {\n            case MembershipActionType.SendDelayedEvent: {\n                // Before we start we check if we come from a state where we have a delay id.\n                if (!this.state.delayId) {\n                    return this.sendOrResendDelayedLeaveEvent(); // Normal case without any previous delayed id.\n                } else {\n                    // This can happen if someone else (or another client) removes our own membership event.\n                    // It will trigger `onRTCSessionMemberUpdate` queue `MembershipActionType.SendDelayedEvent`.\n                    // We might still have our delayed event from the previous participation and dependent on the server this might not\n                    // get removed automatically if the state changes. Hence, it would remove our membership unexpectedly shortly after the rejoin.\n                    //\n                    // In this block we will try to cancel this delayed event before setting up a new one.\n\n                    return this.cancelKnownDelayIdBeforeSendDelayedEvent(this.state.delayId);\n                }\n            }\n            case MembershipActionType.RestartDelayedEvent: {\n                if (!this.state.delayId) {\n                    // Delay id got reset. This action was used to check if the hs canceled the delayed event when the join state got sent.\n                    return createInsertActionUpdate(MembershipActionType.SendDelayedEvent);\n                }\n                return this.restartDelayedEvent(this.state.delayId);\n            }\n            case MembershipActionType.SendScheduledDelayedLeaveEvent: {\n                // We are already good\n                if (!this.state.hasMemberStateEvent) {\n                    return { replace: [] };\n                }\n                if (this.state.delayId) {\n                    return this.sendScheduledDelayedLeaveEventOrFallbackToSendLeaveEvent(this.state.delayId);\n                } else {\n                    return createInsertActionUpdate(MembershipActionType.SendLeaveEvent);\n                }\n            }\n            case MembershipActionType.SendJoinEvent: {\n                return this.sendJoinEvent();\n            }\n            case MembershipActionType.UpdateExpiry: {\n                return this.updateExpiryOnJoinedEvent();\n            }\n            case MembershipActionType.SendLeaveEvent: {\n                // We are good already\n                if (!this.state.hasMemberStateEvent) {\n                    return { replace: [] };\n                }\n                // This is only a fallback in case we do not have working delayed events support.\n                // first we should try to just send the scheduled leave event\n                return this.sendFallbackLeaveEvent();\n            }\n        }\n    }\n\n    // an abstraction to switch between sending state or a sticky event\n    protected clientSendDelayedDisconnectMembership: () => Promise<SendDelayedEventResponse> = () =>\n        this.client._unstable_sendDelayedStateEvent(\n            this.room.roomId,\n            { delay: this.delayedLeaveEventDelayMs },\n            EventType.GroupCallMemberPrefix,\n            {},\n            this.memberId,\n        );\n\n    // HANDLERS (used in the membershipLoopHandler)\n    private async sendOrResendDelayedLeaveEvent(): Promise<ActionUpdate> {\n        // We can reach this at the start of a call (where we do not yet have a membership: state.hasMemberStateEvent=false)\n        // or during a call if the state event canceled our delayed event or caused by an unexpected error that removed our delayed event.\n        // (Another client could have canceled it, the homeserver might have removed/lost it due to a restart, ...)\n        // In the `then` and `catch` block we treat both cases differently. \"if (this.state.hasMemberStateEvent) {} else {}\"\n        return await this.clientSendDelayedDisconnectMembership()\n            .then((response) => {\n                this.state.expectedServerDelayLeaveTs = Date.now() + this.delayedLeaveEventDelayMs;\n                this.setAndEmitProbablyLeft(false);\n                // On success we reset retries and set delayId.\n                this.resetRateLimitCounter(MembershipActionType.SendDelayedEvent);\n                this.state.delayId = response.delay_id;\n                if (this.state.hasMemberStateEvent) {\n                    // This action was scheduled because the previous delayed event was cancelled\n                    // due to lack of https://github.com/element-hq/synapse/pull/17810\n                    return createInsertActionUpdate(\n                        MembershipActionType.RestartDelayedEvent,\n                        this.delayedLeaveEventRestartMs,\n                    );\n                } else {\n                    // This action was scheduled because we are in the process of joining\n                    return createInsertActionUpdate(MembershipActionType.SendJoinEvent);\n                }\n            })\n            .catch((e) => {\n                const repeatActionType = MembershipActionType.SendDelayedEvent;\n                if (this.manageMaxDelayExceededSituation(e)) {\n                    return createInsertActionUpdate(repeatActionType);\n                }\n                const update = this.actionUpdateFromErrors(e, repeatActionType, \"_unstable_sendDelayedStateEvent\");\n                if (update) return update;\n\n                if (this.state.hasMemberStateEvent) {\n                    // This action was scheduled because the previous delayed event was cancelled\n                    // due to lack of https://github.com/element-hq/synapse/pull/17810\n\n                    // Don't do any other delayed event work if its not supported.\n                    if (this.isUnsupportedDelayedEndpoint(e)) return {};\n                    throw Error(\"Could not send delayed event, even though delayed events are supported. \" + e);\n                } else {\n                    // This action was scheduled because we are in the process of joining\n                    // log and fall through\n                    if (this.isUnsupportedDelayedEndpoint(e)) {\n                        this.logger.info(\"Not using delayed event because the endpoint is not supported\");\n                    } else {\n                        this.logger.info(\"Not using delayed event because: \" + e);\n                    }\n                    // On any other error we fall back to not using delayed events and send the join state event immediately\n                    return createInsertActionUpdate(MembershipActionType.SendJoinEvent);\n                }\n            });\n    }\n\n    private async cancelKnownDelayIdBeforeSendDelayedEvent(delayId: string): Promise<ActionUpdate> {\n        // Remove all running updates and restarts\n        return await this.client\n            ._unstable_cancelScheduledDelayedEvent(delayId)\n            .then(() => {\n                this.state.delayId = undefined;\n                this.resetRateLimitCounter(MembershipActionType.SendDelayedEvent);\n                return createReplaceActionUpdate(MembershipActionType.SendDelayedEvent);\n            })\n            .catch((e) => {\n                const repeatActionType = MembershipActionType.SendDelayedEvent;\n                const update = this.actionUpdateFromErrors(e, repeatActionType, \"cancelScheduledDelayedEvent\");\n                if (update) return update;\n\n                if (this.isNotFoundError(e)) {\n                    // If we get a M_NOT_FOUND we know that the delayed event got already removed.\n                    // This means we are good and can set it to undefined and run this again.\n                    this.state.delayId = undefined;\n                    return createReplaceActionUpdate(repeatActionType);\n                }\n                if (this.isUnsupportedDelayedEndpoint(e)) {\n                    return createReplaceActionUpdate(MembershipActionType.SendJoinEvent);\n                }\n                // We do not just ignore and log this error since we would also need to reset the delayId.\n\n                // This becomes an unrecoverable error case since something is significantly off if we don't hit any of the above cases\n                // when state.delayId !== undefined\n                // We do not just ignore and log this error since we would also need to reset the delayId.\n                // It is cleaner if we, the frontend, rejoins instead of resetting the delayId here and behaving like in the success case.\n                throw Error(\n                    \"We failed to cancel a delayed event where we already had a delay id with an error we cannot automatically handle\",\n                );\n            });\n    }\n\n    private setAndEmitProbablyLeft(probablyLeft: boolean): void {\n        if (this.state.probablyLeft === probablyLeft) {\n            return;\n        }\n        this.state.probablyLeft = probablyLeft;\n        this.emit(MembershipManagerEvent.ProbablyLeft, this.state.probablyLeft);\n    }\n\n    private async restartDelayedEvent(delayId: string): Promise<ActionUpdate> {\n        // Compute the duration until we expect the server to send the delayed leave event.\n        const durationUntilServerDelayedLeave = this.state.expectedServerDelayLeaveTs\n            ? this.state.expectedServerDelayLeaveTs - Date.now()\n            : undefined;\n        const abortPromise = new Promise((_, reject) => {\n            setTimeout(\n                () => {\n                    reject(new AbortError(\"Restart delayed event timed out before the HS responded\"));\n                },\n                // We abort immediately at the time where we expect the server to send the delayed leave event.\n                // At this point we want the catch block to run and set the `probablyLeft` state.\n                //\n                // While we are already in probablyLeft state, we use the unaltered delayedLeaveEventRestartLocalTimeoutMs.\n                durationUntilServerDelayedLeave !== undefined && !this.state.probablyLeft\n                    ? Math.min(this.delayedLeaveEventRestartLocalTimeoutMs, durationUntilServerDelayedLeave)\n                    : this.delayedLeaveEventRestartLocalTimeoutMs,\n            );\n        });\n\n        // The obvious choice here would be to use the `IRequestOpts` to set the timeout. Since this call might be forwarded\n        // to the widget driver this information would get lost. That is why we mimic the AbortError using the race.\n        return await Promise.race([this.client._unstable_restartScheduledDelayedEvent(delayId), abortPromise])\n            .then(() => {\n                // Whenever we successfully restart the delayed event we update the `state.expectedServerDelayLeaveTs`\n                // which stores the predicted timestamp at which the server will send the delayed leave event if there wont be any further\n                // successful restart requests.\n                this.state.expectedServerDelayLeaveTs = Date.now() + this.delayedLeaveEventDelayMs;\n                this.resetRateLimitCounter(MembershipActionType.RestartDelayedEvent);\n                this.setAndEmitProbablyLeft(false);\n                return createInsertActionUpdate(\n                    MembershipActionType.RestartDelayedEvent,\n                    this.delayedLeaveEventRestartMs,\n                );\n            })\n            .catch((e) => {\n                if (this.state.expectedServerDelayLeaveTs && this.state.expectedServerDelayLeaveTs <= Date.now()) {\n                    // Once we reach this point it's likely that the server is sending the delayed leave event so we emit `probablyLeft = true`.\n                    // It will emit `probablyLeft = false` once we notice about our leave through sync and successfully setup a new state event.\n                    this.setAndEmitProbablyLeft(true);\n                }\n                const repeatActionType = MembershipActionType.RestartDelayedEvent;\n                if (this.isNotFoundError(e)) {\n                    this.state.delayId = undefined;\n                    return createInsertActionUpdate(MembershipActionType.SendDelayedEvent);\n                }\n                // If the HS does not support delayed events we wont reschedule.\n                if (this.isUnsupportedDelayedEndpoint(e)) return {};\n\n                // TODO this also needs a test: get rate limit while checking id delayed event is scheduled\n                const update = this.actionUpdateFromErrors(e, repeatActionType, \"restartScheduledDelayedEvent\");\n                if (update) return update;\n\n                // In other error cases we have no idea what is happening\n                throw Error(\"Could not restart delayed event, even though delayed events are supported. \" + e);\n            });\n    }\n\n    private async sendScheduledDelayedLeaveEventOrFallbackToSendLeaveEvent(delayId: string): Promise<ActionUpdate> {\n        return await this.client\n            ._unstable_sendScheduledDelayedEvent(delayId)\n            .then(() => {\n                this.state.hasMemberStateEvent = false;\n                this.resetRateLimitCounter(MembershipActionType.SendScheduledDelayedLeaveEvent);\n\n                return { replace: [] };\n            })\n            .catch((e) => {\n                const repeatActionType = MembershipActionType.SendLeaveEvent;\n                if (this.isUnsupportedDelayedEndpoint(e)) return {};\n                if (this.isNotFoundError(e)) {\n                    this.state.delayId = undefined;\n                    return createInsertActionUpdate(repeatActionType);\n                }\n                const update = this.actionUpdateFromErrors(e, repeatActionType, \"sendScheduledDelayedEvent\");\n                if (update) return update;\n\n                // On any other error we fall back to SendLeaveEvent (this includes hard errors from rate limiting)\n                this.logger.warn(\n                    \"Encountered unexpected error during SendScheduledDelayedLeaveEvent. Falling back to SendLeaveEvent\",\n                    e,\n                );\n                return createInsertActionUpdate(repeatActionType);\n            });\n    }\n\n    protected clientSendMembership: (\n        myMembership: RtcMembershipData | SessionMembershipData | EmptyObject,\n    ) => Promise<ISendEventResponse> = (myMembership) => {\n        return this.client.sendStateEvent(\n            this.room.roomId,\n            EventType.GroupCallMemberPrefix,\n            myMembership as EmptyObject | SessionMembershipData,\n            this.memberId,\n        );\n    };\n\n    private async sendJoinEvent(): Promise<ActionUpdate> {\n        return await this.clientSendMembership(this.makeMyMembership(this.membershipEventExpiryMs))\n            .then(() => {\n                this.setAndEmitProbablyLeft(false);\n                this.state.startTime = Date.now();\n                // The next update should already use twice the membershipEventExpiryTimeout\n                this.state.expireUpdateIterations = 1;\n                this.state.hasMemberStateEvent = true;\n                this.resetRateLimitCounter(MembershipActionType.SendJoinEvent);\n                // An UpdateExpiry action might be left over from a previous join event.\n                // We can reach sendJoinEvent when the delayed leave event gets send by the HS.\n                // The branch where we might have a leftover UpdateExpiry action is:\n                // RestartDelayedEvent (cannot find it, server removed it)\n                // -> SendDelayedEvent (send new delayed event)\n                // -> SendJoinEvent (here with a still scheduled UpdateExpiry action)\n                const actionsWithoutUpdateExpiry = this.scheduler.actions.filter(\n                    (a) =>\n                        a.type !== MembershipActionType.UpdateExpiry && // A new UpdateExpiry action with an updated will be scheduled,\n                        a.type !== MembershipActionType.SendJoinEvent, // Manually remove the SendJoinEvent action,\n                );\n                return {\n                    replace: [\n                        ...actionsWithoutUpdateExpiry,\n                        // To check if the delayed event is still there or got removed by inserting the stateEvent, we need to restart it.\n                        { ts: Date.now(), type: MembershipActionType.RestartDelayedEvent },\n                        {\n                            ts: this.computeNextExpiryActionTs(this.state.expireUpdateIterations),\n                            type: MembershipActionType.UpdateExpiry,\n                        },\n                    ],\n                };\n            })\n            .catch((e) => {\n                const update = this.actionUpdateFromErrors(e, MembershipActionType.SendJoinEvent, \"sendStateEvent\");\n                if (update) return update;\n                throw e;\n            });\n    }\n\n    private async updateExpiryOnJoinedEvent(): Promise<ActionUpdate> {\n        const nextExpireUpdateIteration = this.state.expireUpdateIterations + 1;\n        return await this.clientSendMembership(\n            this.makeMyMembership(this.membershipEventExpiryMs * nextExpireUpdateIteration),\n        )\n            .then(() => {\n                // Success, we reset retries and schedule update.\n                this.resetRateLimitCounter(MembershipActionType.UpdateExpiry);\n                this.state.expireUpdateIterations = nextExpireUpdateIteration;\n                return {\n                    insert: [\n                        {\n                            ts: this.computeNextExpiryActionTs(nextExpireUpdateIteration),\n                            type: MembershipActionType.UpdateExpiry,\n                        },\n                    ],\n                };\n            })\n            .catch((e) => {\n                const update = this.actionUpdateFromErrors(e, MembershipActionType.UpdateExpiry, \"sendStateEvent\");\n                if (update) return update;\n\n                throw e;\n            });\n    }\n    private async sendFallbackLeaveEvent(): Promise<ActionUpdate> {\n        return await this.clientSendMembership({})\n            .then(() => {\n                this.resetRateLimitCounter(MembershipActionType.SendLeaveEvent);\n                this.state.hasMemberStateEvent = false;\n                return { replace: [] };\n            })\n            .catch((e) => {\n                const update = this.actionUpdateFromErrors(e, MembershipActionType.SendLeaveEvent, \"sendStateEvent\");\n                if (update) return update;\n                throw e;\n            });\n    }\n\n    // HELPERS\n    private makeMembershipStateKey(localUserId: string, localDeviceId: string): string {\n        const stateKey = `${localUserId}_${localDeviceId}_${this.slotDescription.application}${this.slotDescription.id}`;\n        if (/^org\\.matrix\\.msc(3757|3779)\\b/.exec(this.room.getVersion())) {\n            return stateKey;\n        } else {\n            return `_${stateKey}`;\n        }\n    }\n\n    /**\n     * Constructs our own membership\n     */\n    protected makeMyMembership(expires: number): SessionMembershipData | RtcMembershipData {\n        const ownMembership = this.ownMembership;\n\n        const focusObjects =\n            this.rtcTransport === undefined\n                ? {\n                      focus_active: { type: \"livekit\", focus_selection: \"oldest_membership\" } as const,\n                      foci_preferred: this.fociPreferred ?? [],\n                  }\n                : {\n                      focus_active: { type: \"livekit\", focus_selection: \"multi_sfu\" } as const,\n                      foci_preferred: [this.rtcTransport, ...(this.fociPreferred ?? [])],\n                  };\n        return {\n            \"application\": this.slotDescription.application,\n            \"call_id\": this.slotDescription.id,\n            \"scope\": \"m.room\",\n            \"device_id\": this.deviceId,\n            expires,\n            \"m.call.intent\": this.callIntent,\n            ...focusObjects,\n            ...(ownMembership !== undefined ? { created_ts: ownMembership.createdTs() } : undefined),\n        };\n    }\n\n    // Error checks and handlers\n\n    /**\n     * Check if its a NOT_FOUND error\n     * @param error the error causing this handler check/execution\n     * @returns true if its a not found error\n     */\n    private isNotFoundError(error: unknown): boolean {\n        return error instanceof MatrixError && error.errcode === \"M_NOT_FOUND\";\n    }\n\n    /**\n     * Check if this is a DelayExceeded timeout and update the TimeoutOverride for the next try\n     * @param error the error causing this handler check/execution\n     * @returns true if its a delay exceeded error and we updated the local TimeoutOverride\n     */\n    private manageMaxDelayExceededSituation(error: unknown): boolean {\n        if (\n            error instanceof MatrixError &&\n            error.errcode === \"M_UNKNOWN\" &&\n            error.data[\"org.matrix.msc4140.errcode\"] === \"M_MAX_DELAY_EXCEEDED\"\n        ) {\n            const maxDelayAllowed = error.data[\"org.matrix.msc4140.max_delay\"];\n            if (typeof maxDelayAllowed === \"number\" && this.delayedLeaveEventDelayMs > maxDelayAllowed) {\n                this.delayedLeaveEventDelayMsOverride = maxDelayAllowed;\n            }\n            this.logger.warn(\"Retry sending delayed disconnection event due to server timeout limitations:\", error);\n            return true;\n        }\n        return false;\n    }\n\n    protected actionUpdateFromErrors(\n        error: unknown,\n        type: MembershipActionType,\n        method: string,\n    ): ActionUpdate | undefined {\n        const updateLimit = this.actionUpdateFromRateLimitError(error, method, type);\n        if (updateLimit) return updateLimit;\n        const updateNetwork = this.actionUpdateFromNetworkErrorRetry(error, type);\n        if (updateNetwork) return updateNetwork;\n    }\n    /**\n     * Check if we have a rate limit error and schedule the same action again if we dont exceed the rate limit retry count yet.\n     * @param error the error causing this handler check/execution\n     * @param method the method used for the throw message\n     * @param type which MembershipActionType we reschedule because of a rate limit.\n     * @throws If it is a rate limit error and the retry count got exceeded\n     * @returns Returns true if we handled the error by rescheduling the correct next action.\n     * Returns false if it is not a network error.\n     */\n    private actionUpdateFromRateLimitError(\n        error: unknown,\n        method: string,\n        type: MembershipActionType,\n    ): ActionUpdate | undefined {\n        // \"Is rate limit\"-boundary\n        if (!((error instanceof HTTPError || error instanceof MatrixError) && error.isRateLimitError())) {\n            return undefined;\n        }\n\n        // retry boundary\n        const rateLimitRetries = this.state.rateLimitRetries.get(type) ?? 0;\n        if (rateLimitRetries < this.maximumRateLimitRetryCount) {\n            let resendDelay: number;\n            const defaultMs = 5000;\n            try {\n                resendDelay = error.getRetryAfterMs() ?? defaultMs;\n                this.logger.info(`Rate limited by server, retrying in ${resendDelay}ms`);\n            } catch (e) {\n                this.logger.warn(\n                    `Error while retrieving a rate-limit retry delay, retrying after default delay of ${defaultMs}`,\n                    e,\n                );\n                resendDelay = defaultMs;\n            }\n            this.state.rateLimitRetries.set(type, rateLimitRetries + 1);\n            return createInsertActionUpdate(type, resendDelay);\n        }\n\n        throw Error(\"Exceeded maximum retries for \" + type + \" attempts (client.\" + method + \")\", { cause: error });\n    }\n\n    /**\n     * FIXME Don't Check the error and retry the same MembershipAction again in the configured time and for the configured retry count.\n     * @param error the error causing this handler check/execution\n     * @param type the action type that we need to repeat because of the error\n     * @throws If it is a network error and the retry count got exceeded\n     * @returns\n     * Returns true if we handled the error by rescheduling the correct next action.\n     * Returns false if it is not a network error.\n     */\n    private actionUpdateFromNetworkErrorRetry(error: unknown, type: MembershipActionType): ActionUpdate | undefined {\n        // \"Is a network error\"-boundary\n        const retries = this.state.networkErrorRetries.get(type) ?? 0;\n\n        // Strings for error logging\n        const retryDurationString = this.networkErrorRetryMs / 1000 + \"s\";\n        const retryCounterString = \"(\" + retries + \"/\" + this.maximumNetworkErrorRetryCount + \")\";\n\n        // Variables for scheduling the new event\n        let retryDuration = this.networkErrorRetryMs;\n\n        if (error instanceof Error && error.name === \"AbortError\") {\n            // We do not wait for the timeout on local timeouts.\n            retryDuration = 0;\n            this.logger.warn(\n                \"Network local timeout error while sending event, immediate retry (\" + retryCounterString + \")\",\n                error,\n            );\n        } else if (error instanceof Error && error.message.includes(\"updating delayed event\")) {\n            // TODO: We do not want error message matching here but instead the error should be a typed HTTPError\n            // and be handled below automatically (the same as in the SPA case).\n            //\n            // The error originates because of https://github.com/matrix-org/matrix-widget-api/blob/5d81d4a26ff69e4bd3ddc79a884c9527999fb2f4/src/ClientWidgetApi.ts#L698-L701\n            // uses `e` instance of HttpError (and not MatrixError)\n            // The element web widget driver (only checks for MatrixError) is then failing to process (`processError`) it as a typed error: https://github.com/element-hq/element-web/blob/471712cbf06a067e5499bd5d2d7a75f693d9a12d/src/stores/widgets/StopGapWidgetDriver.ts#L711-L715\n            // So it will not call: `error.asWidgetApiErrorData()` which is also missing for `HttpError`\n            //\n            // A proper fix would be to either find a place to convert the `HttpError` into a `MatrixError` and the `processError`\n            // method to handle it as expected or to adjust `processError` to also process `HttpError`'s.\n            this.logger.warn(\n                \"delayed event update timeout error, retrying in \" + retryDurationString + \" \" + retryCounterString,\n                error,\n            );\n        } else if (error instanceof ConnectionError) {\n            this.logger.warn(\n                \"Network connection error while sending event, retrying in \" +\n                    retryDurationString +\n                    \" \" +\n                    retryCounterString,\n                error,\n            );\n        } else if (\n            (error instanceof HTTPError || error instanceof MatrixError) &&\n            typeof error.httpStatus === \"number\" &&\n            error.httpStatus >= 500 &&\n            error.httpStatus < 600\n        ) {\n            this.logger.warn(\n                \"Server error while sending event, retrying in \" + retryDurationString + \" \" + retryCounterString,\n                error,\n            );\n        } else {\n            return undefined;\n        }\n\n        // retry boundary\n        if (retries < this.maximumNetworkErrorRetryCount) {\n            this.state.networkErrorRetries.set(type, retries + 1);\n            return createInsertActionUpdate(type, retryDuration);\n        }\n\n        // Failure\n        throw Error(\n            \"Reached maximum (\" + this.maximumNetworkErrorRetryCount + \") retries cause by: \" + (error as Error),\n        );\n    }\n\n    /**\n     * Check if its an UnsupportedDelayedEventsEndpointError and which implies that we cannot do any delayed event logic\n     * @param error The error to check\n     * @returns true it its an UnsupportedDelayedEventsEndpointError\n     */\n    private isUnsupportedDelayedEndpoint(error: unknown): boolean {\n        return error instanceof UnsupportedDelayedEventsEndpointError;\n    }\n\n    private resetRateLimitCounter(type: MembershipActionType): void {\n        this.state.rateLimitRetries.set(type, 0);\n        this.state.networkErrorRetries.set(type, 0);\n    }\n\n    public get status(): Status {\n        const actions = this.scheduler.actions;\n        if (actions.length === 1) {\n            const { type } = actions[0];\n            switch (type) {\n                case MembershipActionType.SendDelayedEvent:\n                case MembershipActionType.SendJoinEvent:\n                    return Status.Connecting;\n                case MembershipActionType.UpdateExpiry: // where no delayed events\n                    return Status.Connected;\n                case MembershipActionType.SendScheduledDelayedLeaveEvent:\n                case MembershipActionType.SendLeaveEvent:\n                    return Status.Disconnecting;\n                default:\n                // pass through as not expected\n            }\n        } else if (actions.length === 2) {\n            const types = actions.map((a) => a.type);\n            // normal state for connected with delayed events\n            if (\n                (types.includes(MembershipActionType.RestartDelayedEvent) ||\n                    (types.includes(MembershipActionType.SendDelayedEvent) && this.state.hasMemberStateEvent)) &&\n                types.includes(MembershipActionType.UpdateExpiry)\n            ) {\n                return Status.Connected;\n            }\n        } else if (actions.length === 3) {\n            const types = actions.map((a) => a.type);\n            // It is a correct connected state if we already schedule the next Restart but have not yet cleaned up\n            // the current restart.\n            if (\n                types.filter((t) => t === MembershipActionType.RestartDelayedEvent).length === 2 &&\n                types.includes(MembershipActionType.UpdateExpiry)\n            ) {\n                return Status.Connected;\n            }\n        }\n\n        if (!this.scheduler.running) {\n            return Status.Disconnected;\n        }\n\n        this.logger.error(\"MembershipManager has an unknown state. Actions: \", actions);\n        return Status.Unknown;\n    }\n\n    public get probablyLeft(): boolean {\n        return this.state.probablyLeft;\n    }\n}\n\n/**\n * Implementation of the Membership manager that uses sticky events\n * rather than state events.\n */\nexport class StickyEventMembershipManager extends MembershipManager {\n    public constructor(\n        joinConfig: (SessionConfig & MembershipConfig) | undefined,\n        room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"getVersion\">,\n        private readonly clientWithSticky: MembershipManagerClient &\n            Pick<MatrixClient, \"_unstable_sendStickyEvent\" | \"_unstable_sendStickyDelayedEvent\">,\n        sessionDescription: SlotDescription,\n        parentLogger?: Logger,\n    ) {\n        super(joinConfig, room, clientWithSticky, sessionDescription, parentLogger);\n    }\n\n    protected clientSendDelayedDisconnectMembership: () => Promise<SendDelayedEventResponse> = () =>\n        this.clientWithSticky._unstable_sendStickyDelayedEvent(\n            this.room.roomId,\n            MEMBERSHIP_STICKY_DURATION_MS,\n            { delay: this.delayedLeaveEventDelayMs },\n            null,\n            EventType.RTCMembership,\n            { msc4354_sticky_key: this.memberId },\n        );\n\n    protected clientSendMembership: (\n        myMembership: RtcMembershipData | SessionMembershipData | EmptyObject,\n    ) => Promise<ISendEventResponse> = (myMembership) => {\n        return this.clientWithSticky._unstable_sendStickyEvent(\n            this.room.roomId,\n            MEMBERSHIP_STICKY_DURATION_MS,\n            null,\n            EventType.RTCMembership,\n            { ...myMembership, msc4354_sticky_key: this.memberId },\n        );\n    };\n\n    private static nameMap = new Map([\n        [\"sendStateEvent\", \"_unstable_sendStickyEvent\"],\n        [\"sendDelayedStateEvent\", \"_unstable_sendStickyDelayedEvent\"],\n    ]);\n    protected actionUpdateFromErrors(e: unknown, t: MembershipActionType, m: string): ActionUpdate | undefined {\n        return super.actionUpdateFromErrors(e, t, StickyEventMembershipManager.nameMap.get(m) ?? \"unknown\");\n    }\n\n    protected makeMyMembership(expires: number): SessionMembershipData | RtcMembershipData {\n        const ownMembership = this.ownMembership;\n\n        const relationObject = ownMembership?.eventId\n            ? { \"m.relation\": { rel_type: RelationType.Reference, event_id: ownMembership?.eventId } }\n            : {};\n        return {\n            application: {\n                type: this.slotDescription.application,\n                ...(this.callIntent ? { \"m.call.intent\": this.callIntent } : {}),\n            },\n            slot_id: slotDescriptionToId(this.slotDescription),\n            rtc_transports: this.rtcTransport ? [this.rtcTransport] : [],\n            member: { device_id: this.deviceId, user_id: this.client.getUserId()!, id: this.memberId },\n            versions: [],\n            ...relationObject,\n        };\n    }\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IEncryptionManager } from \"./EncryptionManager.ts\";\nimport { type EncryptionConfig } from \"./MatrixRTCSession.ts\";\nimport { type CallMembership } from \"./CallMembership.ts\";\nimport { decodeBase64, encodeBase64 } from \"../base64.ts\";\nimport { type IKeyTransport, type KeyTransportEventListener, KeyTransportEvents } from \"./IKeyTransport.ts\";\nimport { type Logger } from \"../logger.ts\";\nimport { sleep } from \"../utils.ts\";\nimport type {\n    InboundEncryptionSession,\n    OutboundEncryptionSession,\n    ParticipantDeviceInfo,\n    ParticipantId,\n    Statistics,\n} from \"./types.ts\";\nimport { getParticipantId, OutdatedKeyFilter } from \"./utils.ts\";\n\n/**\n * RTCEncryptionManager is used to manage the encryption keys for a call.\n *\n * It is responsible for distributing the keys to the other participants and rotating the keys if needed.\n *\n * This manager when used with to-device transport will share the existing key only to new joiners, and rotate\n * if there is a leaver.\n *\n * XXX In the future we want to distribute a ratcheted key not the current one for new joiners.\n */\nexport class RTCEncryptionManager implements IEncryptionManager {\n    // This is a stop-gap solution for now. The preferred way to handle this case would be instead\n    // to create a NoOpEncryptionManager that does nothing and use it for the session.\n    // This will be done when removing the legacy EncryptionManager.\n    private manageMediaKeys = false;\n\n    /**\n     * Store the key rings for each participant.\n     * The encryption manager stores the keys because the application layer might not be ready yet to handle the keys.\n     * The keys are stored and can be retrieved later when the application layer is ready {@link RTCEncryptionManager#getEncryptionKeys}.\n     */\n    private participantKeyRings = new Map<ParticipantId, Array<{ key: Uint8Array; keyIndex: number }>>();\n\n    // The current per-sender media key for this device\n    private outboundSession: OutboundEncryptionSession | null = null;\n\n    /**\n     * Ensures that there is only one distribute operation at a time for that call.\n     */\n    private currentKeyDistributionPromise: Promise<void> | null = null;\n\n    /**\n     * The time to wait before using the outbound session after it has been distributed.\n     * This is to ensure that the key is delivered to all participants before it is used.\n     * When creating the first key, this is set to 0 so that the key can be used immediately.\n     */\n    private useKeyDelay = 5000;\n\n    /**\n     * We want to avoid rolling out a new outbound key when the previous one was created less than `keyRotationGracePeriodMs` milliseconds ago.\n     * This is to avoid expensive key rotations when users quickly join the call in a row.\n     *\n     * This must be higher than `useKeyDelay` to have an effect.\n     * If it is lower, the current key will always be older than the grace period.\n     * @private\n     */\n    private keyRotationGracePeriodMs = 10_000;\n\n    /**\n     * If a new key distribution is being requested while one is going on, we will set this flag to true.\n     * This will ensure that a new round is started after the current one.\n     * @private\n     */\n    private needToEnsureKeyAgain = false;\n\n    /**\n     * There is a possibility that keys arrive in the wrong order.\n     * For example, after a quick join/leave/join, there will be 2 keys of index 0 distributed, and\n     * if they are received in the wrong order, the stream won't be decryptable.\n     * For that reason we keep a small buffer of keys for a limited time to disambiguate.\n     * @private\n     */\n    private keyBuffer = new OutdatedKeyFilter();\n\n    private logger: Logger | undefined = undefined;\n\n    public constructor(\n        private userId: string,\n        private deviceId: string,\n        private getMemberships: () => CallMembership[],\n        private transport: IKeyTransport,\n        private statistics: Statistics,\n        // Callback to notify the media layer of new keys\n        private onEncryptionKeysChanged: (\n            keyBin: Uint8Array,\n            encryptionKeyIndex: number,\n            participantId: ParticipantId,\n        ) => void,\n        parentLogger?: Logger,\n    ) {\n        this.logger = parentLogger?.getChild(`[EncryptionManager]`);\n    }\n\n    public getEncryptionKeys(): ReadonlyMap<ParticipantId, ReadonlyArray<{ key: Uint8Array; keyIndex: number }>> {\n        return new Map(this.participantKeyRings);\n    }\n\n    private addKeyToParticipant(key: Uint8Array, keyIndex: number, participantId: ParticipantId): void {\n        if (!this.participantKeyRings.has(participantId)) {\n            this.participantKeyRings.set(participantId, []);\n        }\n        this.participantKeyRings.get(participantId)!.push({ key, keyIndex });\n        this.onEncryptionKeysChanged(key, keyIndex, participantId);\n    }\n\n    public join(joinConfig: EncryptionConfig | undefined): void {\n        this.manageMediaKeys = joinConfig?.manageMediaKeys ?? true; // default to true\n\n        this.logger?.info(`Joining room`);\n        this.useKeyDelay = joinConfig?.useKeyDelay ?? 1000;\n        this.keyRotationGracePeriodMs = joinConfig?.keyRotationGracePeriodMs ?? 10_000;\n        this.transport.on(KeyTransportEvents.ReceivedKeys, this.onNewKeyReceived);\n\n        this.transport.start();\n    }\n\n    public leave(): void {\n        this.transport.off(KeyTransportEvents.ReceivedKeys, this.onNewKeyReceived);\n        this.transport.stop();\n        this.participantKeyRings.clear();\n    }\n\n    /**\n     * Will ensure that a new key is distributed and used to encrypt our media.\n     * If there is already a key distribution in progress, it will schedule a new distribution round just after the current one is completed.\n     * If this function is called repeatedly while a distribution is in progress,\n     * the calls will be coalesced to a single new distribution (that will start just after the current one has completed).\n     */\n    private ensureKeyDistribution(): void {\n        // `manageMediaKeys` is a stop-gap solution for now. The preferred way to handle this case would be instead\n        // to create a NoOpEncryptionManager that does nothing and use it for the session.\n        // This will be done when removing the legacy EncryptionManager.\n        if (!this.manageMediaKeys) return;\n        if (this.currentKeyDistributionPromise == null) {\n            this.logger?.debug(`No active rollout, start a new one`);\n            // start a rollout\n            this.currentKeyDistributionPromise = this.rolloutOutboundKey().then(() => {\n                this.logger?.debug(`Rollout completed`);\n                this.currentKeyDistributionPromise = null;\n                if (this.needToEnsureKeyAgain) {\n                    this.logger?.debug(`New Rollout needed`);\n                    this.needToEnsureKeyAgain = false;\n                    // rollout a new one\n                    this.ensureKeyDistribution();\n                }\n            });\n        } else {\n            // There is a rollout in progress, but a key rotation is requested (could be caused by a membership change)\n            // Remember that a new rotation is needed after the current one.\n            this.logger?.debug(`Rollout in progress, a new rollout will be started after the current one`);\n            this.needToEnsureKeyAgain = true;\n        }\n    }\n\n    public onNewKeyReceived: KeyTransportEventListener = (userId, deviceId, keyBase64Encoded, index, timestamp) => {\n        // `manageMediaKeys` is a stop-gap solution for now. The preferred way to handle this case would be instead\n        // to create a NoOpEncryptionManager that does nothing and use it for the session.\n        // This will be done when removing the legacy EncryptionManager.\n        if (!this.manageMediaKeys) {\n            this.logger?.warn(\n                `Received key over transport ${userId}:${deviceId} at index ${index} but media keys are disabled`,\n            );\n            return;\n        }\n        this.logger?.debug(`Received key over transport ${userId}:${deviceId} at index ${index}`);\n\n        // We received a new key, notify the video layer of this new key so that it can decrypt the frames properly.\n        const participantId = getParticipantId(userId, deviceId);\n        const keyBin = decodeBase64(keyBase64Encoded);\n        const candidateInboundSession: InboundEncryptionSession = {\n            key: keyBin,\n            participantId,\n            keyIndex: index,\n            creationTS: timestamp,\n        };\n\n        const outdated = this.keyBuffer.isOutdated(participantId, candidateInboundSession);\n        if (!outdated) {\n            this.addKeyToParticipant(\n                candidateInboundSession.key,\n                candidateInboundSession.keyIndex,\n                candidateInboundSession.participantId,\n            );\n            this.statistics.counters.roomEventEncryptionKeysReceived += 1;\n        } else {\n            this.logger?.info(`Received an out of order key for ${userId}:${deviceId}, dropping it`);\n        }\n    };\n\n    /**\n     * Called when the membership of the call changes.\n     * This encryption manager is very basic, it will rotate the key everytime this is called.\n     * @param oldMemberships - This parameter is not used here, but it is kept for compatibility with the interface.\n     */\n    public onMembershipsUpdate(oldMemberships: CallMembership[] = []): void {\n        this.logger?.trace(`onMembershipsUpdate`);\n\n        // Ensure the key is distributed. This will be no-op if the key is already being distributed to everyone.\n        // If there is an ongoing distribution, it will be completed before a new one is started.\n        this.ensureKeyDistribution();\n    }\n\n    private async rolloutOutboundKey(): Promise<void> {\n        const isFirstKey = this.outboundSession == null;\n        if (isFirstKey) {\n            // create the first key\n            this.outboundSession = {\n                key: this.generateRandomKey(),\n                creationTS: Date.now(),\n                sharedWith: [],\n                keyId: 0,\n            };\n            this.addKeyToParticipant(\n                this.outboundSession.key,\n                this.outboundSession.keyId,\n                getParticipantId(this.userId, this.deviceId),\n            );\n        }\n        // get current memberships\n        const toShareWith: ParticipantDeviceInfo[] = this.getMemberships()\n            .filter((membership) => {\n                return membership.sender != undefined;\n            })\n            .map((membership) => {\n                return {\n                    userId: membership.sender!,\n                    deviceId: membership.deviceId,\n                    membershipTs: membership.createdTs(),\n                };\n            });\n\n        let alreadySharedWith = this.outboundSession?.sharedWith ?? [];\n\n        // Some users might have rotate their membership event (formally called fingerprint) meaning they might have\n        // clear their key. Reset the `alreadySharedWith` flag for them.\n        alreadySharedWith = alreadySharedWith.filter(\n            (x) =>\n                // If there was a member with same userId and deviceId but different membershipTs, we need to clear it\n                !toShareWith.some(\n                    (o) => x.userId == o.userId && x.deviceId == o.deviceId && x.membershipTs != o.membershipTs,\n                ),\n        );\n\n        const anyLeft = alreadySharedWith.filter(\n            (x) =>\n                !toShareWith.some(\n                    (o) => x.userId == o.userId && x.deviceId == o.deviceId && x.membershipTs == o.membershipTs,\n                ),\n        );\n        const anyJoined = toShareWith.filter(\n            (x) =>\n                !alreadySharedWith.some(\n                    (o) => x.userId == o.userId && x.deviceId == o.deviceId && x.membershipTs == o.membershipTs,\n                ),\n        );\n\n        let toDistributeTo: ParticipantDeviceInfo[] = [];\n        let outboundKey: OutboundEncryptionSession;\n        let hasKeyChanged = false;\n        if (anyLeft.length > 0) {\n            // We need to rotate the key\n            const newOutboundKey = this.createNewOutboundSession();\n            hasKeyChanged = true;\n            toDistributeTo = toShareWith;\n            outboundKey = newOutboundKey;\n        } else if (anyJoined.length > 0) {\n            const now = Date.now();\n            const keyAge = now - this.outboundSession!.creationTS;\n            // If the current key is recently created (less than `keyRotationGracePeriodMs`), we can keep it and just distribute it to the new joiners.\n            if (keyAge < this.keyRotationGracePeriodMs) {\n                // keep the same key\n                // XXX In the future we want to distribute a ratcheted key, not the current one\n                this.logger?.debug(`New joiners detected, but the key is recent enough (age:${keyAge}), keeping it`);\n                toDistributeTo = anyJoined;\n                outboundKey = this.outboundSession!;\n            } else {\n                // We need to rotate the key\n                this.logger?.debug(`New joiners detected, rotating the key`);\n                const newOutboundKey = this.createNewOutboundSession();\n                hasKeyChanged = true;\n                toDistributeTo = toShareWith;\n                outboundKey = newOutboundKey;\n            }\n        } else {\n            // no changes\n            return;\n        }\n\n        try {\n            this.logger?.trace(`Sending key...`);\n            await this.transport.sendKey(encodeBase64(outboundKey.key), outboundKey.keyId, toDistributeTo);\n            this.statistics.counters.roomEventEncryptionKeysSent += 1;\n            outboundKey.sharedWith.push(...toDistributeTo);\n            this.logger?.trace(\n                `key index:${outboundKey.keyId} sent to ${outboundKey.sharedWith.map((m) => `${m.userId}:${m.deviceId}`).join(\",\")}`,\n            );\n            if (hasKeyChanged) {\n                // Delay a bit before using this key\n                // It is recommended not to start using a key immediately but instead wait for a short time to make sure it is delivered.\n                this.logger?.trace(`Delay Rollout for key:${outboundKey.keyId}...`);\n                await sleep(this.useKeyDelay);\n                this.logger?.trace(`...Delayed rollout of index:${outboundKey.keyId} `);\n                this.addKeyToParticipant(\n                    outboundKey.key,\n                    outboundKey.keyId,\n                    getParticipantId(this.userId, this.deviceId),\n                );\n            }\n        } catch (err) {\n            this.logger?.error(`Failed to rollout key`, err);\n        }\n    }\n\n    private createNewOutboundSession(): OutboundEncryptionSession {\n        const newOutboundKey: OutboundEncryptionSession = {\n            key: this.generateRandomKey(),\n            creationTS: Date.now(),\n            sharedWith: [],\n            keyId: this.nextKeyIndex(),\n        };\n\n        this.logger?.info(`creating new outbound key index:${newOutboundKey.keyId}`);\n        // Set this new key as the current one\n        this.outboundSession = newOutboundKey;\n        return newOutboundKey;\n    }\n\n    private nextKeyIndex(): number {\n        if (this.outboundSession) {\n            return (this.outboundSession!.keyId + 1) % 256;\n        }\n        return 0;\n    }\n\n    private generateRandomKey(): Uint8Array {\n        const key = new Uint8Array(16);\n        globalThis.crypto.getRandomValues(key);\n        return key;\n    }\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type { MatrixClient } from \"../client.ts\";\nimport { type EncryptionKeysEventContent, type ParticipantDeviceInfo, type Statistics } from \"./types.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { type MatrixError } from \"../http-api/errors.ts\";\nimport { logger as rootLogger, type Logger } from \"../logger.ts\";\nimport { KeyTransportEvents, type KeyTransportEventsHandlerMap, type IKeyTransport } from \"./IKeyTransport.ts\";\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { type Room, RoomEvent } from \"../models/room.ts\";\n\nexport class RoomKeyTransport\n    extends TypedEventEmitter<KeyTransportEvents, KeyTransportEventsHandlerMap>\n    implements IKeyTransport\n{\n    private logger: Logger = rootLogger;\n    public setParentLogger(parentLogger: Logger): void {\n        this.logger = parentLogger.getChild(`[RoomKeyTransport]`);\n    }\n    public constructor(\n        private room: Pick<Room, \"on\" | \"off\" | \"roomId\">,\n        private client: Pick<\n            MatrixClient,\n            \"sendEvent\" | \"getDeviceId\" | \"getUserId\" | \"cancelPendingEvent\" | \"decryptEventIfNeeded\"\n        >,\n        private statistics: Statistics,\n        parentLogger?: Logger,\n    ) {\n        super();\n        this.setParentLogger(parentLogger ?? rootLogger);\n    }\n    public start(): void {\n        this.room.on(RoomEvent.Timeline, (ev) => void this.consumeCallEncryptionEvent(ev));\n    }\n    public stop(): void {\n        this.room.off(RoomEvent.Timeline, (ev) => void this.consumeCallEncryptionEvent(ev));\n    }\n\n    private async consumeCallEncryptionEvent(event: MatrixEvent, isRetry = false): Promise<void> {\n        await this.client.decryptEventIfNeeded(event);\n\n        if (event.isDecryptionFailure()) {\n            if (!isRetry) {\n                this.logger.warn(\n                    `Decryption failed for event ${event.getId()}: ${event.decryptionFailureReason} will retry once only`,\n                );\n                // retry after 1 second. After this we give up.\n                setTimeout(() => void this.consumeCallEncryptionEvent(event, true), 1000);\n            } else {\n                this.logger.warn(`Decryption failed for event ${event.getId()}: ${event.decryptionFailureReason}`);\n            }\n            return;\n        } else if (isRetry) {\n            this.logger.info(`Decryption succeeded for event ${event.getId()} after retry`);\n        }\n\n        if (event.getType() !== EventType.CallEncryptionKeysPrefix) return Promise.resolve();\n\n        if (!this.room) {\n            this.logger.error(`Got room state event for unknown room ${event.getRoomId()}!`);\n            return Promise.resolve();\n        }\n\n        this.onEncryptionEvent(event);\n    }\n\n    /** implements {@link IKeyTransport#sendKey} */\n    public async sendKey(keyBase64Encoded: string, index: number, members: ParticipantDeviceInfo[]): Promise<void> {\n        // members not used in room transports as the keys are sent to all room members\n        const content: EncryptionKeysEventContent = {\n            keys: [\n                {\n                    index: index,\n                    key: keyBase64Encoded,\n                },\n            ],\n            device_id: this.client.getDeviceId()!,\n            call_id: \"\",\n            sent_ts: Date.now(),\n        };\n\n        try {\n            await this.client.sendEvent(this.room.roomId, EventType.CallEncryptionKeysPrefix, content);\n        } catch (error) {\n            this.logger.error(\"Failed to send call encryption keys\", error);\n            const matrixError = error as MatrixError;\n            if (matrixError.event) {\n                // cancel the pending event: we'll just generate a new one with our latest\n                // keys when we resend\n                this.client.cancelPendingEvent(matrixError.event);\n            }\n            throw error;\n        }\n    }\n\n    public onEncryptionEvent(event: MatrixEvent): void {\n        const userId = event.getSender();\n        const content = event.getContent<EncryptionKeysEventContent>();\n\n        const deviceId = content[\"device_id\"];\n        const callId = content[\"call_id\"];\n\n        if (!userId) {\n            this.logger.warn(`Received m.call.encryption_keys with no userId: callId=${callId}`);\n            return;\n        }\n\n        // We currently only handle callId = \"\" (which is the default for room scoped calls)\n        if (callId !== \"\") {\n            this.logger.warn(\n                `Received m.call.encryption_keys with unsupported callId: userId=${userId}, deviceId=${deviceId}, callId=${callId}`,\n            );\n            return;\n        }\n\n        if (!Array.isArray(content.keys)) {\n            this.logger.warn(`Received m.call.encryption_keys where keys wasn't an array: callId=${callId}`);\n            return;\n        }\n\n        if (userId === this.client.getUserId() && deviceId === this.client.getDeviceId()) {\n            // We store our own sender key in the same set along with keys from others, so it's\n            // important we don't allow our own keys to be set by one of these events (apart from\n            // the fact that we don't need it anyway because we already know our own keys).\n            this.logger.info(\"Ignoring our own keys event\");\n            return;\n        }\n\n        this.statistics.counters.roomEventEncryptionKeysReceived += 1;\n        const age = Date.now() - (typeof content.sent_ts === \"number\" ? content.sent_ts : event.getTs());\n        this.statistics.totals.roomEventEncryptionKeysReceivedTotalAge += age;\n\n        for (const key of content.keys) {\n            if (!key) {\n                this.logger.info(\"Ignoring false-y key in keys event\");\n                continue;\n            }\n\n            const encryptionKey = key.key;\n            const encryptionKeyIndex = key.index;\n\n            if (\n                !encryptionKey ||\n                encryptionKeyIndex === undefined ||\n                encryptionKeyIndex === null ||\n                callId === undefined ||\n                callId === null ||\n                typeof deviceId !== \"string\" ||\n                typeof callId !== \"string\" ||\n                typeof encryptionKey !== \"string\" ||\n                typeof encryptionKeyIndex !== \"number\"\n            ) {\n                this.logger.warn(\n                    `Malformed call encryption_key: userId=${userId}, deviceId=${deviceId}, encryptionKeyIndex=${encryptionKeyIndex} callId=${callId}`,\n                );\n            } else {\n                this.logger.debug(\n                    `onCallEncryption userId=${userId}:${deviceId} encryptionKeyIndex=${encryptionKeyIndex} age=${age}ms`,\n                );\n                this.emit(\n                    KeyTransportEvents.ReceivedKeys,\n                    userId,\n                    deviceId,\n                    encryptionKey,\n                    encryptionKeyIndex,\n                    event.getTs(),\n                );\n            }\n        }\n    }\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type WidgetApiResponseError } from \"matrix-widget-api\";\n\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { type IKeyTransport, KeyTransportEvents, type KeyTransportEventsHandlerMap } from \"./IKeyTransport.ts\";\nimport { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { type EncryptionKeysToDeviceEventContent, type ParticipantDeviceInfo, type Statistics } from \"./types.ts\";\nimport { ClientEvent, type MatrixClient } from \"../client.ts\";\nimport type { MatrixEvent } from \"../models/event.ts\";\nimport { EventType } from \"../@types/event.ts\";\n\nexport class NotSupportedError extends Error {\n    public constructor(message?: string) {\n        super(message);\n    }\n    public get name(): string {\n        return \"NotSupportedError\";\n    }\n}\n/**\n * ToDeviceKeyTransport is used to send MatrixRTC keys to other devices using the\n * to-device CS-API.\n */\nexport class ToDeviceKeyTransport\n    extends TypedEventEmitter<KeyTransportEvents, KeyTransportEventsHandlerMap>\n    implements IKeyTransport\n{\n    private logger: Logger = rootLogger;\n\n    public setParentLogger(parentLogger: Logger): void {\n        this.logger = parentLogger.getChild(`[ToDeviceKeyTransport]`);\n    }\n\n    public constructor(\n        private userId: string,\n        private deviceId: string,\n        private roomId: string,\n        private client: Pick<MatrixClient, \"encryptAndSendToDevice\" | \"on\" | \"off\">,\n        private statistics: Statistics,\n        parentLogger?: Logger,\n    ) {\n        super();\n        this.setParentLogger(parentLogger ?? rootLogger);\n    }\n\n    public start(): void {\n        this.client.on(ClientEvent.ToDeviceEvent, this.onToDeviceEvent);\n    }\n\n    public stop(): void {\n        this.client.off(ClientEvent.ToDeviceEvent, this.onToDeviceEvent);\n    }\n\n    public async sendKey(keyBase64Encoded: string, index: number, members: ParticipantDeviceInfo[]): Promise<void> {\n        const content: EncryptionKeysToDeviceEventContent = {\n            keys: {\n                index: index,\n                key: keyBase64Encoded,\n            },\n            room_id: this.roomId,\n            member: {\n                claimed_device_id: this.deviceId,\n            },\n            session: {\n                call_id: \"\",\n                application: \"m.call\",\n                scope: \"m.room\",\n            },\n            sent_ts: Date.now(),\n        };\n\n        const targets = members\n            .map((member) => {\n                return {\n                    userId: member.userId!,\n                    deviceId: member.deviceId!,\n                };\n            })\n            // filter out me\n            .filter((member) => !(member.userId == this.userId && member.deviceId == this.deviceId));\n\n        if (targets.length > 0) {\n            await this.client\n                .encryptAndSendToDevice(EventType.CallEncryptionKeysPrefix, targets, content)\n                .catch((error: WidgetApiResponseError) => {\n                    const msg: string = error.message;\n                    // This is not ideal. We would want to have a custom error type for unsupported actions.\n                    // This is not part of the widget API spec. Since as of now there are only two implementations:\n                    // Rust SDK + JS-SDK, and the JS-SDK does support to-device sending, we can assume that\n                    // this is a widget driver issue error message.\n                    if (\n                        (msg.includes(\"unknown variant\") && msg.includes(\"send_to_device\")) ||\n                        msg.includes(\"not supported\")\n                    ) {\n                        throw new NotSupportedError(\"The widget driver does not support to-device encryption\");\n                    }\n                });\n            this.statistics.counters.roomEventEncryptionKeysSent += 1;\n        } else {\n            this.logger.warn(\"No targets found for sending key\");\n        }\n    }\n\n    private receiveCallKeyEvent(fromUser: string, content: EncryptionKeysToDeviceEventContent): void {\n        // The event has already been validated at this point.\n\n        this.statistics.counters.roomEventEncryptionKeysReceived += 1;\n\n        // What is this, and why is it needed?\n        // Also to device events do not have an origin server ts\n        const now = Date.now();\n        const age = now - (typeof content.sent_ts === \"number\" ? content.sent_ts : now);\n        this.statistics.totals.roomEventEncryptionKeysReceivedTotalAge += age;\n\n        this.emit(\n            KeyTransportEvents.ReceivedKeys,\n            // TODO this is claimed information\n            fromUser,\n            // TODO: This is claimed information\n            content.member.claimed_device_id!,\n            content.keys.key,\n            content.keys.index,\n            now,\n        );\n    }\n\n    private onToDeviceEvent = (event: MatrixEvent): void => {\n        if (event.getType() !== EventType.CallEncryptionKeysPrefix) {\n            // Ignore this is not a call encryption event\n            return;\n        }\n\n        // TODO: Not possible to check if the event is encrypted or not\n        // see https://github.com/matrix-org/matrix-rust-sdk/issues/4883\n        // if (evnt.getWireType() != EventType.RoomMessageEncrypted) {\n        //     // WARN: The call keys were sent in clear. Ignore them\n        //     logger.warn(`Call encryption keys sent in clear from: ${event.getSender()}`);\n        //     return;\n        // }\n\n        const content = this.getValidEventContent(event);\n        if (!content) return;\n\n        if (!event.getSender()) return;\n\n        this.receiveCallKeyEvent(event.getSender()!, content);\n    };\n\n    private getValidEventContent(event: MatrixEvent): EncryptionKeysToDeviceEventContent | undefined {\n        const content = event.getContent();\n        const roomId = content.room_id;\n        if (!roomId) {\n            // Invalid event\n            this.logger.warn(\"Malformed Event: invalid call encryption keys event, no roomId\");\n            return;\n        }\n        if (roomId !== this.roomId) {\n            this.logger.warn(\"Malformed Event: Mismatch roomId\");\n            return;\n        }\n\n        if (!content.keys || !content.keys.key || typeof content.keys.index !== \"number\") {\n            this.logger.warn(\"Malformed Event: Missing keys field\");\n            return;\n        }\n\n        if (!content.member || !content.member.claimed_device_id) {\n            this.logger.warn(\"Malformed Event: Missing claimed_device_id\");\n            return;\n        }\n\n        // TODO check for session related fields once the to-device encryption uses the new format.\n        return content as EncryptionKeysToDeviceEventContent;\n    }\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type { InboundEncryptionSession, ParticipantId } from \"./types.ts\";\n\n/**\n * Detects when a key for a given index is outdated.\n */\nexport class OutdatedKeyFilter {\n    // Map of participantId -> keyIndex -> timestamp\n    private tsBuffer: Map<ParticipantId, Map<number, number>> = new Map();\n\n    public constructor() {}\n\n    /**\n     * Check if there is a recent key with the same keyId (index) and then use the creationTS to decide what to\n     * do with the key. If the key received is older than the one already in the buffer, it is ignored.\n     * @param participantId\n     * @param item\n     */\n    public isOutdated(participantId: ParticipantId, item: InboundEncryptionSession): boolean {\n        if (!this.tsBuffer.has(participantId)) {\n            this.tsBuffer.set(participantId, new Map<number, number>());\n        }\n\n        const latestTimestamp = this.tsBuffer.get(participantId)?.get(item.keyIndex);\n        if (latestTimestamp && latestTimestamp > item.creationTS) {\n            // The existing key is more recent, ignore this one\n            return true;\n        }\n        this.tsBuffer.get(participantId)!.set(item.keyIndex, item.creationTS);\n        return false;\n    }\n}\n\nexport function getParticipantId(userId: string, deviceId: string): ParticipantId {\n    return `${userId}:${deviceId}`;\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixClient } from \"../client.ts\";\nimport { RelationType, UNSTABLE_MSC3089_BRANCH } from \"../@types/event.ts\";\nimport { type IContent, type MatrixEvent } from \"./event.ts\";\nimport { type MSC3089TreeSpace } from \"./MSC3089TreeSpace.ts\";\nimport { EventTimeline } from \"./event-timeline.ts\";\nimport { type FileType } from \"../http-api/index.ts\";\nimport type { ISendEventResponse } from \"../@types/requests.ts\";\nimport { type EncryptedFile } from \"../@types/media.ts\";\n\nexport interface MSC3089EventContent {\n    active?: boolean;\n    name?: string;\n    locked?: boolean;\n    version?: number;\n}\n\nexport interface MSC3089EventContent {\n    active?: boolean;\n    name?: string;\n    locked?: boolean;\n    version?: number;\n}\n\n/**\n * Represents a [MSC3089](https://github.com/matrix-org/matrix-doc/pull/3089) branch - a reference\n * to a file (leaf) in the tree. Note that this is UNSTABLE and subject to breaking changes\n * without notice.\n */\nexport class MSC3089Branch {\n    public constructor(\n        private client: MatrixClient,\n        public readonly indexEvent: MatrixEvent,\n        public readonly directory: MSC3089TreeSpace,\n    ) {\n        // Nothing to do\n    }\n\n    /**\n     * The file ID.\n     */\n    public get id(): string {\n        const stateKey = this.indexEvent.getStateKey();\n        if (!stateKey) {\n            throw new Error(\"State key not found for branch\");\n        }\n        return stateKey;\n    }\n\n    /**\n     * Whether this branch is active/valid.\n     */\n    public get isActive(): boolean {\n        return this.indexEvent.getContent()[\"active\"] === true;\n    }\n\n    /**\n     * Version for the file, one-indexed.\n     */\n    public get version(): number {\n        return this.indexEvent.getContent()[\"version\"] ?? 1;\n    }\n\n    private get roomId(): string {\n        return this.indexEvent.getRoomId()!;\n    }\n\n    /**\n     * Deletes the file from the tree, including all prior edits/versions.\n     * @returns Promise which resolves when complete.\n     */\n    public async delete(): Promise<void> {\n        await this.client.sendStateEvent(this.roomId, UNSTABLE_MSC3089_BRANCH.name, {}, this.id);\n        await this.client.redactEvent(this.roomId, this.id);\n\n        const nextVersion = (await this.getVersionHistory())[1]; // [0] will be us\n        if (nextVersion) await nextVersion.delete(); // implicit recursion\n    }\n\n    /**\n     * Gets the name for this file.\n     * @returns The name, or \"Unnamed File\" if unknown.\n     */\n    public getName(): string {\n        return this.indexEvent.getContent()[\"name\"] || \"Unnamed File\";\n    }\n\n    /**\n     * Sets the name for this file.\n     * @param name - The new name for this file.\n     * @returns Promise which resolves when complete.\n     */\n    public async setName(name: string): Promise<void> {\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                ...this.indexEvent.getContent(),\n                name: name,\n            },\n            this.id,\n        );\n    }\n\n    /**\n     * Gets whether or not a file is locked.\n     * @returns True if locked, false otherwise.\n     */\n    public isLocked(): boolean {\n        return this.indexEvent.getContent()[\"locked\"] || false;\n    }\n\n    /**\n     * Sets a file as locked or unlocked.\n     * @param locked - True to lock the file, false otherwise.\n     * @returns Promise which resolves when complete.\n     */\n    public async setLocked(locked: boolean): Promise<void> {\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                ...this.indexEvent.getContent(),\n                locked: locked,\n            },\n            this.id,\n        );\n    }\n\n    /**\n     * Gets information about the file needed to download it.\n     * @returns Information about the file.\n     */\n    public async getFileInfo(): Promise<{ info: EncryptedFile; httpUrl: string }> {\n        const event = await this.getFileEvent();\n\n        const file = event.getOriginalContent()[\"file\"];\n        const httpUrl = this.client.mxcUrlToHttp(file[\"url\"]);\n\n        if (!httpUrl) {\n            throw new Error(`No HTTP URL available for ${file[\"url\"]}`);\n        }\n\n        return { info: file, httpUrl: httpUrl };\n    }\n\n    /**\n     * Gets the event the file points to.\n     * @returns Promise which resolves to the file's event.\n     */\n    public async getFileEvent(): Promise<MatrixEvent> {\n        const room = this.client.getRoom(this.roomId);\n        if (!room) throw new Error(\"Unknown room\");\n\n        let event: MatrixEvent | undefined = room.getUnfilteredTimelineSet().findEventById(this.id);\n\n        // keep scrolling back if needed until we find the event or reach the start of the room:\n        while (!event && room.getLiveTimeline().getState(EventTimeline.BACKWARDS)!.paginationToken) {\n            await this.client.scrollback(room, 100);\n            event = room.getUnfilteredTimelineSet().findEventById(this.id);\n        }\n\n        if (!event) throw new Error(\"Failed to find event\");\n\n        // Sometimes the event isn't decrypted for us, so do that.\n        await this.client.decryptEventIfNeeded(event);\n\n        return event;\n    }\n\n    /**\n     * Creates a new version of this file with contents in a type that is compatible with MatrixClient.uploadContent().\n     * @param name - The name of the file.\n     * @param encryptedContents - The encrypted contents.\n     * @param info - The encrypted file information.\n     * @param additionalContent - Optional event content fields to include in the message.\n     * @returns Promise which resolves to the file event's sent response.\n     */\n    public async createNewVersion(\n        name: string,\n        encryptedContents: FileType,\n        info: EncryptedFile,\n        additionalContent?: IContent,\n    ): Promise<ISendEventResponse> {\n        const fileEventResponse = await this.directory.createFile(name, encryptedContents, info, {\n            ...(additionalContent ?? {}),\n            \"m.new_content\": true,\n            \"m.relates_to\": {\n                rel_type: RelationType.Replace,\n                event_id: this.id,\n            },\n        });\n\n        // Update the version of the new event\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                active: true,\n                name: name,\n                version: this.version + 1,\n            },\n            fileEventResponse[\"event_id\"],\n        );\n\n        // Deprecate ourselves\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                ...this.indexEvent.getContent(),\n                active: false,\n            },\n            this.id,\n        );\n\n        return fileEventResponse;\n    }\n\n    /**\n     * Gets the file's version history, starting at this file.\n     * @returns Promise which resolves to the file's version history, with the\n     * first element being the current version and the last element being the first version.\n     */\n    public async getVersionHistory(): Promise<MSC3089Branch[]> {\n        const fileHistory: MSC3089Branch[] = [];\n        fileHistory.push(this); // start with ourselves\n\n        const room = this.client.getRoom(this.roomId);\n        if (!room) throw new Error(\"Invalid or unknown room\");\n\n        // Clone the timeline to reverse it, getting most-recent-first ordering, hopefully\n        // shortening the awful loop below. Without the clone, we can unintentionally mutate\n        // the timeline.\n        const timelineEvents = [...room.getLiveTimeline().getEvents()].reverse();\n\n        // XXX: This is a very inefficient search, but it's the best we can do with the\n        // relations structure we have in the SDK. As of writing, it is not worth the\n        // investment in improving the structure.\n        let childEvent: MatrixEvent | undefined;\n        let parentEvent = await this.getFileEvent();\n        do {\n            childEvent = timelineEvents.find((e) => e.replacingEventId() === parentEvent.getId());\n            if (childEvent) {\n                const branch = this.directory.getFile(childEvent.getId()!);\n                if (branch) {\n                    fileHistory.push(branch);\n                    parentEvent = childEvent;\n                } else {\n                    break; // prevent infinite loop\n                }\n            }\n        } while (childEvent);\n\n        return fileHistory;\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixClient } from \"../client.ts\";\nimport { EventType, MsgType, UNSTABLE_MSC3089_BRANCH, UNSTABLE_MSC3089_LEAF } from \"../@types/event.ts\";\nimport { type Room } from \"./room.ts\";\nimport { logger } from \"../logger.ts\";\nimport { type IContent, type MatrixEvent } from \"./event.ts\";\nimport {\n    averageBetweenStrings,\n    DEFAULT_ALPHABET,\n    lexicographicCompare,\n    nextString,\n    prevString,\n    simpleRetryOperation,\n} from \"../utils.ts\";\nimport { MSC3089Branch } from \"./MSC3089Branch.ts\";\nimport { type ISendEventResponse } from \"../@types/requests.ts\";\nimport { type FileType, MatrixError } from \"../http-api/index.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\nimport { type RoomPowerLevelsEventContent, type SpaceChildEventContent } from \"../@types/state_events.ts\";\nimport type { EncryptedFile, FileContent } from \"../@types/media.ts\";\nimport { type EmptyObject } from \"../@types/common.ts\";\n\n/**\n * The recommended defaults for a tree space's power levels. Note that this\n * is UNSTABLE and subject to breaking changes without notice.\n */\nexport const DEFAULT_TREE_POWER_LEVELS_TEMPLATE = {\n    // Owner\n    invite: 100,\n    kick: 100,\n    ban: 100,\n\n    // Editor\n    redact: 50,\n    state_default: 50,\n    events_default: 50,\n\n    // Viewer\n    users_default: 0,\n\n    // Mixed\n    events: {\n        [EventType.RoomPowerLevels]: 100,\n        [EventType.RoomHistoryVisibility]: 100,\n        [EventType.RoomTombstone]: 100,\n        [EventType.RoomEncryption]: 100,\n        [EventType.RoomName]: 50,\n        [EventType.RoomMessage]: 50,\n        [EventType.RoomMessageEncrypted]: 50,\n        [EventType.Sticker]: 50,\n    },\n\n    users: {}, // defined by calling code\n};\n\n/**\n * Ease-of-use representation for power levels represented as simple roles.\n * Note that this is UNSTABLE and subject to breaking changes without notice.\n */\nexport enum TreePermissions {\n    Viewer = \"viewer\", // Default\n    Editor = \"editor\", // \"Moderator\" or ~PL50\n    Owner = \"owner\", // \"Admin\" or PL100\n}\n\ndeclare module \"../@types/media\" {\n    interface FileContent {\n        [UNSTABLE_MSC3089_LEAF.name]?: EmptyObject;\n    }\n}\n\n/**\n * Represents a [MSC3089](https://github.com/matrix-org/matrix-doc/pull/3089)\n * file tree Space. Note that this is UNSTABLE and subject to breaking changes\n * without notice.\n */\nexport class MSC3089TreeSpace {\n    public readonly room: Room;\n\n    public constructor(\n        private client: MatrixClient,\n        public readonly roomId: string,\n    ) {\n        this.room = this.client.getRoom(this.roomId)!;\n\n        if (!this.room) throw new Error(\"Unknown room\");\n    }\n\n    /**\n     * Syntactic sugar for room ID of the Space.\n     */\n    public get id(): string {\n        return this.roomId;\n    }\n\n    /**\n     * Whether or not this is a top level space.\n     */\n    public get isTopLevel(): boolean {\n        // XXX: This is absolutely not how you find out if the space is top level\n        // but is safe for a managed usecase like we offer in the SDK.\n        const parentEvents = this.room.currentState.getStateEvents(EventType.SpaceParent);\n        if (!parentEvents?.length) return true;\n        return parentEvents.every((e) => !e.getContent()?.[\"via\"]);\n    }\n\n    /**\n     * Sets the name of the tree space.\n     * @param name - The new name for the space.\n     * @returns Promise which resolves when complete.\n     */\n    public async setName(name: string): Promise<void> {\n        await this.client.sendStateEvent(this.roomId, EventType.RoomName, { name }, \"\");\n    }\n\n    /**\n     * Invites a user to the tree space. They will be given the default Viewer\n     * permission level unless specified elsewhere.\n     * @param userId - The user ID to invite.\n     * @param andSubspaces - True (default) to invite the user to all\n     * directories/subspaces too, recursively.\n     * @returns Promise which resolves when complete.\n     */\n    public async invite(userId: string, andSubspaces = true): Promise<void> {\n        const promises: Promise<void>[] = [this.retryInvite(userId)];\n        if (andSubspaces) {\n            promises.push(...this.getDirectories().map((d) => d.invite(userId, andSubspaces)));\n        }\n        await Promise.all(promises);\n    }\n\n    private async retryInvite(userId: string): Promise<void> {\n        await simpleRetryOperation(\n            () => this.client.invite(this.roomId, userId),\n            (e) => {\n                // We don't want to retry permission errors forever...\n                if (e instanceof MatrixError && e.errcode === \"M_FORBIDDEN\") {\n                    return false;\n                }\n                return true;\n            },\n        );\n    }\n\n    /**\n     * Sets the permissions of a user to the given role. Note that if setting a user\n     * to Owner then they will NOT be able to be demoted. If the user does not have\n     * permission to change the power level of the target, an error will be thrown.\n     * @param userId - The user ID to change the role of.\n     * @param role - The role to assign.\n     * @returns Promise which resolves when complete.\n     */\n    public async setPermissions(userId: string, role: TreePermissions): Promise<void> {\n        const currentPls = this.room.currentState.getStateEvents(EventType.RoomPowerLevels, \"\");\n        if (Array.isArray(currentPls)) throw new Error(\"Unexpected return type for power levels\");\n\n        const pls = currentPls?.getContent<RoomPowerLevelsEventContent>() || {};\n        const viewLevel = pls[\"users_default\"] || 0;\n        const editLevel = pls[\"events_default\"] || 50;\n        const adminLevel = pls[\"events\"]?.[EventType.RoomPowerLevels] || 100;\n\n        const users = pls[\"users\"] || {};\n        switch (role) {\n            case TreePermissions.Viewer:\n                users[userId] = viewLevel;\n                break;\n            case TreePermissions.Editor:\n                users[userId] = editLevel;\n                break;\n            case TreePermissions.Owner:\n                users[userId] = adminLevel;\n                break;\n            default:\n                throw new Error(\"Invalid role: \" + role);\n        }\n        pls[\"users\"] = users;\n\n        await this.client.sendStateEvent(this.roomId, EventType.RoomPowerLevels, pls, \"\");\n    }\n\n    /**\n     * Gets the current permissions of a user. Note that any users missing explicit permissions (or not\n     * in the space) will be considered Viewers. Appropriate membership checks need to be performed\n     * elsewhere.\n     * @param userId - The user ID to check permissions of.\n     * @returns The permissions for the user, defaulting to Viewer.\n     */\n    public getPermissions(userId: string): TreePermissions {\n        const currentPls = this.room.currentState.getStateEvents(EventType.RoomPowerLevels, \"\");\n        if (Array.isArray(currentPls)) throw new Error(\"Unexpected return type for power levels\");\n\n        const pls = currentPls?.getContent() || {};\n        const viewLevel = pls[\"users_default\"] || 0;\n        const editLevel = pls[\"events_default\"] || 50;\n        const adminLevel = pls[\"events\"]?.[EventType.RoomPowerLevels] || 100;\n\n        const userLevel = pls[\"users\"]?.[userId] || viewLevel;\n        if (userLevel >= adminLevel) return TreePermissions.Owner;\n        if (userLevel >= editLevel) return TreePermissions.Editor;\n        return TreePermissions.Viewer;\n    }\n\n    /**\n     * Creates a directory under this tree space, represented as another tree space.\n     * @param name - The name for the directory.\n     * @returns Promise which resolves to the created directory.\n     */\n    public async createDirectory(name: string): Promise<MSC3089TreeSpace> {\n        const directory = await this.client.unstableCreateFileTree(name);\n\n        await this.client.sendStateEvent(\n            this.roomId,\n            EventType.SpaceChild,\n            {\n                via: [this.client.getDomain()!],\n            },\n            directory.roomId,\n        );\n\n        await this.client.sendStateEvent(\n            directory.roomId,\n            EventType.SpaceParent,\n            {\n                via: [this.client.getDomain()!],\n            },\n            this.roomId,\n        );\n\n        return directory;\n    }\n\n    /**\n     * Gets a list of all known immediate subdirectories to this tree space.\n     * @returns The tree spaces (directories). May be empty, but not null.\n     */\n    public getDirectories(): MSC3089TreeSpace[] {\n        const trees: MSC3089TreeSpace[] = [];\n        const children = this.room.currentState.getStateEvents(EventType.SpaceChild);\n        for (const child of children) {\n            try {\n                const stateKey = child.getStateKey();\n                if (stateKey) {\n                    const tree = this.client.unstableGetFileTreeSpace(stateKey);\n                    if (tree) trees.push(tree);\n                }\n            } catch (e) {\n                logger.warn(\"Unable to create tree space instance for listing. Are we joined?\", e);\n            }\n        }\n        return trees;\n    }\n\n    /**\n     * Gets a subdirectory of a given ID under this tree space. Note that this will not recurse\n     * into children and instead only look one level deep.\n     * @param roomId - The room ID (directory ID) to find.\n     * @returns The directory, or undefined if not found.\n     */\n    public getDirectory(roomId: string): MSC3089TreeSpace | undefined {\n        return this.getDirectories().find((r) => r.roomId === roomId);\n    }\n\n    /**\n     * Deletes the tree, kicking all members and deleting **all subdirectories**.\n     * @returns Promise which resolves when complete.\n     */\n    public async delete(): Promise<void> {\n        const subdirectories = this.getDirectories();\n        for (const dir of subdirectories) {\n            await dir.delete();\n        }\n\n        const kickMemberships = [KnownMembership.Invite, KnownMembership.Knock, KnownMembership.Join];\n        const members = this.room.currentState.getStateEvents(EventType.RoomMember);\n        for (const member of members) {\n            const isNotUs = member.getStateKey() !== this.client.getUserId();\n            if (isNotUs && kickMemberships.includes(member.getContent().membership! as KnownMembership)) {\n                const stateKey = member.getStateKey();\n                if (!stateKey) {\n                    throw new Error(\"State key not found for branch\");\n                }\n                await this.client.kick(this.roomId, stateKey, \"Room deleted\");\n            }\n        }\n\n        await this.client.leave(this.roomId);\n    }\n\n    private getOrderedChildren(children: MatrixEvent[]): { roomId: string; order: string }[] {\n        const ordered: { roomId: string; order: string }[] = children\n            .map((c) => ({ roomId: c.getStateKey(), order: c.getContent()[\"order\"] }))\n            .filter((c) => c.roomId) as { roomId: string; order: string }[];\n        ordered.sort((a, b) => {\n            if (a.order && !b.order) {\n                return -1;\n            } else if (!a.order && b.order) {\n                return 1;\n            } else if (!a.order && !b.order) {\n                const roomA = this.client.getRoom(a.roomId);\n                const roomB = this.client.getRoom(b.roomId);\n                if (!roomA || !roomB) {\n                    // just don't bother trying to do more partial sorting\n                    return lexicographicCompare(a.roomId, b.roomId);\n                }\n\n                const createTsA = roomA.currentState.getStateEvents(EventType.RoomCreate, \"\")?.getTs() ?? 0;\n                const createTsB = roomB.currentState.getStateEvents(EventType.RoomCreate, \"\")?.getTs() ?? 0;\n                if (createTsA === createTsB) {\n                    return lexicographicCompare(a.roomId, b.roomId);\n                }\n                return createTsA - createTsB;\n            } else {\n                // both not-null orders\n                return lexicographicCompare(a.order, b.order);\n            }\n        });\n        return ordered;\n    }\n\n    private getParentRoom(): Room {\n        const parents = this.room.currentState.getStateEvents(EventType.SpaceParent);\n        const parent = parents[0]; // XXX: Wild assumption\n        if (!parent) throw new Error(\"Expected to have a parent in a non-top level space\");\n\n        // XXX: We are assuming the parent is a valid tree space.\n        // We probably don't need to validate the parent room state for this usecase though.\n        const stateKey = parent.getStateKey();\n        if (!stateKey) throw new Error(\"No state key found for parent\");\n        const parentRoom = this.client.getRoom(stateKey);\n        if (!parentRoom) throw new Error(\"Unable to locate room for parent\");\n\n        return parentRoom;\n    }\n\n    /**\n     * Gets the current order index for this directory. Note that if this is the top level space\n     * then -1 will be returned.\n     * @returns The order index of this space.\n     */\n    public getOrder(): number {\n        if (this.isTopLevel) return -1;\n\n        const parentRoom = this.getParentRoom();\n        const children = parentRoom.currentState.getStateEvents(EventType.SpaceChild);\n        const ordered = this.getOrderedChildren(children);\n\n        return ordered.findIndex((c) => c.roomId === this.roomId);\n    }\n\n    /**\n     * Sets the order index for this directory within its parent. Note that if this is a top level\n     * space then an error will be thrown. -1 can be used to move the child to the start, and numbers\n     * larger than the number of children can be used to move the child to the end.\n     * @param index - The new order index for this space.\n     * @returns Promise which resolves when complete.\n     * @throws Throws if this is a top level space.\n     */\n    public async setOrder(index: number): Promise<void> {\n        if (this.isTopLevel) throw new Error(\"Cannot set order of top level spaces currently\");\n\n        const parentRoom = this.getParentRoom();\n        const children = parentRoom.currentState.getStateEvents(EventType.SpaceChild);\n        const ordered = this.getOrderedChildren(children);\n        index = Math.max(Math.min(index, ordered.length - 1), 0);\n\n        const currentIndex = this.getOrder();\n        const movingUp = currentIndex < index;\n        if (movingUp && index === ordered.length - 1) {\n            index--;\n        } else if (!movingUp && index === 0) {\n            index++;\n        }\n\n        const prev = ordered[movingUp ? index : index - 1];\n        const next = ordered[movingUp ? index + 1 : index];\n\n        let newOrder = DEFAULT_ALPHABET[0];\n        let ensureBeforeIsSane = false;\n        if (!prev) {\n            // Move to front\n            if (next?.order) {\n                newOrder = prevString(next.order);\n            }\n        } else if (index === ordered.length - 1) {\n            // Move to back\n            if (next?.order) {\n                newOrder = nextString(next.order);\n            }\n        } else {\n            // Move somewhere in the middle\n            const startOrder = prev?.order;\n            const endOrder = next?.order;\n            if (startOrder && endOrder) {\n                if (startOrder === endOrder) {\n                    // Error case: just move +1 to break out of awful math\n                    newOrder = nextString(startOrder);\n                } else {\n                    newOrder = averageBetweenStrings(startOrder, endOrder);\n                }\n            } else {\n                if (startOrder) {\n                    // We're at the end (endOrder is null, so no explicit order)\n                    newOrder = nextString(startOrder);\n                } else if (endOrder) {\n                    // We're at the start (startOrder is null, so nothing before us)\n                    newOrder = prevString(endOrder);\n                } else {\n                    // Both points are unknown. We're likely in a range where all the children\n                    // don't have particular order values, so we may need to update them too.\n                    // The other possibility is there's only us as a child, but we should have\n                    // shown up in the other states.\n                    ensureBeforeIsSane = true;\n                }\n            }\n        }\n\n        if (ensureBeforeIsSane) {\n            // We were asked by the order algorithm to prepare the moving space for a landing\n            // in the undefined order part of the order array, which means we need to update the\n            // spaces that come before it with a stable order value.\n            let lastOrder: string | undefined;\n            for (let i = 0; i <= index; i++) {\n                const target = ordered[i];\n                if (i === 0) {\n                    lastOrder = target.order;\n                }\n                if (!target.order) {\n                    // XXX: We should be creating gaps to avoid conflicts\n                    lastOrder = lastOrder ? nextString(lastOrder) : DEFAULT_ALPHABET[0];\n                    const currentChild = parentRoom.currentState.getStateEvents(EventType.SpaceChild, target.roomId);\n                    const content = currentChild?.getContent<SpaceChildEventContent>() ?? {\n                        via: [this.client.getDomain()!],\n                    };\n                    await this.client.sendStateEvent(\n                        parentRoom.roomId,\n                        EventType.SpaceChild,\n                        {\n                            ...content,\n                            order: lastOrder,\n                        },\n                        target.roomId,\n                    );\n                } else {\n                    lastOrder = target.order;\n                }\n            }\n            if (lastOrder) {\n                newOrder = nextString(lastOrder);\n            }\n        }\n\n        // TODO: Deal with order conflicts by reordering\n\n        // Now we can finally update our own order state\n        const currentChild = parentRoom.currentState.getStateEvents(EventType.SpaceChild, this.roomId);\n        const content = currentChild?.getContent<SpaceChildEventContent>() ?? { via: [this.client.getDomain()!] };\n        await this.client.sendStateEvent(\n            parentRoom.roomId,\n            EventType.SpaceChild,\n            {\n                ...content,\n\n                // TODO: Safely constrain to 50 character limit required by spaces.\n                order: newOrder,\n            },\n            this.roomId,\n        );\n    }\n\n    /**\n     * Creates (uploads) a new file to this tree. The file must have already been encrypted for the room.\n     * The file contents are in a type that is compatible with MatrixClient.uploadContent().\n     * @param name - The name of the file.\n     * @param encryptedContents - The encrypted contents.\n     * @param info - The encrypted file information.\n     * @param additionalContent - Optional event content fields to include in the message.\n     * @returns Promise which resolves to the file event's sent response.\n     */\n    public async createFile(\n        name: string,\n        encryptedContents: FileType,\n        info: EncryptedFile,\n        additionalContent?: IContent,\n    ): Promise<ISendEventResponse> {\n        const { content_uri: mxc } = await this.client.uploadContent(encryptedContents, {\n            includeFilename: false,\n        });\n        info.url = mxc;\n\n        const fileContent: FileContent = {\n            msgtype: MsgType.File,\n            body: name,\n            url: mxc,\n            file: info,\n        };\n\n        additionalContent = additionalContent ?? {};\n        if (additionalContent[\"m.new_content\"]) {\n            // We do the right thing according to the spec, but due to how relations are\n            // handled we also end up duplicating this information to the regular `content`\n            // as well.\n            additionalContent[\"m.new_content\"] = fileContent;\n        }\n\n        const res = await this.client.sendMessage(this.roomId, {\n            ...additionalContent,\n            ...fileContent,\n            [UNSTABLE_MSC3089_LEAF.name]: {},\n        } as FileContent);\n\n        await this.client.sendStateEvent(\n            this.roomId,\n            UNSTABLE_MSC3089_BRANCH.name,\n            {\n                active: true,\n                name: name,\n            },\n            res[\"event_id\"],\n        );\n\n        return res;\n    }\n\n    /**\n     * Retrieves a file from the tree.\n     * @param fileEventId - The event ID of the file.\n     * @returns The file, or null if not found.\n     */\n    public getFile(fileEventId: string): MSC3089Branch | null {\n        const branch = this.room.currentState.getStateEvents(UNSTABLE_MSC3089_BRANCH.name, fileEventId);\n        return branch ? new MSC3089Branch(this.client, branch, this) : null;\n    }\n\n    /**\n     * Gets an array of all known files for the tree.\n     * @returns The known files. May be empty, but not null.\n     */\n    public listFiles(): MSC3089Branch[] {\n        return this.listAllFiles().filter((b) => b.isActive);\n    }\n\n    /**\n     * Gets an array of all known files for the tree, including inactive/invalid ones.\n     * @returns The known files. May be empty, but not null.\n     */\n    public listAllFiles(): MSC3089Branch[] {\n        const branches = this.room.currentState.getStateEvents(UNSTABLE_MSC3089_BRANCH.name) ?? [];\n        return branches.map((e) => new MSC3089Branch(this.client, e, this));\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixEvent } from \"./event.ts\";\nimport { type Room } from \"./room.ts\";\nimport { inMainTimelineForReceipt, threadIdForReceipt } from \"../client.ts\";\n\n/**\n * Determine the order of two events in a room.\n *\n * In principle this should use the same order as the server, but in practice\n * this is difficult for events that were not received over the Sync API. See\n * MSC4033 for details.\n *\n * This implementation leans on the order of events within their timelines, and\n * falls back to comparing event timestamps when they are in different\n * timelines.\n *\n * See https://github.com/matrix-org/matrix-js-sdk/issues/3325 for where we are\n * tracking the work to fix this.\n *\n * @param room - the room we are looking in\n * @param leftEventId - the id of the first event\n * @param rightEventId - the id of the second event\n\n * @returns -1 if left \\< right, 1 if left \\> right, 0 if left == right, null if\n *          we can't tell (because we can't find the events).\n */\nexport function compareEventOrdering(room: Room, leftEventId: string, rightEventId: string): number | null {\n    const leftEvent = room.findEventById(leftEventId);\n    const rightEvent = room.findEventById(rightEventId);\n\n    if (!leftEvent || !rightEvent) {\n        // Without the events themselves, we can't find their thread or\n        // timeline, or guess based on timestamp, so we just don't know.\n        return null;\n    }\n\n    // Check whether the events are in the main timeline\n    const isLeftEventInMainTimeline = inMainTimelineForReceipt(leftEvent);\n    const isRightEventInMainTimeline = inMainTimelineForReceipt(rightEvent);\n\n    if (isLeftEventInMainTimeline && isRightEventInMainTimeline) {\n        return compareEventsInMainTimeline(room, leftEventId, rightEventId, leftEvent, rightEvent);\n    } else {\n        // At least one event is not in the timeline, so we can't use the room's\n        // unfiltered timeline set.\n        return compareEventsInThreads(leftEventId, rightEventId, leftEvent, rightEvent);\n    }\n}\n\nfunction compareEventsInMainTimeline(\n    room: Room,\n    leftEventId: string,\n    rightEventId: string,\n    leftEvent: MatrixEvent,\n    rightEvent: MatrixEvent,\n): number | null {\n    // Get the timeline set that contains all the events.\n    const timelineSet = room.getUnfilteredTimelineSet();\n\n    // If they are in the same timeline, compareEventOrdering does what we need\n    const compareSameTimeline = timelineSet.compareEventOrdering(leftEventId, rightEventId);\n    if (compareSameTimeline !== null) {\n        return compareSameTimeline;\n    }\n\n    // Find which timeline each event is in. Refuse to provide an ordering if we\n    // can't find either of the events.\n\n    const leftTimeline = timelineSet.getTimelineForEvent(leftEventId);\n    if (leftTimeline === timelineSet.getLiveTimeline()) {\n        // The left event is part of the live timeline, so it must be after the\n        // right event (since they are not in the same timeline or we would have\n        // returned after compareEventOrdering.\n        return 1;\n    }\n\n    const rightTimeline = timelineSet.getTimelineForEvent(rightEventId);\n    if (rightTimeline === timelineSet.getLiveTimeline()) {\n        // The right event is part of the live timeline, so it must be after the\n        // left event.\n        return -1;\n    }\n\n    // They are in older timeline sets (because they were fetched by paging up).\n    return guessOrderBasedOnTimestamp(leftEvent, rightEvent);\n}\n\nfunction compareEventsInThreads(\n    leftEventId: string,\n    rightEventId: string,\n    leftEvent: MatrixEvent,\n    rightEvent: MatrixEvent,\n): number | null {\n    const leftEventThreadId = threadIdForReceipt(leftEvent);\n    const rightEventThreadId = threadIdForReceipt(rightEvent);\n\n    const leftThread = leftEvent.getThread();\n\n    if (leftThread && leftEventThreadId === rightEventThreadId) {\n        // They are in the same thread, so we can ask the thread's timeline to\n        // figure it out for us\n        return leftThread.timelineSet.compareEventOrdering(leftEventId, rightEventId);\n    } else {\n        return guessOrderBasedOnTimestamp(leftEvent, rightEvent);\n    }\n}\n\n/**\n * Guess the order of events based on server timestamp. This is not good, but\n * difficult to avoid without MSC4033.\n *\n * See https://github.com/matrix-org/matrix-js-sdk/issues/3325\n */\nfunction guessOrderBasedOnTimestamp(leftEvent: MatrixEvent, rightEvent: MatrixEvent): number {\n    const leftTs = leftEvent.getTs();\n    const rightTs = rightEvent.getTs();\n    if (leftTs < rightTs) {\n        return -1;\n    } else if (leftTs > rightTs) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixEvent } from \"./event.ts\";\nimport { Direction } from \"./event-timeline.ts\";\n\nexport class EventContext {\n    private timeline: MatrixEvent[];\n    private ourEventIndex = 0;\n    private paginateTokens: Record<Direction, string | null> = {\n        [Direction.Backward]: null,\n        [Direction.Forward]: null,\n    };\n\n    /**\n     * Construct a new EventContext\n     *\n     * An eventcontext is used for circumstances such as search results, when we\n     * have a particular event of interest, and a bunch of events before and after\n     * it.\n     *\n     * It also stores pagination tokens for going backwards and forwards in the\n     * timeline.\n     *\n     * @param ourEvent - the event at the centre of this context\n     */\n    public constructor(public readonly ourEvent: MatrixEvent) {\n        this.timeline = [ourEvent];\n    }\n\n    /**\n     * Get the main event of interest\n     *\n     * This is a convenience function for getTimeline()[getOurEventIndex()].\n     *\n     * @returns The event at the centre of this context.\n     */\n    public getEvent(): MatrixEvent {\n        return this.timeline[this.ourEventIndex];\n    }\n\n    /**\n     * Get the list of events in this context\n     *\n     * @returns An array of MatrixEvents\n     */\n    public getTimeline(): MatrixEvent[] {\n        return this.timeline;\n    }\n\n    /**\n     * Get the index in the timeline of our event\n     */\n    public getOurEventIndex(): number {\n        return this.ourEventIndex;\n    }\n\n    /**\n     * Get a pagination token.\n     *\n     * @param backwards -   true to get the pagination token for going\n     */\n    public getPaginateToken(backwards = false): string | null {\n        return this.paginateTokens[backwards ? Direction.Backward : Direction.Forward];\n    }\n\n    /**\n     * Set a pagination token.\n     *\n     * Generally this will be used only by the matrix js sdk.\n     *\n     * @param token -        pagination token\n     * @param backwards -   true to set the pagination token for going\n     *                                   backwards in time\n     */\n    public setPaginateToken(token?: string, backwards = false): void {\n        this.paginateTokens[backwards ? Direction.Backward : Direction.Forward] = token ?? null;\n    }\n\n    /**\n     * Add more events to the timeline\n     *\n     * @param events -      new events, in timeline order\n     * @param atStart -   true to insert new events at the start\n     */\n    public addEvents(events: MatrixEvent[], atStart = false): void {\n        // TODO: should we share logic with Room.addEventsToTimeline?\n        // Should Room even use EventContext?\n\n        if (atStart) {\n            this.timeline = events.concat(this.timeline);\n            this.ourEventIndex += events.length;\n        } else {\n            this.timeline = this.timeline.concat(events);\n        }\n    }\n}\n","/*\nCopyright 2015 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Enum for event statuses.\n * @readonly\n */\nexport enum EventStatus {\n    /** The event was not sent and will no longer be retried. */\n    NOT_SENT = \"not_sent\",\n\n    /** The message is being encrypted */\n    ENCRYPTING = \"encrypting\",\n\n    /** The event is in the process of being sent. */\n    SENDING = \"sending\",\n\n    /** The event is in a queue waiting to be sent. */\n    QUEUED = \"queued\",\n\n    /** The event has been sent to the server, but we have not yet received the echo. */\n    SENT = \"sent\",\n\n    /** The event was cancelled before it was successfully sent. */\n    CANCELLED = \"cancelled\",\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { UnstableValue } from \"matrix-events-sdk\";\n\n/// The event type storing the user's individual policies.\n///\n/// Exported for testing purposes.\nexport const POLICIES_ACCOUNT_EVENT_TYPE = new UnstableValue(\"m.policies\", \"org.matrix.msc3847.policies\");\n\n/// The key within the user's individual policies storing the user's ignored invites.\n///\n/// Exported for testing purposes.\nexport const IGNORE_INVITES_ACCOUNT_EVENT_KEY = new UnstableValue(\n    \"m.ignore.invites\",\n    \"org.matrix.msc3847.ignore.invites\",\n);\n\n/// The types of recommendations understood.\nexport enum PolicyRecommendation {\n    Ban = \"m.ban\",\n}\n\n/**\n * The various scopes for policies.\n */\nexport enum PolicyScope {\n    /**\n     * The policy deals with an individual user, e.g. reject invites\n     * from this user.\n     */\n    User = \"m.policy.user\",\n\n    /**\n     * The policy deals with a room, e.g. reject invites towards\n     * a specific room.\n     */\n    Room = \"m.policy.room\",\n\n    /**\n     * The policy deals with a server, e.g. reject invites from\n     * this server.\n     */\n    Server = \"m.policy.server\",\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    type CachedReceipt,\n    MAIN_ROOM_TIMELINE,\n    type Receipt,\n    type ReceiptCache,\n    ReceiptType,\n    type WrappedReceipt,\n} from \"../@types/read_receipts.ts\";\nimport { type ListenerMap, TypedEventEmitter } from \"./typed-event-emitter.ts\";\nimport { isSupportedReceiptType } from \"../utils.ts\";\nimport { MatrixEvent } from \"./event.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { type EventTimelineSet } from \"./event-timeline-set.ts\";\nimport { MapWithDefault } from \"../utils.ts\";\nimport { NotificationCountType } from \"./room.ts\";\nimport { logger } from \"../logger.ts\";\nimport { inMainTimelineForReceipt, threadIdForReceipt } from \"../client.ts\";\n\n/**\n * Create a synthetic receipt for the given event\n * @param userId - The user ID if the receipt sender\n * @param event - The event that is to be acknowledged\n * @param receiptType - The type of receipt\n * @param unthreaded - the receipt is unthreaded\n * @returns a new event with the synthetic receipt in it\n */\nexport function synthesizeReceipt(\n    userId: string,\n    event: MatrixEvent,\n    receiptType: ReceiptType,\n    unthreaded = false,\n): MatrixEvent {\n    return new MatrixEvent({\n        content: {\n            [event.getId()!]: {\n                [receiptType]: {\n                    [userId]: {\n                        ts: event.getTs(),\n                        ...(!unthreaded && { thread_id: threadIdForReceipt(event) }),\n                    },\n                },\n            },\n        },\n        type: EventType.Receipt,\n        room_id: event.getRoomId(),\n    });\n}\n\nconst ReceiptPairRealIndex = 0;\nconst ReceiptPairSyntheticIndex = 1;\n\nexport abstract class ReadReceipt<\n    Events extends string,\n    Arguments extends ListenerMap<Events>,\n    SuperclassArguments extends ListenerMap<any> = Arguments,\n> extends TypedEventEmitter<Events, Arguments, SuperclassArguments> {\n    // receipts should clobber based on receipt_type and user_id pairs hence\n    // the form of this structure. This is sub-optimal for the exposed APIs\n    // which pass in an event ID and get back some receipts, so we also store\n    // a pre-cached list for this purpose.\n    // Map: receipt type  user Id  receipt\n    private receipts = new MapWithDefault<\n        string,\n        Map<string, [realReceipt: WrappedReceipt | null, syntheticReceipt: WrappedReceipt | null]>\n    >(() => new Map());\n    private receiptCacheByEventId: ReceiptCache = new Map();\n\n    public abstract getUnfilteredTimelineSet(): EventTimelineSet;\n    public abstract get timeline(): MatrixEvent[];\n\n    /**\n     * Gets the latest receipt for a given user in the room\n     * @param userId - The id of the user for which we want the receipt\n     * @param ignoreSynthesized - Whether to ignore synthesized receipts or not\n     * @param receiptType - Optional. The type of the receipt we want to get\n     * @returns the latest receipts of the chosen type for the chosen user\n     */\n    public getReadReceiptForUserId(\n        userId: string,\n        ignoreSynthesized = false,\n        receiptType = ReceiptType.Read,\n    ): WrappedReceipt | null {\n        const [realReceipt, syntheticReceipt] = this.receipts.get(receiptType)?.get(userId) ?? [null, null];\n        if (ignoreSynthesized) {\n            return realReceipt;\n        }\n\n        return syntheticReceipt ?? realReceipt;\n    }\n\n    private compareReceipts(a: WrappedReceipt, b: WrappedReceipt): number {\n        // Try compare them in our unfiltered timeline set order, falling back to receipt timestamp which should be\n        // relatively sane as receipts are set only by the originating homeserver so as long as its clock doesn't\n        // jump around then it should be valid.\n        return this.getUnfilteredTimelineSet().compareEventOrdering(a.eventId, b.eventId) ?? a.data.ts - b.data.ts;\n    }\n\n    /**\n     * Get the ID of the event that a given user has read up to, or null if:\n     * - we have received no read receipts for them, or\n     * - the receipt we have points at an event we don't have, or\n     * - the thread ID in the receipt does not match the thread root of the\n     *   referenced event.\n     *\n     * (The event might not exist if it is not loaded, and the thread ID might\n     * not match if the event has moved thread because it was redacted.)\n     *\n     * @param userId - The user ID to get read receipt event ID for\n     * @param ignoreSynthesized - If true, return only receipts that have been\n     *                            sent by the server, not implicit ones generated\n     *                            by the JS SDK.\n     * @returns ID of the latest existing event that the given user has read, or null.\n     */\n    public getEventReadUpTo(userId: string, ignoreSynthesized = false): string | null {\n        // Find what the latest receipt says is the latest event we have read\n        const latestReceipt = this.getLatestReceipt(userId, ignoreSynthesized);\n\n        if (!latestReceipt) {\n            return null;\n        }\n\n        return this.receiptPointsAtConsistentEvent(latestReceipt) ? latestReceipt.eventId : null;\n    }\n\n    /**\n     * Returns true if the event pointed at by this receipt exists, and its\n     * threadRootId is consistent with the thread information in the receipt.\n     */\n    private receiptPointsAtConsistentEvent(receipt: WrappedReceipt): boolean {\n        const event = this.findEventById(receipt.eventId);\n        if (!event) {\n            // If the receipt points at a non-existent event, we have multiple\n            // possibilities:\n            //\n            // 1. We don't have the event because it's not loaded yet - probably\n            //    it's old and we're best off ignoring the receipt - we can just\n            //    send a new one when we read a new event.\n            //\n            // 2. We have a bug e.g. we misclassified this event into the wrong\n            //    thread.\n            //\n            // 3. The referenced event moved out of this thread (e.g. because it\n            //    was deleted.)\n            //\n            // 4. The receipt had the incorrect thread ID (due to a bug in a\n            // client, or malicious behaviour).\n\n            // This receipt is not \"valid\" because it doesn't point at an event\n            // we have. We want to pretend it doesn't exist.\n            return false;\n        }\n\n        if (!receipt.data?.thread_id) {\n            // If this is an unthreaded receipt, it could point at any event, so\n            // there is no need to validate further - this receipt is valid.\n            return true;\n        }\n        // Otherwise it is a threaded receipt...\n\n        if (receipt.data.thread_id === MAIN_ROOM_TIMELINE) {\n            // The receipt is for the main timeline: we check that the event is\n            // in the main timeline.\n\n            // Check if the event is in the main timeline\n            const eventIsInMainTimeline = inMainTimelineForReceipt(event);\n\n            if (eventIsInMainTimeline) {\n                // The receipt is for the main timeline, and so is the event, so\n                // the receipt is valid.\n                return true;\n            }\n        } else {\n            // The receipt is for a different thread (not the main timeline)\n\n            if (event.threadRootId === receipt.data.thread_id) {\n                // If the receipt and event agree on the thread ID, the receipt\n                // is valid.\n                return true;\n            }\n        }\n\n        // The receipt thread ID disagrees with the event thread ID. There are 2\n        // possibilities:\n        //\n        // 1. The event moved to a different thread after the receipt was\n        //    created. This can happen if the event was redacted because that\n        //    moves it to the main timeline.\n        //\n        // 2. There is a bug somewhere - either we put the event into the wrong\n        //    thread, or someone sent an incorrect receipt.\n        //\n        // In many cases, we won't get here because the call to findEventById\n        // would have already returned null. We include this check to cover\n        // cases when `this` is a  room, meaning findEventById will find events\n        // in any thread, and to be defensive against unforeseen code paths.\n        logger.warn(\n            `Ignoring receipt because its thread_id (${receipt.data.thread_id}) disagrees ` +\n                `with the thread root (${event.threadRootId}) of the referenced event ` +\n                `(event ID = ${receipt.eventId})`,\n        );\n\n        // This receipt is not \"valid\" because it disagrees with us about what\n        // thread the event is in. We want to pretend it doesn't exist.\n        return false;\n    }\n\n    private getLatestReceipt(userId: string, ignoreSynthesized: boolean): WrappedReceipt | null {\n        // XXX: This is very very ugly and I hope I won't have to ever add a new\n        // receipt type here again. IMHO this should be done by the server in\n        // some more intelligent manner or the client should just use timestamps\n\n        const publicReadReceipt = this.getReadReceiptForUserId(userId, ignoreSynthesized, ReceiptType.Read);\n        const privateReadReceipt = this.getReadReceiptForUserId(userId, ignoreSynthesized, ReceiptType.ReadPrivate);\n\n        // If we have both, compare them\n        let comparison: number | null | undefined;\n        if (publicReadReceipt?.eventId && privateReadReceipt?.eventId) {\n            comparison = this.compareReceipts(publicReadReceipt, privateReadReceipt);\n        }\n\n        // The public receipt is more likely to drift out of date so the private\n        // one has precedence\n        if (!comparison) return privateReadReceipt ?? publicReadReceipt ?? null;\n\n        // If public read receipt is older, return the private one\n        return (comparison < 0 ? privateReadReceipt : publicReadReceipt) ?? null;\n    }\n\n    public addReceiptToStructure(\n        eventId: string,\n        receiptType: ReceiptType,\n        userId: string,\n        receipt: Receipt,\n        synthetic: boolean,\n    ): void {\n        const receiptTypesMap = this.receipts.getOrCreate(receiptType);\n        let pair = receiptTypesMap.get(userId);\n\n        if (!pair) {\n            pair = [null, null];\n            receiptTypesMap.set(userId, pair);\n        }\n\n        let existingReceipt = pair[ReceiptPairRealIndex];\n        if (synthetic) {\n            existingReceipt = pair[ReceiptPairSyntheticIndex] ?? pair[ReceiptPairRealIndex];\n        }\n\n        const wrappedReceipt: WrappedReceipt = {\n            eventId,\n            data: receipt,\n        };\n\n        if (existingReceipt) {\n            // We only want to add this receipt if we think it is later than the one we already have.\n            // This is managed server-side, but because we synthesize RRs locally we have to do it here too.\n            const ordering = this.compareReceipts(existingReceipt, wrappedReceipt);\n            if (ordering >= 0) {\n                return;\n            }\n        }\n\n        const realReceipt = synthetic ? pair[ReceiptPairRealIndex] : wrappedReceipt;\n        const syntheticReceipt = synthetic ? wrappedReceipt : pair[ReceiptPairSyntheticIndex];\n\n        let ordering: number | null = null;\n        if (realReceipt && syntheticReceipt) {\n            ordering = this.getUnfilteredTimelineSet().compareEventOrdering(\n                realReceipt.eventId,\n                syntheticReceipt.eventId,\n            );\n        }\n\n        const preferSynthetic = ordering === null || ordering < 0;\n\n        // we don't bother caching just real receipts by event ID as there's nothing that would read it.\n        // Take the current cached receipt before we overwrite the pair elements.\n        const cachedReceipt = pair[ReceiptPairSyntheticIndex] ?? pair[ReceiptPairRealIndex];\n\n        if (synthetic && preferSynthetic) {\n            pair[ReceiptPairSyntheticIndex] = wrappedReceipt;\n        } else if (!synthetic) {\n            pair[ReceiptPairRealIndex] = wrappedReceipt;\n\n            if (!preferSynthetic) {\n                pair[ReceiptPairSyntheticIndex] = null;\n            }\n        }\n\n        const newCachedReceipt = pair[ReceiptPairSyntheticIndex] ?? pair[ReceiptPairRealIndex];\n        if (cachedReceipt === newCachedReceipt) return;\n\n        // clean up any previous cache entry\n        if (cachedReceipt && this.receiptCacheByEventId.get(cachedReceipt.eventId)) {\n            const previousEventId = cachedReceipt.eventId;\n            // Remove the receipt we're about to clobber out of existence from the cache\n            this.receiptCacheByEventId.set(\n                previousEventId,\n                this.receiptCacheByEventId.get(previousEventId)!.filter((r) => {\n                    return r.type !== receiptType || r.userId !== userId;\n                }),\n            );\n\n            if (this.receiptCacheByEventId.get(previousEventId)!.length < 1) {\n                this.receiptCacheByEventId.delete(previousEventId); // clean up the cache keys\n            }\n        }\n\n        // cache the new one\n        if (!this.receiptCacheByEventId.get(eventId)) {\n            this.receiptCacheByEventId.set(eventId, []);\n        }\n        this.receiptCacheByEventId.get(eventId)!.push({\n            userId: userId,\n            type: receiptType as ReceiptType,\n            data: receipt,\n        });\n    }\n\n    /**\n     * Get a list of receipts for the given event.\n     * @param event - the event to get receipts for\n     * @returns A list of receipts with a userId, type and data keys or\n     * an empty list.\n     */\n    public getReceiptsForEvent(event: MatrixEvent): CachedReceipt[] {\n        return this.receiptCacheByEventId.get(event.getId()!) || [];\n    }\n\n    public abstract addReceipt(event: MatrixEvent, synthetic: boolean): void;\n\n    public abstract setUnread(type: NotificationCountType, count: number): void;\n\n    /**\n     * Look in this room/thread's timeline to find an event. If `this` is a\n     * room, we look in all threads, but if `this` is a thread, we look only\n     * inside this thread.\n     */\n    public abstract findEventById(eventId: string): MatrixEvent | undefined;\n\n    /**\n     * This issue should also be addressed on synapse's side and is tracked as part\n     * of https://github.com/matrix-org/synapse/issues/14837\n     *\n     * Retrieves the read receipt for the logged in user and checks if it matches\n     * the last event in the room and whether that event originated from the logged\n     * in user.\n     * Under those conditions we can consider the context as read. This is useful\n     * because we never send read receipts against our own events\n     * @param userId - the logged in user\n     */\n    public fixupNotifications(userId: string): void {\n        const receipt = this.getReadReceiptForUserId(userId, false);\n\n        const lastEvent = this.timeline[this.timeline.length - 1];\n        if (lastEvent && receipt?.eventId === lastEvent.getId() && userId === lastEvent.getSender()) {\n            this.setUnread(NotificationCountType.Total, 0);\n            this.setUnread(NotificationCountType.Highlight, 0);\n        }\n    }\n\n    /**\n     * Add a temporary local-echo receipt to the room to reflect in the\n     * client the fact that we've sent one.\n     * @param userId - The user ID if the receipt sender\n     * @param e - The event that is to be acknowledged\n     * @param receiptType - The type of receipt\n     * @param unthreaded - the receipt is unthreaded\n     */\n    public addLocalEchoReceipt(userId: string, e: MatrixEvent, receiptType: ReceiptType, unthreaded = false): void {\n        this.addReceipt(synthesizeReceipt(userId, e, receiptType, unthreaded), true);\n    }\n\n    /**\n     * Get a list of user IDs who have <b>read up to</b> the given event.\n     * @param event - the event to get read receipts for.\n     * @returns A list of user IDs.\n     */\n    public getUsersReadUpTo(event: MatrixEvent): string[] {\n        return this.getReceiptsForEvent(event)\n            .filter(function (receipt) {\n                return isSupportedReceiptType(receipt.type);\n            })\n            .map(function (receipt) {\n                return receipt.userId;\n            });\n    }\n\n    /**\n     * Determines if the given user has read a particular event ID with the known\n     * history of the room. This is not a definitive check as it relies only on\n     * what is available to the room at the time of execution.\n     * @param userId - The user ID to check the read state of.\n     * @param eventId - The event ID to check if the user read.\n     * @returns True if the user has read the event, false otherwise.\n     */\n    public abstract hasUserReadEvent(userId: string, eventId: string): boolean;\n\n    /**\n     * Returns the most recent unthreaded receipt for a given user\n     * @param userId - the MxID of the User\n     * @returns an unthreaded Receipt. Can be undefined if receipts have been disabled\n     * or a user chooses to use private read receipts (or we have simply not received\n     * a receipt from this user yet).\n     *\n     * @deprecated use `hasUserReadEvent` or `getEventReadUpTo` instead\n     */\n    public abstract getLastUnthreadedReceiptFor(userId: string): Receipt | undefined;\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { Relations } from \"./relations.ts\";\nimport { type EventType, type RelationType } from \"../@types/event.ts\";\nimport { EventStatus, type MatrixEvent, MatrixEventEvent } from \"./event.ts\";\nimport { type EventTimelineSet } from \"./event-timeline-set.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { type Room } from \"./room.ts\";\n\nexport class RelationsContainer {\n    // A tree of objects to access a set of related children for an event, as in:\n    // this.relations.get(parentEventId).get(relationType).get(relationEventType)\n    private relations = new Map<string, Map<RelationType | string, Map<EventType | string, Relations>>>();\n\n    public constructor(\n        private readonly client: MatrixClient,\n        private readonly room?: Room,\n    ) {}\n\n    /**\n     * Get a collection of child events to a given event in this timeline set.\n     *\n     * @param eventId - The ID of the event that you'd like to access child events for.\n     * For example, with annotations, this would be the ID of the event being annotated.\n     * @param relationType - The type of relationship involved, such as \"m.annotation\", \"m.reference\", \"m.replace\", etc.\n     * @param eventType - The relation event's type, such as \"m.reaction\", etc.\n     * @throws If `eventId</code>, <code>relationType</code> or <code>eventType`\n     * are not valid.\n     *\n     * @returns\n     * A container for relation events or undefined if there are no relation events for\n     * the relationType.\n     */\n    public getChildEventsForEvent(\n        eventId: string,\n        relationType: RelationType | string,\n        eventType: EventType | string,\n    ): Relations | undefined {\n        return this.relations.get(eventId)?.get(relationType)?.get(eventType);\n    }\n\n    public getAllChildEventsForEvent(parentEventId: string): MatrixEvent[] {\n        const relationsForEvent =\n            this.relations.get(parentEventId) ?? new Map<RelationType | string, Map<EventType | string, Relations>>();\n        const events: MatrixEvent[] = [];\n        for (const relationsRecord of relationsForEvent.values()) {\n            for (const relations of relationsRecord.values()) {\n                events.push(...relations.getRelations());\n            }\n        }\n        return events;\n    }\n\n    /**\n     * Set an event as the target event if any Relations exist for it already.\n     * Child events can point to other child events as their parent, so this method may be\n     * called for events which are also logically child events.\n     *\n     * @param event - The event to check as relation target.\n     */\n    public aggregateParentEvent(event: MatrixEvent): void {\n        const relationsForEvent = this.relations.get(event.getId()!);\n        if (!relationsForEvent) return;\n\n        for (const relationsWithRelType of relationsForEvent.values()) {\n            for (const relationsWithEventType of relationsWithRelType.values()) {\n                relationsWithEventType.setTargetEvent(event);\n            }\n        }\n    }\n\n    /**\n     * Add relation events to the relevant relation collection.\n     *\n     * @param event - The new child event to be aggregated.\n     * @param timelineSet - The event timeline set within which to search for the related event if any.\n     */\n    public aggregateChildEvent(event: MatrixEvent, timelineSet?: EventTimelineSet): void {\n        if (event.isRedacted() || event.status === EventStatus.CANCELLED) {\n            return;\n        }\n\n        const relation = event.getRelation();\n        if (!relation) return;\n\n        const onEventDecrypted = (): void => {\n            if (event.isDecryptionFailure()) {\n                // This could for example happen if the encryption keys are not yet available.\n                // The event may still be decrypted later. Register the listener again.\n                event.once(MatrixEventEvent.Decrypted, onEventDecrypted);\n                return;\n            }\n\n            this.aggregateChildEvent(event, timelineSet);\n        };\n\n        // If the event is currently encrypted, wait until it has been decrypted.\n        if (event.isBeingDecrypted() || event.shouldAttemptDecryption()) {\n            event.once(MatrixEventEvent.Decrypted, onEventDecrypted);\n            return;\n        }\n\n        const { event_id: relatesToEventId, rel_type: relationType } = relation;\n        const eventType = event.getType();\n\n        let relationsForEvent = this.relations.get(relatesToEventId!);\n        if (!relationsForEvent) {\n            relationsForEvent = new Map<RelationType | string, Map<EventType | string, Relations>>();\n            this.relations.set(relatesToEventId!, relationsForEvent);\n        }\n\n        let relationsWithRelType = relationsForEvent.get(relationType!);\n        if (!relationsWithRelType) {\n            relationsWithRelType = new Map<EventType | string, Relations>();\n            relationsForEvent.set(relationType!, relationsWithRelType);\n        }\n\n        let relationsWithEventType = relationsWithRelType.get(eventType);\n        if (!relationsWithEventType) {\n            relationsWithEventType = new Relations(relationType!, eventType, this.client);\n            relationsWithRelType.set(eventType, relationsWithEventType);\n\n            const room = this.room ?? timelineSet?.room;\n            const relatesToEvent =\n                timelineSet?.findEventById(relatesToEventId!) ??\n                room?.findEventById(relatesToEventId!) ??\n                room?.getPendingEvent(relatesToEventId!);\n            if (relatesToEvent) {\n                relationsWithEventType.setTargetEvent(relatesToEvent);\n            }\n        }\n\n        relationsWithEventType.addEvent(event);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MAIN_ROOM_TIMELINE, type Receipt, type ReceiptContent } from \"../@types/read_receipts.ts\";\nimport { threadIdForReceipt } from \"../client.ts\";\nimport { type Room, RoomEvent } from \"./room.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { logger } from \"../logger.ts\";\n\n/**\n * The latest receipts we have for a room.\n */\nexport class RoomReceipts {\n    private room: Room;\n    private threadedReceipts: ThreadedReceipts;\n    private unthreadedReceipts: ReceiptsByUser;\n    private danglingReceipts: DanglingReceipts;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.threadedReceipts = new ThreadedReceipts(room);\n        this.unthreadedReceipts = new ReceiptsByUser(room);\n        this.danglingReceipts = new DanglingReceipts();\n        // We listen for timeline events so we can process dangling receipts\n        room.on(RoomEvent.Timeline, this.onTimelineEvent);\n    }\n\n    /**\n     * Remember the receipt information supplied. For each receipt:\n     *\n     * If we don't have the event for this receipt, store it as \"dangling\" so we\n     * can process it later.\n     *\n     * Otherwise store it per-user in either the threaded store for its\n     * thread_id, or the unthreaded store if there is no thread_id.\n     *\n     * Ignores any receipt that is before an existing receipt for the same user\n     * (in the same thread, if applicable). \"Before\" is defined by the\n     * unfilteredTimelineSet of the room.\n     */\n    public add(receiptContent: ReceiptContent, synthetic: boolean): void {\n        /*\n            Transform this structure:\n            {\n              \"$EVENTID\": {\n                \"m.read|m.read.private\": {\n                  \"@user:example.org\": {\n                    \"ts\": 1661,\n                    \"thread_id\": \"main|$THREAD_ROOT_ID\" // or missing/undefined for an unthreaded receipt\n                  }\n                }\n              },\n              ...\n            }\n            into maps of:\n            threaded :: threadid :: userId :: ReceiptInfo\n            unthreaded :: userId :: ReceiptInfo\n            dangling :: eventId :: DanglingReceipt\n        */\n        for (const [eventId, eventReceipt] of Object.entries(receiptContent)) {\n            for (const [receiptType, receiptsByUser] of Object.entries(eventReceipt)) {\n                for (const [userId, receipt] of Object.entries(receiptsByUser)) {\n                    const referencedEvent = this.room.findEventById(eventId);\n                    if (!referencedEvent) {\n                        this.danglingReceipts.add(\n                            new DanglingReceipt(eventId, receiptType, userId, receipt, synthetic),\n                        );\n                    } else if (receipt.thread_id) {\n                        this.threadedReceipts.set(\n                            receipt.thread_id,\n                            eventId,\n                            receiptType,\n                            userId,\n                            receipt.ts,\n                            synthetic,\n                        );\n                    } else {\n                        this.unthreadedReceipts.set(eventId, receiptType, userId, receipt.ts, synthetic);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Look for dangling receipts for the given event ID,\n     * and add them to the thread of unthread receipts if found.\n     * @param event - the event to look for\n     */\n    private onTimelineEvent = (event: MatrixEvent): void => {\n        const eventId = event.getId();\n        if (!eventId) return;\n\n        const danglingReceipts = this.danglingReceipts.remove(eventId);\n\n        danglingReceipts?.forEach((danglingReceipt) => {\n            // The receipt is a thread receipt\n            if (danglingReceipt.receipt.thread_id) {\n                this.threadedReceipts.set(\n                    danglingReceipt.receipt.thread_id,\n                    danglingReceipt.eventId,\n                    danglingReceipt.receiptType,\n                    danglingReceipt.userId,\n                    danglingReceipt.receipt.ts,\n                    danglingReceipt.synthetic,\n                );\n            } else {\n                this.unthreadedReceipts.set(\n                    eventId,\n                    danglingReceipt.receiptType,\n                    danglingReceipt.userId,\n                    danglingReceipt.receipt.ts,\n                    danglingReceipt.synthetic,\n                );\n            }\n        });\n    };\n\n    public hasUserReadEvent(userId: string, eventId: string): boolean {\n        const unthreaded = this.unthreadedReceipts.get(userId);\n        if (unthreaded) {\n            if (isAfterOrSame(unthreaded.eventId, eventId, this.room)) {\n                // The unthreaded receipt is after this event, so we have read it.\n                return true;\n            }\n        }\n\n        const event = this.room.findEventById(eventId);\n        if (!event) {\n            // We don't know whether the user has read it - default to caution and say no.\n            // This shouldn't really happen and feels like it ought to be an exception: let's\n            // log a warn for now.\n            logger.warn(\n                `hasUserReadEvent event ID ${eventId} not found in room ${this.room.roomId}: this shouldn't happen!`,\n            );\n            return false;\n        }\n\n        const threadId = threadIdForReceipt(event);\n        const threaded = this.threadedReceipts.get(threadId, userId);\n        if (threaded) {\n            if (isAfterOrSame(threaded.eventId, eventId, this.room)) {\n                // The threaded receipt is after this event, so we have read it.\n                return true;\n            }\n        }\n\n        // TODO: what if they sent the second-last event in the thread?\n        if (this.userSentLatestEventInThread(threadId, userId)) {\n            // The user sent the latest message in this event's thread, so we\n            // consider everything in the thread to be read.\n            //\n            // Note: maybe we don't need this because synthetic receipts should\n            // do this job for us?\n            return true;\n        }\n\n        // Neither of the receipts were after the event, so it's unread.\n        return false;\n    }\n\n    /**\n     * @returns true if the thread with this ID can be found, and the supplied\n     *          user sent the latest message in it.\n     */\n    private userSentLatestEventInThread(threadId: string, userId: string): boolean {\n        const timeline =\n            threadId === MAIN_ROOM_TIMELINE\n                ? this.room.getLiveTimeline().getEvents()\n                : this.room.getThread(threadId)?.timeline;\n\n        return !!(timeline && timeline.length > 0 && timeline[timeline.length - 1].getSender() === userId);\n    }\n}\n\n// --- implementation details ---\n\n/**\n * The information \"inside\" a receipt once it has been stored inside\n * RoomReceipts - what eventId it refers to, its type, and its ts.\n *\n * Does not contain userId or threadId since these are stored as keys of the\n * maps in RoomReceipts.\n */\nclass ReceiptInfo {\n    public constructor(\n        public eventId: string,\n        public receiptType: string,\n        public ts: number,\n    ) {}\n}\n\n/**\n * Everything we know about a receipt that is \"dangling\" because we can't find\n * the event to which it refers.\n */\nclass DanglingReceipt {\n    public constructor(\n        public eventId: string,\n        public receiptType: string,\n        public userId: string,\n        public receipt: Receipt,\n        public synthetic: boolean,\n    ) {}\n}\n\nclass UserReceipts {\n    private room: Room;\n\n    /**\n     * The real receipt for this user.\n     */\n    private real: ReceiptInfo | undefined;\n\n    /**\n     * The synthetic receipt for this user. If this is defined, it is later than real.\n     */\n    private synthetic: ReceiptInfo | undefined;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.real = undefined;\n        this.synthetic = undefined;\n    }\n\n    public set(synthetic: boolean, receiptInfo: ReceiptInfo): void {\n        if (synthetic) {\n            this.synthetic = receiptInfo;\n        } else {\n            this.real = receiptInfo;\n        }\n\n        // Preserve the invariant: synthetic is only defined if it's later than real\n        if (this.synthetic && this.real) {\n            if (isAfterOrSame(this.real.eventId, this.synthetic.eventId, this.room)) {\n                this.synthetic = undefined;\n            }\n        }\n    }\n\n    /**\n     * Return the latest receipt we have - synthetic if we have one (and it's\n     * later), otherwise real.\n     */\n    public get(): ReceiptInfo | undefined {\n        // Relies on the invariant that synthetic is only defined if it's later than real.\n        return this.synthetic ?? this.real;\n    }\n\n    /**\n     * Return the latest receipt we have of the specified type (synthetic or not).\n     */\n    public getByType(synthetic: boolean): ReceiptInfo | undefined {\n        return synthetic ? this.synthetic : this.real;\n    }\n}\n\n/**\n * The latest receipt info we have, either for a single thread, or all the\n * unthreaded receipts for a room.\n *\n * userId: ReceiptInfo\n */\nclass ReceiptsByUser {\n    private room: Room;\n\n    /** map of userId: UserReceipts */\n    private data: Map<string, UserReceipts>;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.data = new Map<string, UserReceipts>();\n    }\n\n    /**\n     * Add the supplied receipt to our structure, if it is not earlier than the\n     * one we already hold for this user.\n     */\n    public set(eventId: string, receiptType: string, userId: string, ts: number, synthetic: boolean): void {\n        const userReceipts = getOrCreate(this.data, userId, () => new UserReceipts(this.room));\n\n        const existingReceipt = userReceipts.getByType(synthetic);\n        if (existingReceipt && isAfter(existingReceipt.eventId, eventId, this.room)) {\n            // The new receipt is before the existing one - don't store it.\n            return;\n        }\n\n        // Possibilities:\n        //\n        // 1. there was no existing receipt, or\n        // 2. the existing receipt was before this one, or\n        // 3. we were unable to compare the receipts.\n        //\n        // In the case of 3 it's difficult to decide what to do, so the\n        // most-recently-received receipt wins.\n        //\n        // Case 3 can only happen if the events for these receipts have\n        // disappeared, which is quite unlikely since the new one has just been\n        // checked, and the old one was checked before it was inserted here.\n        //\n        // We go ahead and store this receipt (replacing the other if it exists)\n        userReceipts.set(synthetic, new ReceiptInfo(eventId, receiptType, ts));\n    }\n\n    /**\n     * Find the latest receipt we have for this user. (Note - there is only one\n     * receipt per user, because we are already inside a specific thread or\n     * unthreaded list.)\n     *\n     * If there is a later synthetic receipt for this user, return that.\n     * Otherwise, return the real receipt.\n     *\n     * @returns the found receipt info, or undefined if we have no receipt for this user.\n     */\n    public get(userId: string): ReceiptInfo | undefined {\n        return this.data.get(userId)?.get();\n    }\n}\n\n/**\n * The latest threaded receipts we have for a room.\n */\nclass ThreadedReceipts {\n    private room: Room;\n\n    /** map of threadId: ReceiptsByUser */\n    private data: Map<string, ReceiptsByUser>;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.data = new Map<string, ReceiptsByUser>();\n    }\n\n    /**\n     * Add the supplied receipt to our structure, if it is not earlier than one\n     * we already hold for this user in this thread.\n     */\n    public set(\n        threadId: string,\n        eventId: string,\n        receiptType: string,\n        userId: string,\n        ts: number,\n        synthetic: boolean,\n    ): void {\n        const receiptsByUser = getOrCreate(this.data, threadId, () => new ReceiptsByUser(this.room));\n        receiptsByUser.set(eventId, receiptType, userId, ts, synthetic);\n    }\n\n    /**\n     * Find the latest threaded receipt for the supplied user in the supplied thread.\n     *\n     * @returns the found receipt info or undefined if we don't have one.\n     */\n    public get(threadId: string, userId: string): ReceiptInfo | undefined {\n        return this.data.get(threadId)?.get(userId);\n    }\n}\n\n/**\n * All the receipts that we have received but can't process because we can't\n * find the event they refer to.\n *\n * We hold on to them so we can process them if their event arrives later.\n */\nclass DanglingReceipts {\n    /**\n     * eventId: DanglingReceipt[]\n     */\n    private data = new Map<string, Array<DanglingReceipt>>();\n\n    /**\n     * Remember the supplied dangling receipt.\n     */\n    public add(danglingReceipt: DanglingReceipt): void {\n        const danglingReceipts = getOrCreate(this.data, danglingReceipt.eventId, () => []);\n        danglingReceipts.push(danglingReceipt);\n    }\n\n    /**\n     * Remove and return the dangling receipts for the given event ID.\n     * @param eventId - the event ID to look for\n     * @returns the found dangling receipts, or undefined if we don't have one.\n     */\n    public remove(eventId: string): Array<DanglingReceipt> | undefined {\n        const danglingReceipts = this.data.get(eventId);\n        this.data.delete(eventId);\n        return danglingReceipts;\n    }\n}\n\nfunction getOrCreate<K, V>(m: Map<K, V>, key: K, createFn: () => V): V {\n    const found = m.get(key);\n    if (found) {\n        return found;\n    } else {\n        const created = createFn();\n        m.set(key, created);\n        return created;\n    }\n}\n\n/**\n * Is left after right (or the same)?\n *\n * Only returns true if both events can be found, and left is after or the same\n * as right.\n *\n * @returns left \\>= right\n */\nfunction isAfterOrSame(leftEventId: string, rightEventId: string, room: Room): boolean {\n    const comparison = room.compareEventOrdering(leftEventId, rightEventId);\n    return comparison !== null && comparison >= 0;\n}\n\n/**\n * Is left strictly after right?\n *\n * Only returns true if both events can be found, and left is strictly after right.\n *\n * @returns left \\> right\n */\nfunction isAfter(leftEventId: string, rightEventId: string, room: Room): boolean {\n    const comparison = room.compareEventOrdering(leftEventId, rightEventId);\n    return comparison !== null && comparison > 0;\n}\n","import { logger as loggerInstance } from \"../logger.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\n\nconst logger = loggerInstance.getChild(\"RoomStickyEvents\");\n\nexport enum RoomStickyEventsEvent {\n    Update = \"RoomStickyEvents.Update\",\n}\n\nexport type StickyMatrixEvent = MatrixEvent & { unstableStickyExpiresAt: number };\n\nexport type RoomStickyEventsMap = {\n    /**\n     * Fires when any sticky event changes happen in a room.\n     * @param added Any new sticky events with no predecessor events (matching sender, type, and sticky_key)\n     * @param updated Any sticky events that supersede an existing event (matching sender, type, and sticky_key)\n     * @param removed The events that were removed from the map due to expiry.\n     */\n    [RoomStickyEventsEvent.Update]: (\n        added: StickyMatrixEvent[],\n        updated: { current: StickyMatrixEvent; previous: StickyMatrixEvent }[],\n        removed: StickyMatrixEvent[],\n    ) => void;\n};\n\ntype UserId = `@${string}`;\n\nfunction assertIsUserId(value: unknown): asserts value is UserId {\n    if (typeof value !== \"string\") throw new Error(\"Not a string\");\n    if (!value.startsWith(\"@\")) throw new Error(\"Not a userId\");\n}\n\n/**\n * Tracks sticky events on behalf of one room, and fires an event\n * whenever a sticky event is updated or replaced.\n */\nexport class RoomStickyEventsStore extends TypedEventEmitter<RoomStickyEventsEvent, RoomStickyEventsMap> {\n    /**\n     * Sticky event map is a nested map of:\n     *  eventType -> `content.sticky_key sender` -> StickyMatrixEvent[]\n     *\n     * The events are ordered in latest to earliest expiry, so that the first event\n     * in the array will always be the \"current\" one.\n     */\n    private readonly stickyEventsMap = new Map<string, Map<string, StickyMatrixEvent[]>>();\n    /**\n     * These are sticky events that have no sticky key and therefore exist outside the tuple\n     * system above. They are just held in this Set until they expire.\n     */\n    private readonly unkeyedStickyEvents = new Set<StickyMatrixEvent>();\n\n    private stickyEventTimer?: ReturnType<typeof setTimeout>;\n    private nextStickyEventExpiryTs: number = Number.MAX_SAFE_INTEGER;\n\n    /**\n     * Sort two sticky events by order of expiry. This assumes the sticky events have the same\n     * `type`, `sticky_key` and `sender`.\n     * @returns A positive value if event A will expire sooner, or a negative value if event B will expire sooner.\n     */\n    private static sortStickyEvent(eventA: StickyMatrixEvent, eventB: StickyMatrixEvent): number {\n        // Sticky events with the same key have to use the same expiration duration.\n        // Hence, comparing via `origin_server_ts` yields the exact same result as comparing their expiration time.\n        if (eventB.getTs() !== eventA.getTs()) {\n            return eventB.getTs() - eventA.getTs();\n        }\n\n        if ((eventB.getId() ?? \"\") > (eventA.getId() ?? \"\")) {\n            return 1;\n        }\n\n        // This should fail as we've got corruption in our sticky array.\n        throw Error(\"Comparing two sticky events with the same event ID is not allowed.\");\n    }\n\n    /**\n     * Generate the correct key for an event to be found in the inner maps of `stickyEventsMap`.\n     * @param stickyKey The sticky key of an event.\n     * @param sender The sender of the event.\n     */\n    private static stickyMapKey(stickyKey: string, sender: UserId): string {\n        return `${stickyKey}${sender}`;\n    }\n\n    /**\n     * Get all sticky events that are currently active.\n     * @returns An iterable set of events.\n     */\n    public *getStickyEvents(): Iterable<StickyMatrixEvent> {\n        yield* this.unkeyedStickyEvents;\n        for (const innerMap of this.stickyEventsMap.values()) {\n            // Inner map contains a map of sender+stickykeys => all sticky events\n            for (const events of innerMap.values()) {\n                // The first sticky event is the \"current\" one in the sticky map.\n                yield events[0];\n            }\n        }\n    }\n\n    /**\n     * Get an active sticky event that match the given `type`, `sender`, and `stickyKey`\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @param stickyKey The sticky key used by the event.\n     * @returns A matching active sticky event, or undefined.\n     */\n    public getKeyedStickyEvent(sender: string, type: string, stickyKey: string): StickyMatrixEvent | undefined {\n        assertIsUserId(sender);\n        return this.stickyEventsMap.get(type)?.get(RoomStickyEventsStore.stickyMapKey(stickyKey, sender))?.[0];\n    }\n\n    /**\n     * Get active sticky events without a sticky key that match the given `type` and `sender`.\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @returns An array of matching sticky events.\n     */\n    public getUnkeyedStickyEvent(sender: string, type: string): StickyMatrixEvent[] {\n        return [...this.unkeyedStickyEvents].filter((ev) => ev.getType() === type && ev.getSender() === sender);\n    }\n\n    /**\n     * Adds a sticky event into the local sticky event map.\n     *\n     * NOTE: This will not cause `RoomEvent.StickyEvents` to be emitted.\n     *\n     * @throws If the `event` does not contain valid sticky data.\n     * @param event The MatrixEvent that contains sticky data.\n     * @returns An object describing whether the event was added to the map,\n     *          and the previous event it may have replaced.\n     */\n    private addStickyEvent(event: MatrixEvent): { added: true; prevEvent?: StickyMatrixEvent } | { added: false } {\n        const stickyKey = event.getContent().msc4354_sticky_key;\n        if (typeof stickyKey !== \"string\" && stickyKey !== undefined) {\n            throw new Error(`${event.getId()} is missing msc4354_sticky_key`);\n        }\n\n        // With this we have the guarantee, that all events in stickyEventsMap are correctly formatted\n        if (event.unstableStickyExpiresAt === undefined) {\n            throw new Error(`${event.getId()} is missing msc4354_sticky.duration_ms`);\n        }\n        const sender = event.getSender();\n        const type = event.getType();\n        assertIsUserId(sender);\n        if (event.unstableStickyExpiresAt <= Date.now()) {\n            logger.info(\"ignored sticky event with older expiration time than current time\", stickyKey);\n            return { added: false };\n        }\n\n        // While we fully expect the server to always provide the correct value,\n        // this is just insurance to protect against attacks on our Map.\n        if (!sender.startsWith(\"@\")) {\n            throw new Error(\"Expected sender to start with @\");\n        }\n\n        const stickyEvent = event as StickyMatrixEvent;\n\n        if (stickyKey === undefined) {\n            this.unkeyedStickyEvents.add(stickyEvent);\n            // Recalculate the next expiry time.\n            this.nextStickyEventExpiryTs = Math.min(event.unstableStickyExpiresAt, this.nextStickyEventExpiryTs);\n\n            this.scheduleStickyTimer();\n            return { added: true };\n        }\n\n        // Why this is safe:\n        // A type may contain anything but the *sender* is tightly\n        // constrained so that a key will always end with a @<user_id>\n        // E.g. Where a malicious event type might be \"rtc.member.event@foo:bar\" the key becomes:\n        // \"rtc.member.event.@foo:bar@bar:baz\"\n        const innerMapKey = RoomStickyEventsStore.stickyMapKey(stickyKey, sender);\n        const currentEventSet = [stickyEvent, ...(this.stickyEventsMap.get(type)?.get(innerMapKey) ?? [])].sort(\n            RoomStickyEventsStore.sortStickyEvent,\n        );\n        if (!this.stickyEventsMap.has(type)) {\n            this.stickyEventsMap.set(type, new Map());\n        }\n        this.stickyEventsMap.get(type)?.set(innerMapKey, currentEventSet);\n\n        // Recalculate the next expiry time.\n        this.nextStickyEventExpiryTs = Math.min(stickyEvent.unstableStickyExpiresAt, this.nextStickyEventExpiryTs);\n\n        this.scheduleStickyTimer();\n        return {\n            added: currentEventSet[0] === stickyEvent,\n            prevEvent: currentEventSet?.[1],\n        };\n    }\n\n    /**\n     * Add a series of sticky events, emitting `RoomEvent.StickyEvents` if any\n     * changes were made.\n     * @param events A set of new sticky events.\n     */\n    public addStickyEvents(events: MatrixEvent[]): void {\n        const added: StickyMatrixEvent[] = [];\n        const updated: { current: StickyMatrixEvent; previous: StickyMatrixEvent }[] = [];\n        for (const event of events) {\n            try {\n                const result = this.addStickyEvent(event);\n                if (result.added) {\n                    if (result.prevEvent) {\n                        // e is validated as a StickyMatrixEvent by virtue of `addStickyEvent` returning added: true.\n                        updated.push({ current: event as StickyMatrixEvent, previous: result.prevEvent });\n                    } else {\n                        added.push(event as StickyMatrixEvent);\n                    }\n                }\n            } catch (ex) {\n                logger.warn(\"ignored invalid sticky event\", ex);\n            }\n        }\n        if (added.length || updated.length) this.emit(RoomStickyEventsEvent.Update, added, updated, []);\n        this.scheduleStickyTimer();\n    }\n\n    /**\n     * Schedule the sticky event expiry timer. The timer will\n     * run immediately if an event has already expired.\n     */\n    private scheduleStickyTimer(): void {\n        if (this.stickyEventTimer) {\n            clearTimeout(this.stickyEventTimer);\n            this.stickyEventTimer = undefined;\n        }\n        if (this.nextStickyEventExpiryTs === Number.MAX_SAFE_INTEGER) {\n            // We have no events due to expire.\n            return;\n        } // otherwise, schedule in the future\n        this.stickyEventTimer = setTimeout(this.cleanExpiredStickyEvents, this.nextStickyEventExpiryTs - Date.now());\n    }\n\n    /**\n     * Clean out any expired sticky events.\n     */\n    private readonly cleanExpiredStickyEvents = (): void => {\n        const now = Date.now();\n        const removedEvents: StickyMatrixEvent[] = [];\n\n        // We will recalculate this as we check all events.\n        this.nextStickyEventExpiryTs = Number.MAX_SAFE_INTEGER;\n        for (const [eventType, innerEvents] of this.stickyEventsMap.entries()) {\n            for (const [innerMapKey, [currentEvent, ...previousEvents]] of innerEvents) {\n                // we only added items with `sticky` into this map so we can assert non-null here\n                if (now >= currentEvent.unstableStickyExpiresAt) {\n                    logger.debug(\"Expiring sticky event\", currentEvent.getId());\n                    removedEvents.push(currentEvent);\n                    this.stickyEventsMap.get(eventType)!.delete(innerMapKey);\n                } else {\n                    // Ensure we remove any previous events which have now expired, to avoid unbounded memory consumption.\n                    this.stickyEventsMap\n                        .get(eventType)!\n                        .set(innerMapKey, [\n                            currentEvent,\n                            ...previousEvents.filter((e) => e.unstableStickyExpiresAt <= now),\n                        ]);\n                    // If not removing the event, check to see if it's the next lowest expiry.\n                    this.nextStickyEventExpiryTs = Math.min(\n                        this.nextStickyEventExpiryTs,\n                        currentEvent.unstableStickyExpiresAt,\n                    );\n                }\n            }\n            // Clean up map after use.\n            if (this.stickyEventsMap.get(eventType)?.size === 0) {\n                this.stickyEventsMap.delete(eventType);\n            }\n        }\n        for (const event of this.unkeyedStickyEvents) {\n            if (now >= event.unstableStickyExpiresAt) {\n                logger.debug(\"Expiring sticky event\", event.getId());\n                this.unkeyedStickyEvents.delete(event);\n                removedEvents.push(event);\n            } else {\n                // If not removing the event, check to see if it's the next lowest expiry.\n                this.nextStickyEventExpiryTs = Math.min(this.nextStickyEventExpiryTs, event.unstableStickyExpiresAt);\n            }\n        }\n        if (removedEvents.length) {\n            this.emit(RoomStickyEventsEvent.Update, [], [], removedEvents);\n        }\n        // Finally, schedule the next run.\n        this.scheduleStickyTimer();\n    };\n\n    /**\n     * Handles incoming event redactions. Checks the sticky map\n     * for any active sticky events being redacted.\n     * @param redactedEvent The MatrixEvent OR event ID of the event being redacted. MAY not be a sticky event.\n     */\n    public handleRedaction(redactedEvent: MatrixEvent | string): void {\n        // Note, we do not adjust`nextStickyEventExpiryTs` here.\n        // If this event happens to be the most recent expiring event\n        // then we may do one extra iteration of cleanExpiredStickyEvents\n        // but this saves us having to iterate over all events here to calculate\n        // the next expiry time.\n\n        // Note, as soon as we find a positive match on an event in this function\n        // we can return. There is no need to continue iterating on a positive match\n        // as an event can only appear in one map.\n\n        // Handle unkeyedStickyEvents first since it's *quick*.\n        const redactEventId = typeof redactedEvent === \"string\" ? redactedEvent : redactedEvent.getId();\n        for (const event of this.unkeyedStickyEvents) {\n            if (event.getId() === redactEventId) {\n                this.unkeyedStickyEvents.delete(event);\n                this.emit(RoomStickyEventsEvent.Update, [], [], [event]);\n                return;\n            }\n        }\n\n        // Faster method of finding the event since we have the event cached.\n        if (typeof redactedEvent !== \"string\" && !redactedEvent.isRedacted()) {\n            const stickyKey = redactedEvent.getContent().msc4354_sticky_key;\n            if (typeof stickyKey !== \"string\" && stickyKey !== undefined) {\n                return; // Not a sticky event.\n            }\n            const eventType = redactedEvent.getType();\n            const sender = redactedEvent.getSender();\n            assertIsUserId(sender);\n            const innerMap = this.stickyEventsMap.get(eventType);\n            if (!innerMap) {\n                return;\n            }\n            const mapKey = RoomStickyEventsStore.stickyMapKey(stickyKey, sender);\n            const [currentEvent, ...previousEvents] = innerMap.get(mapKey) ?? [];\n            if (!currentEvent) {\n                // No event current in the map so ignore.\n                return;\n            }\n            logger.debug(`Redaction for ${redactEventId} under sticky key ${stickyKey}`);\n            // Revert to previous state, taking care to skip any other redacted events.\n            const newEvents = previousEvents.filter((e) => !e.isRedacted()).sort(RoomStickyEventsStore.sortStickyEvent);\n            this.stickyEventsMap.get(eventType)?.set(mapKey, newEvents);\n            if (newEvents.length) {\n                this.emit(\n                    RoomStickyEventsEvent.Update,\n                    [],\n                    [\n                        {\n                            // This looks confusing. This emits that the newer event\n                            // has been redacted and the previous event has taken it's place.\n                            previous: currentEvent,\n                            current: newEvents[0],\n                        },\n                    ],\n                    [],\n                );\n            } else {\n                // We did not find a previous event, so just expire.\n                innerMap.delete(mapKey);\n                if (innerMap.size === 0) {\n                    this.stickyEventsMap.delete(eventType);\n                }\n                this.emit(RoomStickyEventsEvent.Update, [], [], [currentEvent]);\n            }\n            return;\n        }\n\n        // We only know the event ID of the redacted event, so we need to\n        // traverse the map to find our event.\n        for (const innerMap of this.stickyEventsMap.values()) {\n            for (const [currentEvent] of innerMap.values()) {\n                if (currentEvent.getId() !== redactEventId) {\n                    continue;\n                }\n                // Found the event.\n                return this.handleRedaction(currentEvent);\n            }\n        }\n    }\n\n    /**\n     * Clear all events and stop the timer from firing.\n     */\n    public clear(): void {\n        this.stickyEventsMap.clear();\n        // Unschedule timer.\n        this.nextStickyEventExpiryTs = Number.MAX_SAFE_INTEGER;\n        this.scheduleStickyTimer();\n    }\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * A stripped m.room.member event which contains the key renderable fields from the event,\n * sent only in simplified sliding sync (not `/v3/sync`).\n * This is very similar to MSC4186Hero from sliding-sync.ts but an internal format with\n * camelCase rather than underscores.\n */\nexport type Hero = {\n    userId: string;\n    displayName?: string;\n    avatarUrl?: string;\n    /**\n     * If true, the hero is from an MSC4186 summary, in which case `displayName` and `avatarUrl` will\n     * have been set by the server if available. If false, the `Hero` has been constructed from a `/v3/sync` response,\n     * so these fields will always be undefined.\n     */\n    fromMSC4186: boolean;\n};\n\n/**\n * High level summary information for a room, as returned by `/v3/sync`.\n */\nexport interface IRoomSummary {\n    /**\n     * The room heroes: a selected set of members that can be used when summarising or\n     * generating a name for a room. List of user IDs.\n     */\n    \"m.heroes\": string[];\n    /**\n     * The number of joined members in the room.\n     */\n    \"m.joined_member_count\"?: number;\n    /**\n     * The number of invited members in the room.\n     */\n    \"m.invited_member_count\"?: number;\n}\n\ninterface IInfo {\n    /** The title of the room (e.g. `m.room.name`) */\n    title: string;\n    /** The description of the room (e.g. `m.room.topic`) */\n    desc?: string;\n    /** The number of joined users. */\n    numMembers?: number;\n    /** The list of aliases for this room. */\n    aliases?: string[];\n    /** The timestamp for this room. */\n    timestamp?: number;\n}\n\n/**\n * Construct a new Room Summary. A summary can be used for display on a recent\n * list, without having to load the entire room list into memory.\n * @param roomId - Required. The ID of this room.\n * @param info - Optional. The summary info. Additional keys are supported.\n */\nexport class RoomSummary {\n    public constructor(\n        public readonly roomId: string,\n        info?: IInfo,\n    ) {}\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MetadataService, OidcClientSettingsStore } from \"oidc-client-ts\";\n\nimport { validateAuthMetadata } from \"./validate.ts\";\nimport { Method, timeoutSignal } from \"../http-api/index.ts\";\nimport { type OidcClientConfig } from \"./index.ts\";\n\n/**\n * @experimental\n * Discover and validate delegated auth configuration\n * - delegated auth issuer openid-configuration is reachable\n * - delegated auth issuer openid-configuration is configured correctly for us\n * Fetches https://oidc-issuer.example.com/.well-known/openid-configuration and other files linked therein.\n * When successful, validated metadata is returned\n * @param issuer - the OIDC issuer as returned by the /auth_issuer API\n * @returns validated authentication metadata and optionally signing keys\n * @throws when delegated auth config is invalid or unreachable\n * @deprecated in favour of {@link MatrixClient#getAuthMetadata}\n */\nexport const discoverAndValidateOIDCIssuerWellKnown = async (issuer: string): Promise<OidcClientConfig> => {\n    const issuerOpenIdConfigUrl = new URL(\".well-known/openid-configuration\", issuer);\n    const issuerWellKnownResponse = await fetch(issuerOpenIdConfigUrl, {\n        method: Method.Get,\n        signal: timeoutSignal(5000),\n    });\n    const issuerWellKnown = await issuerWellKnownResponse.json();\n    return validateAuthMetadataAndKeys(issuerWellKnown);\n};\n\n/**\n * @experimental\n * Validate the authentication metadata and fetch the signing keys from the jwks_uri in the metadata\n * @param authMetadata - the authentication metadata to validate\n * @returns validated authentication metadata and signing keys\n */\nexport const validateAuthMetadataAndKeys = async (authMetadata: unknown): Promise<OidcClientConfig> => {\n    const validatedIssuerConfig = validateAuthMetadata(authMetadata);\n\n    // create a temporary settings store, so we can use metadata service for discovery\n    const settings = new OidcClientSettingsStore({\n        authority: validatedIssuerConfig.issuer,\n        metadata: validatedIssuerConfig,\n        redirect_uri: \"\", // Not known yet, this is here to make the type checker happy\n        client_id: \"\", // Not known yet, this is here to make the type checker happy\n    });\n    const metadataService = new MetadataService(settings);\n\n    return {\n        ...validatedIssuerConfig,\n        signingKeys: await metadataService.getSigningKeys(),\n    };\n};\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Errors expected to be encountered during OIDC discovery, client registration, and authentication.\n * Not intended to be displayed directly to the user.\n */\nexport enum OidcError {\n    NotSupported = \"OIDC authentication not supported\",\n    Misconfigured = \"OIDC is misconfigured\",\n    General = \"Something went wrong with OIDC discovery\",\n    OpSupport = \"Configured OIDC OP does not support required functions\",\n    DynamicRegistrationNotSupported = \"Dynamic registration not supported\",\n    DynamicRegistrationFailed = \"Dynamic registration failed\",\n    DynamicRegistrationInvalid = \"Dynamic registration invalid response\",\n    CodeExchangeFailed = \"Failed to exchange code for token\",\n    InvalidBearerTokenResponse = \"Invalid bearer token response\",\n    InvalidIdToken = \"Invalid ID token\",\n    MissingOrInvalidStoredState = \"State required to finish logging in is not found in storage.\",\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { deepCompare, escapeRegExp, globToRegexp, isNullOrUndefined } from \"./utils.ts\";\nimport { type Logger } from \"./logger.ts\";\nimport { type MatrixClient } from \"./client.ts\";\nimport { type MatrixEvent } from \"./models/event.ts\";\nimport {\n    ConditionKind,\n    type IAnnotatedPushRule,\n    type ICallStartedCondition,\n    type ICallStartedPrefixCondition,\n    type IContainsDisplayNameCondition,\n    type IEventMatchCondition,\n    type IEventPropertyContainsCondition,\n    type IEventPropertyIsCondition,\n    type IPushRule,\n    type IPushRules,\n    type IRoomMemberCountCondition,\n    type ISenderNotificationPermissionCondition,\n    type PushRuleAction,\n    PushRuleActionName,\n    type PushRuleCondition,\n    PushRuleKind,\n    type PushRuleSet,\n    RuleId,\n    TweakName,\n} from \"./@types/PushRules.ts\";\nimport { EventType } from \"./@types/event.ts\";\n\nconst RULEKINDS_IN_ORDER = [\n    PushRuleKind.Override,\n    PushRuleKind.ContentSpecific,\n    PushRuleKind.RoomSpecific,\n    PushRuleKind.SenderSpecific,\n    PushRuleKind.Underride,\n];\n\n// The default override rules to apply to the push rules that arrive from the server.\n// We do this for two reasons:\n//   1. Synapse is unlikely to send us the push rule in an incremental sync - see\n//      https://github.com/matrix-org/synapse/pull/4867#issuecomment-481446072 for\n//      more details.\n//   2. We often want to start using push rules ahead of the server supporting them,\n//      and so we can put them here.\nconst DEFAULT_OVERRIDE_RULES: Record<string, IPushRule> = {\n    \".m.rule.is_room_mention\": {\n        // Matrix v1.7\n        rule_id: \".m.rule.is_room_mention\",\n        default: true,\n        enabled: true,\n        conditions: [\n            {\n                kind: ConditionKind.EventPropertyIs,\n                key: \"content.m\\\\.mentions.room\",\n                value: true,\n            },\n            {\n                kind: ConditionKind.SenderNotificationPermission,\n                key: \"room\",\n            },\n        ],\n        actions: [\n            PushRuleActionName.Notify,\n            {\n                set_tweak: TweakName.Highlight,\n            },\n        ],\n    },\n    \".m.rule.reaction\": {\n        // For homeservers which don't support MSC2153 yet\n        rule_id: \".m.rule.reaction\",\n        default: true,\n        enabled: true,\n        conditions: [\n            {\n                kind: ConditionKind.EventMatch,\n                key: \"type\",\n                pattern: \"m.reaction\",\n            },\n        ],\n        actions: [PushRuleActionName.DontNotify],\n    },\n    \".org.matrix.msc3786.rule.room.server_acl\": {\n        // For homeservers which don't support MSC3786 yet\n        rule_id: \".org.matrix.msc3786.rule.room.server_acl\",\n        default: true,\n        enabled: true,\n        conditions: [\n            {\n                kind: ConditionKind.EventMatch,\n                key: \"type\",\n                pattern: EventType.RoomServerAcl,\n            },\n            {\n                kind: ConditionKind.EventMatch,\n                key: \"state_key\",\n                pattern: \"\",\n            },\n        ],\n        actions: [],\n    },\n};\n\n// A special rule id for `EXPECTED_DEFAULT_OVERRIDE_RULE_IDS` and friends which denotes where user-defined rules live in the order.\nconst UserDefinedRules = Symbol(\"UserDefinedRules\");\n\ntype OrderedRules = Array<string | typeof UserDefinedRules>;\n\nconst EXPECTED_DEFAULT_OVERRIDE_RULE_IDS: OrderedRules = [\n    RuleId.Master,\n    UserDefinedRules,\n    RuleId.SuppressNotices,\n    RuleId.InviteToSelf,\n    RuleId.MemberEvent,\n    RuleId.IsUserMention,\n    RuleId.ContainsDisplayName,\n    RuleId.IsRoomMention,\n    RuleId.AtRoomNotification,\n    RuleId.Tombstone,\n    \".m.rule.reaction\",\n    \".m.rule.room.server_acl\",\n    \".org.matrix.msc3786.rule.room.server_acl\",\n    \".m.rule.suppress_edits\",\n];\n\nconst DEFAULT_UNDERRIDE_RULES: Record<string, IPushRule> = {\n    \".org.matrix.msc3914.rule.room.call\": {\n        // For homeservers which don't support MSC3914 yet\n        rule_id: \".org.matrix.msc3914.rule.room.call\",\n        default: true,\n        enabled: true,\n        conditions: [\n            {\n                kind: ConditionKind.EventMatch,\n                key: \"type\",\n                pattern: \"org.matrix.msc3401.call\",\n            },\n            {\n                kind: ConditionKind.CallStarted,\n            },\n        ],\n        actions: [PushRuleActionName.Notify, { set_tweak: TweakName.Sound, value: \"default\" }],\n    },\n};\n\nconst EXPECTED_DEFAULT_UNDERRIDE_RULE_IDS: OrderedRules = [\n    UserDefinedRules,\n    RuleId.IncomingCall,\n    \".org.matrix.msc3914.rule.room.call\",\n    RuleId.EncryptedDM,\n    RuleId.DM,\n    RuleId.Message,\n    RuleId.EncryptedMessage,\n];\n\n/**\n * Make sure that each of the rules listed in `defaultRuleIds` is listed in the given set of push rules.\n *\n * @param logger - A `Logger` to write log messages to.\n * @param kind - the kind of push rule set being merged.\n * @param incomingRules - the existing set of known push rules for the user.\n * @param defaultRules - a lookup table for the default definitions of push rules.\n * @param orderedRuleIds - the IDs of the expected push rules, in order.\n *\n * @returns A copy of `incomingRules`, with any missing default rules inserted in the right place.\n */\nfunction mergeRulesWithDefaults(\n    logger: Logger,\n    kind: PushRuleKind,\n    incomingRules: IPushRule[],\n    defaultRules: Record<string, IPushRule>,\n    orderedRuleIds: OrderedRules,\n): IPushRule[] {\n    // Split the incomingRules into defaults and custom\n    const incomingDefaultRules = incomingRules.filter((rule) => rule.default);\n    const incomingCustomRules = incomingRules.filter((rule) => !rule.default);\n\n    function insertDefaultPushRule(ruleId: OrderedRules[number]): void {\n        if (ruleId === UserDefinedRules) {\n            // Re-insert any user-defined rules that were in `incomingRules`\n            newRules.push(...incomingCustomRules);\n        } else if (ruleId in defaultRules) {\n            logger.warn(`Adding default global ${kind} push rule ${ruleId}`);\n            newRules.push(defaultRules[ruleId]);\n        } else {\n            logger.warn(`Missing default global ${kind} push rule ${ruleId}`);\n        }\n    }\n\n    let nextExpectedRuleIdIndex = 0;\n    const newRules: IPushRule[] = [];\n    // Merge our expected rules (including the incoming custom rules) into the incoming default rules.\n    for (const rule of incomingDefaultRules) {\n        const ruleIndex = orderedRuleIds.indexOf(rule.rule_id);\n        if (ruleIndex === -1) {\n            // an unrecognised rule; copy it over\n            newRules.push(rule);\n            continue;\n        }\n        while (ruleIndex > nextExpectedRuleIdIndex) {\n            // insert new rules\n            const defaultRuleId = orderedRuleIds[nextExpectedRuleIdIndex];\n            insertDefaultPushRule(defaultRuleId);\n            nextExpectedRuleIdIndex += 1;\n        }\n        // copy over the existing rule\n        newRules.push(rule);\n        nextExpectedRuleIdIndex += 1;\n    }\n\n    // Now copy over any remaining default rules\n    for (const ruleId of orderedRuleIds.slice(nextExpectedRuleIdIndex)) {\n        insertDefaultPushRule(ruleId);\n    }\n\n    return newRules;\n}\n\nexport interface IActionsObject {\n    /** Whether this event should notify the user or not. */\n    notify: boolean;\n    /** How this event should be notified. */\n    tweaks: Partial<Record<TweakName, any>>;\n}\n\nexport class PushProcessor {\n    /**\n     * Construct a Push Processor.\n     * @param client - The Matrix client object to use\n     */\n    public constructor(private readonly client: MatrixClient) {}\n\n    /**\n     * Maps the original key from the push rules to a list of property names\n     * after unescaping.\n     */\n    private readonly parsedKeys = new Map<string, string[]>();\n\n    /**\n     * Convert a list of actions into a object with the actions as keys and their values\n     * @example\n     * eg. `[ 'notify', { set_tweak: 'sound', value: 'default' } ]`\n     *     becomes `{ notify: true, tweaks: { sound: 'default' } }`\n     * @param actionList - The actions list\n     *\n     * @returns A object with key 'notify' (true or false) and an object of actions\n     */\n    public static actionListToActionsObject(actionList: PushRuleAction[]): IActionsObject {\n        const actionObj: IActionsObject = { notify: false, tweaks: {} };\n        for (const action of actionList) {\n            if (action === PushRuleActionName.Notify) {\n                actionObj.notify = true;\n            } else if (typeof action === \"object\") {\n                if (action.value === undefined) {\n                    action.value = true;\n                }\n                actionObj.tweaks[action.set_tweak] = action.value;\n            }\n        }\n        return actionObj;\n    }\n\n    /**\n     * Rewrites conditions on a client's push rules to match the defaults\n     * where applicable. Useful for upgrading push rules to more strict\n     * conditions when the server is falling behind on defaults.\n     *\n     * @param logger - A `Logger` to write log messages to.\n     * @param incomingRules - The client's existing push rules\n     * @param userId - The Matrix ID of the client.\n     * @returns The rewritten rules\n     */\n    public static rewriteDefaultRules(\n        logger: Logger,\n        incomingRules: IPushRules,\n        userId: string | undefined = undefined,\n    ): IPushRules {\n        let newRules: IPushRules = JSON.parse(JSON.stringify(incomingRules)); // deep clone\n\n        // These lines are mostly to make the tests happy. We shouldn't run into these\n        // properties missing in practice.\n        if (!newRules) newRules = {} as IPushRules;\n        if (!newRules.global) newRules.global = {} as PushRuleSet;\n        if (!newRules.global.override) newRules.global.override = [];\n        if (!newRules.global.underride) newRules.global.underride = [];\n\n        // Merge the client-level defaults with the ones from the server\n        newRules.global.override = mergeRulesWithDefaults(\n            logger,\n            PushRuleKind.Override,\n            newRules.global.override,\n            DEFAULT_OVERRIDE_RULES,\n            EXPECTED_DEFAULT_OVERRIDE_RULE_IDS,\n        );\n\n        newRules.global.underride = mergeRulesWithDefaults(\n            logger,\n            PushRuleKind.Underride,\n            newRules.global.underride,\n            DEFAULT_UNDERRIDE_RULES,\n            EXPECTED_DEFAULT_UNDERRIDE_RULE_IDS,\n        );\n\n        return newRules;\n    }\n\n    /**\n     * Create a RegExp object for the given glob pattern with a single capture group around the pattern itself, caching the result.\n     * No cache invalidation is present currently,\n     * as this will be inherently bounded to the size of the user's own push rules.\n     * @param pattern - the glob pattern to convert to a RegExp\n     * @param alignToWordBoundary - whether to align the pattern to word boundaries,\n     *     as specified for `content.body` matches, will use lookaround assertions to ensure the match only includes the pattern\n     * @param flags - the flags to pass to the RegExp constructor, defaults to case-insensitive\n     */\n    public static getPushRuleGlobRegex(pattern: string, alignToWordBoundary = false, flags = \"i\"): RegExp {\n        const [prefix, suffix] = alignToWordBoundary ? [\"(?<=^|\\\\W)\", \"(?=\\\\W|$)\"] : [\"^\", \"$\"];\n        const cacheKey = `${alignToWordBoundary}-${flags}-${pattern}`;\n\n        if (!PushProcessor.cachedGlobToRegex[cacheKey]) {\n            PushProcessor.cachedGlobToRegex[cacheKey] = new RegExp(\n                prefix + \"(\" + globToRegexp(pattern) + \")\" + suffix,\n                flags,\n            );\n        }\n        return PushProcessor.cachedGlobToRegex[cacheKey];\n    }\n\n    /**\n     * Pre-caches the parsed keys for push rules and cleans out any obsolete cache\n     * entries. Should be called after push rules are updated.\n     * @param newRules - The new push rules.\n     */\n    public updateCachedPushRuleKeys(newRules: IPushRules): void {\n        // These lines are mostly to make the tests happy. We shouldn't run into these\n        // properties missing in practice.\n        if (!newRules) newRules = {} as IPushRules;\n        if (!newRules.global) newRules.global = {} as PushRuleSet;\n        if (!newRules.global.override) newRules.global.override = [];\n        if (!newRules.global.room) newRules.global.room = [];\n        if (!newRules.global.sender) newRules.global.sender = [];\n        if (!newRules.global.underride) newRules.global.underride = [];\n\n        // Process the 'key' property on event_match conditions pre-cache the\n        // values and clean-out any unused values.\n        const toRemoveKeys = new Set(this.parsedKeys.keys());\n        for (const ruleset of [\n            newRules.global.override,\n            newRules.global.room,\n            newRules.global.sender,\n            newRules.global.underride,\n        ]) {\n            for (const rule of ruleset) {\n                if (!rule.conditions) {\n                    continue;\n                }\n\n                for (const condition of rule.conditions) {\n                    if (condition.kind !== ConditionKind.EventMatch) {\n                        continue;\n                    }\n\n                    // Ensure we keep this key.\n                    toRemoveKeys.delete(condition.key);\n\n                    // Pre-process the key.\n                    this.parsedKeys.set(condition.key, PushProcessor.partsForDottedKey(condition.key));\n                }\n            }\n        }\n        // Any keys that were previously cached, but are no longer needed should\n        // be removed.\n        toRemoveKeys.forEach((k) => this.parsedKeys.delete(k));\n    }\n\n    private static cachedGlobToRegex: Record<string, RegExp> = {}; // $glob: RegExp\n\n    private matchingRuleFromKindSet(ev: MatrixEvent, kindset: PushRuleSet): IAnnotatedPushRule | null {\n        for (const kind of RULEKINDS_IN_ORDER) {\n            const ruleset = kindset[kind];\n            if (!ruleset) {\n                continue;\n            }\n\n            for (const rule of ruleset) {\n                if (!rule.enabled) {\n                    continue;\n                }\n\n                const rawrule = this.templateRuleToRaw(kind, rule);\n                if (!rawrule) {\n                    continue;\n                }\n\n                if (this.ruleMatchesEvent(rawrule, ev)) {\n                    return {\n                        ...rule,\n                        kind,\n                    };\n                }\n            }\n        }\n        return null;\n    }\n\n    private templateRuleToRaw(\n        kind: PushRuleKind,\n        tprule: IPushRule,\n    ): Pick<IPushRule, \"rule_id\" | \"actions\" | \"conditions\"> | null {\n        const rawrule: Pick<IPushRule, \"rule_id\" | \"actions\" | \"conditions\"> = {\n            rule_id: tprule.rule_id,\n            actions: tprule.actions,\n            conditions: [],\n        };\n        switch (kind) {\n            case PushRuleKind.Underride:\n            case PushRuleKind.Override:\n                rawrule.conditions = tprule.conditions;\n                break;\n            case PushRuleKind.RoomSpecific:\n                if (!tprule.rule_id) {\n                    return null;\n                }\n                rawrule.conditions!.push({\n                    kind: ConditionKind.EventMatch,\n                    key: \"room_id\",\n                    value: tprule.rule_id,\n                });\n                break;\n            case PushRuleKind.SenderSpecific:\n                if (!tprule.rule_id) {\n                    return null;\n                }\n                rawrule.conditions!.push({\n                    kind: ConditionKind.EventMatch,\n                    key: \"user_id\",\n                    value: tprule.rule_id,\n                });\n                break;\n            case PushRuleKind.ContentSpecific:\n                if (!tprule.pattern) {\n                    return null;\n                }\n                rawrule.conditions!.push({\n                    kind: ConditionKind.EventMatch,\n                    key: \"content.body\",\n                    pattern: tprule.pattern,\n                });\n                break;\n        }\n        return rawrule;\n    }\n\n    private eventFulfillsCondition(cond: PushRuleCondition, ev: MatrixEvent): boolean {\n        switch (cond.kind) {\n            case ConditionKind.EventMatch:\n                return this.eventFulfillsEventMatchCondition(cond, ev);\n            case ConditionKind.EventPropertyIs:\n                return this.eventFulfillsEventPropertyIsCondition(cond, ev);\n            case ConditionKind.EventPropertyContains:\n                return this.eventFulfillsEventPropertyContains(cond, ev);\n            case ConditionKind.ContainsDisplayName:\n                return this.eventFulfillsDisplayNameCondition(cond, ev);\n            case ConditionKind.RoomMemberCount:\n                return this.eventFulfillsRoomMemberCountCondition(cond, ev);\n            case ConditionKind.SenderNotificationPermission:\n                return this.eventFulfillsSenderNotifPermCondition(cond, ev);\n            case ConditionKind.CallStarted:\n            case ConditionKind.CallStartedPrefix:\n                return this.eventFulfillsCallStartedCondition(cond, ev);\n        }\n\n        // unknown conditions: we previously matched all unknown conditions,\n        // but given that rules can be added to the base rules on a server,\n        // it's probably better to not match unknown conditions.\n        return false;\n    }\n\n    private eventFulfillsSenderNotifPermCondition(\n        cond: ISenderNotificationPermissionCondition,\n        ev: MatrixEvent,\n    ): boolean {\n        const notifLevelKey = cond[\"key\"];\n        if (!notifLevelKey) {\n            return false;\n        }\n\n        const room = this.client.getRoom(ev.getRoomId());\n        if (!room?.currentState) {\n            return false;\n        }\n\n        // Note that this should not be the current state of the room but the state at\n        // the point the event is in the DAG. Unfortunately the js-sdk does not store\n        // this.\n        return room.currentState.mayTriggerNotifOfType(notifLevelKey, ev.getSender()!);\n    }\n\n    private eventFulfillsRoomMemberCountCondition(cond: IRoomMemberCountCondition, ev: MatrixEvent): boolean {\n        if (!cond.is) {\n            return false;\n        }\n\n        const room = this.client.getRoom(ev.getRoomId());\n        if (!room || !room.currentState || !room.currentState.members) {\n            return false;\n        }\n\n        const memberCount = room.currentState.getJoinedMemberCount();\n\n        const m = cond.is.match(/^([=<>]*)(\\d*)$/);\n        if (!m) {\n            return false;\n        }\n        const ineq = m[1];\n        const rhs = parseInt(m[2]);\n        if (isNaN(rhs)) {\n            return false;\n        }\n        switch (ineq) {\n            case \"\":\n            case \"==\":\n                return memberCount == rhs;\n            case \"<\":\n                return memberCount < rhs;\n            case \">\":\n                return memberCount > rhs;\n            case \"<=\":\n                return memberCount <= rhs;\n            case \">=\":\n                return memberCount >= rhs;\n            default:\n                return false;\n        }\n    }\n\n    private eventFulfillsDisplayNameCondition(cond: IContainsDisplayNameCondition, ev: MatrixEvent): boolean {\n        let content = ev.getContent();\n        if (ev.isEncrypted() && ev.getClearContent()) {\n            content = ev.getClearContent()!;\n        }\n        if (!content || !content.body || typeof content.body != \"string\") {\n            return false;\n        }\n\n        const room = this.client.getRoom(ev.getRoomId());\n        const member = room?.currentState?.getMember(this.client.credentials.userId!);\n        if (!member) {\n            return false;\n        }\n\n        const displayName = member.name;\n\n        // N.B. we can't use \\b as it chokes on unicode. however \\W seems to be okay\n        // as shorthand for [^0-9A-Za-z_].\n        const pat = new RegExp(\"(^|\\\\W)\" + escapeRegExp(displayName) + \"(\\\\W|$)\", \"i\");\n        return content.body.search(pat) > -1;\n    }\n\n    /**\n     * Check whether the given event matches the push rule condition by fetching\n     * the property from the event and comparing against the condition's glob-based\n     * pattern.\n     * @param cond - The push rule condition to check for a match.\n     * @param ev - The event to check for a match.\n     */\n    private eventFulfillsEventMatchCondition(cond: IEventMatchCondition, ev: MatrixEvent): boolean {\n        if (!cond.key) {\n            return false;\n        }\n\n        const val = this.valueForDottedKey(cond.key, ev);\n        if (typeof val !== \"string\") {\n            return false;\n        }\n\n        // XXX This does not match in a case-insensitive manner.\n        //\n        // See https://spec.matrix.org/v1.5/client-server-api/#conditions-1\n        if (cond.value) {\n            return cond.value === val;\n        }\n\n        if (typeof cond.pattern !== \"string\") {\n            return false;\n        }\n\n        // Align to word boundary on `content.body` matches, whole string otherwise\n        // https://spec.matrix.org/v1.13/client-server-api/#conditions-1\n        const regex = PushProcessor.getPushRuleGlobRegex(cond.pattern, cond.key === \"content.body\");\n        return !!val.match(regex);\n    }\n\n    /**\n     * Check whether the given event matches the push rule condition by fetching\n     * the property from the event and comparing exactly against the condition's\n     * value.\n     * @param cond - The push rule condition to check for a match.\n     * @param ev - The event to check for a match.\n     */\n    private eventFulfillsEventPropertyIsCondition(cond: IEventPropertyIsCondition, ev: MatrixEvent): boolean {\n        if (!cond.key || cond.value === undefined) {\n            return false;\n        }\n        return cond.value === this.valueForDottedKey(cond.key, ev);\n    }\n\n    /**\n     * Check whether the given event matches the push rule condition by fetching\n     * the property from the event and comparing exactly against the condition's\n     * value.\n     * @param cond - The push rule condition to check for a match.\n     * @param ev - The event to check for a match.\n     */\n    private eventFulfillsEventPropertyContains(cond: IEventPropertyContainsCondition, ev: MatrixEvent): boolean {\n        if (!cond.key || cond.value === undefined) {\n            return false;\n        }\n        const val = this.valueForDottedKey(cond.key, ev);\n        if (!Array.isArray(val)) {\n            return false;\n        }\n        return val.includes(cond.value);\n    }\n\n    private eventFulfillsCallStartedCondition(\n        _cond: ICallStartedCondition | ICallStartedPrefixCondition,\n        ev: MatrixEvent,\n    ): boolean {\n        // Since servers don't support properly sending push notification\n        // about MSC3401 call events, we do the handling ourselves\n        return (\n            [\"m.ring\", \"m.prompt\"].includes(ev.getContent()[\"m.intent\"]) &&\n            !(\"m.terminated\" in ev.getContent()) &&\n            (ev.getPrevContent()[\"m.terminated\"] !== ev.getContent()[\"m.terminated\"] ||\n                deepCompare(ev.getPrevContent(), {}))\n        );\n    }\n\n    /**\n     * Parse the key into the separate fields to search by splitting on\n     * unescaped \".\", and then removing any escape characters.\n     *\n     * @param str - The key of the push rule condition: a dotted field.\n     * @returns The unescaped parts to fetch.\n     * @internal\n     */\n    public static partsForDottedKey(str: string): string[] {\n        const result: string[] = [];\n\n        // The current field and whether the previous character was the escape\n        // character (a backslash).\n        let part = \"\";\n        let escaped = false;\n\n        // Iterate over each character, and decide whether to append to the current\n        // part (following the escape rules) or to start a new part (based on the\n        // field separator).\n        for (const c of str) {\n            // If the previous character was the escape character (a backslash)\n            // then decide what to append to the current part.\n            if (escaped) {\n                if (c === \"\\\\\" || c === \".\") {\n                    // An escaped backslash or dot just gets added.\n                    part += c;\n                } else {\n                    // A character that shouldn't be escaped gets the backslash prepended.\n                    part += \"\\\\\" + c;\n                }\n                // This always resets being escaped.\n                escaped = false;\n                continue;\n            }\n\n            if (c == \".\") {\n                // The field separator creates a new part.\n                result.push(part);\n                part = \"\";\n            } else if (c == \"\\\\\") {\n                // A backslash adds no characters, but starts an escape sequence.\n                escaped = true;\n            } else {\n                // Otherwise, just add the current character.\n                part += c;\n            }\n        }\n\n        // Ensure the final part is included. If there's an open escape sequence\n        // it should be included.\n        if (escaped) {\n            part += \"\\\\\";\n        }\n        result.push(part);\n\n        return result;\n    }\n\n    /**\n     * For a dotted field and event, fetch the value at that position, if one\n     * exists.\n     *\n     * @param key - The key of the push rule condition: a dotted field to fetch.\n     * @param ev - The matrix event to fetch the field from.\n     * @returns The value at the dotted path given by key.\n     */\n    private valueForDottedKey(key: string, ev: MatrixEvent): any {\n        // The key should already have been parsed via updateCachedPushRuleKeys,\n        // but if it hasn't (maybe via an old consumer of the SDK which hasn't\n        // been updated?) then lazily calculate it here.\n        let parts = this.parsedKeys.get(key);\n        if (parts === undefined) {\n            parts = PushProcessor.partsForDottedKey(key);\n            this.parsedKeys.set(key, parts);\n        }\n        let val: any;\n\n        // special-case the first component to deal with encrypted messages\n        const firstPart = parts[0];\n        let currentIndex = 0;\n        if (firstPart === \"content\") {\n            val = ev.getContent();\n            ++currentIndex;\n        } else if (firstPart === \"type\") {\n            val = ev.getType();\n            ++currentIndex;\n        } else {\n            // use the raw event for any other fields\n            val = ev.event;\n        }\n\n        for (; currentIndex < parts.length; ++currentIndex) {\n            // The previous iteration resulted in null or undefined, bail (and\n            // avoid the type error of attempting to retrieve a property).\n            if (isNullOrUndefined(val)) {\n                return undefined;\n            }\n\n            const thisPart = parts[currentIndex];\n            val = val[thisPart];\n        }\n        return val;\n    }\n\n    private matchingRuleForEventWithRulesets(ev: MatrixEvent, rulesets?: IPushRules): IAnnotatedPushRule | null {\n        if (!rulesets) {\n            return null;\n        }\n\n        if (ev.getSender() === this.client.getSafeUserId()) {\n            return null;\n        }\n\n        return this.matchingRuleFromKindSet(ev, rulesets.global);\n    }\n\n    private pushActionsForEventAndRulesets(\n        ev: MatrixEvent,\n        rulesets?: IPushRules,\n    ): {\n        actions?: IActionsObject;\n        rule?: IAnnotatedPushRule;\n    } {\n        const rule = this.matchingRuleForEventWithRulesets(ev, rulesets);\n        if (!rule) {\n            return {};\n        }\n\n        const actionObj = PushProcessor.actionListToActionsObject(rule.actions);\n\n        // Some actions are implicit in some situations: we add those here\n        if (actionObj.tweaks.highlight === undefined) {\n            // if it isn't specified, highlight if it's a content\n            // rule but otherwise not\n            actionObj.tweaks.highlight = rule.kind == PushRuleKind.ContentSpecific;\n        }\n\n        return { actions: actionObj, rule };\n    }\n\n    public ruleMatchesEvent(rule: Partial<IPushRule> & Pick<IPushRule, \"conditions\">, ev: MatrixEvent): boolean {\n        // Disable the deprecated mentions push rules if the new mentions property exists.\n        if (\n            this.client.supportsIntentionalMentions() &&\n            ev.getContent()[\"m.mentions\"] !== undefined &&\n            (rule.rule_id === RuleId.ContainsUserName ||\n                rule.rule_id === RuleId.ContainsDisplayName ||\n                rule.rule_id === RuleId.AtRoomNotification)\n        ) {\n            return false;\n        }\n\n        return !rule.conditions?.some((cond) => !this.eventFulfillsCondition(cond, ev));\n    }\n\n    /**\n     * Get the user's push actions for the given event\n     */\n    public actionsForEvent(ev: MatrixEvent): IActionsObject {\n        const { actions } = this.pushActionsForEventAndRulesets(ev, this.client.pushRules);\n        return actions || ({} as IActionsObject);\n    }\n\n    public actionsAndRuleForEvent(ev: MatrixEvent): {\n        actions?: IActionsObject;\n        rule?: IAnnotatedPushRule;\n    } {\n        return this.pushActionsForEventAndRulesets(ev, this.client.pushRules);\n    }\n\n    /**\n     * Get one of the users push rules by its ID\n     *\n     * @param ruleId - The ID of the rule to search for\n     * @returns The push rule, or null if no such rule was found\n     */\n    public getPushRuleById(ruleId: string): IPushRule | null {\n        const result = this.getPushRuleAndKindById(ruleId);\n        return result?.rule ?? null;\n    }\n\n    /**\n     * Get one of the users push rules by its ID\n     *\n     * @param ruleId - The ID of the rule to search for\n     * @returns rule The push rule, or null if no such rule was found\n     * @returns kind - The PushRuleKind of the rule to search for\n     */\n    public getPushRuleAndKindById(ruleId: string): { rule: IPushRule; kind: PushRuleKind } | null {\n        for (const scope of [\"global\"] as const) {\n            if (this.client.pushRules?.[scope] === undefined) continue;\n\n            for (const kind of RULEKINDS_IN_ORDER) {\n                if (this.client.pushRules[scope][kind] === undefined) continue;\n\n                for (const rule of this.client.pushRules[scope][kind]!) {\n                    if (rule.rule_id === ruleId) return { rule, kind };\n                }\n            }\n        }\n        return null;\n    }\n}\n","/*\nCopyright 2016 OpenMarket Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/* A re-implementation of the javascript callback functions (setTimeout,\n * clearTimeout; setInterval and clearInterval are not yet implemented) which\n * try to improve handling of large clock jumps (as seen when\n * suspending/resuming the system).\n *\n * In particular, if a timeout would have fired while the system was suspended,\n * it will instead fire as soon as possible after resume.\n */\n\nimport { logger } from \"./logger.ts\";\n\n// we schedule a callback at least this often, to check if we've missed out on\n// some wall-clock time due to being suspended.\nconst TIMER_CHECK_PERIOD_MS = 1000;\n\n// counter, for making up ids to return from setTimeout\nlet count = 0;\n\n// the key for our callback with the real globalThis.setTimeout\nlet realCallbackKey: NodeJS.Timeout | number;\n\ntype Callback = {\n    runAt: number;\n    func: (...params: any[]) => void;\n    params: any[];\n    key: number;\n};\n\n// a sorted list of the callbacks to be run.\n// each is an object with keys [runAt, func, params, key].\nconst callbackList: Callback[] = [];\n\n// var debuglog = logger.log.bind(logger);\n/* istanbul ignore next */\nconst debuglog = function (...params: any[]): void {};\n\n/**\n * reimplementation of window.setTimeout, which will call the callback if\n * the wallclock time goes past the deadline.\n *\n * @param func -   callback to be called after a delay\n * @param delayMs -  number of milliseconds to delay by\n *\n * @returns an identifier for this callback, which may be passed into\n *                   clearTimeout later.\n */\nexport function setTimeout(func: (...params: any[]) => void, delayMs: number, ...params: any[]): number {\n    delayMs = delayMs || 0;\n    if (delayMs < 0) {\n        delayMs = 0;\n    }\n\n    const runAt = Date.now() + delayMs;\n    const key = count++;\n    debuglog(\"setTimeout: scheduling cb\", key, \"at\", runAt, \"(delay\", delayMs, \")\");\n    const data = {\n        runAt: runAt,\n        func: func,\n        params: params,\n        key: key,\n    };\n\n    // figure out where it goes in the list\n    const idx = binarySearch(callbackList, function (el) {\n        return el.runAt - runAt;\n    });\n\n    callbackList.splice(idx, 0, data);\n    scheduleRealCallback();\n\n    return key;\n}\n\n/**\n * reimplementation of window.clearTimeout, which mirrors setTimeout\n *\n * @param key -   result from an earlier setTimeout call\n */\nexport function clearTimeout(key: number): void {\n    if (callbackList.length === 0) {\n        return;\n    }\n\n    // remove the element from the list\n    let i: number;\n    for (i = 0; i < callbackList.length; i++) {\n        const cb = callbackList[i];\n        if (cb.key == key) {\n            callbackList.splice(i, 1);\n            break;\n        }\n    }\n\n    // iff it was the first one in the list, reschedule our callback.\n    if (i === 0) {\n        scheduleRealCallback();\n    }\n}\n\n// use the real globalThis.setTimeout to schedule a callback to runCallbacks.\nfunction scheduleRealCallback(): void {\n    if (realCallbackKey) {\n        globalThis.clearTimeout(realCallbackKey as NodeJS.Timeout);\n    }\n\n    const first = callbackList[0];\n\n    if (!first) {\n        debuglog(\"scheduleRealCallback: no more callbacks, not rescheduling\");\n        return;\n    }\n\n    const timestamp = Date.now();\n    const delayMs = Math.min(first.runAt - timestamp, TIMER_CHECK_PERIOD_MS);\n\n    debuglog(\"scheduleRealCallback: now:\", timestamp, \"delay:\", delayMs);\n    realCallbackKey = globalThis.setTimeout(runCallbacks, delayMs);\n}\n\nfunction runCallbacks(): void {\n    const timestamp = Date.now();\n    debuglog(\"runCallbacks: now:\", timestamp);\n\n    // get the list of things to call\n    const callbacksToRun: Callback[] = [];\n    // eslint-disable-next-line\n    while (true) {\n        const first = callbackList[0];\n        if (!first || first.runAt > timestamp) {\n            break;\n        }\n        const cb = callbackList.shift()!;\n        debuglog(\"runCallbacks: popping\", cb.key);\n        callbacksToRun.push(cb);\n    }\n\n    // reschedule the real callback before running our functions, to\n    // keep the codepaths the same whether or not our functions\n    // register their own setTimeouts.\n    scheduleRealCallback();\n\n    for (const cb of callbacksToRun) {\n        try {\n            cb.func.apply(globalThis, cb.params);\n        } catch (e) {\n            logger.error(\"Uncaught exception in callback function\", e);\n        }\n    }\n}\n\n/* search in a sorted array.\n *\n * returns the index of the last element for which func returns\n * greater than zero, or array.length if no such element exists.\n */\nfunction binarySearch<T>(array: T[], func: (v: T) => number): number {\n    // min is inclusive, max exclusive.\n    let min = 0;\n    let max = array.length;\n\n    while (min < max) {\n        const mid = (min + max) >> 1;\n        const res = func(array[mid]);\n        if (res > 0) {\n            // the element at 'mid' is too big; set it as the new max.\n            max = mid;\n        } else {\n            // the element at 'mid' is too small. 'min' is inclusive, so +1.\n            min = mid + 1;\n        }\n    }\n    // presumably, min==max now.\n    return min;\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/** The prefix used on indexeddbs created by rust-crypto */\nexport const RUST_SDK_STORE_PREFIX = \"matrix-js-sdk\";\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module which manages queuing, scheduling and retrying\n * of requests.\n */\nimport { logger } from \"./logger.ts\";\nimport { type MatrixEvent } from \"./models/event.ts\";\nimport { EventType } from \"./@types/event.ts\";\nimport { removeElement } from \"./utils.ts\";\nimport { calculateRetryBackoff, type MatrixError } from \"./http-api/index.ts\";\nimport { type ISendEventResponse } from \"./@types/requests.ts\";\n\nconst DEBUG = false; // set true to enable console logging.\n\ninterface IQueueEntry<T> {\n    event: MatrixEvent;\n    resolvers: PromiseWithResolvers<T>;\n    attempts: number;\n}\n\n/**\n * The function to invoke to process (send) events in the queue.\n * @param event - The event to send.\n * @returns Resolved/rejected depending on the outcome of the request.\n */\ntype ProcessFunction<T> = (event: MatrixEvent) => Promise<T>;\n\n// eslint-disable-next-line camelcase\nexport class MatrixScheduler<T = ISendEventResponse> {\n    /**\n     * Default retry algorithm for the matrix scheduler. Retries events up to 4 times with exponential backoff.\n     * @param attempts - Number of attempts that have been made, including the one that just failed (ie. starting at 1)\n     * @see retryAlgorithm\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public static RETRY_BACKOFF_RATELIMIT(event: MatrixEvent | null, attempts: number, err: MatrixError): number {\n        return calculateRetryBackoff(err, attempts, false);\n    }\n\n    /**\n     * Queues `m.room.message` events and lets other events continue\n     * concurrently.\n     * @see queueAlgorithm\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public static QUEUE_MESSAGES(event: MatrixEvent): string | null {\n        // enqueue messages or events that associate with another event (redactions and relations)\n        if (event.getType() === EventType.RoomMessage || event.hasAssociation()) {\n            // put these events in the 'message' queue.\n            return \"message\";\n        }\n        // allow all other events continue concurrently.\n        return null;\n    }\n\n    // queueName: [{\n    //  event: MatrixEvent,  // event to send\n    //  defer: PromiseWithResolvers,  // defer to resolve/reject at the END of the retries\n    //  attempts: Number  // number of times we've called processFn\n    // }, ...]\n    private readonly queues: Record<string, IQueueEntry<T>[]> = {};\n    private activeQueues: string[] = [];\n    private procFn: ProcessFunction<T> | null = null;\n\n    /**\n     * Construct a scheduler for Matrix. Requires\n     * {@link MatrixScheduler#setProcessFunction} to be provided\n     * with a way of processing events.\n     * @param retryAlgorithm - Optional. The retry\n     * algorithm to apply when determining when to try to send an event again.\n     * Defaults to {@link MatrixScheduler.RETRY_BACKOFF_RATELIMIT}.\n     * @param queueAlgorithm - Optional. The queuing\n     * algorithm to apply when determining which events should be sent before the\n     * given event. Defaults to {@link MatrixScheduler.QUEUE_MESSAGES}.\n     */\n    public constructor(\n        /**\n         * The retry algorithm to apply when retrying events. To stop retrying, return\n         * `-1`. If this event was part of a queue, it will be removed from\n         * the queue.\n         * @param event - The event being retried.\n         * @param attempts - The number of failed attempts. This will always be \\>= 1.\n         * @param err - The most recent error message received when trying\n         * to send this event.\n         * @returns The number of milliseconds to wait before trying again. If\n         * this is 0, the request will be immediately retried. If this is\n         * `-1`, the event will be marked as\n         * {@link EventStatus.NOT_SENT} and will not be retried.\n         */\n        public readonly retryAlgorithm = MatrixScheduler.RETRY_BACKOFF_RATELIMIT,\n        /**\n         * The queuing algorithm to apply to events. This function must be idempotent as\n         * it may be called multiple times with the same event. All queues created are\n         * serviced in a FIFO manner. To send the event ASAP, return `null`\n         * which will not put this event in a queue. Events that fail to send that form\n         * part of a queue will be removed from the queue and the next event in the\n         * queue will be sent.\n         * @param event - The event to be sent.\n         * @returns The name of the queue to put the event into. If a queue with\n         * this name does not exist, it will be created. If this is `null`,\n         * the event is not put into a queue and will be sent concurrently.\n         */\n        public readonly queueAlgorithm = MatrixScheduler.QUEUE_MESSAGES,\n    ) {}\n\n    /**\n     * Retrieve a queue based on an event. The event provided does not need to be in\n     * the queue.\n     * @param event - An event to get the queue for.\n     * @returns A shallow copy of events in the queue or null.\n     * Modifying this array will not modify the list itself. Modifying events in\n     * this array <i>will</i> modify the underlying event in the queue.\n     * @see MatrixScheduler.removeEventFromQueue To remove an event from the queue.\n     */\n    public getQueueForEvent(event: MatrixEvent): MatrixEvent[] | null {\n        const name = this.queueAlgorithm(event);\n        if (!name || !this.queues[name]) {\n            return null;\n        }\n        return this.queues[name].map(function (obj) {\n            return obj.event;\n        });\n    }\n\n    /**\n     * Remove this event from the queue. The event is equal to another event if they\n     * have the same ID returned from event.getId().\n     * @param event - The event to remove.\n     * @returns True if this event was removed.\n     */\n    public removeEventFromQueue(event: MatrixEvent): boolean {\n        const name = this.queueAlgorithm(event);\n        if (!name || !this.queues[name]) {\n            return false;\n        }\n        let removed = false;\n        removeElement(this.queues[name], (element) => {\n            if (element.event.getId() === event.getId()) {\n                // XXX we should probably reject the promise?\n                // https://github.com/matrix-org/matrix-js-sdk/issues/496\n                removed = true;\n                return true;\n            }\n            return false;\n        });\n        return removed;\n    }\n\n    /**\n     * Set the process function. Required for events in the queue to be processed.\n     * If set after events have been added to the queue, this will immediately start\n     * processing them.\n     * @param fn - The function that can process events\n     * in the queue.\n     */\n    public setProcessFunction(fn: ProcessFunction<T>): void {\n        this.procFn = fn;\n        this.startProcessingQueues();\n    }\n\n    /**\n     * Queue an event if it is required and start processing queues.\n     * @param event - The event that may be queued.\n     * @returns A promise if the event was queued, which will be\n     * resolved or rejected in due time, else null.\n     */\n    public queueEvent(event: MatrixEvent): Promise<T> | null {\n        const queueName = this.queueAlgorithm(event);\n        if (!queueName) {\n            return null;\n        }\n        // add the event to the queue and make a deferred for it.\n        if (!this.queues[queueName]) {\n            this.queues[queueName] = [];\n        }\n        const eventResolvers = Promise.withResolvers<T>();\n        this.queues[queueName].push({\n            event: event,\n            resolvers: eventResolvers,\n            attempts: 0,\n        });\n        debuglog(\"Queue algorithm dumped event %s into queue '%s'\", event.getId(), queueName);\n        this.startProcessingQueues();\n        return eventResolvers.promise;\n    }\n\n    private startProcessingQueues(): void {\n        if (!this.procFn) return;\n        // for each inactive queue with events in them\n        Object.keys(this.queues)\n            .filter((queueName) => {\n                return this.activeQueues.indexOf(queueName) === -1 && this.queues[queueName].length > 0;\n            })\n            .forEach((queueName) => {\n                // mark the queue as active\n                this.activeQueues.push(queueName);\n                // begin processing the head of the queue\n                debuglog(\"Spinning up queue: '%s'\", queueName);\n                this.processQueue(queueName);\n            });\n    }\n\n    private processQueue = (queueName: string): void => {\n        // get head of queue\n        const obj = this.peekNextEvent(queueName);\n        if (!obj) {\n            this.disableQueue(queueName);\n            return;\n        }\n        debuglog(\"Queue '%s' has %s pending events\", queueName, this.queues[queueName].length);\n        // fire the process function and if it resolves, resolve the deferred. Else\n        // invoke the retry algorithm.\n\n        // First wait for a resolved promise, so the resolve handlers for\n        // the deferred of the previously sent event can run.\n        // This way enqueued relations/redactions to enqueued events can receive\n        // the remove id of their target before being sent.\n        Promise.resolve()\n            .then(() => {\n                return this.procFn!(obj.event);\n            })\n            .then(\n                (res) => {\n                    // remove this from the queue\n                    this.removeNextEvent(queueName);\n                    debuglog(\"Queue '%s' sent event %s\", queueName, obj.event.getId());\n                    obj.resolvers.resolve(res);\n                    // keep processing\n                    this.processQueue(queueName);\n                },\n                (err) => {\n                    obj.attempts += 1;\n                    // ask the retry algorithm when/if we should try again\n                    const waitTimeMs = this.retryAlgorithm(obj.event, obj.attempts, err);\n                    debuglog(\n                        \"retry(%s) err=%s event_id=%s waitTime=%s\",\n                        obj.attempts,\n                        err,\n                        obj.event.getId(),\n                        waitTimeMs,\n                    );\n                    if (waitTimeMs === -1) {\n                        // give up (you quitter!)\n                        logger.info(\"Queue '%s' giving up on event %s\", queueName, obj.event.getId());\n                        // remove this from the queue\n                        this.clearQueue(queueName, err);\n                    } else {\n                        setTimeout(this.processQueue, waitTimeMs, queueName);\n                    }\n                },\n            );\n    };\n\n    private disableQueue(queueName: string): void {\n        // queue is empty. Mark as inactive and stop recursing.\n        const index = this.activeQueues.indexOf(queueName);\n        if (index >= 0) {\n            this.activeQueues.splice(index, 1);\n        }\n        logger.info(\"Stopping queue '%s' as it is now empty\", queueName);\n    }\n\n    private clearQueue(queueName: string, err: unknown): void {\n        logger.info(\"clearing queue '%s'\", queueName);\n        let obj: IQueueEntry<T> | undefined;\n        while ((obj = this.removeNextEvent(queueName))) {\n            obj.resolvers.reject(err);\n        }\n        this.disableQueue(queueName);\n    }\n\n    private peekNextEvent(queueName: string): IQueueEntry<T> | undefined {\n        const queue = this.queues[queueName];\n        if (!Array.isArray(queue)) {\n            return undefined;\n        }\n        return queue[0];\n    }\n\n    private removeNextEvent(queueName: string): IQueueEntry<T> | undefined {\n        const queue = this.queues[queueName];\n        if (!Array.isArray(queue)) {\n            return undefined;\n        }\n        return queue.shift();\n    }\n}\n\n/* istanbul ignore next */\nfunction debuglog(...args: any[]): void {\n    if (DEBUG) {\n        logger.log(...args);\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type { SyncCryptoCallbacks } from \"./common-crypto/CryptoBackend.ts\";\nimport { NotificationCountType, Room, RoomEvent } from \"./models/room.ts\";\nimport { logger } from \"./logger.ts\";\nimport { promiseMapSeries } from \"./utils.ts\";\nimport { EventTimeline } from \"./models/event-timeline.ts\";\nimport { ClientEvent, type IStoredClientOpts, type MatrixClient } from \"./client.ts\";\nimport {\n    type ISyncStateData,\n    SyncState,\n    _createAndReEmitRoom,\n    type SyncApiOptions,\n    defaultClientOpts,\n    defaultSyncApiOpts,\n    type SetPresence,\n    processToDeviceMessages,\n} from \"./sync.ts\";\nimport { type MatrixEvent } from \"./models/event.ts\";\nimport {\n    type IMinimalEvent,\n    type IRoomEvent,\n    type IStateEvent,\n    type IStrippedState,\n    type ISyncResponse,\n    type ReceivedToDeviceMessage,\n} from \"./sync-accumulator.ts\";\nimport { MatrixError } from \"./http-api/index.ts\";\nimport {\n    type Extension,\n    ExtensionState,\n    type MSC3575RoomData,\n    type MSC3575SlidingSyncResponse,\n    type SlidingSync,\n    SlidingSyncEvent,\n    SlidingSyncState,\n} from \"./sliding-sync.ts\";\nimport { EventType } from \"./@types/event.ts\";\nimport { type IPushRules } from \"./@types/PushRules.ts\";\nimport { RoomStateEvent } from \"./models/room-state.ts\";\nimport { RoomMemberEvent } from \"./models/room-member.ts\";\nimport { KnownMembership } from \"./@types/membership.ts\";\n\n// Number of consecutive failed syncs that will lead to a syncState of ERROR as opposed\n// to RECONNECTING. This is needed to inform the client of server issues when the\n// keepAlive is successful but the server /sync fails.\nconst FAILED_SYNC_ERROR_THRESHOLD = 3;\n\ntype ExtensionE2EERequest = {\n    enabled: boolean;\n};\n\ntype ExtensionE2EEResponse = Pick<\n    ISyncResponse,\n    | \"device_lists\"\n    | \"device_one_time_keys_count\"\n    | \"device_unused_fallback_key_types\"\n    | \"org.matrix.msc2732.device_unused_fallback_key_types\"\n>;\n\nclass ExtensionE2EE implements Extension<ExtensionE2EERequest, ExtensionE2EEResponse> {\n    public constructor(private readonly crypto: SyncCryptoCallbacks) {}\n\n    public name(): string {\n        return \"e2ee\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PreProcess;\n    }\n\n    public async onRequest(isInitial: boolean): Promise<ExtensionE2EERequest> {\n        if (isInitial) {\n            // In SSS, the `?pos=` contains the stream position for device list updates.\n            // If we do not have a `?pos=` (e.g because we forgot it, or because the server\n            // invalidated our connection) then we MUST invlaidate all device lists because\n            // the server will not tell us the delta. This will then cause UTDs as we will fail\n            // to encrypt for new devices. This is an expensive call, so we should\n            // really really remember `?pos=` wherever possible.\n            logger.log(\"ExtensionE2EE: invalidating all device lists due to missing 'pos'\");\n            await this.crypto.markAllTrackedUsersAsDirty();\n        }\n        return {\n            enabled: true, // this is sticky so only send it on the initial request\n        };\n    }\n\n    public async onResponse(data: ExtensionE2EEResponse): Promise<void> {\n        // Handle device list updates\n        if (data.device_lists) {\n            await this.crypto.processDeviceLists(data.device_lists);\n        }\n\n        // Handle one_time_keys_count and unused_fallback_key_types\n        await this.crypto.processKeyCounts(\n            data.device_one_time_keys_count,\n            data[\"device_unused_fallback_key_types\"] || data[\"org.matrix.msc2732.device_unused_fallback_key_types\"],\n        );\n\n        this.crypto.onSyncCompleted({});\n    }\n}\n\ntype ExtensionToDeviceRequest = {\n    since?: string;\n    limit?: number;\n    enabled?: boolean;\n};\n\ntype ExtensionToDeviceResponse = {\n    events: Required<ISyncResponse>[\"to_device\"][\"events\"];\n    next_batch: string | null;\n};\n\nclass ExtensionToDevice implements Extension<ExtensionToDeviceRequest, ExtensionToDeviceResponse> {\n    private nextBatch: string | null = null;\n\n    public constructor(\n        private readonly client: MatrixClient,\n        private readonly cryptoCallbacks?: SyncCryptoCallbacks,\n    ) {}\n\n    public name(): string {\n        return \"to_device\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PreProcess;\n    }\n\n    public async onRequest(isInitial: boolean): Promise<ExtensionToDeviceRequest> {\n        return {\n            since: this.nextBatch !== null ? this.nextBatch : undefined,\n            limit: 100,\n            enabled: true,\n        };\n    }\n\n    public async onResponse(data: ExtensionToDeviceResponse): Promise<void> {\n        const events = data[\"events\"] || [];\n        let receivedToDeviceMessages: ReceivedToDeviceMessage[];\n        if (this.cryptoCallbacks) {\n            receivedToDeviceMessages = await this.cryptoCallbacks.preprocessToDeviceMessages(events);\n        } else {\n            receivedToDeviceMessages = events.map((rawEvent) =>\n                // Crypto is not enabled, so we just return the events.\n                ({\n                    message: rawEvent,\n                    encryptionInfo: null,\n                }),\n            );\n        }\n        processToDeviceMessages(receivedToDeviceMessages, this.client);\n\n        this.nextBatch = data.next_batch;\n    }\n}\n\ntype ExtensionAccountDataRequest = {\n    enabled: boolean;\n};\n\ntype ExtensionAccountDataResponse = {\n    global: IMinimalEvent[];\n    rooms: Record<string, IMinimalEvent[]>;\n};\n\nclass ExtensionAccountData implements Extension<ExtensionAccountDataRequest, ExtensionAccountDataResponse> {\n    public constructor(private readonly client: MatrixClient) {}\n\n    public name(): string {\n        return \"account_data\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PostProcess;\n    }\n\n    public async onRequest(isInitial: boolean): Promise<ExtensionAccountDataRequest> {\n        return {\n            enabled: true,\n        };\n    }\n\n    public async onResponse(data: ExtensionAccountDataResponse): Promise<void> {\n        if (data.global && data.global.length > 0) {\n            this.processGlobalAccountData(data.global);\n        }\n\n        for (const roomId in data.rooms) {\n            const accountDataEvents = mapEvents(this.client, roomId, data.rooms[roomId]);\n            const room = this.client.getRoom(roomId);\n            if (!room) {\n                logger.warn(\"got account data for room but room doesn't exist on client:\", roomId);\n                continue;\n            }\n            room.addAccountData(accountDataEvents);\n            accountDataEvents.forEach((e) => {\n                this.client.emit(ClientEvent.Event, e);\n            });\n        }\n    }\n\n    private processGlobalAccountData(globalAccountData: IMinimalEvent[]): void {\n        const events = mapEvents(this.client, undefined, globalAccountData);\n        const prevEventsMap = events.reduce<Record<string, MatrixEvent | undefined>>((m, c) => {\n            m[c.getType()] = this.client.store.getAccountData(c.getType());\n            return m;\n        }, {});\n        this.client.store.storeAccountDataEvents(events);\n        events.forEach((accountDataEvent) => {\n            // Honour push rules that come down the sync stream but also\n            // honour push rules that were previously cached. Base rules\n            // will be updated when we receive push rules via getPushRules\n            // (see sync) before syncing over the network.\n            if (accountDataEvent.getType() === EventType.PushRules) {\n                const rules = accountDataEvent.getContent<IPushRules>();\n                this.client.setPushRules(rules);\n            }\n            const prevEvent = prevEventsMap[accountDataEvent.getType()];\n            this.client.emit(ClientEvent.AccountData, accountDataEvent, prevEvent);\n            return accountDataEvent;\n        });\n    }\n}\n\ntype ExtensionTypingRequest = {\n    enabled: boolean;\n};\n\ntype ExtensionTypingResponse = {\n    rooms: Record<string, IMinimalEvent>;\n};\n\nclass ExtensionTyping implements Extension<ExtensionTypingRequest, ExtensionTypingResponse> {\n    public constructor(private readonly client: MatrixClient) {}\n\n    public name(): string {\n        return \"typing\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PostProcess;\n    }\n\n    public async onRequest(isInitial: boolean): Promise<ExtensionTypingRequest> {\n        return {\n            enabled: true,\n        };\n    }\n\n    public async onResponse(data: ExtensionTypingResponse): Promise<void> {\n        if (!data?.rooms) {\n            return;\n        }\n\n        for (const roomId in data.rooms) {\n            processEphemeralEvents(this.client, roomId, [data.rooms[roomId]]);\n        }\n    }\n}\n\ntype ExtensionReceiptsRequest = {\n    enabled: boolean;\n};\n\ntype ExtensionReceiptsResponse = {\n    rooms: Record<string, IMinimalEvent>;\n};\n\nclass ExtensionReceipts implements Extension<ExtensionReceiptsRequest, ExtensionReceiptsResponse> {\n    public constructor(private readonly client: MatrixClient) {}\n\n    public name(): string {\n        return \"receipts\";\n    }\n\n    public when(): ExtensionState {\n        return ExtensionState.PostProcess;\n    }\n\n    public async onRequest(isInitial: boolean): Promise<ExtensionReceiptsRequest> {\n        return {\n            enabled: true,\n        };\n    }\n\n    public async onResponse(data: ExtensionReceiptsResponse): Promise<void> {\n        if (!data?.rooms) {\n            return;\n        }\n\n        for (const roomId in data.rooms) {\n            processEphemeralEvents(this.client, roomId, [data.rooms[roomId]]);\n        }\n    }\n}\n\n/**\n * A copy of SyncApi such that it can be used as a drop-in replacement for sync v2. For the actual\n * sliding sync API, see sliding-sync.ts or the class SlidingSync.\n */\nexport class SlidingSyncSdk {\n    private readonly opts: IStoredClientOpts;\n    private readonly syncOpts: SyncApiOptions;\n    private syncState: SyncState | null = null;\n    private syncStateData?: ISyncStateData;\n    private lastPos: string | null = null;\n    private failCount = 0;\n    private notifEvents: MatrixEvent[] = []; // accumulator of sync events in the current sync response\n\n    public constructor(\n        private readonly slidingSync: SlidingSync,\n        private readonly client: MatrixClient,\n        opts: IStoredClientOpts | undefined,\n        syncOpts: SyncApiOptions,\n    ) {\n        this.opts = defaultClientOpts(opts);\n        this.syncOpts = defaultSyncApiOpts(syncOpts);\n\n        if (client.getNotifTimelineSet()) {\n            client.reEmitter.reEmit(client.getNotifTimelineSet()!, [RoomEvent.Timeline, RoomEvent.TimelineReset]);\n        }\n\n        this.slidingSync.on(SlidingSyncEvent.Lifecycle, this.onLifecycle.bind(this));\n        this.slidingSync.on(SlidingSyncEvent.RoomData, this.onRoomData.bind(this));\n        const extensions: Extension<any, any>[] = [\n            new ExtensionToDevice(this.client, this.syncOpts.cryptoCallbacks),\n            new ExtensionAccountData(this.client),\n            new ExtensionTyping(this.client),\n            new ExtensionReceipts(this.client),\n        ];\n        if (this.syncOpts.cryptoCallbacks) {\n            extensions.push(new ExtensionE2EE(this.syncOpts.cryptoCallbacks));\n        }\n        extensions.forEach((ext) => {\n            this.slidingSync.registerExtension(ext);\n        });\n    }\n\n    private async onRoomData(roomId: string, roomData: MSC3575RoomData): Promise<void> {\n        let room = this.client.store.getRoom(roomId);\n        if (!room) {\n            if (!roomData.initial) {\n                this.syncOpts.logger.debug(\n                    \"initial flag not set but no stored room exists for room \",\n                    roomId,\n                    roomData,\n                );\n                return;\n            }\n            room = _createAndReEmitRoom(this.client, roomId, this.opts);\n        }\n        await this.processRoomData(this.client, room!, roomData);\n    }\n\n    private onLifecycle(state: SlidingSyncState, resp: MSC3575SlidingSyncResponse | null, err?: Error): void {\n        if (err) {\n            this.syncOpts.logger.debug(\"onLifecycle\", state, err);\n        }\n        switch (state) {\n            case SlidingSyncState.Complete:\n                this.purgeNotifications();\n                if (!resp) {\n                    break;\n                }\n                // Element won't stop showing the initial loading spinner unless we fire SyncState.Prepared\n                if (!this.lastPos) {\n                    this.updateSyncState(SyncState.Prepared, {\n                        oldSyncToken: undefined,\n                        nextSyncToken: resp.pos,\n                        catchingUp: false,\n                        fromCache: false,\n                    });\n                }\n                // Conversely, Element won't show the room list unless there is at least 1x SyncState.Syncing\n                // so hence for the very first sync we will fire prepared then immediately syncing.\n                this.updateSyncState(SyncState.Syncing, {\n                    oldSyncToken: this.lastPos!,\n                    nextSyncToken: resp.pos,\n                    catchingUp: false,\n                    fromCache: false,\n                });\n                this.lastPos = resp.pos;\n                break;\n            case SlidingSyncState.RequestFinished:\n                if (err) {\n                    this.failCount += 1;\n                    this.updateSyncState(\n                        this.failCount > FAILED_SYNC_ERROR_THRESHOLD ? SyncState.Error : SyncState.Reconnecting,\n                        {\n                            error: new MatrixError(err),\n                        },\n                    );\n                    if (this.shouldAbortSync(new MatrixError(err))) {\n                        return; // shouldAbortSync actually stops syncing too so we don't need to do anything.\n                    }\n                } else {\n                    this.failCount = 0;\n                    this.syncOpts.logger.debug(\n                        `SlidingSyncState.RequestFinished with ${Object.keys(resp?.rooms || []).length} rooms`,\n                    );\n                }\n                break;\n        }\n    }\n\n    /**\n     * Sync rooms the user has left.\n     * @returns Resolved when they've been added to the store.\n     */\n    public async syncLeftRooms(): Promise<Room[]> {\n        return []; // TODO\n    }\n\n    /**\n     * Peek into a room. This will result in the room in question being synced so it\n     * is accessible via getRooms(). Live updates for the room will be provided.\n     * @param roomId - The room ID to peek into.\n     * @returns A promise which resolves once the room has been added to the\n     * store.\n     */\n    public async peek(roomId: string): Promise<Room> {\n        return null!; // TODO\n    }\n\n    /**\n     * Stop polling for updates in the peeked room. NOPs if there is no room being\n     * peeked.\n     */\n    public stopPeeking(): void {\n        // TODO\n    }\n\n    /**\n     * Specify the set_presence value to be used for subsequent calls to the Sync API.\n     * @param presence - the presence to specify to set_presence of sync calls\n     */\n    public setPresence(presence?: SetPresence): void {\n        // TODO not possible in sliding sync yet\n    }\n\n    /**\n     * Returns the current state of this sync object\n     * @see MatrixClient#event:\"sync\"\n     */\n    public getSyncState(): SyncState | null {\n        return this.syncState;\n    }\n\n    /**\n     * Returns the additional data object associated with\n     * the current sync state, or null if there is no\n     * such data.\n     * Sync errors, if available, are put in the 'error' key of\n     * this object.\n     */\n    public getSyncStateData(): ISyncStateData | null {\n        return this.syncStateData ?? null;\n    }\n\n    // Helper functions which set up JS SDK structs are below and are identical to the sync v2 counterparts\n\n    public createRoom(roomId: string): Room {\n        // XXX cargoculted from sync.ts\n        const { timelineSupport } = this.client;\n        const room = new Room(roomId, this.client, this.client.getUserId()!, {\n            lazyLoadMembers: this.opts.lazyLoadMembers,\n            pendingEventOrdering: this.opts.pendingEventOrdering,\n            timelineSupport,\n        });\n        this.client.reEmitter.reEmit(room, [\n            RoomEvent.Name,\n            RoomEvent.Redaction,\n            RoomEvent.RedactionCancelled,\n            RoomEvent.Receipt,\n            RoomEvent.Tags,\n            RoomEvent.LocalEchoUpdated,\n            RoomEvent.AccountData,\n            RoomEvent.MyMembership,\n            RoomEvent.Timeline,\n            RoomEvent.TimelineReset,\n        ]);\n        this.registerStateListeners(room);\n        return room;\n    }\n\n    private registerStateListeners(room: Room): void {\n        // XXX cargoculted from sync.ts\n        // we need to also re-emit room state and room member events, so hook it up\n        // to the client now. We need to add a listener for RoomState.members in\n        // order to hook them correctly.\n        this.client.reEmitter.reEmit(room.currentState, [\n            RoomStateEvent.Events,\n            RoomStateEvent.Members,\n            RoomStateEvent.NewMember,\n            RoomStateEvent.Update,\n        ]);\n        room.currentState.on(RoomStateEvent.NewMember, (event, state, member) => {\n            member.user = this.client.getUser(member.userId) ?? undefined;\n            this.client.reEmitter.reEmit(member, [\n                RoomMemberEvent.Name,\n                RoomMemberEvent.Typing,\n                RoomMemberEvent.PowerLevel,\n                RoomMemberEvent.Membership,\n            ]);\n        });\n    }\n\n    /*\n    private deregisterStateListeners(room: Room): void { // XXX cargoculted from sync.ts\n        // could do with a better way of achieving this.\n        room.currentState.removeAllListeners(RoomStateEvent.Events);\n        room.currentState.removeAllListeners(RoomStateEvent.Members);\n        room.currentState.removeAllListeners(RoomStateEvent.NewMember);\n    } */\n\n    private shouldAbortSync(error: MatrixError): boolean {\n        if (error.errcode === \"M_UNKNOWN_TOKEN\") {\n            // The logout already happened, we just need to stop.\n            this.syncOpts.logger.warn(\"Token no longer valid - assuming logout\");\n            this.stop();\n            this.updateSyncState(SyncState.Error, { error });\n            return true;\n        }\n        return false;\n    }\n\n    private async processRoomData(client: MatrixClient, room: Room, roomData: MSC3575RoomData): Promise<void> {\n        roomData = ensureNameEvent(client, room.roomId, roomData);\n        const stateEvents = mapEvents(this.client, room.roomId, roomData.required_state);\n        // Prevent events from being decrypted ahead of time\n        // this helps large account to speed up faster\n        // room::decryptCriticalEvent is in charge of decrypting all the events\n        // required for a client to function properly\n        let timelineEvents = mapEvents(this.client, room.roomId, roomData.timeline, false);\n        const ephemeralEvents: MatrixEvent[] = []; // TODO this.mapSyncEventsFormat(joinObj.ephemeral);\n\n        // TODO: handle threaded / beacon events\n\n        if (roomData.limited || roomData.initial) {\n            // we should not know about any of these timeline entries if this is a genuinely new room.\n            // If we do, then we've effectively done scrollback (e.g requesting timeline_limit: 1 for\n            // this room, then timeline_limit: 50).\n            const knownEvents = new Set<string>();\n            room.getLiveTimeline()\n                .getEvents()\n                .forEach((e) => {\n                    knownEvents.add(e.getId()!);\n                });\n            // all unknown events BEFORE a known event must be scrollback e.g:\n            //       D E   <-- what we know\n            // A B C D E F <-- what we just received\n            // means:\n            // A B C       <-- scrollback\n            //       D E   <-- dupes\n            //           F <-- new event\n            // We bucket events based on if we have seen a known event yet.\n            const oldEvents: MatrixEvent[] = [];\n            const newEvents: MatrixEvent[] = [];\n            let seenKnownEvent = false;\n            for (let i = timelineEvents.length - 1; i >= 0; i--) {\n                const recvEvent = timelineEvents[i];\n                if (knownEvents.has(recvEvent.getId()!)) {\n                    seenKnownEvent = true;\n                    continue; // don't include this event, it's a dupe\n                }\n                if (seenKnownEvent) {\n                    // old -> new\n                    oldEvents.push(recvEvent);\n                } else {\n                    // old -> new\n                    newEvents.unshift(recvEvent);\n                }\n            }\n            timelineEvents = newEvents;\n            if (oldEvents.length > 0) {\n                // old events are scrollback, insert them now\n                room.addEventsToTimeline(oldEvents, true, false, room.getLiveTimeline(), roomData.prev_batch);\n            }\n        }\n\n        const encrypted = room.hasEncryptionStateEvent();\n        // we do this first so it's correct when any of the events fire\n        if (roomData.notification_count != null) {\n            room.setUnreadNotificationCount(NotificationCountType.Total, roomData.notification_count);\n        }\n\n        if (roomData.highlight_count != null) {\n            // We track unread notifications ourselves in encrypted rooms, so don't\n            // bother setting it here. We trust our calculations better than the\n            // server's for this case, and therefore will assume that our non-zero\n            // count is accurate.\n            if (!encrypted || (encrypted && room.getUnreadNotificationCount(NotificationCountType.Highlight) <= 0)) {\n                room.setUnreadNotificationCount(NotificationCountType.Highlight, roomData.highlight_count);\n            }\n        }\n        if (roomData.bump_stamp) {\n            room.setBumpStamp(roomData.bump_stamp);\n        }\n\n        if (Number.isInteger(roomData.invited_count)) {\n            room.currentState.setInvitedMemberCount(roomData.invited_count!);\n        }\n        if (Number.isInteger(roomData.joined_count)) {\n            room.currentState.setJoinedMemberCount(roomData.joined_count!);\n        }\n\n        if (roomData.invite_state) {\n            const inviteStateEvents = mapEvents(this.client, room.roomId, roomData.invite_state);\n            await this.injectRoomEvents(room, inviteStateEvents);\n            if (roomData.initial) {\n                room.recalculate();\n                this.client.store.storeRoom(room);\n                this.client.emit(ClientEvent.Room, room);\n            }\n            inviteStateEvents.forEach((e) => {\n                this.client.emit(ClientEvent.Event, e);\n            });\n            return;\n        }\n\n        if (roomData.limited) {\n            // set the back-pagination token. Do this *before* adding any\n            // events so that clients can start back-paginating.\n            room.getLiveTimeline().setPaginationToken(roomData.prev_batch ?? null, EventTimeline.BACKWARDS);\n        }\n\n        /* TODO\n        else if (roomData.limited) {\n\n            let limited = true;\n\n            // we've got a limited sync, so we *probably* have a gap in the\n            // timeline, so should reset. But we might have been peeking or\n            // paginating and already have some of the events, in which\n            // case we just want to append any subsequent events to the end\n            // of the existing timeline.\n            //\n            // This is particularly important in the case that we already have\n            // *all* of the events in the timeline - in that case, if we reset\n            // the timeline, we'll end up with an entirely empty timeline,\n            // which we'll try to paginate but not get any new events (which\n            // will stop us linking the empty timeline into the chain).\n            //\n            for (let i = timelineEvents.length - 1; i >= 0; i--) {\n                const eventId = timelineEvents[i].getId();\n                if (room.getTimelineForEvent(eventId)) {\n                    this.syncOpts.logger.debug(\"Already have event \" + eventId + \" in limited \" +\n                        \"sync - not resetting\");\n                    limited = false;\n\n                    // we might still be missing some of the events before i;\n                    // we don't want to be adding them to the end of the\n                    // timeline because that would put them out of order.\n                    timelineEvents.splice(0, i);\n\n                    // XXX: there's a problem here if the skipped part of the\n                    // timeline modifies the state set in stateEvents, because\n                    // we'll end up using the state from stateEvents rather\n                    // than the later state from timelineEvents. We probably\n                    // need to wind stateEvents forward over the events we're\n                    // skipping.\n                    break;\n                }\n            }\n\n            if (limited) {\n                room.resetLiveTimeline(\n                    roomData.prev_batch,\n                    null, // TODO this.syncOpts.canResetEntireTimeline(room.roomId) ? null : syncEventData.oldSyncToken,\n                );\n\n                // We have to assume any gap in any timeline is\n                // reason to stop incrementally tracking notifications and\n                // reset the timeline.\n                this.client.resetNotifTimelineSet();\n                this.registerStateListeners(room);\n            }\n        } */\n\n        await this.injectRoomEvents(room, stateEvents, timelineEvents, roomData.num_live);\n\n        // we deliberately don't add ephemeral events to the timeline\n        room.addEphemeralEvents(ephemeralEvents);\n\n        // local fields must be set before any async calls because call site assumes\n        // synchronous execution prior to emitting SlidingSyncState.Complete\n        room.updateMyMembership(KnownMembership.Join);\n\n        room.setMSC4186SummaryData(roomData.heroes, roomData.joined_count, roomData.invited_count);\n\n        room.recalculate();\n        if (roomData.initial) {\n            client.store.storeRoom(room);\n            client.emit(ClientEvent.Room, room);\n        }\n\n        // check if any timeline events should bing and add them to the notifEvents array:\n        // we'll purge this once we've fully processed the sync response\n        this.addNotifications(timelineEvents);\n\n        const processRoomEvent = async (e: MatrixEvent): Promise<void> => {\n            client.emit(ClientEvent.Event, e);\n            if (e.isState() && e.getType() == EventType.RoomEncryption && this.syncOpts.cryptoCallbacks) {\n                await this.syncOpts.cryptoCallbacks.onCryptoEvent(room, e);\n            }\n        };\n\n        await promiseMapSeries(stateEvents, processRoomEvent);\n        await promiseMapSeries(timelineEvents, processRoomEvent);\n        ephemeralEvents.forEach(function (e) {\n            client.emit(ClientEvent.Event, e);\n        });\n\n        // Decrypt only the last message in all rooms to make sure we can generate a preview\n        // And decrypt all events after the recorded read receipt to ensure an accurate\n        // notification count\n        room.decryptCriticalEvents();\n    }\n\n    /**\n     * Injects events into a room's model.\n     * @param stateEventList - A list of state events. This is the state\n     * at the *END* of the timeline list if it is supplied.\n     * @param timelineEventList - A list of timeline events. Lower index\n     * is earlier in time. Higher index is later.\n     * @param numLive - the number of events in timelineEventList which just happened,\n     * supplied from the server.\n     */\n    public async injectRoomEvents(\n        room: Room,\n        stateEventList: MatrixEvent[],\n        timelineEventList: MatrixEvent[] = [],\n        numLive: number = 0,\n    ): Promise<void> {\n        // If there are no events in the timeline yet, initialise it with\n        // the given state events\n        const liveTimeline = room.getLiveTimeline();\n        const timelineWasEmpty = liveTimeline.getEvents().length == 0;\n        if (timelineWasEmpty) {\n            // Passing these events into initialiseState will freeze them, so we need\n            // to compute and cache the push actions for them now, otherwise sync dies\n            // with an attempt to assign to read only property.\n            // XXX: This is pretty horrible and is assuming all sorts of behaviour from\n            // these functions that it shouldn't be. We should probably either store the\n            // push actions cache elsewhere so we can freeze MatrixEvents, or otherwise\n            // find some solution where MatrixEvents are immutable but allow for a cache\n            // field.\n            for (const ev of stateEventList) {\n                this.client.getPushActionsForEvent(ev);\n            }\n            liveTimeline.initialiseState(stateEventList);\n        }\n\n        // If the timeline wasn't empty, we process the state events here: they're\n        // defined as updates to the state before the start of the timeline, so this\n        // starts to roll the state forward.\n        // XXX: That's what we *should* do, but this can happen if we were previously\n        // peeking in a room, in which case we obviously do *not* want to add the\n        // state events here onto the end of the timeline. Historically, the js-sdk\n        // has just set these new state events on the old and new state. This seems\n        // very wrong because there could be events in the timeline that diverge the\n        // state, in which case this is going to leave things out of sync. However,\n        // for now I think it;s best to behave the same as the code has done previously.\n        if (!timelineWasEmpty) {\n            // XXX: As above, don't do this...\n            //room.addLiveEvents(stateEventList || []);\n            // Do this instead...\n            room.oldState.setStateEvents(stateEventList);\n            room.currentState.setStateEvents(stateEventList);\n        }\n\n        // the timeline is broken into 'live' events which just happened and normal timeline events\n        // which are still to be appended to the end of the live timeline but happened a while ago.\n        // The live events are marked as fromCache=false to ensure that downstream components know\n        // this is a live event, not historical (from a remote server cache).\n\n        let liveTimelineEvents: MatrixEvent[] = [];\n        if (numLive > 0) {\n            // last numLive events are live\n            liveTimelineEvents = timelineEventList.slice(-1 * numLive);\n            // everything else is not live\n            timelineEventList = timelineEventList.slice(0, -1 * liveTimelineEvents.length);\n        }\n\n        // Execute the timeline events.\n        // This also needs to be done before running push rules on the events as they need\n        // to be decorated with sender etc.\n        await room.addLiveEvents(timelineEventList, {\n            fromCache: true,\n            addToState: false,\n        });\n        if (liveTimelineEvents.length > 0) {\n            await room.addLiveEvents(liveTimelineEvents, {\n                fromCache: false,\n                addToState: false,\n            });\n        }\n\n        room.recalculate();\n\n        // resolve invites now we have set the latest state\n        this.resolveInvites(room);\n    }\n\n    private resolveInvites(room: Room): void {\n        if (!room || !this.opts.resolveInvitesToProfiles) {\n            return;\n        }\n        const client = this.client;\n        // For each invited room member we want to give them a displayname/avatar url\n        // if they have one (the m.room.member invites don't contain this).\n        room.getMembersWithMembership(KnownMembership.Invite).forEach(function (member) {\n            if (member.requestedProfileInfo) return;\n            member.requestedProfileInfo = true;\n            // try to get a cached copy first.\n            const user = client.getUser(member.userId);\n            let promise: ReturnType<MatrixClient[\"getProfileInfo\"]>;\n            if (user) {\n                promise = Promise.resolve({\n                    avatar_url: user.avatarUrl,\n                    displayname: user.displayName,\n                });\n            } else {\n                promise = client.getProfileInfo(member.userId);\n            }\n            promise.then(\n                function (info) {\n                    // slightly naughty by doctoring the invite event but this means all\n                    // the code paths remain the same between invite/join display name stuff\n                    // which is a worthy trade-off for some minor pollution.\n                    const inviteEvent = member.events.member!;\n                    if (inviteEvent.getContent().membership !== KnownMembership.Invite) {\n                        // between resolving and now they have since joined, so don't clobber\n                        return;\n                    }\n                    inviteEvent.getContent().avatar_url = info.avatar_url;\n                    inviteEvent.getContent().displayname = info.displayname;\n                    // fire listeners\n                    member.setMembershipEvent(inviteEvent, room.currentState);\n                },\n                function (_err) {\n                    // OH WELL.\n                },\n            );\n        });\n    }\n\n    public retryImmediately(): boolean {\n        return true;\n    }\n\n    /**\n     * Main entry point. Blocks until stop() is called.\n     */\n    public async sync(): Promise<void> {\n        this.syncOpts.logger.debug(\"Sliding sync init loop\");\n\n        //   1) We need to get push rules so we can check if events should bing as we get\n        //      them from /sync.\n        while (!this.client.isGuest()) {\n            try {\n                this.syncOpts.logger.debug(\"Getting push rules...\");\n                const result = await this.client.getPushRules();\n                this.syncOpts.logger.debug(\"Got push rules\");\n                this.client.pushRules = result;\n                break;\n            } catch (err) {\n                this.syncOpts.logger.error(\"Getting push rules failed\", err);\n                if (this.shouldAbortSync(<MatrixError>err)) {\n                    return;\n                }\n            }\n        }\n\n        // start syncing\n        await this.slidingSync.start();\n    }\n\n    /**\n     * Stops the sync object from syncing.\n     */\n    public stop(): void {\n        this.syncOpts.logger.debug(\"SyncApi.stop\");\n        this.slidingSync.stop();\n    }\n\n    /**\n     * Sets the sync state and emits an event to say so\n     * @param newState - The new state string\n     * @param data - Object of additional data to emit in the event\n     */\n    private updateSyncState(newState: SyncState, data?: ISyncStateData): void {\n        const old = this.syncState;\n        this.syncState = newState;\n        this.syncStateData = data;\n        this.client.emit(ClientEvent.Sync, this.syncState, old, data);\n    }\n\n    /**\n     * Takes a list of timelineEvents and adds and adds to notifEvents\n     * as appropriate.\n     * This must be called after the room the events belong to has been stored.\n     *\n     * @param timelineEventList - A list of timeline events. Lower index\n     * is earlier in time. Higher index is later.\n     */\n    private addNotifications(timelineEventList: MatrixEvent[]): void {\n        // gather our notifications into this.notifEvents\n        if (!this.client.getNotifTimelineSet()) {\n            return;\n        }\n        for (const timelineEvent of timelineEventList) {\n            const pushActions = this.client.getPushActionsForEvent(timelineEvent);\n            if (pushActions && pushActions.notify && pushActions.tweaks && pushActions.tweaks.highlight) {\n                this.notifEvents.push(timelineEvent);\n            }\n        }\n    }\n\n    /**\n     * Purge any events in the notifEvents array. Used after a /sync has been complete.\n     * This should not be called at a per-room scope (e.g in onRoomData) because otherwise the ordering\n     * will be messed up e.g room A gets a bing, room B gets a newer bing, but both in the same /sync\n     * response. If we purge at a per-room scope then we could process room B before room A leading to\n     * room B appearing earlier in the notifications timeline, even though it has the higher origin_server_ts.\n     */\n    private purgeNotifications(): void {\n        this.notifEvents.sort(function (a, b) {\n            return a.getTs() - b.getTs();\n        });\n        this.notifEvents.forEach((event) => {\n            this.client.getNotifTimelineSet()?.addLiveEvent(event, { addToState: false });\n        });\n        this.notifEvents = [];\n    }\n}\n\nfunction ensureNameEvent(client: MatrixClient, roomId: string, roomData: MSC3575RoomData): MSC3575RoomData {\n    // make sure m.room.name is in required_state if there is a name, replacing anything previously\n    // there if need be. This ensures clients transparently 'calculate' the right room name. Native\n    // sliding sync clients should just read the \"name\" field.\n    if (!roomData.name) {\n        return roomData;\n    }\n    for (const stateEvent of roomData.required_state) {\n        if (stateEvent.type === EventType.RoomName && stateEvent.state_key === \"\") {\n            stateEvent.content = {\n                name: roomData.name,\n            };\n            return roomData;\n        }\n    }\n    roomData.required_state.push({\n        event_id: \"$fake-sliding-sync-name-event-\" + roomId,\n        state_key: \"\",\n        type: EventType.RoomName,\n        content: {\n            name: roomData.name,\n        },\n        sender: client.getUserId()!,\n        origin_server_ts: new Date().getTime(),\n    });\n    return roomData;\n}\n\ntype TaggedEvent = (IStrippedState | IRoomEvent | IStateEvent | IMinimalEvent) & { room_id?: string };\n\n// Helper functions which set up JS SDK structs are below and are identical to the sync v2 counterparts,\n// just outside the class.\nfunction mapEvents(client: MatrixClient, roomId: string | undefined, events: object[], decrypt = true): MatrixEvent[] {\n    const mapper = client.getEventMapper({ decrypt });\n    return (events as TaggedEvent[]).map(function (e) {\n        e.room_id = roomId;\n        return mapper(e);\n    });\n}\n\nfunction processEphemeralEvents(client: MatrixClient, roomId: string, ephEvents: IMinimalEvent[]): void {\n    const ephemeralEvents = mapEvents(client, roomId, ephEvents);\n    const room = client.getRoom(roomId);\n    if (!room) {\n        logger.warn(\"got ephemeral events for room but room doesn't exist on client:\", roomId);\n        return;\n    }\n    room.addEphemeralEvents(ephemeralEvents);\n    ephemeralEvents.forEach((e) => {\n        client.emit(ClientEvent.Event, e);\n    });\n}\n","/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IMinimalEvent, type ISyncData, type ISyncResponse, SyncAccumulator } from \"../sync-accumulator.ts\";\nimport { deepCopy, promiseTry } from \"../utils.ts\";\nimport { exists as idbExists } from \"../indexeddb-helpers.ts\";\nimport { logger } from \"../logger.ts\";\nimport { type IStateEventWithRoomId, type IStoredClientOpts } from \"../matrix.ts\";\nimport { type ISavedSync } from \"./index.ts\";\nimport { type IIndexedDBBackend, type UserTuple } from \"./indexeddb-backend.ts\";\nimport { type IndexedToDeviceBatch, type ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage.ts\";\n\ntype DbMigration = (db: IDBDatabase) => void;\nconst DB_MIGRATIONS: DbMigration[] = [\n    (db): void => {\n        // Make user store, clobber based on user ID. (userId property of User objects)\n        db.createObjectStore(\"users\", { keyPath: [\"userId\"] });\n\n        // Make account data store, clobber based on event type.\n        // (event.type property of MatrixEvent objects)\n        db.createObjectStore(\"accountData\", { keyPath: [\"type\"] });\n\n        // Make /sync store (sync tokens, room data, etc), always clobber (const key).\n        db.createObjectStore(\"sync\", { keyPath: [\"clobber\"] });\n    },\n    (db): void => {\n        const oobMembersStore = db.createObjectStore(\"oob_membership_events\", {\n            keyPath: [\"room_id\", \"state_key\"],\n        });\n        oobMembersStore.createIndex(\"room\", \"room_id\");\n    },\n    (db): void => {\n        db.createObjectStore(\"client_options\", { keyPath: [\"clobber\"] });\n    },\n    (db): void => {\n        db.createObjectStore(\"to_device_queue\", { autoIncrement: true });\n    },\n    // Expand as needed.\n];\nconst VERSION = DB_MIGRATIONS.length;\n\n/**\n * Helper method to collect results from a Cursor and promiseify it.\n * @param store - The store to perform openCursor on.\n * @param keyRange - Optional key range to apply on the cursor.\n * @param resultMapper - A function which is repeatedly called with a\n * Cursor.\n * Return the data you want to keep.\n * @returns Promise which resolves to an array of whatever you returned from\n * resultMapper.\n */\nfunction selectQuery<T>(\n    store: IDBObjectStore,\n    keyRange: IDBKeyRange | IDBValidKey | undefined,\n    resultMapper: (cursor: IDBCursorWithValue) => T,\n): Promise<T[]> {\n    const query = store.openCursor(keyRange);\n    return new Promise((resolve, reject) => {\n        const results: T[] = [];\n        query.onerror = (): void => {\n            reject(new Error(\"Query failed: \" + query.error?.name));\n        };\n        // collect results\n        query.onsuccess = (): void => {\n            const cursor = query.result;\n            if (!cursor) {\n                resolve(results);\n                return; // end of results\n            }\n            results.push(resultMapper(cursor));\n            cursor.continue();\n        };\n    });\n}\n\nfunction txnAsPromise(txn: IDBTransaction): Promise<Event> {\n    return new Promise((resolve, reject) => {\n        txn.oncomplete = function (event): void {\n            resolve(event);\n        };\n        txn.onerror = function (): void {\n            reject(txn.error);\n        };\n    });\n}\n\nfunction reqAsEventPromise(req: IDBRequest): Promise<Event> {\n    return new Promise((resolve, reject) => {\n        req.onsuccess = function (event): void {\n            resolve(event);\n        };\n        req.onerror = function (): void {\n            reject(req.error);\n        };\n    });\n}\n\nfunction reqAsPromise(req: IDBRequest): Promise<IDBRequest> {\n    return new Promise((resolve, reject) => {\n        req.onsuccess = (): void => resolve(req);\n        req.onerror = (err): void => reject(err);\n    });\n}\n\nfunction reqAsCursorPromise<T>(req: IDBRequest<T>): Promise<T> {\n    return reqAsEventPromise(req).then((event) => req.result);\n}\n\nexport class LocalIndexedDBStoreBackend implements IIndexedDBBackend {\n    public static exists(indexedDB: IDBFactory, dbName: string): Promise<boolean> {\n        dbName = \"matrix-js-sdk:\" + (dbName || \"default\");\n        return idbExists(indexedDB, dbName);\n    }\n\n    private readonly dbName: string;\n    private readonly syncAccumulator: SyncAccumulator;\n    private db?: IDBDatabase;\n    private disconnected = true;\n    private _isNewlyCreated = false;\n    private syncToDatabasePromise?: Promise<void>;\n    private pendingUserPresenceData: UserTuple[] = [];\n\n    /**\n     * Does the actual reading from and writing to the indexeddb\n     *\n     * Construct a new Indexed Database store backend. This requires a call to\n     * `connect()` before this store can be used.\n     * @param indexedDB - The Indexed DB interface e.g\n     * `window.indexedDB`\n     * @param dbName - Optional database name. The same name must be used\n     * to open the same database.\n     */\n    public constructor(\n        private readonly indexedDB: IDBFactory,\n        dbName = \"default\",\n    ) {\n        this.dbName = \"matrix-js-sdk:\" + dbName;\n        this.syncAccumulator = new SyncAccumulator();\n    }\n\n    /**\n     * Attempt to connect to the database. This can fail if the user does not\n     * grant permission.\n     * @returns Promise which resolves if successfully connected.\n     */\n    public connect(onClose?: () => void): Promise<void> {\n        if (!this.disconnected) {\n            logger.log(`LocalIndexedDBStoreBackend.connect: already connected or connecting`);\n            return Promise.resolve();\n        }\n\n        this.disconnected = false;\n\n        logger.log(`LocalIndexedDBStoreBackend.connect: connecting...`);\n        const req = this.indexedDB.open(this.dbName, VERSION);\n        req.onupgradeneeded = (ev): void => {\n            const db = req.result;\n            const oldVersion = ev.oldVersion;\n            logger.log(`LocalIndexedDBStoreBackend.connect: upgrading from ${oldVersion}`);\n            if (oldVersion < 1) {\n                // The database did not previously exist\n                this._isNewlyCreated = true;\n            }\n            DB_MIGRATIONS.forEach((migration, index) => {\n                if (oldVersion <= index) migration(db);\n            });\n        };\n\n        req.onblocked = (): void => {\n            logger.log(`can't yet open LocalIndexedDBStoreBackend because it is open elsewhere`);\n        };\n\n        logger.log(`LocalIndexedDBStoreBackend.connect: awaiting connection...`);\n        return reqAsEventPromise(req).then(async () => {\n            logger.log(`LocalIndexedDBStoreBackend.connect: connected`);\n            this.db = req.result;\n\n            // add a poorly-named listener for when deleteDatabase is called\n            // so we can close our db connections.\n            this.db.onversionchange = (): void => {\n                this.db?.close(); // this does not call onclose\n                this.disconnected = true;\n                this.db = undefined;\n            };\n            this.db.onclose = (): void => {\n                this.disconnected = true;\n                this.db = undefined;\n                onClose?.();\n            };\n\n            await this.init();\n        });\n    }\n\n    /** @returns whether or not the database was newly created in this session. */\n    public isNewlyCreated(): Promise<boolean> {\n        return Promise.resolve(this._isNewlyCreated);\n    }\n\n    /**\n     * Having connected, load initial data from the database and prepare for use\n     * @returns Promise which resolves on success\n     */\n    private init(): Promise<unknown> {\n        return Promise.all([this.loadAccountData(), this.loadSyncData()]).then(([accountData, syncData]) => {\n            logger.log(`LocalIndexedDBStoreBackend: loaded initial data`);\n            this.syncAccumulator.accumulate(\n                {\n                    next_batch: syncData.nextBatch,\n                    rooms: syncData.roomsData,\n                    account_data: {\n                        events: accountData,\n                    },\n                },\n                true,\n            );\n        });\n    }\n\n    /**\n     * Returns the out-of-band membership events for this room that\n     * were previously loaded.\n     * @returns the events, potentially an empty array if OOB loading didn't yield any new members\n     * @returns in case the members for this room haven't been stored yet\n     */\n    public getOutOfBandMembers(roomId: string): Promise<IStateEventWithRoomId[] | null> {\n        return new Promise<IStateEventWithRoomId[] | null>((resolve, reject) => {\n            const tx = this.db!.transaction([\"oob_membership_events\"], \"readonly\");\n            const store = tx.objectStore(\"oob_membership_events\");\n            const roomIndex = store.index(\"room\");\n            const range = IDBKeyRange.only(roomId);\n            const request = roomIndex.openCursor(range);\n\n            const membershipEvents: IStateEventWithRoomId[] = [];\n            // did we encounter the oob_written marker object\n            // amongst the results? That means OOB member\n            // loading already happened for this room\n            // but there were no members to persist as they\n            // were all known already\n            let oobWritten = false;\n\n            request.onsuccess = (): void => {\n                const cursor = request.result;\n                if (!cursor) {\n                    // Unknown room\n                    if (!membershipEvents.length && !oobWritten) {\n                        return resolve(null);\n                    }\n                    return resolve(membershipEvents);\n                }\n                const record = cursor.value;\n                if (record.oob_written) {\n                    oobWritten = true;\n                } else {\n                    membershipEvents.push(record);\n                }\n                cursor.continue();\n            };\n            request.onerror = (err): void => {\n                reject(err);\n            };\n        }).then((events) => {\n            logger.log(`LL: got ${events?.length} membershipEvents from storage for room ${roomId} ...`);\n            return events;\n        });\n    }\n\n    /**\n     * Stores the out-of-band membership events for this room. Note that\n     * it still makes sense to store an empty array as the OOB status for the room is\n     * marked as fetched, and getOutOfBandMembers will return an empty array instead of null\n     * @param membershipEvents - the membership events to store\n     */\n    public async setOutOfBandMembers(roomId: string, membershipEvents: IStateEventWithRoomId[]): Promise<void> {\n        logger.log(`LL: backend about to store ${membershipEvents.length}` + ` members for ${roomId}`);\n        const tx = this.db!.transaction([\"oob_membership_events\"], \"readwrite\");\n        const store = tx.objectStore(\"oob_membership_events\");\n        membershipEvents.forEach((e) => {\n            store.put(e);\n        });\n        // aside from all the events, we also write a marker object to the store\n        // to mark the fact that OOB members have been written for this room.\n        // It's possible that 0 members need to be written as all where previously know\n        // but we still need to know whether to return null or [] from getOutOfBandMembers\n        // where null means out of band members haven't been stored yet for this room\n        const markerObject = {\n            room_id: roomId,\n            oob_written: true,\n            state_key: 0,\n        };\n        store.put(markerObject);\n        await txnAsPromise(tx);\n        logger.log(`LL: backend done storing for ${roomId}!`);\n    }\n\n    public async clearOutOfBandMembers(roomId: string): Promise<void> {\n        // the approach to delete all members for a room\n        // is to get the min and max state key from the index\n        // for that room, and then delete between those\n        // keys in the store.\n        // this should be way faster than deleting every member\n        // individually for a large room.\n        const readTx = this.db!.transaction([\"oob_membership_events\"], \"readonly\");\n        const store = readTx.objectStore(\"oob_membership_events\");\n        const roomIndex = store.index(\"room\");\n        const roomRange = IDBKeyRange.only(roomId);\n\n        const minStateKeyProm = reqAsCursorPromise(roomIndex.openKeyCursor(roomRange, \"next\")).then(\n            (cursor) => (<IDBValidKey[]>cursor?.primaryKey)[1],\n        );\n        const maxStateKeyProm = reqAsCursorPromise(roomIndex.openKeyCursor(roomRange, \"prev\")).then(\n            (cursor) => (<IDBValidKey[]>cursor?.primaryKey)[1],\n        );\n        const [minStateKey, maxStateKey] = await Promise.all([minStateKeyProm, maxStateKeyProm]);\n\n        const writeTx = this.db!.transaction([\"oob_membership_events\"], \"readwrite\");\n        const writeStore = writeTx.objectStore(\"oob_membership_events\");\n        const membersKeyRange = IDBKeyRange.bound([roomId, minStateKey], [roomId, maxStateKey]);\n\n        logger.log(\n            `LL: Deleting all users + marker in storage for room ${roomId}, with key range:`,\n            [roomId, minStateKey],\n            [roomId, maxStateKey],\n        );\n        await reqAsPromise(writeStore.delete(membersKeyRange));\n    }\n\n    /**\n     * Clear the entire database. This should be used when logging out of a client\n     * to prevent mixing data between accounts. Closes the database.\n     * @returns Resolved when the database is cleared.\n     */\n    public clearDatabase(): Promise<void> {\n        return new Promise((resolve) => {\n            logger.log(`Removing indexeddb instance: ${this.dbName}`);\n\n            // Close the database first to avoid firing unexpected close events\n            this.db?.close();\n\n            const req = this.indexedDB.deleteDatabase(this.dbName);\n\n            req.onblocked = (): void => {\n                logger.log(`can't yet delete indexeddb ${this.dbName} because it is open elsewhere`);\n            };\n\n            req.onerror = (): void => {\n                // in firefox, with indexedDB disabled, this fails with a\n                // DOMError. We treat this as non-fatal, so that we can still\n                // use the app.\n                logger.warn(`unable to delete js-sdk store indexeddb: ${req.error?.name}`);\n                resolve();\n            };\n\n            req.onsuccess = (): void => {\n                logger.log(`Removed indexeddb instance: ${this.dbName}`);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * @param copy - If false, the data returned is from internal\n     * buffers and must not be mutated. Otherwise, a copy is made before\n     * returning such that the data can be safely mutated. Default: true.\n     *\n     * @returns Promise which resolves with a sync response to restore the\n     * client state to where it was at the last save, or null if there\n     * is no saved sync data.\n     */\n    public getSavedSync(copy = true): Promise<ISavedSync | null> {\n        const data = this.syncAccumulator.getJSON();\n        if (!data.nextBatch) return Promise.resolve(null);\n        if (copy) {\n            // We must deep copy the stored data so that the /sync processing code doesn't\n            // corrupt the internal state of the sync accumulator (it adds non-clonable keys)\n            return Promise.resolve(deepCopy(data));\n        } else {\n            return Promise.resolve(data);\n        }\n    }\n\n    public getNextBatchToken(): Promise<string> {\n        return Promise.resolve(this.syncAccumulator.getNextBatchToken());\n    }\n\n    public setSyncData(syncData: ISyncResponse): Promise<void> {\n        return Promise.resolve().then(() => {\n            this.syncAccumulator.accumulate(syncData);\n        });\n    }\n\n    /**\n     * Sync users and all accumulated sync data to the database.\n     * If a previous sync is in flight, the new data will be added to the\n     * next sync and the current sync's promise will be returned.\n     * @param userTuples - The user tuples\n     * @returns Promise which resolves if the data was persisted.\n     */\n    public async syncToDatabase(userTuples: UserTuple[]): Promise<void> {\n        if (this.syncToDatabasePromise) {\n            logger.warn(\"Skipping syncToDatabase() as persist already in flight\");\n            this.pendingUserPresenceData.push(...userTuples);\n            return this.syncToDatabasePromise;\n        }\n        userTuples.unshift(...this.pendingUserPresenceData);\n        this.syncToDatabasePromise = this.doSyncToDatabase(userTuples);\n        return this.syncToDatabasePromise;\n    }\n\n    private async doSyncToDatabase(userTuples: UserTuple[]): Promise<void> {\n        try {\n            const syncData = this.syncAccumulator.getJSON(true);\n            await Promise.all([\n                this.persistUserPresenceEvents(userTuples),\n                this.persistAccountData(syncData.accountData),\n                this.persistSyncData(syncData.nextBatch, syncData.roomsData),\n            ]);\n        } finally {\n            this.syncToDatabasePromise = undefined;\n        }\n    }\n\n    /**\n     * Persist rooms /sync data along with the next batch token.\n     * @param nextBatch - The next_batch /sync value.\n     * @param roomsData - The 'rooms' /sync data from a SyncAccumulator\n     * @returns Promise which resolves if the data was persisted.\n     */\n    private persistSyncData(nextBatch: string, roomsData: ISyncResponse[\"rooms\"]): Promise<void> {\n        logger.log(\"Persisting sync data up to\", nextBatch);\n        return promiseTry<void>(() => {\n            const txn = this.db!.transaction([\"sync\"], \"readwrite\");\n            const store = txn.objectStore(\"sync\");\n            store.put({\n                clobber: \"-\", // constant key so will always clobber\n                nextBatch,\n                roomsData,\n            }); // put == UPSERT\n            return txnAsPromise(txn).then(() => {\n                logger.log(\"Persisted sync data up to\", nextBatch);\n            });\n        });\n    }\n\n    /**\n     * Persist a list of account data events. Events with the same 'type' will\n     * be replaced.\n     * @param accountData - An array of raw user-scoped account data events\n     * @returns Promise which resolves if the events were persisted.\n     */\n    private persistAccountData(accountData: IMinimalEvent[]): Promise<void> {\n        return promiseTry<void>(() => {\n            const txn = this.db!.transaction([\"accountData\"], \"readwrite\");\n            const store = txn.objectStore(\"accountData\");\n            for (const event of accountData) {\n                store.put(event); // put == UPSERT\n            }\n            return txnAsPromise(txn).then();\n        });\n    }\n\n    /**\n     * Persist a list of [user id, presence event] they are for.\n     * Users with the same 'userId' will be replaced.\n     * Presence events should be the event in its raw form (not the Event\n     * object)\n     * @param tuples - An array of [userid, event] tuples\n     * @returns Promise which resolves if the users were persisted.\n     */\n    private persistUserPresenceEvents(tuples: UserTuple[]): Promise<void> {\n        return promiseTry<void>(() => {\n            const txn = this.db!.transaction([\"users\"], \"readwrite\");\n            const store = txn.objectStore(\"users\");\n            for (const tuple of tuples) {\n                store.put({\n                    userId: tuple[0],\n                    event: tuple[1],\n                }); // put == UPSERT\n            }\n            return txnAsPromise(txn).then();\n        });\n    }\n\n    /**\n     * Load all user presence events from the database. This is not cached.\n     * FIXME: It would probably be more sensible to store the events in the\n     * sync.\n     * @returns A list of presence events in their raw form.\n     */\n    public getUserPresenceEvents(): Promise<UserTuple[]> {\n        return promiseTry<UserTuple[]>(() => {\n            const txn = this.db!.transaction([\"users\"], \"readonly\");\n            const store = txn.objectStore(\"users\");\n            return selectQuery(store, undefined, (cursor) => {\n                return [cursor.value.userId, cursor.value.event];\n            });\n        });\n    }\n\n    /**\n     * Load all the account data events from the database. This is not cached.\n     * @returns A list of raw global account events.\n     */\n    private loadAccountData(): Promise<IMinimalEvent[]> {\n        logger.log(`LocalIndexedDBStoreBackend: loading account data...`);\n        return promiseTry<IMinimalEvent[]>(() => {\n            const txn = this.db!.transaction([\"accountData\"], \"readonly\");\n            const store = txn.objectStore(\"accountData\");\n            return selectQuery(store, undefined, (cursor) => {\n                return cursor.value;\n            }).then((result: IMinimalEvent[]) => {\n                logger.log(`LocalIndexedDBStoreBackend: loaded account data`);\n                return result;\n            });\n        });\n    }\n\n    /**\n     * Load the sync data from the database.\n     * @returns An object with \"roomsData\" and \"nextBatch\" keys.\n     */\n    private loadSyncData(): Promise<ISyncData> {\n        logger.log(`LocalIndexedDBStoreBackend: loading sync data...`);\n        return promiseTry<ISyncData>(() => {\n            const txn = this.db!.transaction([\"sync\"], \"readonly\");\n            const store = txn.objectStore(\"sync\");\n            return selectQuery(store, undefined, (cursor) => {\n                return cursor.value;\n            }).then((results: ISyncData[]) => {\n                logger.log(`LocalIndexedDBStoreBackend: loaded sync data`);\n                if (results.length > 1) {\n                    logger.warn(\"loadSyncData: More than 1 sync row found.\");\n                }\n                return results.length > 0 ? results[0] : ({} as ISyncData);\n            });\n        });\n    }\n\n    public getClientOptions(): Promise<IStoredClientOpts | undefined> {\n        return Promise.resolve().then(() => {\n            const txn = this.db!.transaction([\"client_options\"], \"readonly\");\n            const store = txn.objectStore(\"client_options\");\n            return selectQuery(store, undefined, (cursor) => {\n                return cursor.value?.options;\n            }).then((results) => results[0]);\n        });\n    }\n\n    public async storeClientOptions(options: IStoredClientOpts): Promise<void> {\n        const txn = this.db!.transaction([\"client_options\"], \"readwrite\");\n        const store = txn.objectStore(\"client_options\");\n        store.put({\n            clobber: \"-\", // constant key so will always clobber\n            options: options,\n        }); // put == UPSERT\n        await txnAsPromise(txn);\n    }\n\n    public async saveToDeviceBatches(batches: ToDeviceBatchWithTxnId[]): Promise<void> {\n        const txn = this.db!.transaction([\"to_device_queue\"], \"readwrite\");\n        const store = txn.objectStore(\"to_device_queue\");\n        for (const batch of batches) {\n            store.add(batch);\n        }\n        await txnAsPromise(txn);\n    }\n\n    public async getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch | null> {\n        const txn = this.db!.transaction([\"to_device_queue\"], \"readonly\");\n        const store = txn.objectStore(\"to_device_queue\");\n        const cursor = await reqAsCursorPromise(store.openCursor());\n        if (!cursor) return null;\n\n        const resultBatch = cursor.value as ToDeviceBatchWithTxnId;\n\n        return {\n            id: cursor.key as number,\n            txnId: resultBatch.txnId,\n            eventType: resultBatch.eventType,\n            batch: resultBatch.batch,\n        };\n    }\n\n    public async removeToDeviceBatch(id: number): Promise<void> {\n        const txn = this.db!.transaction([\"to_device_queue\"], \"readwrite\");\n        const store = txn.objectStore(\"to_device_queue\");\n        store.delete(id);\n        await txnAsPromise(txn);\n    }\n\n    /*\n     * Close the database\n     */\n    public async destroy(): Promise<void> {\n        this.db?.close();\n    }\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module.\n */\n\nimport { type EventType } from \"../@types/event.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { type User } from \"../models/user.ts\";\nimport { type IEvent, type MatrixEvent } from \"../models/event.ts\";\nimport { type Filter } from \"../filter.ts\";\nimport { type ISavedSync, type IStore, type UserCreator } from \"./index.ts\";\nimport { type RoomSummary } from \"../models/room-summary.ts\";\nimport { type ISyncResponse } from \"../sync-accumulator.ts\";\nimport { type IStateEventWithRoomId } from \"../@types/search.ts\";\nimport { type IndexedToDeviceBatch, type ToDeviceBatch } from \"../models/ToDeviceMessage.ts\";\nimport { type IStoredClientOpts } from \"../client.ts\";\n\n/**\n * Construct a stub store. This does no-ops on most store methods.\n */\nexport class StubStore implements IStore {\n    public readonly accountData = new Map(); // stub\n    private fromToken: string | null = null;\n\n    /** @returns whether or not the database was newly created in this session. */\n    public isNewlyCreated(): Promise<boolean> {\n        return Promise.resolve(true);\n    }\n\n    /**\n     * Get the sync token.\n     */\n    public getSyncToken(): string | null {\n        return this.fromToken;\n    }\n\n    /**\n     * Set the sync token.\n     */\n    public setSyncToken(token: string): void {\n        this.fromToken = token;\n    }\n\n    /**\n     * No-op.\n     */\n    public storeRoom(room: Room): void {}\n\n    /**\n     * No-op.\n     */\n    public getRoom(roomId: string): Room | null {\n        return null;\n    }\n\n    /**\n     * No-op.\n     * @returns An empty array.\n     */\n    public getRooms(): Room[] {\n        return [];\n    }\n\n    /**\n     * Permanently delete a room.\n     */\n    public removeRoom(roomId: string): void {\n        return;\n    }\n\n    /**\n     * No-op.\n     * @returns An empty array.\n     */\n    public getRoomSummaries(): RoomSummary[] {\n        return [];\n    }\n\n    /**\n     * No-op.\n     */\n    public storeUser(user: User): void {}\n\n    /**\n     * No-op.\n     */\n    public getUser(userId: string): User | null {\n        return null;\n    }\n\n    /**\n     * No-op.\n     */\n    public getUsers(): User[] {\n        return [];\n    }\n\n    /**\n     * No-op.\n     */\n    public scrollback(room: Room, limit: number): MatrixEvent[] {\n        return [];\n    }\n\n    /**\n     * No-op.\n     */\n    public setUserCreator(creator: UserCreator): void {\n        return;\n    }\n\n    /**\n     * Store events for a room.\n     * @param room - The room to store events for.\n     * @param events - The events to store.\n     * @param token - The token associated with these events.\n     * @param toStart - True if these are paginated results.\n     */\n    public storeEvents(room: Room, events: MatrixEvent[], token: string | null, toStart: boolean): void {}\n\n    /**\n     * Store a filter.\n     */\n    public storeFilter(filter: Filter): void {}\n\n    /**\n     * Retrieve a filter.\n     * @returns A filter or null.\n     */\n    public getFilter(userId: string, filterId: string): Filter | null {\n        return null;\n    }\n\n    /**\n     * Retrieve a filter ID with the given name.\n     * @param filterName - The filter name.\n     * @returns The filter ID or null.\n     */\n    public getFilterIdByName(filterName: string): string | null {\n        return null;\n    }\n\n    /**\n     * Set a filter name to ID mapping.\n     */\n    public setFilterIdByName(filterName: string, filterId?: string): void {}\n\n    /**\n     * Store user-scoped account data events\n     * @param events - The events to store.\n     */\n    public storeAccountDataEvents(events: MatrixEvent[]): void {}\n\n    /**\n     * Get account data event by event type\n     * @param eventType - The event type being queried\n     */\n    public getAccountData(eventType: EventType | string): MatrixEvent | undefined {\n        return undefined;\n    }\n\n    /**\n     * setSyncData does nothing as there is no backing data store.\n     *\n     * @param syncData - The sync data\n     * @returns An immediately resolved promise.\n     */\n    public setSyncData(syncData: ISyncResponse): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * We never want to save because we have nothing to save to.\n     *\n     * @returns If the store wants to save\n     */\n    public wantsSave(): boolean {\n        return false;\n    }\n\n    /**\n     * Save does nothing as there is no backing data store.\n     */\n    public save(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Startup does nothing.\n     * @returns An immediately resolved promise.\n     */\n    public startup(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * @returns Promise which resolves with a sync response to restore the\n     * client state to where it was at the last save, or null if there\n     * is no saved sync data.\n     */\n    public getSavedSync(): Promise<ISavedSync | null> {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * @returns If there is a saved sync, the nextBatch token\n     * for this sync, otherwise null.\n     */\n    public getSavedSyncToken(): Promise<string | null> {\n        return Promise.resolve(null);\n    }\n\n    /**\n     * Delete all data from this store. Does nothing since this store\n     * doesn't store anything.\n     * @returns An immediately resolved promise.\n     */\n    public deleteAllData(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    public getOutOfBandMembers(): Promise<IStateEventWithRoomId[] | null> {\n        return Promise.resolve(null);\n    }\n\n    public setOutOfBandMembers(roomId: string, membershipEvents: IStateEventWithRoomId[]): Promise<void> {\n        return Promise.resolve();\n    }\n\n    public clearOutOfBandMembers(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    public getClientOptions(): Promise<IStoredClientOpts | undefined> {\n        return Promise.resolve(undefined);\n    }\n\n    public storeClientOptions(options: IStoredClientOpts): Promise<void> {\n        return Promise.resolve();\n    }\n\n    public async getPendingEvents(roomId: string): Promise<Partial<IEvent>[]> {\n        return [];\n    }\n\n    public setPendingEvents(roomId: string, events: Partial<IEvent>[]): Promise<void> {\n        return Promise.resolve();\n    }\n\n    public async saveToDeviceBatches(batch: ToDeviceBatch[]): Promise<void> {\n        return Promise.resolve();\n    }\n\n    public getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch | null> {\n        return Promise.resolve(null);\n    }\n\n    public async removeToDeviceBatch(id: number): Promise<void> {\n        return Promise.resolve();\n    }\n\n    public async destroy(): Promise<void> {\n        // Nothing to do\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { THREAD_RELATION_TYPE } from \"./models/thread.ts\";\nimport { type IEvent } from \"./models/event.ts\";\n\n/**\n * Returns a filter function for the /relations endpoint to filter out relations directly\n * to the thread root event that should not live in the thread timeline\n *\n * @param threadId - the thread ID (ie. the event ID of the root event of the thread)\n * @returns the filtered list of events\n */\nexport function getRelationsThreadFilter(threadId: string): (e: Partial<IEvent>) => boolean {\n    return (e: Partial<IEvent>) =>\n        e.content?.[\"m.relates_to\"]?.event_id !== threadId ||\n        e.content?.[\"m.relates_to\"]?.rel_type === THREAD_RELATION_TYPE.name;\n}\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBase64, encodeBase64 } from \"../base64.ts\";\nimport { deriveKeys } from \"./internal/deriveKeys.ts\";\nimport { type AESEncryptedSecretStoragePayload } from \"../@types/AESEncryptedSecretStoragePayload.ts\";\n\n/**\n * Encrypt a string as a secret storage item, using AES-CTR.\n *\n * @param data - the plaintext to encrypt\n * @param key - the encryption key to use as an input to the HKDF function which is used to derive the AES key for\n *    encryption. Obviously, the same key must be provided when decrypting.\n * @param name - the name of the secret. Used as an input to the HKDF operation which is used to derive the AES key,\n *    so again the same value must be provided when decrypting.\n * @param ivStr - the base64-encoded initialization vector to use. If not supplied, a random one will be generated.\n *\n * @returns The encrypted result, including the ciphertext itself, the initialization vector (as supplied in `ivStr`,\n *   or generated), and an HMAC on the ciphertext  all base64-encoded.\n */\nexport default async function encryptAESSecretStorageItem(\n    data: string,\n    key: Uint8Array,\n    name: string,\n    ivStr?: string,\n): Promise<AESEncryptedSecretStoragePayload> {\n    let iv: Uint8Array;\n    if (ivStr) {\n        iv = decodeBase64(ivStr);\n    } else {\n        iv = new Uint8Array(16);\n        globalThis.crypto.getRandomValues(iv);\n\n        // clear bit 63 of the IV to stop us hitting the 64-bit counter boundary\n        // (which would mean we wouldn't be able to decrypt on Android). The loss\n        // of a single bit of iv is a price we have to pay.\n        iv[8] &= 0x7f;\n    }\n\n    const [aesKey, hmacKey] = await deriveKeys(key, name);\n    const encodedData = new TextEncoder().encode(data);\n\n    const ciphertext = await globalThis.crypto.subtle.encrypt(\n        {\n            name: \"AES-CTR\",\n            counter: iv,\n            length: 64,\n        },\n        aesKey,\n        encodedData,\n    );\n\n    const hmac = await globalThis.crypto.subtle.sign({ name: \"HMAC\" }, hmacKey, ciphertext);\n\n    return {\n        iv: encodeBase64(iv),\n        ciphertext: encodeBase64(new Uint8Array(ciphertext)),\n        mac: encodeBase64(new Uint8Array(hmac)),\n    };\n}\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// salt for HKDF, with 8 bytes of zeros\nconst zeroSalt = new Uint8Array(8);\n\n/**\n * Derive AES and HMAC keys from a master key.\n *\n * This is used for deriving secret storage keys: see https://spec.matrix.org/v1.11/client-server-api/#msecret_storagev1aes-hmac-sha2 (step 1).\n *\n * @param key\n * @param name\n */\nexport async function deriveKeys(key: Uint8Array, name: string): Promise<[CryptoKey, CryptoKey]> {\n    const hkdfkey = await globalThis.crypto.subtle.importKey(\"raw\", key, { name: \"HKDF\" }, false, [\"deriveBits\"]);\n    const keybits = await globalThis.crypto.subtle.deriveBits(\n        {\n            name: \"HKDF\",\n            salt: zeroSalt,\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/879\n            info: new TextEncoder().encode(name),\n            hash: \"SHA-256\",\n        },\n        hkdfkey,\n        512,\n    );\n\n    const aesKey = keybits.slice(0, 32);\n    const hmacKey = keybits.slice(32);\n\n    const aesProm = globalThis.crypto.subtle.importKey(\"raw\", aesKey, { name: \"AES-CTR\" }, false, [\n        \"encrypt\",\n        \"decrypt\",\n    ]);\n\n    const hmacProm = globalThis.crypto.subtle.importKey(\n        \"raw\",\n        hmacKey,\n        {\n            name: \"HMAC\",\n            hash: { name: \"SHA-256\" },\n        },\n        false,\n        [\"sign\", \"verify\"],\n    );\n\n    return Promise.all([aesProm, hmacProm]);\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Room versions strings that we know about and do not use hydra semantics.\n */\nconst PRE_HYDRA_ROOM_VERSIONS = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\"];\n\n/**\n * Checks if the given room version is one where new \"hydra\" power level\n * semantics (ie. room version 12 or later) should be used\n * (see https://github.com/matrix-org/matrix-spec-proposals/pull/4289).\n * This will return `false` for versions that are known to the js-sdk and\n * do not use hydra: any room versions unknown to the js-sdk (experimental or\n * otherwise) will cause the function to return true.\n *\n * @param roomVersion - The version of the room to check.\n * @returns `true` if hydra semantics should be used for the room version, `false` otherwise.\n */\nexport function shouldUseHydraForRoomVersion(roomVersion: string): boolean {\n    return !PRE_HYDRA_ROOM_VERSIONS.includes(roomVersion);\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nlet audioContext: AudioContext | null = null;\nlet refCount = 0;\n\n/**\n * Acquires a reference to the shared AudioContext.\n * It's highly recommended to reuse this AudioContext rather than creating your\n * own, because multiple AudioContexts can be problematic in some browsers.\n * Make sure to call releaseContext when you're done using it.\n * @returns The shared AudioContext\n */\nexport const acquireContext = (): AudioContext => {\n    if (audioContext === null) audioContext = new AudioContext();\n    refCount++;\n    return audioContext;\n};\n\n/**\n * Signals that one of the references to the shared AudioContext has been\n * released, allowing the context and associated hardware resources to be\n * cleaned up if nothing else is using it.\n */\nexport const releaseContext = (): void => {\n    refCount--;\n    if (refCount === 0) {\n        audioContext?.close();\n        audioContext = null;\n    }\n};\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { logger } from \"../logger.ts\";\nimport { CallDirection, CallError, CallErrorCode, CallState, createNewMatrixCall, type MatrixCall } from \"./call.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { ClientEvent, type MatrixClient } from \"../client.ts\";\nimport { type MCallAnswer, type MCallHangupReject } from \"./callEventTypes.ts\";\nimport { type GroupCall, GroupCallErrorCode, GroupCallEvent, GroupCallUnknownDeviceError } from \"./groupCall.ts\";\nimport { RoomEvent } from \"../models/room.ts\";\n\n// Don't ring unless we'd be ringing for at least 3 seconds: the user needs some\n// time to press the 'accept' button\nconst RING_GRACE_PERIOD = 3000;\n\nexport enum CallEventHandlerEvent {\n    Incoming = \"Call.incoming\",\n}\n\nexport type CallEventHandlerEventHandlerMap = {\n    /**\n     * Fires whenever an incoming call arrives.\n     * @param call - The incoming call.\n     * @example\n     * ```\n     * matrixClient.on(\"Call.incoming\", function(call){\n     *   call.answer(); // auto-answer\n     * });\n     * ```\n     */\n    [CallEventHandlerEvent.Incoming]: (call: MatrixCall) => void;\n};\n\nexport class CallEventHandler {\n    // XXX: Most of these are only public because of the tests\n    public calls: Map<string, MatrixCall>;\n    public callEventBuffer: MatrixEvent[];\n    public nextSeqByCall: Map<string, number> = new Map();\n    public toDeviceEventBuffers: Map<string, Array<MatrixEvent>> = new Map();\n\n    private client: MatrixClient;\n    private candidateEventsByCall: Map<string, Array<MatrixEvent>>;\n    private eventBufferPromiseChain?: Promise<void>;\n\n    public constructor(client: MatrixClient) {\n        this.client = client;\n        this.calls = new Map<string, MatrixCall>();\n        // The sync code always emits one event at a time, so it will patiently\n        // wait for us to finish processing a call invite before delivering the\n        // next event, even if that next event is a hangup. We therefore accumulate\n        // all our call events and then process them on the 'sync' event, ie.\n        // each time a sync has completed. This way, we can avoid emitting incoming\n        // call events if we get both the invite and answer/hangup in the same sync.\n        // This happens quite often, eg. replaying sync from storage, catchup sync\n        // after loading and after we've been offline for a bit.\n        this.callEventBuffer = [];\n        this.candidateEventsByCall = new Map<string, Array<MatrixEvent>>();\n    }\n\n    public start(): void {\n        this.client.on(ClientEvent.Sync, this.onSync);\n        this.client.on(RoomEvent.Timeline, this.onRoomTimeline);\n        this.client.on(ClientEvent.ToDeviceEvent, this.onToDeviceEvent);\n    }\n\n    public stop(): void {\n        this.client.removeListener(ClientEvent.Sync, this.onSync);\n        this.client.removeListener(RoomEvent.Timeline, this.onRoomTimeline);\n        this.client.removeListener(ClientEvent.ToDeviceEvent, this.onToDeviceEvent);\n    }\n\n    private onSync = (): void => {\n        // Process the current event buffer and start queuing into a new one.\n        const currentEventBuffer = this.callEventBuffer;\n        this.callEventBuffer = [];\n\n        // Ensure correct ordering by only processing this queue after the previous one has finished processing\n        if (this.eventBufferPromiseChain) {\n            this.eventBufferPromiseChain = this.eventBufferPromiseChain.then(() =>\n                this.evaluateEventBuffer(currentEventBuffer),\n            );\n        } else {\n            this.eventBufferPromiseChain = this.evaluateEventBuffer(currentEventBuffer);\n        }\n    };\n\n    private async evaluateEventBuffer(eventBuffer: MatrixEvent[]): Promise<void> {\n        await Promise.all(eventBuffer.map((event) => this.client.decryptEventIfNeeded(event)));\n\n        const callEvents = eventBuffer.filter((event) => {\n            const eventType = event.getType();\n            return eventType.startsWith(\"m.call.\") || eventType.startsWith(\"org.matrix.call.\");\n        });\n\n        const ignoreCallIds = new Set<string>();\n\n        // inspect the buffer and mark all calls which have been answered\n        // or hung up before passing them to the call event handler.\n        for (const event of callEvents) {\n            const eventType = event.getType();\n\n            if (eventType === EventType.CallAnswer || eventType === EventType.CallHangup) {\n                ignoreCallIds.add(event.getContent().call_id);\n            }\n        }\n\n        // Process call events in the order that they were received\n        for (const event of callEvents) {\n            const eventType = event.getType();\n            const callId = event.getContent().call_id;\n\n            if (eventType === EventType.CallInvite && ignoreCallIds.has(callId)) {\n                // This call has previously been answered or hung up: ignore it\n                continue;\n            }\n\n            try {\n                await this.handleCallEvent(event);\n            } catch (e) {\n                logger.error(\"CallEventHandler evaluateEventBuffer() caught exception handling call event\", e);\n            }\n        }\n    }\n\n    private onRoomTimeline = (event: MatrixEvent): void => {\n        this.callEventBuffer.push(event);\n    };\n\n    private onToDeviceEvent = (event: MatrixEvent): void => {\n        const content = event.getContent();\n\n        if (!content.call_id) {\n            this.callEventBuffer.push(event);\n            return;\n        }\n\n        if (!this.nextSeqByCall.has(content.call_id)) {\n            this.nextSeqByCall.set(content.call_id, 0);\n        }\n\n        if (content.seq === undefined) {\n            this.callEventBuffer.push(event);\n            return;\n        }\n\n        const nextSeq = this.nextSeqByCall.get(content.call_id) || 0;\n\n        if (content.seq !== nextSeq) {\n            if (!this.toDeviceEventBuffers.has(content.call_id)) {\n                this.toDeviceEventBuffers.set(content.call_id, []);\n            }\n\n            const buffer = this.toDeviceEventBuffers.get(content.call_id)!;\n            const index = buffer.findIndex((e) => e.getContent().seq > content.seq);\n\n            if (index === -1) {\n                buffer.push(event);\n            } else {\n                buffer.splice(index, 0, event);\n            }\n        } else {\n            const callId = content.call_id;\n            this.callEventBuffer.push(event);\n            this.nextSeqByCall.set(callId, content.seq + 1);\n\n            const buffer = this.toDeviceEventBuffers.get(callId);\n\n            let nextEvent = buffer && buffer.shift();\n\n            while (nextEvent && nextEvent.getContent().seq === this.nextSeqByCall.get(callId)) {\n                this.callEventBuffer.push(nextEvent);\n                this.nextSeqByCall.set(callId, nextEvent.getContent().seq + 1);\n                nextEvent = buffer!.shift();\n            }\n        }\n    };\n\n    private async handleCallEvent(event: MatrixEvent): Promise<void> {\n        this.client.emit(ClientEvent.ReceivedVoipEvent, event);\n\n        const content = event.getContent();\n        const callRoomId =\n            event.getRoomId() || this.client.groupCallEventHandler!.getGroupCallById(content.conf_id)?.room?.roomId;\n        const groupCallId = content.conf_id;\n        const type = event.getType() as EventType;\n        const senderId = event.getSender()!;\n        let call = content.call_id ? this.calls.get(content.call_id) : undefined;\n\n        let opponentDeviceId: string | undefined;\n\n        let groupCall: GroupCall | undefined;\n        if (groupCallId) {\n            groupCall = this.client.groupCallEventHandler!.getGroupCallById(groupCallId);\n\n            if (!groupCall) {\n                logger.warn(\n                    `CallEventHandler handleCallEvent() could not find a group call - ignoring event (groupCallId=${groupCallId}, type=${type})`,\n                );\n                return;\n            }\n\n            opponentDeviceId = content.device_id;\n\n            if (!opponentDeviceId) {\n                logger.warn(\n                    `CallEventHandler handleCallEvent() could not find a device id - ignoring event (senderId=${senderId})`,\n                );\n                groupCall.emit(GroupCallEvent.Error, new GroupCallUnknownDeviceError(senderId));\n                return;\n            }\n\n            if (content.dest_session_id !== this.client.getSessionId()) {\n                logger.warn(\n                    \"CallEventHandler handleCallEvent() call event does not match current session id - ignoring\",\n                );\n                return;\n            }\n        }\n\n        const weSentTheEvent =\n            senderId === this.client.credentials.userId &&\n            (opponentDeviceId === undefined || opponentDeviceId === this.client.getDeviceId()!);\n\n        if (!callRoomId) return;\n\n        if (type === EventType.CallInvite) {\n            // ignore invites you send\n            if (weSentTheEvent) return;\n            // expired call\n            if (event.getLocalAge() > content.lifetime - RING_GRACE_PERIOD) return;\n            // stale/old invite event\n            if (call && call.state === CallState.Ended) return;\n\n            if (call) {\n                logger.warn(\n                    `CallEventHandler handleCallEvent() already has a call but got an invite - clobbering (callId=${content.call_id})`,\n                );\n            }\n\n            if (content.invitee && content.invitee !== this.client.getUserId()) {\n                return; // This invite was meant for another user in the room\n            }\n\n            const timeUntilTurnCresExpire = (this.client.getTurnServersExpiry() ?? 0) - Date.now();\n            logger.info(\n                \"CallEventHandler handleCallEvent() current turn creds expire in \" + timeUntilTurnCresExpire + \" ms\",\n            );\n            call =\n                createNewMatrixCall(this.client, callRoomId, {\n                    forceTURN: this.client.forceTURN,\n                    opponentDeviceId,\n                    groupCallId,\n                    opponentSessionId: content.sender_session_id,\n                }) ?? undefined;\n            if (!call) {\n                logger.log(\n                    `CallEventHandler handleCallEvent() this client does not support WebRTC (callId=${content.call_id})`,\n                );\n                // don't hang up the call: there could be other clients\n                // connected that do support WebRTC and declining the\n                // the call on their behalf would be really annoying.\n                return;\n            }\n\n            call.callId = content.call_id;\n            const stats = groupCall?.getGroupCallStats();\n            if (stats) {\n                call.initStats(stats);\n            }\n\n            try {\n                await call.initWithInvite(event);\n            } catch (e) {\n                if (e instanceof CallError) {\n                    if (e.code === GroupCallErrorCode.UnknownDevice) {\n                        groupCall?.emit(GroupCallEvent.Error, e);\n                    } else {\n                        logger.error(e);\n                    }\n                }\n            }\n            this.calls.set(call.callId, call);\n\n            // if we stashed candidate events for that call ID, play them back now\n            if (this.candidateEventsByCall.get(call.callId)) {\n                for (const ev of this.candidateEventsByCall.get(call.callId)!) {\n                    call.onRemoteIceCandidatesReceived(ev);\n                }\n            }\n\n            // Were we trying to call that user (room)?\n            let existingCall: MatrixCall | undefined;\n            for (const thisCall of this.calls.values()) {\n                const isCalling = [CallState.WaitLocalMedia, CallState.CreateOffer, CallState.InviteSent].includes(\n                    thisCall.state,\n                );\n\n                if (\n                    call.roomId === thisCall.roomId &&\n                    thisCall.direction === CallDirection.Outbound &&\n                    call.getOpponentMember()?.userId === thisCall.invitee &&\n                    isCalling\n                ) {\n                    existingCall = thisCall;\n                    break;\n                }\n            }\n\n            if (existingCall) {\n                if (existingCall.callId > call.callId) {\n                    logger.log(\n                        `CallEventHandler handleCallEvent() detected glare - answering incoming call and canceling outgoing call (incomingId=${call.callId}, outgoingId=${existingCall.callId})`,\n                    );\n                    existingCall.replacedBy(call);\n                } else {\n                    logger.log(\n                        `CallEventHandler handleCallEvent() detected glare - hanging up incoming call (incomingId=${call.callId}, outgoingId=${existingCall.callId})`,\n                    );\n                    call.hangup(CallErrorCode.Replaced, true);\n                }\n            } else {\n                this.client.emit(CallEventHandlerEvent.Incoming, call);\n            }\n            return;\n        } else if (type === EventType.CallCandidates) {\n            if (weSentTheEvent) return;\n\n            if (!call) {\n                // store the candidates; we may get a call eventually.\n                if (!this.candidateEventsByCall.has(content.call_id)) {\n                    this.candidateEventsByCall.set(content.call_id, []);\n                }\n                this.candidateEventsByCall.get(content.call_id)!.push(event);\n            } else {\n                call.onRemoteIceCandidatesReceived(event);\n            }\n            return;\n        } else if ([EventType.CallHangup, EventType.CallReject].includes(type)) {\n            // Note that we also observe our own hangups here so we can see\n            // if we've already rejected a call that would otherwise be valid\n            if (!call) {\n                // if not live, store the fact that the call has ended because\n                // we're probably getting events backwards so\n                // the hangup will come before the invite\n                call =\n                    createNewMatrixCall(this.client, callRoomId, {\n                        opponentDeviceId,\n                        opponentSessionId: content.sender_session_id,\n                    }) ?? undefined;\n                if (call) {\n                    call.callId = content.call_id;\n                    call.initWithHangup(event);\n                    this.calls.set(content.call_id, call);\n                }\n            } else {\n                if (call.state !== CallState.Ended) {\n                    if (type === EventType.CallHangup) {\n                        call.onHangupReceived(content as MCallHangupReject);\n                    } else {\n                        call.onRejectReceived(content as MCallHangupReject);\n                    }\n\n                    // @ts-expect-error typescript thinks the state can't be 'ended' because we're\n                    // inside the if block where it wasn't, but it could have changed because\n                    // on[Hangup|Reject]Received are side-effecty.\n                    if (call.state === CallState.Ended) this.calls.delete(content.call_id);\n                }\n            }\n            return;\n        }\n\n        // The following events need a call and a peer connection\n        if (!call || !call.hasPeerConnection) {\n            logger.info(\n                `CallEventHandler handleCallEvent() discarding possible call event as we don't have a call (type=${type})`,\n            );\n            return;\n        }\n        // Ignore remote echo\n        if (event.getContent().party_id === call.ourPartyId) return;\n\n        switch (type) {\n            case EventType.CallAnswer:\n                if (weSentTheEvent) {\n                    if (call.state === CallState.Ringing) {\n                        call.onAnsweredElsewhere(content as MCallAnswer);\n                    }\n                } else {\n                    call.onAnswerReceived(event);\n                }\n                break;\n            case EventType.CallSelectAnswer:\n                call.onSelectAnswerReceived(event);\n                break;\n\n            case EventType.CallNegotiate:\n                call.onNegotiateReceived(event);\n                break;\n\n            case EventType.CallAssertedIdentity:\n            case EventType.CallAssertedIdentityPrefix:\n                call.onAssertedIdentityReceived(event);\n                break;\n\n            case EventType.CallSDPStreamMetadataChanged:\n            case EventType.CallSDPStreamMetadataChangedPrefix:\n                call.onSDPStreamMetadataChangedReceived(event);\n                break;\n        }\n    }\n}\n","// allow non-camelcase as these are events type that go onto the wire\n/* eslint-disable camelcase */\n\nimport { type CallErrorCode } from \"./call.ts\";\n\n// TODO: Change to \"sdp_stream_metadata\" when MSC3077 is merged\nexport const SDPStreamMetadataKey = \"org.matrix.msc3077.sdp_stream_metadata\";\n\nexport enum SDPStreamMetadataPurpose {\n    Usermedia = \"m.usermedia\",\n    Screenshare = \"m.screenshare\",\n}\n\nexport interface SDPStreamMetadataObject {\n    purpose: SDPStreamMetadataPurpose;\n    audio_muted: boolean;\n    video_muted: boolean;\n}\n\nexport interface SDPStreamMetadata {\n    [key: string]: SDPStreamMetadataObject;\n}\n\nexport interface CallCapabilities {\n    \"m.call.transferee\": boolean;\n    \"m.call.dtmf\": boolean;\n}\n\nexport interface CallReplacesTarget {\n    id: string;\n    display_name: string;\n    avatar_url: string;\n}\n\nexport interface MCallBase {\n    call_id: string;\n    conf_id?: string;\n    version: string | number;\n    party_id?: string;\n    sender_session_id?: string;\n    dest_session_id?: string;\n}\n\nexport interface MCallAnswer extends MCallBase {\n    answer: RTCSessionDescription;\n    capabilities?: CallCapabilities;\n    [SDPStreamMetadataKey]: SDPStreamMetadata;\n}\n\nexport interface MCallSelectAnswer extends MCallBase {\n    selected_party_id: string;\n}\n\nexport interface MCallInviteNegotiate extends MCallBase {\n    offer: RTCSessionDescription;\n    description: RTCSessionDescription;\n    lifetime: number;\n    capabilities?: CallCapabilities;\n    invitee?: string;\n    sender_session_id?: string;\n    dest_session_id?: string;\n    [SDPStreamMetadataKey]: SDPStreamMetadata;\n}\n\nexport interface MCallSDPStreamMetadataChanged extends MCallBase {\n    [SDPStreamMetadataKey]: SDPStreamMetadata;\n}\n\nexport interface MCallReplacesEvent extends MCallBase {\n    replacement_id: string;\n    target_user: CallReplacesTarget;\n    create_call: string;\n    await_call: string;\n    target_room: string;\n}\n\nexport interface MCAllAssertedIdentity extends MCallBase {\n    asserted_identity: {\n        id: string;\n        display_name: string;\n        avatar_url: string;\n    };\n}\n\nexport interface MCallCandidates extends MCallBase {\n    candidates: Omit<RTCIceCandidateInit, \"usernameFragment\">[];\n}\n\nexport interface MCallHangupReject extends MCallBase {\n    reason?: CallErrorCode;\n}\n\n/* eslint-enable camelcase */\n","/*\nCopyright 2021 imon Brandner <simon.bra.ag@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { type MatrixClient, ClientEvent } from \"../client.ts\";\nimport { GroupCall, GroupCallIntent, GroupCallType, type IGroupCallDataChannelOptions } from \"./groupCall.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { type RoomState, RoomStateEvent } from \"../models/room-state.ts\";\nimport { type RoomMember } from \"../models/room-member.ts\";\nimport { logger } from \"../logger.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { SyncState } from \"../sync.ts\";\n\nexport enum GroupCallEventHandlerEvent {\n    Incoming = \"GroupCall.incoming\",\n    Outgoing = \"GroupCall.outgoing\",\n    Ended = \"GroupCall.ended\",\n    Participants = \"GroupCall.participants\",\n}\n\nexport type GroupCallEventHandlerEventHandlerMap = {\n    [GroupCallEventHandlerEvent.Incoming]: (call: GroupCall) => void;\n    [GroupCallEventHandlerEvent.Outgoing]: (call: GroupCall) => void;\n    [GroupCallEventHandlerEvent.Ended]: (call: GroupCall) => void;\n    [GroupCallEventHandlerEvent.Participants]: (participants: RoomMember[], call: GroupCall) => void;\n};\n\ninterface RoomDeferred {\n    prom: Promise<void>;\n    resolve?: () => void;\n}\n\nexport class GroupCallEventHandler {\n    public groupCalls = new Map<string, GroupCall>(); // roomId -> GroupCall\n\n    // All rooms we know about and whether we've seen a 'Room' event\n    // for them. The promise will be fulfilled once we've processed that\n    // event which means we're \"up to date\" on what calls are in a room\n    // and get\n    private roomDeferreds = new Map<string, RoomDeferred>();\n\n    public constructor(private client: MatrixClient) {}\n\n    public async start(): Promise<void> {\n        // We wait until the client has started syncing for real.\n        // This is because we only support one call at a time, and want\n        // the latest. We therefore want the latest state of the room before\n        // we create a group call for the room so we can be fairly sure that\n        // the group call we create is really the latest one.\n        if (this.client.getSyncState() !== SyncState.Syncing) {\n            logger.debug(\"GroupCallEventHandler start() waiting for client to start syncing\");\n            await new Promise<void>((resolve) => {\n                const onSync = (): void => {\n                    if (this.client.getSyncState() === SyncState.Syncing) {\n                        this.client.off(ClientEvent.Sync, onSync);\n                        return resolve();\n                    }\n                };\n                this.client.on(ClientEvent.Sync, onSync);\n            });\n        }\n\n        const rooms = this.client.getRooms();\n\n        for (const room of rooms) {\n            this.createGroupCallForRoom(room);\n        }\n\n        this.client.on(ClientEvent.Room, this.onRoomsChanged);\n        this.client.on(RoomStateEvent.Events, this.onRoomStateChanged);\n    }\n\n    public stop(): void {\n        this.client.removeListener(ClientEvent.Room, this.onRoomsChanged);\n        this.client.removeListener(RoomStateEvent.Events, this.onRoomStateChanged);\n    }\n\n    private getRoomDeferred(roomId: string): RoomDeferred {\n        let deferred = this.roomDeferreds.get(roomId);\n        if (deferred === undefined) {\n            let resolveFunc: () => void;\n            deferred = {\n                prom: new Promise<void>((resolve) => {\n                    resolveFunc = resolve;\n                }),\n            };\n            deferred.resolve = resolveFunc!;\n            this.roomDeferreds.set(roomId, deferred);\n        }\n\n        return deferred;\n    }\n\n    public waitUntilRoomReadyForGroupCalls(roomId: string): Promise<void> {\n        return this.getRoomDeferred(roomId).prom;\n    }\n\n    public getGroupCallById(groupCallId: string): GroupCall | undefined {\n        return [...this.groupCalls.values()].find((groupCall) => groupCall.groupCallId === groupCallId);\n    }\n\n    private createGroupCallForRoom(room: Room): void {\n        const callEvents = room.currentState.getStateEvents(EventType.GroupCallPrefix);\n        const sortedCallEvents = callEvents.sort((a, b) => b.getTs() - a.getTs());\n\n        for (const callEvent of sortedCallEvents) {\n            const content = callEvent.getContent();\n\n            if (content[\"m.terminated\"] || callEvent.isRedacted()) {\n                continue;\n            }\n\n            logger.debug(\n                `GroupCallEventHandler createGroupCallForRoom() choosing group call from possible calls (stateKey=${callEvent.getStateKey()}, ts=${callEvent.getTs()}, roomId=${\n                    room.roomId\n                }, numOfPossibleCalls=${callEvents.length})`,\n            );\n\n            this.createGroupCallFromRoomStateEvent(callEvent);\n            break;\n        }\n\n        this.getRoomDeferred(room.roomId).resolve!();\n    }\n\n    private createGroupCallFromRoomStateEvent(event: MatrixEvent): GroupCall | undefined {\n        const roomId = event.getRoomId();\n        const content = event.getContent();\n\n        const room = this.client.getRoom(roomId);\n\n        if (!room) {\n            logger.warn(\n                `GroupCallEventHandler createGroupCallFromRoomStateEvent() couldn't find room for call (roomId=${roomId})`,\n            );\n            return;\n        }\n\n        const groupCallId = event.getStateKey();\n\n        const callType = content[\"m.type\"];\n\n        if (!Object.values(GroupCallType).includes(callType)) {\n            logger.warn(\n                `GroupCallEventHandler createGroupCallFromRoomStateEvent() received invalid call type (type=${callType}, roomId=${roomId})`,\n            );\n            return;\n        }\n\n        const callIntent = content[\"m.intent\"];\n\n        if (!Object.values(GroupCallIntent).includes(callIntent)) {\n            logger.warn(`Received invalid group call intent (type=${callType}, roomId=${roomId})`);\n            return;\n        }\n\n        const isPtt = Boolean(content[\"io.element.ptt\"]);\n\n        let dataChannelOptions: IGroupCallDataChannelOptions | undefined;\n\n        if (content?.dataChannelsEnabled && content?.dataChannelOptions) {\n            // Pull out just the dataChannelOptions we want to support.\n            const { ordered, maxPacketLifeTime, maxRetransmits, protocol } = content.dataChannelOptions;\n            dataChannelOptions = { ordered, maxPacketLifeTime, maxRetransmits, protocol };\n        }\n\n        const groupCall = new GroupCall(\n            this.client,\n            room,\n            callType,\n            isPtt,\n            callIntent,\n            groupCallId,\n            // Because without Media section a WebRTC connection is not possible, so need a RTCDataChannel to set up a\n            // no media WebRTC connection anyway.\n            content?.dataChannelsEnabled || this.client.isVoipWithNoMediaAllowed,\n            dataChannelOptions,\n            this.client.isVoipWithNoMediaAllowed,\n            this.client.useLivekitForGroupCalls,\n            content[\"io.element.livekit_service_url\"],\n        );\n\n        this.groupCalls.set(room.roomId, groupCall);\n        this.client.emit(GroupCallEventHandlerEvent.Incoming, groupCall);\n\n        return groupCall;\n    }\n\n    private onRoomsChanged = (room: Room): void => {\n        this.createGroupCallForRoom(room);\n    };\n\n    private onRoomStateChanged = (event: MatrixEvent, state: RoomState): void => {\n        const eventType = event.getType();\n\n        if (eventType === EventType.GroupCallPrefix) {\n            const groupCallId = event.getStateKey();\n            const content = event.getContent();\n\n            const currentGroupCall = this.groupCalls.get(state.roomId);\n\n            if (!currentGroupCall && !content[\"m.terminated\"] && !event.isRedacted()) {\n                this.createGroupCallFromRoomStateEvent(event);\n            } else if (currentGroupCall && currentGroupCall.groupCallId === groupCallId) {\n                if (content[\"m.terminated\"] || event.isRedacted()) {\n                    currentGroupCall.terminate(false);\n                } else if (content[\"m.type\"] !== currentGroupCall.type) {\n                    // TODO: Handle the callType changing when the room state changes\n                    logger.warn(\n                        `GroupCallEventHandler onRoomStateChanged() currently does not support changing type (roomId=${state.roomId})`,\n                    );\n                }\n            } else if (currentGroupCall && currentGroupCall.groupCallId !== groupCallId) {\n                // TODO: Handle new group calls and multiple group calls\n                logger.warn(\n                    `GroupCallEventHandler onRoomStateChanged() currently does not support multiple calls (roomId=${state.roomId})`,\n                );\n            }\n        }\n    };\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { type CallFeedReport, type CallFeedStats, type TrackStats, type TransceiverStats } from \"./statsReport.ts\";\nimport { type CallFeed } from \"../callFeed.ts\";\n\nexport class CallFeedStatsReporter {\n    public static buildCallFeedReport(callId: string, opponentMemberId: string, pc: RTCPeerConnection): CallFeedReport {\n        const rtpTransceivers = pc.getTransceivers();\n        const transceiver: TransceiverStats[] = [];\n        const callFeeds: CallFeedStats[] = [];\n\n        rtpTransceivers.forEach((t) => {\n            const sender = t.sender?.track ? CallFeedStatsReporter.buildTrackStats(t.sender.track, \"sender\") : null;\n            const receiver = CallFeedStatsReporter.buildTrackStats(t.receiver.track, \"receiver\");\n            transceiver.push({\n                mid: t.mid == null ? \"null\" : t.mid,\n                direction: t.direction,\n                currentDirection: t.currentDirection == null ? \"null\" : t.currentDirection,\n                sender,\n                receiver,\n            });\n        });\n\n        return {\n            callId,\n            opponentMemberId,\n            transceiver,\n            callFeeds,\n        };\n    }\n\n    private static buildTrackStats(track: MediaStreamTrack, label = \"--\"): TrackStats {\n        const settingDeviceId = track.getSettings()?.deviceId;\n        const constrainDeviceId = track.getConstraints()?.deviceId;\n\n        return {\n            id: track.id,\n            kind: track.kind,\n            settingDeviceId: settingDeviceId ?? \"unknown\",\n            constrainDeviceId: constrainDeviceId ?? \"unknown\",\n            muted: track.muted,\n            enabled: track.enabled,\n            readyState: track.readyState,\n            label,\n        } as TrackStats;\n    }\n\n    public static expandCallFeedReport(\n        report: CallFeedReport,\n        callFeeds: CallFeed[],\n        prefix = \"unknown\",\n    ): CallFeedReport {\n        callFeeds.forEach((feed) => {\n            const audioTracks = feed.stream.getAudioTracks();\n            const videoTracks = feed.stream.getVideoTracks();\n            const audio =\n                audioTracks.length > 0\n                    ? CallFeedStatsReporter.buildTrackStats(feed.stream.getAudioTracks()[0], feed.purpose)\n                    : null;\n            const video =\n                videoTracks.length > 0\n                    ? CallFeedStatsReporter.buildTrackStats(feed.stream.getVideoTracks()[0], feed.purpose)\n                    : null;\n            const feedStats = {\n                stream: feed.stream.id,\n                type: feed.isLocal() ? \"local\" : \"remote\",\n                audio,\n                video,\n                purpose: feed.purpose,\n                prefix,\n                isVideoMuted: feed.isVideoMuted(),\n                isAudioMuted: feed.isAudioMuted(),\n            } as CallFeedStats;\n            report.callFeeds.push(feedStats);\n        });\n        return report;\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type TransportStats } from \"./transportStats.ts\";\nimport { type Bitrate } from \"./media/mediaTrackStats.ts\";\n\nexport interface ConnectionStatsBandwidth {\n    /**\n     * bytes per second\n     */\n    download: number;\n    /**\n     * bytes per second\n     */\n    upload: number;\n}\n\nexport interface ConnectionStatsBitrate extends Bitrate {\n    audio?: Bitrate;\n    video?: Bitrate;\n}\n\nexport interface PacketLoss {\n    total: number;\n    download: number;\n    upload: number;\n}\n\nexport class ConnectionStats {\n    public bandwidth: ConnectionStatsBitrate = {} as ConnectionStatsBitrate;\n    public bitrate: ConnectionStatsBitrate = {} as ConnectionStatsBitrate;\n    public packetLoss: PacketLoss = {} as PacketLoss;\n    public transport: TransportStats[] = [];\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { type Bitrate } from \"./media/mediaTrackStats.ts\";\n\nexport class ConnectionStatsBuilder {\n    public static buildBandwidthReport(now: RTCIceCandidatePairStats): Bitrate {\n        const availableIncomingBitrate = now.availableIncomingBitrate;\n        const availableOutgoingBitrate = now.availableOutgoingBitrate;\n\n        return {\n            download: availableIncomingBitrate ? Math.round(availableIncomingBitrate / 1000) : 0,\n            upload: availableOutgoingBitrate ? Math.round(availableOutgoingBitrate / 1000) : 0,\n        };\n    }\n}\n","import { type TransportStats } from \"./transportStats.ts\";\n\nexport class TransportStatsBuilder {\n    public static buildReport(\n        report: RTCStatsReport | undefined,\n        now: RTCIceCandidatePairStats,\n        conferenceStatsTransport: TransportStats[],\n        isFocus: boolean,\n    ): TransportStats[] {\n        const localUsedCandidate = report?.get(now.localCandidateId);\n        const remoteUsedCandidate = report?.get(now.remoteCandidateId);\n\n        // RTCIceCandidateStats\n        // https://w3c.github.io/webrtc-stats/#icecandidate-dict*\n        if (remoteUsedCandidate && localUsedCandidate) {\n            const remoteIpAddress =\n                remoteUsedCandidate.ip !== undefined ? remoteUsedCandidate.ip : remoteUsedCandidate.address;\n            const remotePort = remoteUsedCandidate.port;\n            const ip = `${remoteIpAddress}:${remotePort}`;\n\n            const localIpAddress =\n                localUsedCandidate.ip !== undefined ? localUsedCandidate.ip : localUsedCandidate.address;\n            const localPort = localUsedCandidate.port;\n            const localIp = `${localIpAddress}:${localPort}`;\n\n            const type = remoteUsedCandidate.protocol;\n\n            // Save the address unless it has been saved already.\n            if (\n                !conferenceStatsTransport.some(\n                    (t: TransportStats) => t.ip === ip && t.type === type && t.localIp === localIp,\n                )\n            ) {\n                conferenceStatsTransport.push({\n                    ip,\n                    type,\n                    localIp,\n                    isFocus,\n                    localCandidateType: localUsedCandidate.candidateType,\n                    remoteCandidateType: remoteUsedCandidate.candidateType,\n                    networkType: localUsedCandidate.networkType,\n                    rtt: now.currentRoundTripTime ? now.currentRoundTripTime * 1000 : NaN,\n                } as TransportStats);\n            }\n        }\n        return conferenceStatsTransport;\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { parse as parseSdp } from \"sdp-transform\";\n\nexport type Mid = string;\nexport type Ssrc = string;\nexport type MapType = \"local\" | \"remote\";\n\nexport class MediaSsrcHandler {\n    private readonly ssrcToMid = { local: new Map<Mid, Ssrc[]>(), remote: new Map<Mid, Ssrc[]>() };\n\n    public findMidBySsrc(ssrc: Ssrc, type: \"local\" | \"remote\"): Mid | undefined {\n        let mid: Mid | undefined;\n        this.ssrcToMid[type].forEach((ssrcs, m) => {\n            if (ssrcs.find((s) => s == ssrc)) {\n                mid = m;\n                return;\n            }\n        });\n        return mid;\n    }\n\n    public parse(description: string, type: MapType): void {\n        const sdp = parseSdp(description);\n        const ssrcToMid = new Map<Mid, Ssrc[]>();\n        sdp.media.forEach((m) => {\n            if ((!!m.mid && m.type === \"video\") || m.type === \"audio\") {\n                const ssrcs: Ssrc[] = [];\n                m.ssrcs?.forEach((ssrc) => {\n                    if (ssrc.attribute === \"cname\") {\n                        ssrcs.push(`${ssrc.id}`);\n                    }\n                });\n                ssrcToMid.set(`${m.mid}`, ssrcs);\n            }\n        });\n        this.ssrcToMid[type] = ssrcToMid;\n    }\n\n    public getSsrcToMidMap(type: MapType): Map<Mid, Ssrc[]> {\n        return this.ssrcToMid[type];\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport type TrackId = string;\n\nexport class MediaTrackHandler {\n    public constructor(private readonly pc: RTCPeerConnection) {}\n\n    public getLocalTracks(kind: \"audio\" | \"video\"): MediaStreamTrack[] {\n        const isNotNullAndKind = (track: MediaStreamTrack | null): boolean => {\n            return track !== null && track.kind === kind;\n        };\n        return this.pc\n            .getTransceivers()\n            .filter((t) => t.currentDirection === \"sendonly\" || t.currentDirection === \"sendrecv\")\n            .filter((t) => t.sender !== null)\n            .map((t) => t.sender)\n            .map((s) => s.track)\n            .filter(isNotNullAndKind) as MediaStreamTrack[];\n    }\n\n    public getTackById(trackId: string): MediaStreamTrack | undefined {\n        return this.pc\n            .getTransceivers()\n            .map((t) => {\n                if (t?.sender.track !== null && t.sender.track.id === trackId) {\n                    return t.sender.track;\n                }\n                if (t?.receiver.track !== null && t.receiver.track.id === trackId) {\n                    return t.receiver.track;\n                }\n                return undefined;\n            })\n            .find((t) => t !== undefined);\n    }\n\n    public getLocalTrackIdByMid(mid: string): string | undefined {\n        const transceiver = this.pc.getTransceivers().find((t) => t.mid === mid);\n        return transceiver?.sender?.track?.id;\n    }\n\n    public getRemoteTrackIdByMid(mid: string): string | undefined {\n        const transceiver = this.pc.getTransceivers().find((t) => t.mid === mid);\n        return transceiver?.receiver?.track?.id;\n    }\n\n    public getActiveSimulcastStreams(): number {\n        //@TODO implement this right.. Check how many layer configured\n        return 3;\n    }\n\n    public getTransceiverByTrackId(trackId: TrackId): RTCRtpTransceiver | undefined {\n        return this.pc.getTransceivers().find((t) => {\n            return t.receiver.track.id === trackId || (t.sender.track !== null && t.sender.track.id === trackId);\n        });\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type AudioConcealment } from \"../statsReport.ts\";\nimport { type TrackId } from \"./mediaTrackHandler.ts\";\n\nexport interface PacketLoss {\n    packetsTotal: number;\n    packetsLost: number;\n    isDownloadStream: boolean;\n}\n\nexport interface Bitrate {\n    /**\n     * bytes per second\n     */\n    download: number;\n    /**\n     * bytes per second\n     */\n    upload: number;\n}\nexport interface ConcealedAudio {\n    /**\n     * duration in ms\n     */\n    duration: number;\n\n    ratio: number;\n}\nexport interface Resolution {\n    width: number;\n    height: number;\n}\n\nexport type TrackStatsType = \"local\" | \"remote\";\n\nexport class MediaTrackStats {\n    private loss: PacketLoss = { packetsTotal: 0, packetsLost: 0, isDownloadStream: false };\n    private bitrate: Bitrate = { download: 0, upload: 0 };\n    private resolution: Resolution = { width: -1, height: -1 };\n    private audioConcealment: AudioConcealment = { concealedAudio: 0, totalAudioDuration: 0 };\n    private framerate = 0;\n    private jitter = 0;\n    private codec = \"\";\n    private isAlive = true;\n    private isMuted = false;\n    private isEnabled = true;\n\n    public constructor(\n        public readonly trackId: TrackId,\n        public readonly type: TrackStatsType,\n        public readonly kind: \"audio\" | \"video\",\n    ) {}\n\n    public getType(): TrackStatsType {\n        return this.type;\n    }\n\n    public setLoss(loss: PacketLoss): void {\n        this.loss = loss;\n    }\n\n    public getLoss(): PacketLoss {\n        return this.loss;\n    }\n\n    public setResolution(resolution: Resolution): void {\n        this.resolution = resolution;\n    }\n\n    public getResolution(): Resolution {\n        return this.resolution;\n    }\n\n    public setFramerate(framerate: number): void {\n        this.framerate = framerate;\n    }\n\n    public getFramerate(): number {\n        return this.framerate;\n    }\n\n    public setBitrate(bitrate: Bitrate): void {\n        this.bitrate = bitrate;\n    }\n\n    public getBitrate(): Bitrate {\n        return this.bitrate;\n    }\n\n    public setCodec(codecShortType: string): boolean {\n        this.codec = codecShortType;\n        return true;\n    }\n\n    public getCodec(): string {\n        return this.codec;\n    }\n\n    public resetBitrate(): void {\n        this.bitrate = { download: 0, upload: 0 };\n    }\n\n    public set alive(isAlive: boolean) {\n        this.isAlive = isAlive;\n    }\n\n    /**\n     * A MediaTrackState is alive if the corresponding MediaStreamTrack track bound to a transceiver and the\n     * MediaStreamTrack is in state MediaStreamTrack.readyState === live\n     */\n    public get alive(): boolean {\n        return this.isAlive;\n    }\n\n    public set muted(isMuted: boolean) {\n        this.isMuted = isMuted;\n    }\n\n    /**\n     * A MediaTrackState.isMuted corresponding to MediaStreamTrack.muted.\n     * But these values only match if MediaTrackState.isAlive.\n     */\n    public get muted(): boolean {\n        return this.isMuted;\n    }\n\n    public set enabled(isEnabled: boolean) {\n        this.isEnabled = isEnabled;\n    }\n\n    /**\n     * A MediaTrackState.isEnabled corresponding to MediaStreamTrack.enabled.\n     * But these values only match if MediaTrackState.isAlive.\n     */\n    public get enabled(): boolean {\n        return this.isEnabled;\n    }\n\n    public setJitter(jitter: number): void {\n        this.jitter = jitter;\n    }\n\n    /**\n     * Jitter in milliseconds\n     */\n    public getJitter(): number {\n        return this.jitter;\n    }\n\n    /**\n     * Audio concealment ration (conceled duration / total duration)\n     */\n    public setAudioConcealment(concealedAudioDuration: number, totalAudioDuration: number): void {\n        this.audioConcealment.concealedAudio = concealedAudioDuration;\n        this.audioConcealment.totalAudioDuration = totalAudioDuration;\n    }\n\n    public getAudioConcealment(): AudioConcealment {\n        return this.audioConcealment;\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { type TrackID } from \"../statsReport.ts\";\nimport { MediaTrackStats } from \"./mediaTrackStats.ts\";\nimport { type MediaTrackHandler, type TrackId } from \"./mediaTrackHandler.ts\";\nimport { type MediaSsrcHandler } from \"./mediaSsrcHandler.ts\";\n\nexport class MediaTrackStatsHandler {\n    private readonly track2stats = new Map<TrackID, MediaTrackStats>();\n\n    public constructor(\n        public readonly mediaSsrcHandler: MediaSsrcHandler,\n        public readonly mediaTrackHandler: MediaTrackHandler,\n    ) {}\n\n    /**\n     * Find tracks by rtc stats\n     * Argument report is any because the stats api is not consistent:\n     * For example `trackIdentifier`, `mid` not existing in every implementations\n     * https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats\n     * https://developer.mozilla.org/en-US/docs/Web/API/RTCInboundRtpStreamStats\n     */\n    public findTrack2Stats(report: any, type: \"remote\" | \"local\"): MediaTrackStats | undefined {\n        let trackID;\n        if (report.trackIdentifier) {\n            trackID = report.trackIdentifier;\n        } else if (report.mid) {\n            trackID =\n                type === \"remote\"\n                    ? this.mediaTrackHandler.getRemoteTrackIdByMid(report.mid)\n                    : this.mediaTrackHandler.getLocalTrackIdByMid(report.mid);\n        } else if (report.ssrc) {\n            const mid = this.mediaSsrcHandler.findMidBySsrc(report.ssrc, type);\n            if (!mid) {\n                return undefined;\n            }\n            trackID =\n                type === \"remote\"\n                    ? this.mediaTrackHandler.getRemoteTrackIdByMid(report.mid)\n                    : this.mediaTrackHandler.getLocalTrackIdByMid(report.mid);\n        }\n\n        if (!trackID) {\n            return undefined;\n        }\n\n        let trackStats = this.track2stats.get(trackID);\n\n        if (!trackStats) {\n            const track = this.mediaTrackHandler.getTackById(trackID);\n            if (track !== undefined) {\n                const kind: \"audio\" | \"video\" = track.kind === \"audio\" ? track.kind : \"video\";\n                trackStats = new MediaTrackStats(trackID, type, kind);\n                this.track2stats.set(trackID, trackStats);\n            } else {\n                return undefined;\n            }\n        }\n        return trackStats;\n    }\n\n    public findLocalVideoTrackStats(report: any): MediaTrackStats | undefined {\n        const localVideoTracks = this.mediaTrackHandler.getLocalTracks(\"video\");\n        if (localVideoTracks.length === 0) {\n            return undefined;\n        }\n        return this.findTrack2Stats(report, \"local\");\n    }\n\n    public getTrack2stats(): Map<TrackID, MediaTrackStats> {\n        return this.track2stats;\n    }\n\n    public findTransceiverByTrackId(trackID: TrackId): undefined | RTCRtpTransceiver {\n        return this.mediaTrackHandler.getTransceiverByTrackId(trackID);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nexport class ValueFormatter {\n    public static getNonNegativeValue(imput: any): number {\n        let value = imput;\n\n        if (typeof value !== \"number\") {\n            value = Number(value);\n        }\n\n        if (isNaN(value)) {\n            return 0;\n        }\n\n        return Math.max(0, value);\n    }\n}\n","import { type MediaTrackStats } from \"./media/mediaTrackStats.ts\";\nimport { ValueFormatter } from \"./valueFormatter.ts\";\nimport { type TrackSummary } from \"./callStatsReportSummary.ts\";\n\nexport class TrackStatsBuilder {\n    public static buildFramerateResolution(trackStats: MediaTrackStats, now: any): void {\n        const resolution = {\n            height: now.frameHeight,\n            width: now.frameWidth,\n        };\n        const frameRate = now.framesPerSecond;\n\n        if (resolution.height && resolution.width) {\n            trackStats.setResolution(resolution);\n        }\n        trackStats.setFramerate(Math.round(frameRate || 0));\n    }\n\n    public static calculateSimulcastFramerate(trackStats: MediaTrackStats, now: any, before: any, layer: number): void {\n        let frameRate = trackStats.getFramerate();\n        if (!frameRate) {\n            if (before) {\n                const timeMs = now.timestamp - before.timestamp;\n\n                if (timeMs > 0 && now.framesSent) {\n                    const numberOfFramesSinceBefore = now.framesSent - before.framesSent;\n\n                    frameRate = (numberOfFramesSinceBefore / timeMs) * 1000;\n                }\n            }\n\n            if (!frameRate) {\n                return;\n            }\n        }\n\n        // Reset frame rate to 0 when video is suspended as a result of endpoint falling out of last-n.\n        frameRate = layer ? Math.round(frameRate / layer) : 0;\n        trackStats.setFramerate(frameRate);\n    }\n\n    public static buildCodec(report: RTCStatsReport | undefined, trackStats: MediaTrackStats, now: any): void {\n        const codec = report?.get(now.codecId);\n\n        if (codec) {\n            /**\n             * The mime type has the following form: video/VP8 or audio/ISAC,\n             * so we what to keep just the type after the '/', audio and video\n             * keys will be added on the processing side.\n             */\n            const codecShortType = codec.mimeType.split(\"/\")[1];\n\n            if (codecShortType) trackStats.setCodec(codecShortType);\n        }\n    }\n\n    public static buildBitrateReceived(trackStats: MediaTrackStats, now: any, before: any): void {\n        trackStats.setBitrate({\n            download: TrackStatsBuilder.calculateBitrate(\n                now.bytesReceived,\n                before.bytesReceived,\n                now.timestamp,\n                before.timestamp,\n            ),\n            upload: 0,\n        });\n    }\n\n    public static buildBitrateSend(trackStats: MediaTrackStats, now: any, before: any): void {\n        trackStats.setBitrate({\n            download: 0,\n            upload: this.calculateBitrate(now.bytesSent, before.bytesSent, now.timestamp, before.timestamp),\n        });\n    }\n\n    public static buildPacketsLost(trackStats: MediaTrackStats, now: any, before: any): void {\n        const key = now.type === \"outbound-rtp\" ? \"packetsSent\" : \"packetsReceived\";\n\n        let packetsNow = now[key];\n        if (!packetsNow || packetsNow < 0) {\n            packetsNow = 0;\n        }\n\n        const packetsBefore = ValueFormatter.getNonNegativeValue(before[key]);\n        const packetsDiff = Math.max(0, packetsNow - packetsBefore);\n\n        const packetsLostNow = ValueFormatter.getNonNegativeValue(now.packetsLost);\n        const packetsLostBefore = ValueFormatter.getNonNegativeValue(before.packetsLost);\n        const packetsLostDiff = Math.max(0, packetsLostNow - packetsLostBefore);\n\n        trackStats.setLoss({\n            packetsTotal: packetsDiff + packetsLostDiff,\n            packetsLost: packetsLostDiff,\n            isDownloadStream: now.type !== \"outbound-rtp\",\n        });\n    }\n\n    private static calculateBitrate(\n        bytesNowAny: any,\n        bytesBeforeAny: any,\n        nowTimestamp: number,\n        beforeTimestamp: number,\n    ): number {\n        const bytesNow = ValueFormatter.getNonNegativeValue(bytesNowAny);\n        const bytesBefore = ValueFormatter.getNonNegativeValue(bytesBeforeAny);\n        const bytesProcessed = Math.max(0, bytesNow - bytesBefore);\n\n        const timeMs = nowTimestamp - beforeTimestamp;\n        let bitrateKbps = 0;\n\n        if (timeMs > 0) {\n            bitrateKbps = Math.round((bytesProcessed * 8) / timeMs);\n        }\n\n        return bitrateKbps;\n    }\n\n    public static setTrackStatsState(trackStats: MediaTrackStats, transceiver: RTCRtpTransceiver | undefined): void {\n        if (transceiver === undefined) {\n            trackStats.alive = false;\n            return;\n        }\n\n        const track = trackStats.getType() === \"remote\" ? transceiver.receiver.track : transceiver?.sender?.track;\n        if (track === undefined || track === null) {\n            trackStats.alive = false;\n            return;\n        }\n\n        if (track.readyState === \"ended\") {\n            trackStats.alive = false;\n            return;\n        }\n        trackStats.muted = track.muted;\n        trackStats.enabled = track.enabled;\n        trackStats.alive = true;\n    }\n\n    public static buildTrackSummary(trackStatsList: MediaTrackStats[]): {\n        audioTrackSummary: TrackSummary;\n        videoTrackSummary: TrackSummary;\n    } {\n        const videoTrackSummary: TrackSummary = {\n            count: 0,\n            muted: 0,\n            maxJitter: 0,\n            maxPacketLoss: 0,\n            concealedAudio: 0,\n            totalAudio: 0,\n        };\n        const audioTrackSummary: TrackSummary = {\n            count: 0,\n            muted: 0,\n            maxJitter: 0,\n            maxPacketLoss: 0,\n            concealedAudio: 0,\n            totalAudio: 0,\n        };\n\n        const remoteTrackList = trackStatsList.filter((t) => t.getType() === \"remote\");\n        const audioTrackList = remoteTrackList.filter((t) => t.kind === \"audio\");\n\n        remoteTrackList.forEach((stats) => {\n            const trackSummary = stats.kind === \"video\" ? videoTrackSummary : audioTrackSummary;\n            trackSummary.count++;\n            if (stats.alive && stats.muted) {\n                trackSummary.muted++;\n            }\n            if (trackSummary.maxJitter < stats.getJitter()) {\n                trackSummary.maxJitter = stats.getJitter();\n            }\n            if (trackSummary.maxPacketLoss < stats.getLoss().packetsLost) {\n                trackSummary.maxPacketLoss = stats.getLoss().packetsLost;\n            }\n            if (audioTrackList.length > 0) {\n                trackSummary.concealedAudio += stats.getAudioConcealment()?.concealedAudio;\n                trackSummary.totalAudio += stats.getAudioConcealment()?.totalAudioDuration;\n            }\n        });\n\n        return { audioTrackSummary, videoTrackSummary };\n    }\n\n    public static buildJitter(trackStats: MediaTrackStats, statsReport: any): void {\n        if (statsReport.type !== \"inbound-rtp\") {\n            return;\n        }\n\n        const jitterStr = statsReport?.jitter;\n        if (jitterStr !== undefined) {\n            const jitter = ValueFormatter.getNonNegativeValue(jitterStr);\n            trackStats.setJitter(Math.round(jitter * 1000));\n        } else {\n            trackStats.setJitter(-1);\n        }\n    }\n\n    public static buildAudioConcealment(trackStats: MediaTrackStats, statsReport: any): void {\n        if (statsReport.type !== \"inbound-rtp\") {\n            return;\n        }\n        const msPerSample = (1000 * statsReport?.totalSamplesDuration) / statsReport?.totalSamplesReceived;\n        const concealedAudioDuration = msPerSample * statsReport?.concealedSamples;\n        const totalAudioDuration = 1000 * statsReport?.totalSamplesDuration;\n        trackStats.setAudioConcealment(concealedAudioDuration, totalAudioDuration);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport {\n    type AudioConcealment,\n    type CodecMap,\n    type ConnectionStatsReport,\n    type FramerateMap,\n    type ResolutionMap,\n    type TrackID,\n} from \"./statsReport.ts\";\nimport { type MediaTrackStats, type Resolution } from \"./media/mediaTrackStats.ts\";\n\nexport class ConnectionStatsReportBuilder {\n    public static build(stats: Map<TrackID, MediaTrackStats>): ConnectionStatsReport {\n        const report = {} as ConnectionStatsReport;\n\n        // process stats\n        const totalPackets = {\n            download: 0,\n            upload: 0,\n        };\n        const lostPackets = {\n            download: 0,\n            upload: 0,\n        };\n        let bitrateDownload = 0;\n        let bitrateUpload = 0;\n        const resolutions: ResolutionMap = {\n            local: new Map<TrackID, Resolution>(),\n            remote: new Map<TrackID, Resolution>(),\n        };\n        const framerates: FramerateMap = { local: new Map<TrackID, number>(), remote: new Map<TrackID, number>() };\n        const codecs: CodecMap = { local: new Map<TrackID, string>(), remote: new Map<TrackID, string>() };\n        const jitter = new Map<TrackID, number>();\n        const audioConcealment = new Map<TrackID, AudioConcealment>();\n\n        let audioBitrateDownload = 0;\n        let audioBitrateUpload = 0;\n        let videoBitrateDownload = 0;\n        let videoBitrateUpload = 0;\n\n        let totalConcealedAudio = 0;\n        let totalAudioDuration = 0;\n\n        for (const [trackId, trackStats] of stats) {\n            // process packet loss stats\n            const loss = trackStats.getLoss();\n            const type = loss.isDownloadStream ? \"download\" : \"upload\";\n\n            totalPackets[type] += loss.packetsTotal;\n            lostPackets[type] += loss.packetsLost;\n\n            // process bitrate stats\n            bitrateDownload += trackStats.getBitrate().download;\n            bitrateUpload += trackStats.getBitrate().upload;\n\n            // collect resolutions and framerates\n            if (trackStats.kind === \"audio\") {\n                // process audio quality stats\n                const audioConcealmentForTrack = trackStats.getAudioConcealment();\n                totalConcealedAudio += audioConcealmentForTrack.concealedAudio;\n                totalAudioDuration += audioConcealmentForTrack.totalAudioDuration;\n\n                audioBitrateDownload += trackStats.getBitrate().download;\n                audioBitrateUpload += trackStats.getBitrate().upload;\n            } else {\n                videoBitrateDownload += trackStats.getBitrate().download;\n                videoBitrateUpload += trackStats.getBitrate().upload;\n            }\n\n            resolutions[trackStats.getType()].set(trackId, trackStats.getResolution());\n            framerates[trackStats.getType()].set(trackId, trackStats.getFramerate());\n            codecs[trackStats.getType()].set(trackId, trackStats.getCodec());\n            if (trackStats.getType() === \"remote\") {\n                jitter.set(trackId, trackStats.getJitter());\n                if (trackStats.kind === \"audio\") {\n                    audioConcealment.set(trackId, trackStats.getAudioConcealment());\n                }\n            }\n\n            trackStats.resetBitrate();\n        }\n\n        report.bitrate = {\n            upload: bitrateUpload,\n            download: bitrateDownload,\n        };\n\n        report.bitrate.audio = {\n            upload: audioBitrateUpload,\n            download: audioBitrateDownload,\n        };\n\n        report.bitrate.video = {\n            upload: videoBitrateUpload,\n            download: videoBitrateDownload,\n        };\n\n        report.packetLoss = {\n            total: ConnectionStatsReportBuilder.calculatePacketLoss(\n                lostPackets.download + lostPackets.upload,\n                totalPackets.download + totalPackets.upload,\n            ),\n            download: ConnectionStatsReportBuilder.calculatePacketLoss(lostPackets.download, totalPackets.download),\n            upload: ConnectionStatsReportBuilder.calculatePacketLoss(lostPackets.upload, totalPackets.upload),\n        };\n        report.audioConcealment = audioConcealment;\n        report.totalAudioConcealment = {\n            concealedAudio: totalConcealedAudio,\n            totalAudioDuration,\n        };\n\n        report.framerate = framerates;\n        report.resolution = resolutions;\n        report.codec = codecs;\n        report.jitter = jitter;\n        return report;\n    }\n\n    private static calculatePacketLoss(lostPackets: number, totalPackets: number): number {\n        if (!totalPackets || totalPackets <= 0 || !lostPackets || lostPackets <= 0) {\n            return 0;\n        }\n\n        return Math.round((lostPackets / totalPackets) * 100);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ConnectionStats } from \"./connectionStats.ts\";\nimport { type StatsReportEmitter } from \"./statsReportEmitter.ts\";\nimport { type ByteSend, type ByteSentStatsReport, type TrackID } from \"./statsReport.ts\";\nimport { ConnectionStatsBuilder } from \"./connectionStatsBuilder.ts\";\nimport { TransportStatsBuilder } from \"./transportStatsBuilder.ts\";\nimport { MediaSsrcHandler } from \"./media/mediaSsrcHandler.ts\";\nimport { MediaTrackHandler } from \"./media/mediaTrackHandler.ts\";\nimport { MediaTrackStatsHandler } from \"./media/mediaTrackStatsHandler.ts\";\nimport { TrackStatsBuilder } from \"./trackStatsBuilder.ts\";\nimport { ConnectionStatsReportBuilder } from \"./connectionStatsReportBuilder.ts\";\nimport { ValueFormatter } from \"./valueFormatter.ts\";\nimport { type CallStatsReportSummary } from \"./callStatsReportSummary.ts\";\nimport { logger } from \"../../logger.ts\";\nimport { CallFeedStatsReporter } from \"./callFeedStatsReporter.ts\";\n\nexport class CallStatsReportGatherer {\n    private isActive = true;\n    private previousStatsReport: RTCStatsReport | undefined;\n    private currentStatsReport: RTCStatsReport | undefined;\n    private readonly connectionStats = new ConnectionStats();\n\n    private readonly trackStats: MediaTrackStatsHandler;\n\n    public constructor(\n        public readonly callId: string,\n        private opponentMemberId: string,\n        private readonly pc: RTCPeerConnection,\n        private readonly emitter: StatsReportEmitter,\n        private readonly isFocus = true,\n    ) {\n        pc.addEventListener(\"signalingstatechange\", this.onSignalStateChange.bind(this));\n        this.trackStats = new MediaTrackStatsHandler(new MediaSsrcHandler(), new MediaTrackHandler(pc));\n    }\n\n    public async processStats(groupCallId: string, localUserId: string): Promise<CallStatsReportSummary> {\n        const summary = {\n            isFirstCollection: this.previousStatsReport === undefined,\n            receivedMedia: 0,\n            receivedAudioMedia: 0,\n            receivedVideoMedia: 0,\n            audioTrackSummary: { count: 0, muted: 0, maxPacketLoss: 0, maxJitter: 0, concealedAudio: 0, totalAudio: 0 },\n            videoTrackSummary: { count: 0, muted: 0, maxPacketLoss: 0, maxJitter: 0, concealedAudio: 0, totalAudio: 0 },\n        } as CallStatsReportSummary;\n        if (this.isActive) {\n            const statsPromise = this.pc.getStats();\n            if (typeof statsPromise?.then === \"function\") {\n                return statsPromise\n                    .then((report) => {\n                        // @ts-ignore\n                        this.currentStatsReport = typeof report?.result === \"function\" ? report.result() : report;\n\n                        try {\n                            this.processStatsReport(groupCallId, localUserId);\n                        } catch (error) {\n                            this.handleError(error);\n                            return summary;\n                        }\n\n                        this.previousStatsReport = this.currentStatsReport;\n                        summary.receivedMedia = this.connectionStats.bitrate.download;\n                        summary.receivedAudioMedia = this.connectionStats.bitrate.audio?.download || 0;\n                        summary.receivedVideoMedia = this.connectionStats.bitrate.video?.download || 0;\n                        const trackSummary = TrackStatsBuilder.buildTrackSummary(\n                            Array.from(this.trackStats.getTrack2stats().values()),\n                        );\n                        return {\n                            ...summary,\n                            audioTrackSummary: trackSummary.audioTrackSummary,\n                            videoTrackSummary: trackSummary.videoTrackSummary,\n                        };\n                    })\n                    .catch((error) => {\n                        this.handleError(error);\n                        return summary;\n                    });\n            }\n            this.isActive = false;\n        }\n        return Promise.resolve(summary);\n    }\n\n    private processStatsReport(groupCallId: string, localUserId: string): void {\n        const byteSentStatsReport: ByteSentStatsReport = new Map<TrackID, ByteSend>() as ByteSentStatsReport;\n        byteSentStatsReport.callId = this.callId;\n        byteSentStatsReport.opponentMemberId = this.opponentMemberId;\n\n        this.currentStatsReport?.forEach((now) => {\n            const before = this.previousStatsReport ? this.previousStatsReport.get(now.id) : null;\n            // RTCIceCandidatePairStats - https://w3c.github.io/webrtc-stats/#candidatepair-dict*\n            if (now.type === \"candidate-pair\" && now.nominated && now.state === \"succeeded\") {\n                this.connectionStats.bandwidth = ConnectionStatsBuilder.buildBandwidthReport(now);\n                this.connectionStats.transport = TransportStatsBuilder.buildReport(\n                    this.currentStatsReport,\n                    now,\n                    this.connectionStats.transport,\n                    this.isFocus,\n                );\n\n                // RTCReceivedRtpStreamStats\n                // https://w3c.github.io/webrtc-stats/#receivedrtpstats-dict*\n                // RTCSentRtpStreamStats\n                // https://w3c.github.io/webrtc-stats/#sentrtpstats-dict*\n            } else if (now.type === \"inbound-rtp\" || now.type === \"outbound-rtp\") {\n                const trackStats = this.trackStats.findTrack2Stats(\n                    now,\n                    now.type === \"inbound-rtp\" ? \"remote\" : \"local\",\n                );\n                if (!trackStats) {\n                    return;\n                }\n\n                if (before) {\n                    TrackStatsBuilder.buildPacketsLost(trackStats, now, before);\n                }\n\n                // Get the resolution and framerate for only remote video sources here. For the local video sources,\n                // 'track' stats will be used since they have the updated resolution based on the simulcast streams\n                // currently being sent. Promise based getStats reports three 'outbound-rtp' streams and there will be\n                // more calculations needed to determine what is the highest resolution stream sent by the client if the\n                // 'outbound-rtp' stats are used.\n                if (now.type === \"inbound-rtp\") {\n                    TrackStatsBuilder.buildFramerateResolution(trackStats, now);\n                    if (before) {\n                        TrackStatsBuilder.buildBitrateReceived(trackStats, now, before);\n                    }\n                    const ts = this.trackStats.findTransceiverByTrackId(trackStats.trackId);\n                    TrackStatsBuilder.setTrackStatsState(trackStats, ts);\n                    TrackStatsBuilder.buildJitter(trackStats, now);\n                    TrackStatsBuilder.buildAudioConcealment(trackStats, now);\n                } else if (before) {\n                    byteSentStatsReport.set(trackStats.trackId, ValueFormatter.getNonNegativeValue(now.bytesSent));\n                    TrackStatsBuilder.buildBitrateSend(trackStats, now, before);\n                }\n                TrackStatsBuilder.buildCodec(this.currentStatsReport, trackStats, now);\n            } else if (now.type === \"track\" && now.kind === \"video\" && !now.remoteSource) {\n                const trackStats = this.trackStats.findLocalVideoTrackStats(now);\n                if (!trackStats) {\n                    return;\n                }\n                TrackStatsBuilder.buildFramerateResolution(trackStats, now);\n                TrackStatsBuilder.calculateSimulcastFramerate(\n                    trackStats,\n                    now,\n                    before,\n                    this.trackStats.mediaTrackHandler.getActiveSimulcastStreams(),\n                );\n            }\n        });\n\n        this.emitter.emitByteSendReport(byteSentStatsReport);\n        this.emitter.emitCallFeedReport(\n            CallFeedStatsReporter.buildCallFeedReport(this.callId, this.opponentMemberId, this.pc),\n        );\n        this.processAndEmitConnectionStatsReport();\n    }\n\n    public setActive(isActive: boolean): void {\n        this.isActive = isActive;\n    }\n\n    public getActive(): boolean {\n        return this.isActive;\n    }\n\n    private handleError(error: any): void {\n        this.isActive = false;\n        logger.warn(`CallStatsReportGatherer ${this.callId} processStatsReport fails and set to inactive ${error}`);\n    }\n\n    private processAndEmitConnectionStatsReport(): void {\n        const report = ConnectionStatsReportBuilder.build(this.trackStats.getTrack2stats());\n        report.callId = this.callId;\n        report.opponentMemberId = this.opponentMemberId;\n\n        this.connectionStats.bandwidth = report.bandwidth;\n        this.connectionStats.bitrate = report.bitrate;\n        this.connectionStats.packetLoss = report.packetLoss;\n\n        this.emitter.emitConnectionStatsReport({\n            ...report,\n            transport: this.connectionStats.transport,\n        });\n\n        this.connectionStats.transport = [];\n    }\n\n    public stopProcessingStats(): void {}\n\n    private onSignalStateChange(): void {\n        if (this.pc.signalingState === \"stable\") {\n            if (this.pc.currentRemoteDescription) {\n                this.trackStats.mediaSsrcHandler.parse(this.pc.currentRemoteDescription.sdp, \"remote\");\n            }\n            if (this.pc.currentLocalDescription) {\n                this.trackStats.mediaSsrcHandler.parse(this.pc.currentLocalDescription.sdp, \"local\");\n            }\n        }\n    }\n\n    public setOpponentMemberId(id: string): void {\n        this.opponentMemberId = id;\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { TypedEventEmitter } from \"../../models/typed-event-emitter.ts\";\nimport {\n    type ByteSentStatsReport,\n    type CallFeedReport,\n    type ConnectionStatsReport,\n    StatsReport,\n    type SummaryStatsReport,\n} from \"./statsReport.ts\";\n\nexport type StatsReportHandlerMap = {\n    [StatsReport.BYTE_SENT_STATS]: (report: ByteSentStatsReport) => void;\n    [StatsReport.CONNECTION_STATS]: (report: ConnectionStatsReport) => void;\n    [StatsReport.CALL_FEED_REPORT]: (report: CallFeedReport) => void;\n    [StatsReport.SUMMARY_STATS]: (report: SummaryStatsReport) => void;\n};\n\nexport class StatsReportEmitter extends TypedEventEmitter<StatsReport, StatsReportHandlerMap> {\n    public emitByteSendReport(byteSentStats: ByteSentStatsReport): void {\n        this.emit(StatsReport.BYTE_SENT_STATS, byteSentStats);\n    }\n\n    public emitConnectionStatsReport(report: ConnectionStatsReport): void {\n        this.emit(StatsReport.CONNECTION_STATS, report);\n    }\n\n    public emitCallFeedReport(report: CallFeedReport): void {\n        this.emit(StatsReport.CALL_FEED_REPORT, report);\n    }\n\n    public emitSummaryStatsReport(report: SummaryStatsReport): void {\n        this.emit(StatsReport.SUMMARY_STATS, report);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { CallStatsReportGatherer } from \"./callStatsReportGatherer.ts\";\nimport { StatsReportEmitter } from \"./statsReportEmitter.ts\";\nimport { type CallStatsReportSummary } from \"./callStatsReportSummary.ts\";\nimport { SummaryStatsReportGatherer } from \"./summaryStatsReportGatherer.ts\";\nimport { logger } from \"../../logger.ts\";\n\nexport class GroupCallStats {\n    private timer: undefined | ReturnType<typeof setTimeout>;\n    private readonly gatherers: Map<string, CallStatsReportGatherer> = new Map<string, CallStatsReportGatherer>();\n    public readonly reports = new StatsReportEmitter();\n    private readonly summaryStatsReportGatherer = new SummaryStatsReportGatherer(this.reports);\n\n    public constructor(\n        private groupCallId: string,\n        private userId: string,\n        private interval: number = 10000,\n    ) {}\n\n    public start(): void {\n        if (this.timer === undefined && this.interval > 0) {\n            this.timer = setInterval(() => {\n                this.processStats();\n            }, this.interval);\n        }\n    }\n\n    public stop(): void {\n        if (this.timer !== undefined) {\n            clearInterval(this.timer);\n            this.gatherers.forEach((c) => c.stopProcessingStats());\n        }\n    }\n\n    public hasStatsReportGatherer(callId: string): boolean {\n        return this.gatherers.has(callId);\n    }\n\n    public addStatsReportGatherer(\n        callId: string,\n        opponentMemberId: string,\n        peerConnection: RTCPeerConnection,\n    ): boolean {\n        if (this.hasStatsReportGatherer(callId)) {\n            return false;\n        }\n        this.gatherers.set(callId, new CallStatsReportGatherer(callId, opponentMemberId, peerConnection, this.reports));\n        return true;\n    }\n\n    public removeStatsReportGatherer(callId: string): boolean {\n        return this.gatherers.delete(callId);\n    }\n\n    public getStatsReportGatherer(callId: string): CallStatsReportGatherer | undefined {\n        return this.hasStatsReportGatherer(callId) ? this.gatherers.get(callId) : undefined;\n    }\n\n    public updateOpponentMember(callId: string, opponentMember: string): void {\n        this.getStatsReportGatherer(callId)?.setOpponentMemberId(opponentMember);\n    }\n\n    private processStats(): void {\n        const summary: Promise<CallStatsReportSummary>[] = [];\n        this.gatherers.forEach((c) => {\n            summary.push(c.processStats(this.groupCallId, this.userId));\n        });\n\n        Promise.all(summary)\n            .then((s: Awaited<CallStatsReportSummary>[]) => this.summaryStatsReportGatherer.build(s))\n            .catch((err) => {\n                logger.error(\"Could not build summary stats report\", err);\n            });\n    }\n\n    public setInterval(interval: number): void {\n        this.interval = interval;\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { type StatsReportEmitter } from \"./statsReportEmitter.ts\";\nimport { type CallStatsReportSummary } from \"./callStatsReportSummary.ts\";\nimport { type SummaryStatsReport } from \"./statsReport.ts\";\nimport { type ParticipantState } from \"../groupCall.ts\";\nimport { type RoomMember } from \"../../matrix.ts\";\n\ninterface CallStatsReportSummaryCounter {\n    receivedAudio: number;\n    receivedVideo: number;\n    receivedMedia: number;\n    concealedAudio: number;\n    totalAudio: number;\n}\n\nexport class SummaryStatsReportGatherer {\n    public constructor(private emitter: StatsReportEmitter) {}\n\n    public build(allSummary: CallStatsReportSummary[]): void {\n        // Filter all stats which collect the first time webrtc stats.\n        // Because stats based on time interval and the first collection of a summery stats has no previous\n        // webrtcStats as basement all the calculation are 0. We don't want track the 0 stats.\n        const summary = allSummary.filter((s) => !s.isFirstCollection);\n        const summaryTotalCount = summary.length;\n        // For counting the peer connections we also want to consider the ignored summaries\n        const peerConnectionsCount = allSummary.length;\n        if (summaryTotalCount === 0) {\n            return;\n        }\n\n        const summaryCounter: CallStatsReportSummaryCounter = {\n            receivedAudio: 0,\n            receivedVideo: 0,\n            receivedMedia: 0,\n            concealedAudio: 0,\n            totalAudio: 0,\n        };\n        let maxJitter = 0;\n        let maxPacketLoss = 0;\n        summary.forEach((stats) => {\n            this.countTrackListReceivedMedia(summaryCounter, stats);\n            this.countConcealedAudio(summaryCounter, stats);\n            maxJitter = this.buildMaxJitter(maxJitter, stats);\n            maxPacketLoss = this.buildMaxPacketLoss(maxPacketLoss, stats);\n        });\n        const decimalPlaces = 5;\n        const report = {\n            percentageReceivedMedia: Number((summaryCounter.receivedMedia / summaryTotalCount).toFixed(decimalPlaces)),\n            percentageReceivedVideoMedia: Number(\n                (summaryCounter.receivedVideo / summaryTotalCount).toFixed(decimalPlaces),\n            ),\n            percentageReceivedAudioMedia: Number(\n                (summaryCounter.receivedAudio / summaryTotalCount).toFixed(decimalPlaces),\n            ),\n            maxJitter,\n            maxPacketLoss,\n            percentageConcealedAudio: Number(\n                summaryCounter.totalAudio > 0\n                    ? (summaryCounter.concealedAudio / summaryCounter.totalAudio).toFixed(decimalPlaces)\n                    : 0,\n            ),\n            peerConnections: peerConnectionsCount,\n        } as SummaryStatsReport;\n        this.emitter.emitSummaryStatsReport(report);\n    }\n\n    public static extendSummaryReport(\n        report: SummaryStatsReport,\n        callParticipants: Map<RoomMember, Map<string, ParticipantState>>,\n    ): void {\n        // Calculate the actual number of devices based on the participants state event\n        // (this is used, to compare the expected participant count from the room state with the acutal peer connections)\n        // const devices = callParticipants.()\n        const devices: [string, ParticipantState][] = [];\n        const users: [RoomMember, Map<string, ParticipantState>][] = [];\n        for (const userEntry of callParticipants) {\n            users.push(userEntry);\n            for (const device of userEntry[1]) {\n                devices.push(device);\n            }\n        }\n        report.opponentDevicesInCall = Math.max(0, devices.length - 1);\n        report.opponentUsersInCall = Math.max(0, users.length - 1);\n        report.diffDevicesToPeerConnections = Math.max(0, devices.length - 1) - report.peerConnections;\n        report.ratioPeerConnectionToDevices =\n            Math.max(0, devices.length - 1) == 0 ? 0 : report.peerConnections / (devices.length - 1);\n    }\n\n    private countTrackListReceivedMedia(counter: CallStatsReportSummaryCounter, stats: CallStatsReportSummary): void {\n        let hasReceivedAudio = false;\n        let hasReceivedVideo = false;\n        if (stats.receivedAudioMedia > 0 || stats.audioTrackSummary.count === 0) {\n            counter.receivedAudio++;\n            hasReceivedAudio = true;\n        }\n        if (stats.receivedVideoMedia > 0 || stats.videoTrackSummary.count === 0) {\n            counter.receivedVideo++;\n            hasReceivedVideo = true;\n        } else {\n            if (stats.videoTrackSummary.muted > 0 && stats.videoTrackSummary.muted === stats.videoTrackSummary.count) {\n                counter.receivedVideo++;\n                hasReceivedVideo = true;\n            }\n        }\n\n        if (hasReceivedVideo && hasReceivedAudio) {\n            counter.receivedMedia++;\n        }\n    }\n\n    private buildMaxJitter(maxJitter: number, stats: CallStatsReportSummary): number {\n        if (maxJitter < stats.videoTrackSummary.maxJitter) {\n            maxJitter = stats.videoTrackSummary.maxJitter;\n        }\n\n        if (maxJitter < stats.audioTrackSummary.maxJitter) {\n            maxJitter = stats.audioTrackSummary.maxJitter;\n        }\n        return maxJitter;\n    }\n\n    private buildMaxPacketLoss(maxPacketLoss: number, stats: CallStatsReportSummary): number {\n        if (maxPacketLoss < stats.videoTrackSummary.maxPacketLoss) {\n            maxPacketLoss = stats.videoTrackSummary.maxPacketLoss;\n        }\n\n        if (maxPacketLoss < stats.audioTrackSummary.maxPacketLoss) {\n            maxPacketLoss = stats.audioTrackSummary.maxPacketLoss;\n        }\n        return maxPacketLoss;\n    }\n\n    private countConcealedAudio(summaryCounter: CallStatsReportSummaryCounter, stats: CallStatsReportSummary): void {\n        summaryCounter.concealedAudio += stats.audioTrackSummary.concealedAudio;\n        summaryCounter.totalAudio += stats.audioTrackSummary.totalAudio;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nexport { ErrorResponse, ErrorTimeout } from \"./errors\";\nexport type { INavigator, IFrameWindowParams, IWindow, NavigateParams, NavigateResponse, PopupWindowParams, RedirectParams } from \"./navigators\";\nexport { Log, Logger } from \"./utils\";\nexport type { ILogger, PopupWindowFeatures } from \"./utils\";\nexport type { OidcAddressClaim, OidcStandardClaims, IdTokenClaims, JwtClaims } from \"./Claims\";\n\nexport { AccessTokenEvents } from \"./AccessTokenEvents\";\nexport type { AccessTokenCallback } from \"./AccessTokenEvents\";\nexport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nexport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nexport type { AsyncStorage } from \"./AsyncStorage\";\nexport { MetadataService } from \"./MetadataService\";\nexport * from \"./OidcClient\";\nexport { OidcClientSettingsStore } from \"./OidcClientSettings\";\nexport type { OidcClientSettings, SigningKey, ExtraHeader } from \"./OidcClientSettings\";\nexport type { OidcMetadata } from \"./OidcMetadata\";\nexport { SessionMonitor } from \"./SessionMonitor\";\nexport type { SessionStatus } from \"./SessionStatus\";\nexport type { SigninRequest, SigninRequestCreateArgs } from \"./SigninRequest\";\nexport type { RefreshState } from \"./RefreshState\";\nexport { SigninResponse } from \"./SigninResponse\";\nexport { SigninState } from \"./SigninState\";\nexport type { SigninStateArgs, SigninStateCreateArgs } from \"./SigninState\";\nexport type { SignoutRequest, SignoutRequestArgs } from \"./SignoutRequest\";\nexport { SignoutResponse } from \"./SignoutResponse\";\nexport { State } from \"./State\";\nexport type { StateStore } from \"./StateStore\";\nexport { User } from \"./User\";\nexport type { UserProfile } from \"./User\";\nexport * from \"./UserManager\";\nexport type {\n    UserManagerEvents,\n    SilentRenewErrorCallback,\n    UserLoadedCallback,\n    UserSessionChangedCallback,\n    UserSignedInCallback,\n    UserSignedOutCallback,\n    UserUnloadedCallback,\n} from \"./UserManagerEvents\";\nexport { UserManagerSettingsStore } from \"./UserManagerSettings\";\nexport type { UserManagerSettings } from \"./UserManagerSettings\";\nexport { Version } from \"./Version\";\nexport { WebStorageStateStore } from \"./WebStorageStateStore\";\nexport { IndexedDbDPoPStore } from \"./IndexedDbDPoPStore\";\nexport { DPoPState } from \"./DPoPStore\";\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Native interface\n *\n * @public\n */\nexport interface ILogger {\n    debug(...args: unknown[]): void;\n    info(...args: unknown[]): void;\n    warn(...args: unknown[]): void;\n    error(...args: unknown[]): void;\n}\n\nconst nopLogger: ILogger = {\n    debug: () => undefined,\n    info: () => undefined,\n    warn: () => undefined,\n    error: () => undefined,\n};\n\nlet level: number;\nlet logger: ILogger;\n\n/**\n * Log levels\n *\n * @public\n */\nexport enum Log {\n    NONE,\n    ERROR,\n    WARN,\n    INFO,\n    DEBUG\n}\n\n/**\n * Log manager\n *\n * @public\n */\nexport namespace Log { // eslint-disable-line @typescript-eslint/no-namespace\n    export function reset(): void {\n        level = Log.INFO;\n        logger = nopLogger;\n    }\n\n    export function setLevel(value: Log): void {\n        if (!(Log.NONE <= value && value <= Log.DEBUG)) {\n            throw new Error(\"Invalid log level\");\n        }\n        level = value;\n    }\n\n    export function setLogger(value: ILogger): void {\n        logger = value;\n    }\n}\n\n/**\n * Internal logger instance\n *\n * @public\n */\nexport class Logger {\n    private _method?: string;\n    public constructor(private _name: string) {}\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    public debug(...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public info(...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public warn(...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public error(...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n\n    public throw(err: Error): never {\n        this.error(err);\n        throw err;\n    }\n\n    public create(method: string): Logger {\n        const methodLogger: Logger = Object.create(this);\n        methodLogger._method = method;\n        methodLogger.debug(\"begin\");\n        return methodLogger;\n    }\n\n    public static createStatic(name: string, staticMethod: string): Logger {\n        const staticLogger = new Logger(`${name}.${staticMethod}`);\n        staticLogger.debug(\"begin\");\n        return staticLogger;\n    }\n\n    private static _format(name: string, method?: string) {\n        const prefix = `[${name}]`;\n        return method ? `${prefix} ${method}:` : prefix;\n    }\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    // helpers for static class methods\n    public static debug(name: string, ...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(name), ...args);\n        }\n    }\n    public static info(name: string, ...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(name), ...args);\n        }\n    }\n    public static warn(name: string, ...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(name), ...args);\n        }\n    }\n    public static error(name: string, ...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(name), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n}\n\nLog.reset();\n","import { jwtDecode } from \"jwt-decode\";\n\nimport { Logger } from \"./Logger\";\nimport type { JwtClaims } from \"../Claims\";\nimport { CryptoUtils } from \"./CryptoUtils\";\n\n/**\n * @internal\n */\nexport class JwtUtils {\n    // IMPORTANT: doesn't validate the token\n    public static decode(token: string): JwtClaims {\n        try {\n            return jwtDecode<JwtClaims>(token);\n        }\n        catch (err) {\n            Logger.error(\"JwtUtils.decode\", err);\n            throw err;\n        }\n    }\n\n    public static async generateSignedJwt(header: object, payload: object, privateKey: CryptoKey) : Promise<string> {\n        const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n        const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n        const encodedToken = `${encodedHeader}.${encodedPayload}`;\n\n        const signature = await window.crypto.subtle.sign(\n            {\n                name: \"ECDSA\",\n                hash: { name: \"SHA-256\" },\n            },\n            privateKey,\n            new TextEncoder().encode(encodedToken),\n        );\n\n        const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n        return `${encodedToken}.${encodedSignature}`;\n    }\n\n    public static async generateSignedJwtWithHmac(header: object, payload: object, secretKey: CryptoKey): Promise<string> {\n        const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n        const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n        const encodedToken = `${encodedHeader}.${encodedPayload}`;\n\n        const signature = await window.crypto.subtle.sign(\n            \"HMAC\",\n            secretKey,\n            new TextEncoder().encode(encodedToken),\n        );\n\n        const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n        return `${encodedToken}.${encodedSignature}`;\n    }\n}\n","import { Logger } from \"./Logger\";\nimport { JwtUtils } from \"./JwtUtils\";\n\nexport interface GenerateDPoPProofOpts {\n    url: string;\n    accessToken?: string;\n    httpMethod?: string;\n    keyPair: CryptoKeyPair;\n    nonce?: string;\n}\n\nconst UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\n\nconst toBase64 = (val: ArrayBuffer | Uint8Array): string =>\n    btoa([...new Uint8Array(val)]\n        .map((chr) => String.fromCharCode(chr))\n        .join(\"\"));\n\n/**\n * @internal\n */\nexport class CryptoUtils {\n    private static _randomWord(): number {\n        const arr = new Uint32Array(1);\n        crypto.getRandomValues(arr);\n        return arr[0];\n    }\n\n    /**\n     * Generates RFC4122 version 4 guid\n     */\n    public static generateUUIDv4(): string {\n        const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c =>\n            (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16),\n        );\n        return uuid.replace(/-/g, \"\");\n    }\n\n    /**\n     * PKCE: Generate a code verifier\n     */\n    public static generateCodeVerifier(): string {\n        return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n    }\n\n    /**\n     * PKCE: Generate a code challenge\n     */\n    public static async generateCodeChallenge(code_verifier: string): Promise<string> {\n        if (!crypto.subtle) {\n            throw new Error(\"Crypto.subtle is available only in secure contexts (HTTPS).\");\n        }\n\n        try {\n            const encoder = new TextEncoder();\n            const data = encoder.encode(code_verifier);\n            const hashed = await crypto.subtle.digest(\"SHA-256\", data);\n            return toBase64(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n        }\n        catch (err) {\n            Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n            throw err;\n        }\n    }\n\n    /**\n     * Generates a base64-encoded string for a basic auth header\n     */\n    public static generateBasicAuth(client_id: string, client_secret: string): string {\n        const encoder = new TextEncoder();\n        const data = encoder.encode([client_id, client_secret].join(\":\"));\n        return toBase64(data);\n    }\n\n    /**\n     * Generates a hash of a string using a given algorithm\n     * @param alg\n     * @param message\n     */\n    public static async hash(alg: string, message: string) : Promise<Uint8Array> {\n        const msgUint8 = new TextEncoder().encode(message);\n        const hashBuffer = await crypto.subtle.digest(alg, msgUint8);\n        return new Uint8Array(hashBuffer);\n    }\n\n    /**\n     * Generates a base64url encoded string\n     */\n    public static encodeBase64Url = (input: Uint8Array) => {\n        return toBase64(input).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    };\n\n    /**\n     * Generates a rfc7638 compliant jwk thumbprint\n     * @param jwk\n     */\n    public static async customCalculateJwkThumbprint(jwk: JsonWebKey): Promise<string> {\n        let jsonObject: object;\n        switch (jwk.kty) {\n            case \"RSA\":\n                jsonObject = {\n                    \"e\": jwk.e,\n                    \"kty\": jwk.kty,\n                    \"n\": jwk.n,\n                };\n                break;\n            case \"EC\":\n                jsonObject = {\n                    \"crv\": jwk.crv,\n                    \"kty\": jwk.kty,\n                    \"x\": jwk.x,\n                    \"y\": jwk.y,\n                };\n                break;\n            case \"OKP\":\n                jsonObject = {\n                    \"crv\": jwk.crv,\n                    \"kty\": jwk.kty,\n                    \"x\": jwk.x,\n                };\n                break;\n            case \"oct\":\n                jsonObject = {\n                    \"crv\": jwk.k,\n                    \"kty\": jwk.kty,\n                };\n                break;\n            default:\n                throw new Error(\"Unknown jwk type\");\n        }\n        const utf8encodedAndHashed = await CryptoUtils.hash(\"SHA-256\", JSON.stringify(jsonObject));\n        return CryptoUtils.encodeBase64Url(utf8encodedAndHashed);\n    }\n\n    public static async generateDPoPProof({\n        url,\n        accessToken,\n        httpMethod,\n        keyPair,\n        nonce,\n    }: GenerateDPoPProofOpts): Promise<string> {\n        let hashedToken: Uint8Array;\n        let encodedHash: string;\n\n        const payload: Record<string, string | number> = {\n            \"jti\": window.crypto.randomUUID(),\n            \"htm\": httpMethod ?? \"GET\",\n            \"htu\": url,\n            \"iat\": Math.floor(Date.now() / 1000),\n        };\n\n        if (accessToken) {\n            hashedToken = await CryptoUtils.hash(\"SHA-256\", accessToken);\n            encodedHash = CryptoUtils.encodeBase64Url(hashedToken);\n            payload.ath = encodedHash;\n        }\n\n        if (nonce) {\n            payload.nonce = nonce;\n        }\n\n        try {\n            const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n            const header = {\n                \"alg\": \"ES256\",\n                \"typ\": \"dpop+jwt\",\n                \"jwk\": {\n                    \"crv\": publicJwk.crv,\n                    \"kty\": publicJwk.kty,\n                    \"x\": publicJwk.x,\n                    \"y\": publicJwk.y,\n                },\n            };\n            return await JwtUtils.generateSignedJwt(header, payload, keyPair.privateKey);\n        } catch (err) {\n            if (err instanceof TypeError) {\n                throw new Error(`Error exporting dpop public key: ${err.message}`);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    public static async generateDPoPJkt(keyPair: CryptoKeyPair) : Promise<string> {\n        try {\n            const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n            return await CryptoUtils.customCalculateJwkThumbprint(publicJwk);\n        } catch (err) {\n            if (err instanceof TypeError) {\n                throw new Error(`Could not retrieve dpop keys from storage: ${err.message}`);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    public static async generateDPoPKeys() : Promise<CryptoKeyPair> {\n        return await window.crypto.subtle.generateKey(\n            {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n            },\n            false,\n            [\"sign\", \"verify\"],\n        );\n    }\n\n    /**\n     * Generates a client assertion JWT for client_secret_jwt authentication\n     * @param client_id The client identifier\n     * @param client_secret The client secret\n     * @param audience The token endpoint URL (audience)\n     * @param algorithm The HMAC algorithm to use (HS256, HS384, HS512). Defaults to HS256\n     */\n    public static async generateClientAssertionJwt(client_id: string, client_secret: string, audience: string, algorithm: string = \"HS256\"): Promise<string> {\n        const now = Math.floor(Date.now() / 1000);\n\n        const header = {\n            \"alg\": algorithm,\n            \"typ\": \"JWT\",\n        };\n\n        const payload = {\n            \"iss\": client_id,\n            \"sub\": client_id,\n            \"aud\": audience,\n            \"jti\": CryptoUtils.generateUUIDv4(),\n            \"exp\": now + 300, // 5 minutes\n            \"iat\": now,\n        };\n\n        const hashMap: Record<string, string> = {\n            \"HS256\": \"SHA-256\",\n            \"HS384\": \"SHA-384\",\n            \"HS512\": \"SHA-512\",\n        };\n\n        const hashFunction = hashMap[algorithm];\n        if (!hashFunction) {\n            throw new Error(`Unsupported algorithm: ${algorithm}. Supported algorithms are: HS256, HS384, HS512`);\n        }\n\n        const encoder = new TextEncoder();\n        const secretKey = await crypto.subtle.importKey(\n            \"raw\",\n            encoder.encode(client_secret),\n            { name: \"HMAC\", hash: hashFunction },\n            false,\n            [\"sign\"],\n        );\n\n        return await JwtUtils.generateSignedJwtWithHmac(header, payload, secretKey);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport type Callback<EventType extends unknown[]> = (...ev: EventType) => (Promise<void> | void);\n\n/**\n * @internal\n */\nexport class Event<EventType extends unknown[]> {\n    protected readonly _logger: Logger;\n\n    private readonly _callbacks: Array<Callback<EventType>> = [];\n\n    public constructor(protected readonly _name: string) {\n        this._logger = new Logger(`Event('${this._name}')`);\n    }\n\n    public addHandler(cb: Callback<EventType>): () => void {\n        this._callbacks.push(cb);\n        return () => this.removeHandler(cb);\n    }\n\n    public removeHandler(cb: Callback<EventType>): void {\n        const idx = this._callbacks.lastIndexOf(cb);\n        if (idx >= 0) {\n            this._callbacks.splice(idx, 1);\n        }\n    }\n\n    public async raise(...ev: EventType): Promise<void> {\n        this._logger.debug(\"raise:\", ...ev);\n        for (const cb of this._callbacks) {\n            await cb(...ev);\n        }\n    }\n}\n","/**\n *\n * @public\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n */\nexport interface PopupWindowFeatures {\n    left?: number;\n    top?: number;\n    width?: number;\n    height?: number;\n    menubar?: boolean | string;\n    toolbar?: boolean | string;\n    location?: boolean | string;\n    status?: boolean | string;\n    resizable?: boolean | string;\n    scrollbars?: boolean | string;\n    /** Close popup window after time in seconds, by default it is -1. To enable this feature, set value greater than 0. */\n    closePopupWindowAfterInSeconds?: number;\n\n    [k: string]: boolean | string | number | undefined;\n}\n\nexport class PopupUtils {\n    /**\n     * Populates a map of window features with a placement centered in front of\n     * the current window. If no explicit width is given, a default value is\n     * binned into [800, 720, 600, 480, 360] based on the current window's width.\n     */\n    static center({ ...features }: PopupWindowFeatures): PopupWindowFeatures {\n        if (features.width == null)\n            features.width = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618) ?? 360;\n        features.left ??= Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n        if (features.height != null)\n            features.top ??= Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n        return features;\n    }\n\n    static serialize(features: PopupWindowFeatures): string {\n        return Object.entries(features)\n            .filter(([, value]) => value != null)\n            .map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value as string : value ? \"yes\" : \"no\"}`)\n            .join(\",\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event } from \"./Event\";\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport class Timer extends Event<[void]> {\n    protected readonly _logger = new Logger(`Timer('${this._name}')`);\n    private _timerHandle: ReturnType<typeof setInterval> | null = null;\n    private _expiration = 0;\n\n    // get the time\n    public static getEpochTime(): number {\n        return Math.floor(Date.now() / 1000);\n    }\n\n    public init(durationInSeconds: number): void {\n        const logger = this._logger.create(\"init\");\n        durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n        const expiration = Timer.getEpochTime() + durationInSeconds;\n        if (this.expiration === expiration && this._timerHandle) {\n            // no need to reinitialize to same expiration, so bail out\n            logger.debug(\"skipping since already initialized for expiration at\", this.expiration);\n            return;\n        }\n\n        this.cancel();\n\n        logger.debug(\"using duration\", durationInSeconds);\n        this._expiration = expiration;\n\n        // we're using a fairly short timer and then checking the expiration in the\n        // callback to handle scenarios where the browser device sleeps, and then\n        // the timers end up getting delayed.\n        const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n        this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1000);\n    }\n\n    public get expiration(): number {\n        return this._expiration;\n    }\n\n    public cancel(): void {\n        this._logger.create(\"cancel\");\n        if (this._timerHandle) {\n            clearInterval(this._timerHandle);\n            this._timerHandle = null;\n        }\n    }\n\n    protected _callback = (): void => {\n        const diff = this._expiration - Timer.getEpochTime();\n        this._logger.debug(\"timer completes in\", diff);\n\n        if (this._expiration <= Timer.getEpochTime()) {\n            this.cancel();\n            void super.raise();\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @internal\n */\nexport class UrlUtils {\n    public static readParams(url: string, responseMode: \"query\" | \"fragment\" = \"query\"): URLSearchParams {\n        if (!url) throw new TypeError(\"Invalid URL\");\n        // the base URL is irrelevant, it's just here to support relative url arguments\n        const parsedUrl = new URL(url, \"http://127.0.0.1\");\n        const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n        return new URLSearchParams(params.slice(1));\n    }\n}\n\n/**\n * @internal\n */\nexport const URL_STATE_DELIMITER = \";\";","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\n\n/**\n * Error class thrown in case of an authentication error.\n *\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class ErrorResponse extends Error {\n    /** Marker to detect class: \"ErrorResponse\" */\n    public readonly name: string = \"ErrorResponse\";\n\n    /** An error code string that can be used to classify the types of errors that occur and to respond to errors. */\n    public readonly error: string | null;\n    /** additional information that can help a developer identify the cause of the error.*/\n    public readonly error_description: string | null;\n    /**\n     * URI identifying a human-readable web page with information about the error, used to provide the client\n       developer with additional information about the error.\n    */\n    public readonly error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public state?: unknown;\n\n    public readonly session_state: string | null;\n\n    public url_state?: string;\n\n    public constructor(\n        args: {\n            error?: string | null; error_description?: string | null; error_uri?: string | null;\n            userState?: unknown; session_state?: string | null; url_state?: string;\n        },\n        /** The x-www-form-urlencoded request body sent to the authority server */\n        public readonly form?: URLSearchParams,\n    ) {\n        super(args.error_description || args.error || \"\");\n\n        if (!args.error) {\n            Logger.error(\"ErrorResponse\", \"No error passed\");\n            throw new Error(\"No error passed\");\n        }\n\n        this.error = args.error;\n        this.error_description = args.error_description ?? null;\n        this.error_uri = args.error_uri ?? null;\n\n        this.state = args.userState;\n        this.session_state = args.session_state ?? null;\n        this.url_state = args.url_state;\n    }\n}\n","// Copyright (C) 2021 AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Error class thrown in case of network timeouts (e.g IFrame time out).\n *\n * @public\n */\nexport class ErrorTimeout extends Error {\n    /** Marker to detect class: \"ErrorTimeout\" */\n    public readonly name: string = \"ErrorTimeout\";\n\n    public constructor(message?: string) {\n        super(message);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type AccessTokenCallback = (...ev: unknown[]) => (Promise<void> | void);\n\n/**\n * @public\n */\nexport class AccessTokenEvents {\n    protected readonly _logger = new Logger(\"AccessTokenEvents\");\n\n    private readonly _expiringTimer = new Timer(\"Access token expiring\");\n    private readonly _expiredTimer = new Timer(\"Access token expired\");\n    private readonly _expiringNotificationTimeInSeconds: number;\n\n    public constructor(args: { expiringNotificationTimeInSeconds: number }) {\n        this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n    }\n\n    public async load(container: User): Promise<void> {\n        const logger = this._logger.create(\"load\");\n        // only register events if there's an access token and it has an expiration\n        if (container.access_token && container.expires_in !== undefined) {\n            const duration = container.expires_in;\n            logger.debug(\"access token present, remaining duration:\", duration);\n\n            if (duration > 0) {\n                // only register expiring if we still have time\n                let expiring = duration - this._expiringNotificationTimeInSeconds;\n                if (expiring <= 0) {\n                    expiring = 1;\n                }\n\n                logger.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n                this._expiringTimer.init(expiring);\n            }\n            else {\n                logger.debug(\"canceling existing expiring timer because we're past expiration.\");\n                this._expiringTimer.cancel();\n            }\n\n            // if it's negative, it will still fire\n            const expired = duration + 1;\n            logger.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n            this._expiredTimer.init(expired);\n        }\n        else {\n            this._expiringTimer.cancel();\n            this._expiredTimer.cancel();\n        }\n    }\n\n    public async unload(): Promise<void> {\n        this._logger.debug(\"unload: canceling existing access token timers\");\n        this._expiringTimer.cancel();\n        this._expiredTimer.cancel();\n    }\n\n    /**\n     * Add callback: Raised prior to the access token expiring.\n     */\n    public addAccessTokenExpiring(cb: AccessTokenCallback): () => void {\n        return this._expiringTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised prior to the access token expiring.\n     */\n    public removeAccessTokenExpiring(cb: AccessTokenCallback): void {\n        this._expiringTimer.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised after the access token has expired.\n     */\n    public addAccessTokenExpired(cb: AccessTokenCallback): () => void {\n        return this._expiredTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised after the access token has expired.\n     */\n    public removeAccessTokenExpired(cb: AccessTokenCallback): void {\n        this._expiredTimer.removeHandler(cb);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport class CheckSessionIFrame {\n    private readonly _logger = new Logger(\"CheckSessionIFrame\");\n    private _frame_origin: string;\n    private _frame: HTMLIFrameElement;\n    private _timer: ReturnType<typeof setInterval> | null = null;\n    private _session_state: string | null = null;\n\n    public constructor(\n        private _callback: () => Promise<void>,\n        private _client_id: string,\n        url: string,\n        private _intervalInSeconds: number,\n        private _stopOnError: boolean,\n    ) {\n        const parsedUrl = new URL(url);\n        this._frame_origin = parsedUrl.origin;\n\n        this._frame = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        this._frame.style.visibility = \"hidden\";\n        this._frame.style.position = \"fixed\";\n        this._frame.style.left = \"-1000px\";\n        this._frame.style.top = \"0\";\n        this._frame.width = \"0\";\n        this._frame.height = \"0\";\n        this._frame.src = parsedUrl.href;\n    }\n\n    public load(): Promise<void> {\n        return new Promise<void>((resolve) => {\n            this._frame.onload = () => {\n                resolve();\n            };\n\n            window.document.body.appendChild(this._frame);\n            window.addEventListener(\"message\", this._message, false);\n        });\n    }\n\n    private _message = (e: MessageEvent<string>): void => {\n        if (e.origin === this._frame_origin &&\n            e.source === this._frame.contentWindow\n        ) {\n            if (e.data === \"error\") {\n                this._logger.error(\"error message from check session op iframe\");\n                if (this._stopOnError) {\n                    this.stop();\n                }\n            }\n            else if (e.data === \"changed\") {\n                this._logger.debug(\"changed message from check session op iframe\");\n                this.stop();\n                void this._callback();\n            }\n            else {\n                this._logger.debug(e.data + \" message from check session op iframe\");\n            }\n        }\n    };\n\n    public start(session_state: string): void {\n        if (this._session_state === session_state) {\n            return;\n        }\n\n        this._logger.create(\"start\");\n\n        this.stop();\n\n        this._session_state = session_state;\n\n        const send = () => {\n            if (!this._frame.contentWindow || !this._session_state) {\n                return;\n            }\n\n            this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n        };\n\n        // trigger now\n        send();\n\n        // and setup timer\n        this._timer = setInterval(send, this._intervalInSeconds * 1000);\n    }\n\n    public stop(): void {\n        this._logger.create(\"stop\");\n        this._session_state = null;\n\n        if (this._timer) {\n\n            clearInterval(this._timer);\n            this._timer = null;\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @public\n */\nexport class InMemoryWebStorage implements Storage {\n    private readonly _logger = new Logger(\"InMemoryWebStorage\");\n    private _data: Record<string, string> = {};\n\n    public clear(): void {\n        this._logger.create(\"clear\");\n        this._data = {};\n    }\n\n    public getItem(key: string): string {\n        this._logger.create(`getItem('${key}')`);\n        return this._data[key];\n    }\n\n    public setItem(key: string, value: string): void {\n        this._logger.create(`setItem('${key}')`);\n        this._data[key] = value;\n    }\n\n    public removeItem(key: string): void {\n        this._logger.create(`removeItem('${key}')`);\n        delete this._data[key];\n    }\n\n    public get length(): number {\n        return Object.getOwnPropertyNames(this._data).length;\n    }\n\n    public key(index: number): string {\n        return Object.getOwnPropertyNames(this._data)[index];\n    }\n}\n","export class ErrorDPoPNonce extends Error {\n    /** Marker to detect class: \"ErrorDPoPNonce\" */\n    public readonly name: string = \"ErrorDPoPNonce\";\n    public readonly nonce: string;\n\n    public constructor(nonce: string, message?: string) {\n        super(message);\n        this.nonce = nonce;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { ErrorResponse, ErrorTimeout } from \"./errors\";\nimport type { ExtraHeader } from \"./OidcClientSettings\";\nimport { Logger } from \"./utils\";\nimport { ErrorDPoPNonce } from \"./errors/ErrorDPoPNonce\";\n\n/**\n * @internal\n */\nexport type JwtHandler = (text: string) => Promise<Record<string, unknown>>;\n\n/**\n * @internal\n */\nexport interface GetJsonOpts {\n    token?: string;\n    credentials?: RequestCredentials;\n    timeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport interface PostFormOpts {\n    body: URLSearchParams;\n    basicAuth?: string;\n    timeoutInSeconds?: number;\n    initCredentials?: \"same-origin\" | \"include\" | \"omit\";\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport class JsonService {\n    private readonly _logger = new Logger(\"JsonService\");\n\n    private _contentTypes: string[] = [];\n\n    public constructor(\n        additionalContentTypes: string[] = [],\n        private _jwtHandler: JwtHandler | null = null,\n        private _extraHeaders: Record<string, ExtraHeader> = {},\n    ) {\n        this._contentTypes.push(...additionalContentTypes, \"application/json\");\n        if (_jwtHandler) {\n            this._contentTypes.push(\"application/jwt\");\n        }\n    }\n\n    protected async fetchWithTimeout(input: RequestInfo, init: RequestInit & { timeoutInSeconds?: number } = {}) {\n        const { timeoutInSeconds, ...initFetch } = init;\n        if (!timeoutInSeconds) {\n            return await fetch(input, initFetch);\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n\n        try {\n            const response = await fetch(input, {\n                ...init,\n                signal: controller.signal,\n            });\n            return response;\n        }\n        catch (err) {\n            if (err instanceof DOMException && err.name === \"AbortError\") {\n                throw new ErrorTimeout(\"Network timed out\");\n            }\n            throw err;\n        }\n        finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    public async getJson(url: string, {\n        token,\n        credentials,\n        timeoutInSeconds,\n    }: GetJsonOpts = {}): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"getJson\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n        };\n        if (token) {\n            logger.debug(\"token passed, setting Authorization header\");\n            headers[\"Authorization\"] = \"Bearer \" + token;\n        }\n\n        this._appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"GET\", headers, timeoutInSeconds, credentials });\n        }\n        catch (err) {\n            logger.error(\"Network Error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            logger.throw(new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`));\n        }\n        if (response.ok && this._jwtHandler && contentType?.startsWith(\"application/jwt\")) {\n            return await this._jwtHandler(await response.text());\n        }\n        let json: Record<string, unknown>;\n        try {\n            json = await response.json();\n        }\n        catch (err) {\n            logger.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n\n    public async postForm(url: string, {\n        body,\n        basicAuth,\n        timeoutInSeconds,\n        initCredentials,\n        extraHeaders,\n    }: PostFormOpts): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"postForm\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            ...extraHeaders,\n        };\n        if (basicAuth !== undefined) {\n            headers[\"Authorization\"] = \"Basic \" + basicAuth;\n        }\n\n        this._appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n        }\n        catch (err) {\n            logger.error(\"Network error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            throw new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`);\n        }\n\n        const responseText = await response.text();\n\n        let json: Record<string, unknown> = {};\n        if (responseText) {\n            try {\n                json = JSON.parse(responseText);\n            }\n            catch (err) {\n                logger.error(\"Error parsing JSON response\", err);\n                if (response.ok) throw err;\n                throw new Error(`${response.statusText} (${response.status})`);\n            }\n        }\n\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (response.headers.has(\"dpop-nonce\")) {\n                const nonce = response.headers.get(\"dpop-nonce\") as string;\n                throw new ErrorDPoPNonce(nonce, `${JSON.stringify(json)}`);\n            }\n            if (json.error) {\n                throw new ErrorResponse(json, body);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n\n        return json;\n    }\n\n    private _appendExtraHeaders(\n        headers: Record<string, string>,\n    ): void {\n        const logger = this._logger.create(\"appendExtraHeaders\");\n        const customKeys = Object.keys(this._extraHeaders);\n        const protectedHeaders = [\n            \"accept\",\n            \"content-type\",\n        ];\n        const preventOverride = [\n            \"authorization\",\n        ];\n        if (customKeys.length === 0) {\n            return;\n        }\n        customKeys.forEach((headerName) => {\n            if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n                logger.warn(\"Protected header could not be set\", headerName, protectedHeaders);\n                return;\n            }\n            if (preventOverride.includes(headerName.toLocaleLowerCase()) &&\n                Object.keys(headers).includes(headerName)) {\n                logger.warn(\"Header could not be overridden\", headerName, preventOverride);\n                return;\n            }\n            const content = (typeof this._extraHeaders[headerName] === \"function\") ?\n                (this._extraHeaders[headerName] as ()=>string)() :\n                this._extraHeaders[headerName];\n            if (content && content !== \"\") {\n                headers[headerName] = content;\n            }\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { OidcClientSettingsStore, SigningKey } from \"./OidcClientSettings\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n */\nexport class MetadataService {\n    private readonly _logger = new Logger(\"MetadataService\");\n    private readonly _jsonService;\n\n    // cache\n    private _metadataUrl: string;\n    private _signingKeys: SigningKey[] | null = null;\n    private _metadata: Partial<OidcMetadata> | null = null;\n    private _fetchRequestCredentials: RequestCredentials | undefined;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore) {\n        this._metadataUrl = this._settings.metadataUrl;\n        this._jsonService = new JsonService(\n            [\"application/jwk-set+json\"],\n            null,\n            this._settings.extraHeaders,\n        );\n        if (this._settings.signingKeys) {\n            this._logger.debug(\"using signingKeys from settings\");\n            this._signingKeys = this._settings.signingKeys;\n        }\n\n        if (this._settings.metadata) {\n            this._logger.debug(\"using metadata from settings\");\n            this._metadata = this._settings.metadata;\n        }\n\n        if (this._settings.fetchRequestCredentials) {\n            this._logger.debug(\"using fetchRequestCredentials from settings\");\n            this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n        }\n    }\n\n    public resetSigningKeys(): void {\n        this._signingKeys = null;\n    }\n\n    public async getMetadata(): Promise<Partial<OidcMetadata>> {\n        const logger = this._logger.create(\"getMetadata\");\n        if (this._metadata) {\n            logger.debug(\"using cached values\");\n            return this._metadata;\n        }\n\n        if (!this._metadataUrl) {\n            logger.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"getting metadata from\", this._metadataUrl);\n        const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n\n        logger.debug(\"merging remote JSON with seed metadata\");\n        this._metadata = Object.assign({}, metadata, this._settings.metadataSeed);\n        return this._metadata;\n    }\n\n    public getIssuer(): Promise<string> {\n        return this._getMetadataProperty(\"issuer\") as Promise<string>;\n    }\n\n    public getAuthorizationEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"authorization_endpoint\") as Promise<string>;\n    }\n\n    public getUserInfoEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"userinfo_endpoint\") as Promise<string>;\n    }\n\n    public getTokenEndpoint(optional: false): Promise<string>;\n    public getTokenEndpoint(optional?: true): Promise<string | undefined>;\n    public getTokenEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"token_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getCheckSessionIframe(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"check_session_iframe\", true) as Promise<string | undefined>;\n    }\n\n    public getEndSessionEndpoint(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"end_session_endpoint\", true) as Promise<string | undefined>;\n    }\n\n    public getRevocationEndpoint(optional: false): Promise<string>;\n    public getRevocationEndpoint(optional?: true): Promise<string | undefined>;\n    public getRevocationEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"revocation_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getKeysEndpoint(optional: false): Promise<string>;\n    public getKeysEndpoint(optional?: true): Promise<string | undefined>;\n    public getKeysEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"jwks_uri\", optional) as Promise<string | undefined>;\n    }\n\n    protected async _getMetadataProperty(name: keyof OidcMetadata, optional=false): Promise<string | boolean | string[] | undefined> {\n        const logger = this._logger.create(`_getMetadataProperty('${name}')`);\n\n        const metadata = await this.getMetadata();\n        logger.debug(\"resolved\");\n\n        if (metadata[name] === undefined) {\n            if (optional === true) {\n                logger.warn(\"Metadata does not contain optional property\");\n                return undefined;\n            }\n\n            logger.throw(new Error(\"Metadata does not contain property \" + name));\n        }\n\n        return metadata[name];\n    }\n\n    public async getSigningKeys(): Promise<SigningKey[] | null> {\n        const logger = this._logger.create(\"getSigningKeys\");\n        if (this._signingKeys) {\n            logger.debug(\"returning signingKeys from cache\");\n            return this._signingKeys;\n        }\n\n        const jwks_uri = await this.getKeysEndpoint(false);\n        logger.debug(\"got jwks_uri\", jwks_uri);\n\n        const keySet = await this._jsonService.getJson(jwks_uri, { timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n        logger.debug(\"got key set\", keySet);\n\n        if (!Array.isArray(keySet.keys)) {\n            logger.throw(new Error(\"Missing keys on keyset\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        this._signingKeys = keySet.keys;\n        return this._signingKeys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\nimport type { AsyncStorage } from \"./AsyncStorage\";\n\n/**\n * @public\n */\nexport class WebStorageStateStore implements StateStore {\n    private readonly _logger = new Logger(\"WebStorageStateStore\");\n\n    private readonly _store: AsyncStorage | Storage;\n    private readonly _prefix: string;\n\n    public constructor({\n        prefix = \"oidc.\",\n        store = localStorage,\n    }: { prefix?: string; store?: AsyncStorage | Storage } = {}) {\n        this._store = store;\n        this._prefix = prefix;\n    }\n\n    public async set(key: string, value: string): Promise<void> {\n        this._logger.create(`set('${key}')`);\n\n        key = this._prefix + key;\n        await this._store.setItem(key, value);\n    }\n\n    public async get(key: string): Promise<string | null> {\n        this._logger.create(`get('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        return item;\n    }\n\n    public async remove(key: string): Promise<string | null> {\n        this._logger.create(`remove('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        await this._store.removeItem(key);\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        this._logger.create(\"getAllKeys\");\n        const len = await this._store.length;\n\n        const keys = [];\n        for (let index = 0; index < len; index++) {\n            const key = await this._store.key(index);\n            if (key && key.indexOf(this._prefix) === 0) {\n                keys.push(key.substr(this._prefix.length));\n            }\n        }\n        return keys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\nimport type { StateStore } from \"./StateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nimport type { DPoPStore } from \"./DPoPStore\";\n\nconst DefaultResponseType = \"code\";\nconst DefaultScope = \"openid\";\nconst DefaultClientAuthentication = \"client_secret_post\";\nconst DefaultStaleStateAgeInSeconds = 60 * 15;\n\n/**\n * @public\n */\nexport type SigningKey = Record<string, string | string[]>;\n\n/**\n * @public\n */\nexport type ExtraHeader = string | (() => string);\n\n/**\n * Optional DPoP settings\n * @public\n */\nexport interface DPoPSettings {\n    bind_authorization_code?: boolean;\n    store: DPoPStore;\n}\n\n/**\n * The settings used to configure the {@link OidcClient}.\n *\n * @public\n */\nexport interface OidcClientSettings {\n    /** The URL of the OIDC/OAuth2 provider */\n    authority: string;\n    metadataUrl?: string;\n    /** Provide metadata when authority server does not allow CORS on the metadata endpoint */\n    metadata?: Partial<OidcMetadata>;\n    /** Can be used to seed or add additional values to the results of the discovery request */\n    metadataSeed?: Partial<OidcMetadata>;\n    /** Provide signingKeys when authority server does not allow CORS on the jwks uri */\n    signingKeys?: SigningKey[];\n\n    /** Your client application's identifier as registered with the OIDC/OAuth2 */\n    client_id: string;\n    client_secret?: string;\n    /** The type of response desired from the OIDC/OAuth2 provider (default: \"code\") */\n    response_type?: string;\n    /** The scope being requested from the OIDC/OAuth2 provider (default: \"openid\") */\n    scope?: string;\n    /** The redirect URI of your client application to receive a response from the OIDC/OAuth2 provider */\n    redirect_uri: string;\n    /** The OIDC/OAuth2 post-logout redirect URI */\n    post_logout_redirect_uri?: string;\n\n    /**\n     * Client authentication method that is used to authenticate when using the token endpoint (default: \"client_secret_post\")\n     * - \"client_secret_basic\": using the HTTP Basic authentication scheme\n     * - \"client_secret_post\": including the client credentials in the request body\n     * - \"client_secret_jwt\": using a JWT signed with the client secret\n     *\n     * See https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\n     */\n    client_authentication?: \"client_secret_basic\" | \"client_secret_post\" | \"client_secret_jwt\";\n\n    /**\n     * The signature algorithm to use for client_secret_jwt authentication (default: \"HS256\")\n     * Supported algorithms: HS256, HS384, HS512\n     */\n    token_endpoint_auth_signing_alg?: \"HS256\" | \"HS384\" | \"HS512\";\n\n    /** optional protocol param */\n    prompt?: string;\n    /** optional protocol param */\n    display?: string;\n    /** optional protocol param */\n    max_age?: number;\n    /** optional protocol param */\n    ui_locales?: string;\n    /** optional protocol param */\n    acr_values?: string;\n    /** optional protocol param */\n    resource?: string | string[];\n\n    /**\n     * Optional protocol param\n     * The response mode used by the authority server is defined by the response_type unless explicitly specified:\n     * - Response mode for the OAuth 2.0 response type \"code\" is the \"query\" encoding\n     * - Response mode for the OAuth 2.0 response type \"token\" is the \"fragment\" encoding\n     *\n     * @see https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\n     */\n    response_mode?: \"query\" | \"fragment\";\n\n    /**\n     * Should optional OIDC protocol claims be removed from profile or specify the ones to be removed (default: true)\n     * When true, the following claims are removed by default: [\"nbf\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\"]\n     * When specifying claims, the following claims are not allowed: [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"]\n    */\n    filterProtocolClaims?: boolean | string[];\n    /** Flag to control if additional identity data is loaded from the user info endpoint in order to populate the user's profile (default: false) */\n    loadUserInfo?: boolean;\n    /** Number (in seconds) indicating the age of state entries in storage for authorize requests that are considered abandoned and thus can be cleaned up (default: 900) */\n    staleStateAgeInSeconds?: number;\n\n    /**\n     * Indicates how objects returned from the user info endpoint as claims (e.g. `address`) are merged into the claims from the\n     * id token as a single object.  (default: `{ array: \"replace\" }`)\n     * - array: \"replace\": natives (string, int, float) and arrays are replaced, objects are merged as distinct objects\n     * - array: \"merge\": natives (string, int, float) are replaced, arrays and objects are merged as distinct objects\n     */\n    mergeClaimsStrategy?: { array: \"replace\" | \"merge\" };\n\n    /**\n     * Storage object used to persist interaction state (default: window.localStorage, InMemoryWebStorage iff no window).\n     * E.g. `stateStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    stateStore?: StateStore;\n\n    /**\n     * An object containing additional query string parameters to be including in the authorization request.\n     * E.g, when using Azure AD to obtain an access token an additional resource parameter is required. extraQueryParams: `{resource:\"some_identifier\"}`\n     */\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    extraTokenParams?: Record<string, unknown>;\n\n    /**\n     * An object containing additional header to be including in request.\n     */\n    extraHeaders?: Record<string, ExtraHeader>;\n\n    /**\n     * DPoP enabled or disabled\n     */\n    dpop?: DPoPSettings | undefined;\n\n    /**\n     * Will check the content type header of the response of the revocation endpoint to match these passed values (default: [])\n     */\n    revokeTokenAdditionalContentTypes?: string[];\n    /**\n     * Will disable PKCE validation, changing to true will not append to sign in request code_challenge and code_challenge_method. (default: false)\n     */\n    disablePKCE?: boolean;\n    /**\n     * Sets the credentials for fetch requests. (default: \"same-origin\")\n     * Use this if you need to send cookies to the OIDC/OAuth2 provider or if you are using a proxy that requires cookies\n     */\n    fetchRequestCredentials?: RequestCredentials;\n\n    /**\n     * Only scopes in this list will be passed in the token refresh request.\n     */\n    refreshTokenAllowedScope?: string | undefined;\n\n    /**\n     * Defines request timeouts globally across all requests made to the authorisation server\n     */\n    requestTimeoutInSeconds?: number | undefined;\n\n    /**\n     * https://datatracker.ietf.org/doc/html/rfc6749#section-3.3 describes behavior when omitting scopes from sign in requests\n     * If the IDP supports default scopes, this setting will ignore the scopes property passed to the config. (Default: false)\n     */\n    omitScopeWhenRequesting?: boolean;\n}\n\n/**\n * The settings with defaults applied of the {@link OidcClient}.\n *\n * @public\n * @see {@link OidcClientSettings}\n */\nexport class OidcClientSettingsStore {\n    // metadata\n    public readonly authority: string;\n    public readonly metadataUrl: string;\n    public readonly metadata: Partial<OidcMetadata> | undefined;\n    public readonly metadataSeed: Partial<OidcMetadata> | undefined;\n    public readonly signingKeys: SigningKey[] | undefined;\n\n    // client config\n    public readonly client_id: string;\n    public readonly client_secret: string | undefined;\n    public readonly response_type: string;\n    public readonly scope: string;\n    public readonly redirect_uri: string;\n    public readonly post_logout_redirect_uri: string | undefined;\n    public readonly client_authentication: \"client_secret_basic\" | \"client_secret_post\" | \"client_secret_jwt\";\n    public readonly token_endpoint_auth_signing_alg: \"HS256\" | \"HS384\" | \"HS512\";\n\n    // optional protocol params\n    public readonly prompt: string | undefined;\n    public readonly display: string | undefined;\n    public readonly max_age: number | undefined;\n    public readonly ui_locales: string | undefined;\n    public readonly acr_values: string | undefined;\n    public readonly resource: string | string[] | undefined;\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    // behavior flags\n    public readonly filterProtocolClaims: boolean | string[];\n    public readonly loadUserInfo: boolean;\n    public readonly staleStateAgeInSeconds: number;\n    public readonly mergeClaimsStrategy: { array: \"replace\" | \"merge\" };\n    public readonly omitScopeWhenRequesting: boolean;\n\n    public readonly stateStore: StateStore;\n\n    // extra\n    public readonly extraQueryParams: Record<string, string | number | boolean>;\n    public readonly extraTokenParams: Record<string, unknown>;\n    public readonly dpop: DPoPSettings | undefined;\n    public readonly extraHeaders: Record<string, ExtraHeader>;\n\n    public readonly revokeTokenAdditionalContentTypes?: string[];\n    public readonly fetchRequestCredentials: RequestCredentials;\n    public readonly refreshTokenAllowedScope: string | undefined;\n    public readonly disablePKCE: boolean;\n    public readonly requestTimeoutInSeconds: number | undefined;\n\n    public constructor({\n        // metadata related\n        authority, metadataUrl, metadata, signingKeys, metadataSeed,\n        // client related\n        client_id, client_secret, response_type = DefaultResponseType, scope = DefaultScope,\n        redirect_uri, post_logout_redirect_uri,\n        client_authentication = DefaultClientAuthentication,\n        token_endpoint_auth_signing_alg = \"HS256\",\n        // optional protocol\n        prompt, display, max_age, ui_locales, acr_values, resource, response_mode,\n        // behavior flags\n        filterProtocolClaims = true,\n        loadUserInfo = false,\n        requestTimeoutInSeconds,\n        staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n        mergeClaimsStrategy = { array: \"replace\" },\n        disablePKCE = false,\n        // other behavior\n        stateStore,\n        revokeTokenAdditionalContentTypes,\n        fetchRequestCredentials,\n        refreshTokenAllowedScope,\n        // extra\n        extraQueryParams = {},\n        extraTokenParams = {},\n        extraHeaders = {},\n        dpop,\n        omitScopeWhenRequesting = false,\n    }: OidcClientSettings) {\n\n        this.authority = authority;\n\n        if (metadataUrl) {\n            this.metadataUrl = metadataUrl;\n        } else {\n            this.metadataUrl = authority;\n            if (authority) {\n                if (!this.metadataUrl.endsWith(\"/\")) {\n                    this.metadataUrl += \"/\";\n                }\n                this.metadataUrl += \".well-known/openid-configuration\";\n            }\n        }\n\n        this.metadata = metadata;\n        this.metadataSeed = metadataSeed;\n        this.signingKeys = signingKeys;\n\n        this.client_id = client_id;\n        this.client_secret = client_secret;\n        this.response_type = response_type;\n        this.scope = scope;\n        this.redirect_uri = redirect_uri;\n        this.post_logout_redirect_uri = post_logout_redirect_uri;\n        this.client_authentication = client_authentication;\n        this.token_endpoint_auth_signing_alg = token_endpoint_auth_signing_alg;\n\n        this.prompt = prompt;\n        this.display = display;\n        this.max_age = max_age;\n        this.ui_locales = ui_locales;\n        this.acr_values = acr_values;\n        this.resource = resource;\n        this.response_mode = response_mode;\n\n        this.filterProtocolClaims = filterProtocolClaims ?? true;\n        this.loadUserInfo = !!loadUserInfo;\n        this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n        this.mergeClaimsStrategy = mergeClaimsStrategy;\n        this.omitScopeWhenRequesting = omitScopeWhenRequesting;\n        this.disablePKCE = !!disablePKCE;\n        this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n\n        this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : \"same-origin\";\n        this.requestTimeoutInSeconds = requestTimeoutInSeconds;\n\n        if (stateStore) {\n            this.stateStore = stateStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n            this.stateStore = new WebStorageStateStore({ store });\n        }\n\n        this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n\n        this.extraQueryParams = extraQueryParams;\n        this.extraTokenParams = extraTokenParams;\n        this.extraHeaders = extraHeaders;\n\n        this.dpop = dpop;\n        if (this.dpop && !this.dpop?.store) {\n            throw new Error(\"A DPoPStore is required when dpop is enabled\");\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport class UserInfoService {\n    protected readonly _logger = new Logger(\"UserInfoService\");\n    private readonly _jsonService: JsonService;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            undefined,\n            this._getClaimsFromJwt,\n            this._settings.extraHeaders,\n        );\n    }\n\n    public async getClaims(token: string): Promise<JwtClaims> {\n        const logger = this._logger.create(\"getClaims\");\n        if (!token) {\n            this._logger.throw(new Error(\"No token passed\"));\n        }\n\n        const url = await this._metadataService.getUserInfoEndpoint();\n        logger.debug(\"got userinfo url\", url);\n\n        const claims = await this._jsonService.getJson(url, {\n            token,\n            credentials: this._settings.fetchRequestCredentials,\n            timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n        });\n        logger.debug(\"got claims\", claims);\n\n        return claims;\n    }\n\n    protected _getClaimsFromJwt = async (responseText: string): Promise<JwtClaims> => {\n        const logger = this._logger.create(\"_getClaimsFromJwt\");\n        try {\n            const payload = JwtUtils.decode(responseText);\n            logger.debug(\"JWT decoding successful\");\n\n            return payload;\n        } catch (err) {\n            logger.error(\"Error parsing JWT response\");\n            throw err;\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { ExtraHeader, OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport interface ExchangeCodeArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    code: string;\n    code_verifier?: string;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeCredentialsArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    scope?: string;\n\n    username: string;\n    password: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeRefreshTokenArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    refresh_token: string;\n    scope?: string;\n    resource?: string | string[];\n\n    timeoutInSeconds?: number;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport interface RevokeArgs {\n    token: string;\n    token_type_hint?: \"access_token\" | \"refresh_token\";\n}\n\n/**\n * @internal\n */\nexport class TokenClient {\n    private readonly _logger = new Logger(\"TokenClient\");\n    private readonly _jsonService;\n\n    public constructor(\n        private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            this._settings.revokeTokenAdditionalContentTypes,\n            null,\n            this._settings.extraHeaders,\n        );\n    }\n\n    /**\n     * Exchange code.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n     */\n    public async exchangeCode({\n        grant_type = \"authorization_code\",\n        redirect_uri = this._settings.redirect_uri,\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        extraHeaders,\n        ...args\n    }: ExchangeCodeArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCode\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!redirect_uri) {\n            logger.throw(new Error(\"A redirect_uri is required\"));\n        }\n        if (!args.code) {\n            logger.throw(new Error(\"A code is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, redirect_uri });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        // Validate client_secret if required before making any external calls\n        if ((this._settings.client_authentication === \"client_secret_basic\" ||\n             this._settings.client_authentication === \"client_secret_jwt\") &&\n            (client_secret === undefined || client_secret === null)) {\n            logger.throw(new Error(\"A client_secret is required\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        let basicAuth: string | undefined;\n        const url = await this._metadataService.getTokenEndpoint(false);\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret!);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n            case \"client_secret_jwt\": {\n                const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret!, url, this._settings.token_endpoint_auth_signing_alg);\n                params.append(\"client_id\", client_id);\n                params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                params.append(\"client_assertion\", clientAssertion);\n                break;\n            }\n        }\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, {\n            body: params,\n            basicAuth,\n            timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n            initCredentials: this._settings.fetchRequestCredentials,\n            extraHeaders,\n        });\n\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange credentials.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n     */\n    public async exchangeCredentials({\n        grant_type = \"password\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        scope = this._settings.scope,\n        ...args\n    }: ExchangeCredentialsArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCredentials\");\n\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        if (!this._settings.omitScopeWhenRequesting) {\n            params.set(\"scope\", scope);\n        }\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        // Validate client_secret if required before making any external calls\n        if ((this._settings.client_authentication === \"client_secret_basic\" ||\n             this._settings.client_authentication === \"client_secret_jwt\") &&\n            (client_secret === undefined || client_secret === null)) {\n            logger.throw(new Error(\"A client_secret is required\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        let basicAuth: string | undefined;\n        const url = await this._metadataService.getTokenEndpoint(false);\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret!);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n            case \"client_secret_jwt\": {\n                const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret!, url, this._settings.token_endpoint_auth_signing_alg);\n                params.append(\"client_id\", client_id);\n                params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                params.append(\"client_assertion\", clientAssertion);\n                break;\n            }\n        }\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds: this._settings.requestTimeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange a refresh token.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n     */\n    public async exchangeRefreshToken({\n        grant_type = \"refresh_token\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        timeoutInSeconds,\n        extraHeaders,\n        ...args\n    }: ExchangeRefreshTokenArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeRefreshToken\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!args.refresh_token) {\n            logger.throw(new Error(\"A refresh_token is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        for (const [key, value] of Object.entries(args)) {\n            if (Array.isArray(value)) {\n                value.forEach(param => params.append(key, param));\n            }\n            else if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        // Validate client_secret if required before making any external calls\n        if ((this._settings.client_authentication === \"client_secret_basic\" ||\n             this._settings.client_authentication === \"client_secret_jwt\") &&\n            (client_secret === undefined || client_secret === null)) {\n            logger.throw(new Error(\"A client_secret is required\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        let basicAuth: string | undefined;\n        const url = await this._metadataService.getTokenEndpoint(false);\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret!);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n            case \"client_secret_jwt\": {\n                const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret!, url, this._settings.token_endpoint_auth_signing_alg);\n                params.append(\"client_id\", client_id);\n                params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                params.append(\"client_assertion\", clientAssertion);\n                break;\n            }\n        }\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials, extraHeaders });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Revoke an access or refresh token.\n     *\n     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n     */\n    public async revoke(args: RevokeArgs): Promise<void> {\n        const logger = this._logger.create(\"revoke\");\n        if (!args.token) {\n            logger.throw(new Error(\"A token is required\"));\n        }\n\n        const url = await this._metadataService.getRevocationEndpoint(false);\n\n        logger.debug(`got revocation endpoint, revoking ${args.token_type_hint ?? \"default token type\"}`);\n\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        params.set(\"client_id\", this._settings.client_id);\n        if (this._settings.client_secret) {\n            params.set(\"client_secret\", this._settings.client_secret);\n        }\n\n        await this._jsonService.postForm(url, { body: params, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n        logger.debug(\"got response\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { UserInfoService } from \"./UserInfoService\";\nimport { TokenClient } from \"./TokenClient\";\nimport type { ExtraHeader, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { SigninState } from \"./SigninState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { State } from \"./State\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { UserProfile } from \"./User\";\nimport type { RefreshState } from \"./RefreshState\";\nimport type { IdTokenClaims } from \"./Claims\";\nimport type { ClaimsService } from \"./ClaimsService\";\n\n/**\n * @internal\n */\nexport class ResponseValidator {\n    protected readonly _logger = new Logger(\"ResponseValidator\");\n    protected readonly _userInfoService: UserInfoService;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n        protected readonly _metadataService: MetadataService,\n        protected readonly _claimsService: ClaimsService,\n    ) {\n        this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n        this._tokenClient = new TokenClient(this._settings, this._metadataService);\n    }\n\n    public async validateSigninResponse(response: SigninResponse, state: SigninState, extraHeaders?: Record<string, ExtraHeader>): Promise<void> {\n        const logger = this._logger.create(\"validateSigninResponse\");\n\n        this._processSigninState(response, state);\n        logger.debug(\"state processed\");\n\n        await this._processCode(response, state, extraHeaders);\n        logger.debug(\"code processed\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, state?.skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateCredentialsResponse(response: SigninResponse, skipUserInfo: boolean): Promise<void> {\n        const logger = this._logger.create(\"validateCredentialsResponse\");\n        const shouldValidateSubClaim = response.isOpenId && !!response.id_token;\n\n        if (shouldValidateSubClaim) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, skipUserInfo, shouldValidateSubClaim);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateRefreshResponse(response: SigninResponse, state: RefreshState): Promise<void> {\n        const logger = this._logger.create(\"validateRefreshResponse\");\n\n        response.userState = state.data;\n        // if there's no session_state on the response, copy over session_state from original request\n        response.session_state ??= state.session_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        // OpenID Connect Core 1.0 says that id_token is optional in refresh response:\n        // https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokenResponse\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response, state.id_token);\n            logger.debug(\"ID Token validated\");\n        }\n\n        if (!response.id_token) {\n            // if there's no id_token on the response, copy over id_token from original request\n            response.id_token = state.id_token;\n            // and decoded part too\n            response.profile = state.profile;\n        }\n\n        const hasIdToken = response.isOpenId && !!response.id_token;\n        await this._processClaims(response, false, hasIdToken);\n        logger.debug(\"claims processed\");\n    }\n\n    public validateSignoutResponse(response: SignoutResponse, state: State): void {\n        const logger = this._logger.create(\"validateSignoutResponse\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n    }\n\n    protected _processSigninState(response: SigninResponse, state: SigninState): void {\n        const logger = this._logger.create(\"_processSigninState\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        if (!state.client_id) {\n            logger.throw(new Error(\"No client_id on state\"));\n        }\n\n        if (!state.authority) {\n            logger.throw(new Error(\"No authority on state\"));\n        }\n\n        // ensure we're using the correct authority\n        if (this._settings.authority !== state.authority) {\n            logger.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n        }\n        if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n            logger.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n        response.url_state = state.url_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n\n        if (state.code_verifier && !response.code) {\n            logger.throw(new Error(\"Expected code in response\"));\n        }\n\n    }\n\n    protected async _processClaims(response: SigninResponse, skipUserInfo = false, validateSub = true): Promise<void> {\n        const logger = this._logger.create(\"_processClaims\");\n        response.profile = this._claimsService.filterProtocolClaims(response.profile);\n\n        if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n            logger.debug(\"not loading user info\");\n            return;\n        }\n\n        logger.debug(\"loading user info\");\n        const claims = await this._userInfoService.getClaims(response.access_token);\n        logger.debug(\"user info claims received from user info endpoint\");\n\n        if (validateSub && claims.sub !== response.profile.sub) {\n            logger.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n        }\n\n        response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims as IdTokenClaims));\n        logger.debug(\"user info claims received, updated profile:\", response.profile);\n    }\n\n    protected async _processCode(response: SigninResponse, state: SigninState, extraHeaders?: Record<string, ExtraHeader>): Promise<void> {\n        const logger = this._logger.create(\"_processCode\");\n        if (response.code) {\n            logger.debug(\"Validating code\");\n            const tokenResponse = await this._tokenClient.exchangeCode({\n                client_id: state.client_id,\n                client_secret: state.client_secret,\n                code: response.code,\n                redirect_uri: state.redirect_uri,\n                code_verifier: state.code_verifier,\n                extraHeaders: extraHeaders,\n                ...state.extraTokenParams,\n            });\n            Object.assign(response, tokenResponse);\n        } else {\n            logger.debug(\"No code to process\");\n        }\n    }\n\n    protected _validateIdTokenAttributes(response: SigninResponse, existingToken?: string): void {\n        const logger = this._logger.create(\"_validateIdTokenAttributes\");\n\n        logger.debug(\"decoding ID Token JWT\");\n        const incoming = JwtUtils.decode(response.id_token ?? \"\");\n\n        if (!incoming.sub) {\n            logger.throw(new Error(\"ID Token is missing a subject claim\"));\n        }\n\n        if (existingToken) {\n            const existing = JwtUtils.decode(existingToken);\n            if (incoming.sub !== existing.sub) {\n                logger.throw(new Error(\"sub in id_token does not match current sub\"));\n            }\n            if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n                logger.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n            }\n            if (incoming.azp && incoming.azp !== existing.azp) {\n                logger.throw(new Error(\"azp in id_token does not match original azp\"));\n            }\n            if (!incoming.azp && existing.azp) {\n                logger.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n            }\n        }\n\n        response.profile = incoming as UserProfile;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils, Timer } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\n\n/**\n * @public\n */\nexport class State {\n    public readonly id: string;\n    public readonly created: number;\n    public readonly request_type: string | undefined;\n    public readonly url_state: string | undefined;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n        url_state?: string;\n    }) {\n        this.id = args.id || CryptoUtils.generateUUIDv4();\n        this.data = args.data;\n\n        if (args.created && args.created > 0) {\n            this.created = args.created;\n        }\n        else {\n            this.created = Timer.getEpochTime();\n        }\n        this.request_type = args.request_type;\n        this.url_state = args.url_state;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"State\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n        });\n    }\n\n    public static fromStorageString(storageString: string): Promise<State> {\n        Logger.createStatic(\"State\", \"fromStorageString\");\n        return Promise.resolve(new State(JSON.parse(storageString)));\n    }\n\n    public static async clearStaleState(storage: StateStore, age: number): Promise<void> {\n        const logger = Logger.createStatic(\"State\", \"clearStaleState\");\n        const cutoff = Timer.getEpochTime() - age;\n\n        const keys = await storage.getAllKeys();\n        logger.debug(\"got keys\", keys);\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const item = await storage.get(key);\n            let remove = false;\n\n            if (item) {\n                try {\n                    const state = await State.fromStorageString(item);\n\n                    logger.debug(\"got item from key:\", key, state.created);\n                    if (state.created <= cutoff) {\n                        remove = true;\n                    }\n                }\n                catch (err) {\n                    logger.error(\"Error parsing state for key:\", key, err);\n                    remove = true;\n                }\n            }\n            else {\n                logger.debug(\"no item in storage for key:\", key);\n                remove = true;\n            }\n\n            if (remove) {\n                logger.debug(\"removed item for key:\", key);\n                void storage.remove(key);\n            }\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils } from \"./utils\";\nimport { State } from \"./State\";\n\n/** @public */\nexport interface SigninStateArgs {\n    id?: string;\n    data?: unknown;\n    created?: number;\n    request_type?: string;\n\n    code_verifier?: string;\n    code_challenge?: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    scope: string;\n    client_secret?: string;\n    extraTokenParams?: Record<string, unknown>;\n    response_mode?: \"query\" | \"fragment\";\n    skipUserInfo?: boolean;\n    url_state?: string;\n}\n\n/** @public */\nexport type SigninStateCreateArgs = Omit<SigninStateArgs, \"code_verifier\"> & {\n    code_verifier?: string | boolean;\n};\n\n/**\n * @public\n */\nexport class SigninState extends State {\n    // isCode\n    /** The same code_verifier that was used to obtain the authorization_code via PKCE. */\n    public readonly code_verifier: string | undefined;\n    /** Used to secure authorization code grants via Proof Key for Code Exchange (PKCE). */\n    public readonly code_challenge: string | undefined;\n\n    // to ensure state still matches settings\n    /** @see {@link OidcClientSettings.authority} */\n    public readonly authority: string;\n    /** @see {@link OidcClientSettings.client_id} */\n    public readonly client_id: string;\n    /** @see {@link OidcClientSettings.redirect_uri} */\n    public readonly redirect_uri: string;\n    /** @see {@link OidcClientSettings.scope} */\n    public readonly scope: string;\n    /** @see {@link OidcClientSettings.client_secret} */\n    public readonly client_secret: string | undefined;\n    /** @see {@link OidcClientSettings.extraTokenParams} */\n    public readonly extraTokenParams: Record<string, unknown> | undefined;\n    /** @see {@link OidcClientSettings.response_mode} */\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    public readonly skipUserInfo: boolean | undefined;\n\n    private constructor(args: SigninStateArgs) {\n        super(args);\n\n        this.code_verifier = args.code_verifier;\n        this.code_challenge = args.code_challenge;\n        this.authority = args.authority;\n        this.client_id = args.client_id;\n        this.redirect_uri = args.redirect_uri;\n        this.scope = args.scope;\n        this.client_secret = args.client_secret;\n        this.extraTokenParams = args.extraTokenParams;\n\n        this.response_mode = args.response_mode;\n        this.skipUserInfo = args.skipUserInfo;\n    }\n\n    public static async create(args: SigninStateCreateArgs): Promise<SigninState> {\n        const code_verifier = args.code_verifier === true ? CryptoUtils.generateCodeVerifier() : (args.code_verifier || undefined);\n        const code_challenge = code_verifier ? (await CryptoUtils.generateCodeChallenge(code_verifier)) : undefined;\n\n        return new SigninState({\n            ...args,\n            code_verifier,\n            code_challenge,\n        });\n    }\n\n    public toStorageString(): string {\n        new Logger(\"SigninState\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n\n            code_verifier: this.code_verifier,\n            authority: this.authority,\n            client_id: this.client_id,\n            redirect_uri: this.redirect_uri,\n            scope: this.scope,\n            client_secret: this.client_secret,\n            extraTokenParams : this.extraTokenParams,\n            response_mode: this.response_mode,\n            skipUserInfo: this.skipUserInfo,\n        });\n    }\n\n    public static fromStorageString(storageString: string): Promise<SigninState> {\n        Logger.createStatic(\"SigninState\", \"fromStorageString\");\n        const data = JSON.parse(storageString);\n        return SigninState.create(data);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, URL_STATE_DELIMITER } from \"./utils\";\nimport { SigninState } from \"./SigninState\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest\n */\nexport interface SigninRequestCreateArgs {\n    // mandatory\n    url: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    response_type: string;\n    scope: string;\n\n    // optional\n    response_mode?: \"query\" | \"fragment\";\n    nonce?: string;\n    display?: string;\n    dpopJkt?: string;\n    prompt?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n\n    // other\n    resource?: string | string[];\n    request?: string;\n    request_uri?: string;\n    request_type?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    extraTokenParams?: Record<string, unknown>;\n    client_secret?: string;\n    skipUserInfo?: boolean;\n    disablePKCE?: boolean;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n    url_state?: string;\n    omitScopeWhenRequesting?: boolean;\n}\n\n/**\n * @public\n */\nexport class SigninRequest {\n    private static readonly _logger = new Logger(\"SigninRequest\");\n\n    public readonly url: string;\n    public readonly state: SigninState;\n\n    private constructor(args: {\n        url: string;\n        state: SigninState;\n    }) {\n        this.url = args.url;\n        this.state = args.state;\n    }\n\n    public static async create({\n        // mandatory\n        url, authority, client_id, redirect_uri, response_type, scope,\n        // optional\n        state_data, response_mode, request_type, client_secret, nonce, url_state,\n        resource,\n        skipUserInfo,\n        extraQueryParams,\n        extraTokenParams,\n        disablePKCE,\n        dpopJkt,\n        omitScopeWhenRequesting,\n        ...optionalParams\n    }: SigninRequestCreateArgs): Promise<SigninRequest> {\n        if (!url) {\n            this._logger.error(\"create: No url passed\");\n            throw new Error(\"url\");\n        }\n        if (!client_id) {\n            this._logger.error(\"create: No client_id passed\");\n            throw new Error(\"client_id\");\n        }\n        if (!redirect_uri) {\n            this._logger.error(\"create: No redirect_uri passed\");\n            throw new Error(\"redirect_uri\");\n        }\n        if (!response_type) {\n            this._logger.error(\"create: No response_type passed\");\n            throw new Error(\"response_type\");\n        }\n        if (!scope) {\n            this._logger.error(\"create: No scope passed\");\n            throw new Error(\"scope\");\n        }\n        if (!authority) {\n            this._logger.error(\"create: No authority passed\");\n            throw new Error(\"authority\");\n        }\n\n        const state = await SigninState.create({\n            data: state_data,\n            request_type,\n            url_state,\n            code_verifier: !disablePKCE,\n            client_id, authority, redirect_uri,\n            response_mode,\n            client_secret, scope, extraTokenParams,\n            skipUserInfo,\n        });\n\n        const parsedUrl = new URL(url);\n        parsedUrl.searchParams.append(\"client_id\", client_id);\n        parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n        parsedUrl.searchParams.append(\"response_type\", response_type);\n        if (!omitScopeWhenRequesting) {\n            parsedUrl.searchParams.append(\"scope\", scope);\n        }\n        if (nonce) {\n            parsedUrl.searchParams.append(\"nonce\", nonce);\n        }\n\n        if (dpopJkt) {\n            parsedUrl.searchParams.append(\"dpop_jkt\", dpopJkt);\n        }\n\n        let stateParam = state.id;\n        if (url_state) {\n            stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n        }\n        parsedUrl.searchParams.append(\"state\", stateParam);\n        if (state.code_challenge) {\n            parsedUrl.searchParams.append(\"code_challenge\", state.code_challenge);\n            parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n        }\n\n        if (resource) {\n            // https://datatracker.ietf.org/doc/html/rfc8707\n            const resources = Array.isArray(resource) ? resource : [resource];\n            resources\n                .forEach(r => parsedUrl.searchParams.append(\"resource\", r));\n        }\n\n        for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        return new SigninRequest({\n            url: parsedUrl.href,\n            state,\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Timer, URL_STATE_DELIMITER } from \"./utils\";\nimport type { UserProfile } from \"./User\";\n\nconst OidcScope = \"openid\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthResponse\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SigninResponse {\n    // props present in the initial callback response regardless of success\n    public readonly state: string | null;\n    /** @see {@link User.session_state} */\n    public session_state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public readonly error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public readonly error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public readonly error_uri: string | null;\n\n    // success props\n    public readonly code: string | null;\n\n    // props set after validation\n    /** @see {@link User.id_token} */\n    public id_token?: string;\n    /** @see {@link User.access_token} */\n    public access_token = \"\";\n    /** @see {@link User.token_type} */\n    public token_type = \"\";\n    /** @see {@link User.refresh_token} */\n    public refresh_token?: string;\n    /** @see {@link User.scope} */\n    public scope?: string;\n    /** @see {@link User.expires_at} */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n    public url_state?: string;\n\n    /** @see {@link User.profile} */\n    public profile: UserProfile = {} as UserProfile;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        this.session_state = params.get(\"session_state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) {\n                this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n            }\n        }\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n\n        this.code = params.get(\"code\");\n    }\n\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n    public set expires_in(value: number | undefined) {\n        // spec expects a number, but normalize here just in case\n        if (typeof value === \"string\") value = Number(value);\n        if (value !== undefined && value >= 0) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    public get isOpenId(): boolean {\n        return this.scope?.split(\" \").includes(OidcScope) || !!this.id_token;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, URL_STATE_DELIMITER } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout\n */\nexport interface SignoutRequestArgs {\n    // mandatory\n    url: string;\n\n    // optional\n    id_token_hint?: string;\n    client_id?: string;\n    post_logout_redirect_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    request_type?: string;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n    url_state?: string;\n}\n\n/**\n * @public\n */\nexport class SignoutRequest {\n    private readonly _logger = new Logger(\"SignoutRequest\");\n\n    public readonly url: string;\n    public readonly state?: State;\n\n    public constructor({\n        url,\n        state_data, id_token_hint, post_logout_redirect_uri, extraQueryParams, request_type, client_id, url_state,\n    }: SignoutRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n\n        const parsedUrl = new URL(url);\n        if (id_token_hint) {\n            parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n        }\n        if (client_id) {\n            parsedUrl.searchParams.append(\"client_id\", client_id);\n        }\n\n        if (post_logout_redirect_uri) {\n            parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n\n            // Add state if either data needs to be stored, or url_state set for an intermediate proxy\n            if (state_data || url_state) {\n                this.state = new State({ data: state_data, request_type, url_state });\n\n                let stateParam = this.state.id;\n                if (url_state) {\n                    stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n                }\n                parsedUrl.searchParams.append(\"state\", stateParam);\n            }\n        }\n\n        for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { URL_STATE_DELIMITER } from \"./utils\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SignoutResponse {\n    public readonly state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n    public url_state?: string;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) {\n                this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n            }\n        }\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { UserProfile } from \"./User\";\nimport { Logger } from \"./utils\";\n\n/**\n * Protocol claims that could be removed by default from profile.\n * Derived from the following sets of claims:\n * - {@link https://datatracker.ietf.org/doc/html/rfc7519.html#section-4.1}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#IDToken}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken}\n *\n * @internal\n */\nconst DefaultProtocolClaims = [\n    \"nbf\",\n    \"jti\",\n    \"auth_time\",\n    \"nonce\",\n    \"acr\",\n    \"amr\",\n    \"azp\",\n    \"at_hash\", // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n] as const;\n\n/**\n * Protocol claims that should never be removed from profile.\n * \"sub\" is needed internally and others should remain required as per the OIDC specs.\n *\n * @internal\n */\nconst InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\n\n/**\n * @internal\n */\nexport class ClaimsService {\n    protected readonly _logger = new Logger(\"ClaimsService\");\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n    ) {}\n\n    public filterProtocolClaims(claims: UserProfile): UserProfile {\n        const result = { ...claims };\n\n        if (this._settings.filterProtocolClaims) {\n            let protocolClaims;\n            if (Array.isArray(this._settings.filterProtocolClaims)) {\n                protocolClaims = this._settings.filterProtocolClaims;\n            } else {\n                protocolClaims = DefaultProtocolClaims;\n            }\n\n            for (const claim of protocolClaims) {\n                if (!InternalRequiredProtocolClaims.includes(claim)) {\n                    delete result[claim];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public mergeClaims(claims1: JwtClaims, claims2: JwtClaims): UserProfile;\n    public mergeClaims(claims1: UserProfile, claims2: JwtClaims): UserProfile {\n        const result = { ...claims1 };\n        for (const [claim, values] of Object.entries(claims2)) {\n            if (result[claim] !== values) {\n                if (Array.isArray(result[claim]) || Array.isArray(values)) {\n                    if (this._settings.mergeClaimsStrategy.array == \"replace\") {\n                        result[claim] = values;\n                    } else {\n                        const mergedValues = Array.isArray(result[claim]) ? result[claim] as unknown[] : [result[claim]];\n                        for (const value of Array.isArray(values) ? values : [values]) {\n                            if (!mergedValues.includes(value)) {\n                                mergedValues.push(value);\n                            }\n                        }\n                        result[claim] = mergedValues;\n                    }\n                } else if (typeof result[claim] === \"object\" && typeof values === \"object\") {\n                    result[claim] = this.mergeClaims(result[claim] as JwtClaims, values as JwtClaims);\n                } else {\n                    result[claim] = values;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n","/**\n * @public\n */\nexport interface DPoPStore {\n    set(key: string, value: DPoPState): Promise<void>;\n    get(key: string): Promise<DPoPState>;\n    remove(key: string): Promise<DPoPState>;\n    getAllKeys(): Promise<string[]>;\n}\n\n/**\n * @public\n */\nexport class DPoPState {\n    public constructor(\n        public readonly keys: CryptoKeyPair,\n        public nonce?: string,\n    ) { }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger, UrlUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type ExtraHeader, type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport { ResponseValidator } from \"./ResponseValidator\";\nimport { MetadataService } from \"./MetadataService\";\nimport type { RefreshState } from \"./RefreshState\";\nimport { SigninRequest, type SigninRequestCreateArgs } from \"./SigninRequest\";\nimport { SigninResponse } from \"./SigninResponse\";\nimport { SignoutRequest, type SignoutRequestArgs } from \"./SignoutRequest\";\nimport { SignoutResponse } from \"./SignoutResponse\";\nimport { SigninState } from \"./SigninState\";\nimport { State } from \"./State\";\nimport { TokenClient } from \"./TokenClient\";\nimport { ClaimsService } from \"./ClaimsService\";\nimport { DPoPState, type DPoPStore } from \"./DPoPStore\";\nimport { ErrorDPoPNonce } from \"./errors/ErrorDPoPNonce\";\n\n/**\n * @public\n */\nexport interface CreateSigninRequestArgs\n    extends Omit<SigninRequestCreateArgs, \"url\" | \"authority\" | \"client_id\" | \"redirect_uri\" | \"response_type\" | \"scope\" | \"state_data\"> {\n    redirect_uri?: string;\n    response_type?: string;\n    scope?: string;\n    dpopJkt?: string;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n}\n\n/**\n * @public\n */\nexport interface UseRefreshTokenArgs {\n    redirect_uri?: string;\n    resource?: string | string[];\n    extraTokenParams?: Record<string, unknown>;\n    timeoutInSeconds?: number;\n\n    state: RefreshState;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @public\n */\nexport type CreateSignoutRequestArgs = Omit<SignoutRequestArgs, \"url\" | \"state_data\"> & {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n};\n\n/**\n * @public\n */\nexport type ProcessResourceOwnerPasswordCredentialsArgs = {\n    username: string;\n    password: string;\n    skipUserInfo?: boolean;\n    extraTokenParams?: Record<string, unknown>;\n};\n\n/**\n * Provides the raw OIDC/OAuth2 protocol support for the authorization endpoint and the end session endpoint in the\n * authorization server. It provides a bare-bones protocol implementation and is used by the UserManager class.\n * Only use this class if you simply want protocol support without the additional management features of the\n * UserManager class.\n *\n * @public\n */\nexport class OidcClient {\n    public readonly settings: OidcClientSettingsStore;\n    protected readonly _logger = new Logger(\"OidcClient\");\n\n    public readonly metadataService: MetadataService;\n    protected readonly _claimsService: ClaimsService;\n    protected readonly _validator: ResponseValidator;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(settings: OidcClientSettings);\n    public constructor(settings: OidcClientSettingsStore, metadataService: MetadataService);\n    public constructor(settings: OidcClientSettings | OidcClientSettingsStore, metadataService?: MetadataService) {\n        this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n\n        this.metadataService = metadataService ?? new MetadataService(this.settings);\n        this._claimsService = new ClaimsService(this.settings);\n        this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n        this._tokenClient = new TokenClient(this.settings, this.metadataService);\n    }\n\n    public async createSigninRequest({\n        state,\n        request,\n        request_uri,\n        request_type,\n        id_token_hint,\n        login_hint,\n        skipUserInfo,\n        nonce,\n        url_state,\n        response_type = this.settings.response_type,\n        scope = this.settings.scope,\n        redirect_uri = this.settings.redirect_uri,\n        prompt = this.settings.prompt,\n        display = this.settings.display,\n        max_age = this.settings.max_age,\n        ui_locales = this.settings.ui_locales,\n        acr_values = this.settings.acr_values,\n        resource = this.settings.resource,\n        response_mode = this.settings.response_mode,\n        extraQueryParams = this.settings.extraQueryParams,\n        extraTokenParams = this.settings.extraTokenParams,\n        dpopJkt,\n        omitScopeWhenRequesting = this.settings.omitScopeWhenRequesting,\n    }: CreateSigninRequestArgs): Promise<SigninRequest> {\n        const logger = this._logger.create(\"createSigninRequest\");\n\n        if (response_type !== \"code\") {\n            throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n        }\n\n        const url = await this.metadataService.getAuthorizationEndpoint();\n        logger.debug(\"Received authorization endpoint\", url);\n\n        const signinRequest = await SigninRequest.create({\n            url,\n            authority: this.settings.authority,\n            client_id: this.settings.client_id,\n            redirect_uri,\n            response_type,\n            scope,\n            state_data: state,\n            url_state,\n            prompt, display, max_age, ui_locales, id_token_hint, login_hint, acr_values, dpopJkt,\n            resource, request, request_uri, extraQueryParams, extraTokenParams, request_type, response_mode,\n            client_secret: this.settings.client_secret,\n            skipUserInfo,\n            nonce,\n            disablePKCE: this.settings.disablePKCE,\n            omitScopeWhenRequesting,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signinState = signinRequest.state;\n        await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n        return signinRequest;\n    }\n\n    public async readSigninResponseState(url: string, removeState = false): Promise<{ state: SigninState; response: SigninResponse }> {\n        const logger = this._logger.create(\"readSigninResponseState\");\n\n        const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.throw(new Error(\"No state in response\"));\n            // need to throw within this function's body for type narrowing to work\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = await SigninState.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSigninResponse(url: string, extraHeaders?: Record<string, ExtraHeader>, removeState = true): Promise<SigninResponse> {\n        const logger = this._logger.create(\"processSigninResponse\");\n\n        const { state, response } = await this.readSigninResponseState(url, removeState);\n        logger.debug(\"received state from storage; validating response\");\n\n        if (this.settings.dpop && this.settings.dpop.store) {\n            const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n            extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n        }\n\n        /**\n         * The DPoP spec describes a method for Authorization Servers to supply a nonce value\n         * in order to limit the lifetime of a given DPoP proof.\n         * See https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid\n         * This involves the AS returning a 400 bad request with a DPoP-Nonce header containing\n         * the nonce value. The client must then retry the request with a recomputed DPoP proof\n         * containing the supplied nonce value.\n         */\n        try {\n            await this._validator.validateSigninResponse(response, state, extraHeaders);\n        }\n        catch (err) {\n            if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n                const dpopProof = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n                extraHeaders![\"DPoP\"] = dpopProof;\n                await this._validator.validateSigninResponse(response, state, extraHeaders);\n            } else {\n                throw err;\n            }\n        }\n\n        return response;\n    }\n\n    async getDpopProof(dpopStore: DPoPStore, nonce?: string): Promise<string> {\n        let keyPair: CryptoKeyPair;\n        let dpopState: DPoPState;\n\n        if (!(await dpopStore.getAllKeys()).includes(this.settings.client_id)) {\n            keyPair = await CryptoUtils.generateDPoPKeys();\n            dpopState = new DPoPState(keyPair, nonce);\n            await dpopStore.set(this.settings.client_id, dpopState);\n        } else {\n            dpopState = await dpopStore.get(this.settings.client_id);\n\n            // if the server supplied nonce has changed since the last request, update the nonce\n            if (dpopState.nonce !== nonce && nonce) {\n                dpopState.nonce = nonce;\n                await dpopStore.set(this.settings.client_id, dpopState);\n            }\n        }\n\n        return await CryptoUtils.generateDPoPProof({\n            url: await this.metadataService.getTokenEndpoint(false),\n            httpMethod: \"POST\",\n            keyPair: dpopState.keys,\n            nonce: dpopState.nonce,\n        });\n    }\n\n    public async processResourceOwnerPasswordCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n        extraTokenParams = {},\n    }: ProcessResourceOwnerPasswordCredentialsArgs): Promise<SigninResponse> {\n        const tokenResponse: Record<string, unknown> = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n        const signinResponse: SigninResponse = new SigninResponse(new URLSearchParams());\n        Object.assign(signinResponse, tokenResponse);\n        await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n        return signinResponse;\n    }\n\n    public async useRefreshToken({\n        state,\n        redirect_uri,\n        resource,\n        timeoutInSeconds,\n        extraHeaders,\n        extraTokenParams,\n    }: UseRefreshTokenArgs): Promise<SigninResponse> {\n        const logger = this._logger.create(\"useRefreshToken\");\n\n        // https://github.com/authts/oidc-client-ts/issues/695\n        // In some cases (e.g. AzureAD), not all granted scopes are allowed on token refresh requests.\n        // Therefore, we filter all granted scopes by a list of allowable scopes.\n        let scope;\n        if (this.settings.refreshTokenAllowedScope === undefined) {\n            scope = state.scope;\n        } else {\n            const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n            const providedScopes = state.scope?.split(\" \") || [];\n\n            scope = providedScopes.filter(s => allowableScopes.includes(s)).join(\" \");\n        }\n\n        if (this.settings.dpop && this.settings.dpop.store) {\n            const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n            extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n        }\n\n        /**\n         * The DPoP spec describes a method for Authorization Servers to supply a nonce value\n         * in order to limit the lifetime of a given DPoP proof.\n         * See https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid\n         * This involves the AS returning a 400 bad request with a DPoP-Nonce header containing\n         * the nonce value. The client must then retry the request with a recomputed DPoP proof\n         * containing the supplied nonce value.\n         */\n        let result;\n        try {\n            result = await this._tokenClient.exchangeRefreshToken({\n                refresh_token: state.refresh_token,\n                // provide the (possible filtered) scope list\n                scope,\n                redirect_uri,\n                resource,\n                timeoutInSeconds,\n                extraHeaders,\n                ...extraTokenParams,\n            });\n        } catch (err) {\n            if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n                extraHeaders![\"DPoP\"] = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n                result = await this._tokenClient.exchangeRefreshToken({\n                    refresh_token: state.refresh_token,\n                    // provide the (possible filtered) scope list\n                    scope,\n                    redirect_uri,\n                    resource,\n                    timeoutInSeconds,\n                    extraHeaders,\n                    ...extraTokenParams,\n                });\n            } else {\n                throw err;\n            }\n        }\n\n        const response = new SigninResponse(new URLSearchParams());\n        Object.assign(response, result);\n        logger.debug(\"validating response\", response);\n        await this._validator.validateRefreshResponse(response, {\n            ...state,\n            // override the scope in the state handed over to the validator\n            // so it can set the granted scope to the requested scope in case none is included in the response\n            scope,\n        });\n        return response;\n    }\n\n    public async createSignoutRequest({\n        state,\n        id_token_hint,\n        client_id,\n        request_type,\n        url_state,\n        post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n        extraQueryParams = this.settings.extraQueryParams,\n    }: CreateSignoutRequestArgs = {}): Promise<SignoutRequest> {\n        const logger = this._logger.create(\"createSignoutRequest\");\n\n        const url = await this.metadataService.getEndSessionEndpoint();\n        if (!url) {\n            logger.throw(new Error(\"No end session endpoint\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"Received end session endpoint\", url);\n\n        // specify the client identifier when post_logout_redirect_uri is used but id_token_hint is not\n        if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n            client_id = this.settings.client_id;\n        }\n\n        const request = new SignoutRequest({\n            url,\n            id_token_hint,\n            client_id,\n            post_logout_redirect_uri,\n            state_data: state,\n            extraQueryParams,\n            request_type,\n            url_state,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signoutState = request.state;\n        if (signoutState) {\n            logger.debug(\"Signout request has state to persist\");\n            await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n        }\n\n        return request;\n    }\n\n    public async readSignoutResponseState(url: string, removeState = false): Promise<{ state: State | undefined; response: SignoutResponse }> {\n        const logger = this._logger.create(\"readSignoutResponseState\");\n\n        const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.debug(\"No state in response\");\n\n            if (response.error) {\n                logger.warn(\"Response was error:\", response.error);\n                throw new ErrorResponse(response);\n            }\n\n            return { state: undefined, response };\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = await State.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSignoutResponse(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"processSignoutResponse\");\n\n        const { state, response } = await this.readSignoutResponseState(url, true);\n        if (state) {\n            logger.debug(\"Received state from storage; validating response\");\n            this._validator.validateSignoutResponse(response, state);\n        } else {\n            logger.debug(\"No state from storage; skipping response validation\");\n        }\n\n        return response;\n    }\n\n    public clearStaleState(): Promise<void> {\n        this._logger.create(\"clearStaleState\");\n        return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n    }\n\n    public async revokeToken(token: string, type?: \"access_token\" | \"refresh_token\"): Promise<void> {\n        this._logger.create(\"revokeToken\");\n        return await this._tokenClient.revoke({\n            token,\n            token_type_hint: type,\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nimport type { UserManager } from \"./UserManager\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport class SessionMonitor {\n    private readonly _logger = new Logger(\"SessionMonitor\");\n\n    private _sub: string | undefined;\n    private _checkSessionIFrame?: CheckSessionIFrame;\n\n    public constructor(private readonly _userManager: UserManager) {\n        if (!_userManager) {\n            this._logger.throw(new Error(\"No user manager passed\"));\n        }\n\n        this._userManager.events.addUserLoaded(this._start);\n        this._userManager.events.addUserUnloaded(this._stop);\n\n        this._init().catch((err: unknown) => {\n            // catch to suppress errors since we're in a ctor\n            this._logger.error(err);\n        });\n    }\n\n    protected async _init(): Promise<void> {\n        this._logger.create(\"_init\");\n        const user = await this._userManager.getUser();\n        // doing this manually here since calling getUser\n        // doesn't trigger load event.\n        if (user) {\n            void this._start(user);\n        }\n        else if (this._userManager.settings.monitorAnonymousSession) {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n                const tmpUser = {\n                    session_state: session.session_state,\n                    profile: session.sub ? {\n                        sub: session.sub,\n                    } : null,\n                };\n                void this._start(tmpUser);\n            }\n        }\n    }\n\n    protected _start = async (\n        user: User | {\n            session_state: string;\n            profile: { sub: string } | null;\n        },\n    ): Promise<void> => {\n        const session_state = user.session_state;\n        if (!session_state) {\n            return;\n        }\n        const logger = this._logger.create(\"_start\");\n\n        if (user.profile) {\n            this._sub = user.profile.sub;\n            logger.debug(\"session_state\", session_state, \", sub\", this._sub);\n        }\n        else {\n            this._sub = undefined;\n            logger.debug(\"session_state\", session_state, \", anonymous user\");\n        }\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.start(session_state);\n            return;\n        }\n\n        try {\n            const url = await this._userManager.metadataService.getCheckSessionIframe();\n            if (url) {\n                logger.debug(\"initializing check session iframe\");\n\n                const client_id = this._userManager.settings.client_id;\n                const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n                const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n\n                const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n                await checkSessionIFrame.load();\n                this._checkSessionIFrame = checkSessionIFrame;\n                checkSessionIFrame.start(session_state);\n            }\n            else {\n                logger.warn(\"no check session iframe found in the metadata\");\n            }\n        }\n        catch (err) {\n            // catch to suppress errors since we're in non-promise callback\n            logger.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n        }\n    };\n\n    protected _stop = (): void => {\n        const logger = this._logger.create(\"_stop\");\n        this._sub = undefined;\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.stop();\n        }\n\n        if (this._userManager.settings.monitorAnonymousSession) {\n            // using a timer to delay re-initialization to avoid race conditions during signout\n            // TODO rewrite to use promise correctly\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            const timerHandle = setInterval(async () => {\n                clearInterval(timerHandle);\n\n                try {\n                    const session = await this._userManager.querySessionStatus();\n                    if (session) {\n                        const tmpUser = {\n                            session_state: session.session_state,\n                            profile: session.sub ? {\n                                sub: session.sub,\n                            } : null,\n                        };\n                        void this._start(tmpUser);\n                    }\n                }\n                catch (err) {\n                    // catch to suppress errors since we're in a callback\n                    logger.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n                }\n            }, 1000);\n        }\n    };\n\n    protected _callback = async (): Promise<void> => {\n        const logger = this._logger.create(\"_callback\");\n        try {\n            const session = await this._userManager.querySessionStatus();\n            let raiseEvent = true;\n\n            if (session && this._checkSessionIFrame) {\n                if (session.sub === this._sub) {\n                    raiseEvent = false;\n                    this._checkSessionIFrame.start(session.session_state);\n\n                    logger.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n                    await this._userManager.events._raiseUserSessionChanged();\n                }\n                else {\n                    logger.debug(\"different subject signed into OP\", session.sub);\n                }\n            }\n            else {\n                logger.debug(\"subject no longer signed into OP\");\n            }\n\n            if (raiseEvent) {\n                if (this._sub) {\n                    await this._userManager.events._raiseUserSignedOut();\n                }\n                else {\n                    await this._userManager.events._raiseUserSignedIn();\n                }\n            } else {\n                logger.debug(\"no change in session detected, no event to raise\");\n            }\n        }\n        catch (err) {\n            if (this._sub) {\n                logger.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n                await this._userManager.events._raiseUserSignedOut();\n            }\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { IdTokenClaims } from \"./Claims\";\n\n/**\n * Holds claims represented by a combination of the `id_token` and the user info endpoint.\n *\n * @public\n */\nexport type UserProfile = IdTokenClaims;\n\n/**\n * @public\n */\nexport class User {\n    /**\n     * A JSON Web Token (JWT). Only provided if `openid` scope was requested.\n     * The application can access the data decoded by using the `profile` property.\n     */\n    public id_token?: string;\n\n    /** The session state value returned from the OIDC provider. */\n    public session_state: string | null;\n\n    /**\n     * The requested access token returned from the OIDC provider. The application can use this token to\n     * authenticate itself to the secured resource.\n     */\n    public access_token: string;\n\n    /**\n     * An OAuth 2.0 refresh token. The app can use this token to acquire additional access tokens after the\n     * current access token expires. Refresh tokens are long-lived and can be used to maintain access to resources\n     * for extended periods of time.\n     */\n    public refresh_token?: string;\n\n    /** Typically \"Bearer\" */\n    public token_type: string;\n\n    /** The scopes that the requested access token is valid for. */\n    public scope?: string;\n\n    /** The claims represented by a combination of the `id_token` and the user info endpoint. */\n    public profile: UserProfile;\n\n    /** The expires at returned from the OIDC provider. */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public readonly state: unknown;\n    public readonly url_state?: string;\n\n    public constructor(args: {\n        id_token?: string;\n        session_state?: string | null;\n        access_token: string;\n        refresh_token?: string;\n        token_type: string;\n        scope?: string;\n        profile: UserProfile;\n        expires_at?: number;\n        userState?: unknown;\n        url_state?: string;\n    }) {\n        this.id_token = args.id_token;\n        this.session_state = args.session_state ?? null;\n        this.access_token = args.access_token;\n        this.refresh_token = args.refresh_token;\n\n        this.token_type = args.token_type;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.expires_at = args.expires_at;\n        this.state = args.userState;\n        this.url_state = args.url_state;\n    }\n\n    /** Computed number of seconds the access token has remaining. */\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n\n    public set expires_in(value: number | undefined) {\n        if (value !== undefined) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    /** Computed value indicating if the access token is expired. */\n    public get expired(): boolean | undefined {\n        const expires_in = this.expires_in;\n        if (expires_in === undefined) {\n            return undefined;\n        }\n        return expires_in <= 0;\n    }\n\n    /** Array representing the parsed values from the `scope`. */\n    public get scopes(): string[] {\n        return this.scope?.split(\" \") ?? [];\n    }\n\n    public toStorageString(): string {\n        new Logger(\"User\").create(\"toStorageString\");\n        return JSON.stringify({\n            id_token: this.id_token,\n            session_state: this.session_state,\n            access_token: this.access_token,\n            refresh_token: this.refresh_token,\n            token_type: this.token_type,\n            scope: this.scope,\n            profile: this.profile,\n            expires_at: this.expires_at,\n        });\n    }\n\n    public static fromStorageString(storageString: string): User {\n        Logger.createStatic(\"User\", \"fromStorageString\");\n        return new User(JSON.parse(storageString));\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event, Logger, UrlUtils } from \"../utils\";\nimport type { IWindow, NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst messageSource = \"oidc-client\";\n\ninterface MessageData {\n    source: string;\n    url: string;\n    keepOpen: boolean;\n}\n\n/**\n * Window implementation which resolves via communication from a child window\n * via the `Window.postMessage()` interface.\n *\n * @internal\n */\nexport abstract class AbstractChildWindow implements IWindow {\n    protected abstract readonly _logger: Logger;\n    protected readonly _abort = new Event<[reason: Error]>(\"Window navigation aborted\");\n    protected readonly _disposeHandlers = new Set<() => void>();\n\n    protected _window: WindowProxy | null = null;\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"navigate\");\n        if (!this._window) {\n            throw new Error(\"Attempted to navigate on a disposed window\");\n        }\n\n        logger.debug(\"setting URL in window\");\n        this._window.location.replace(params.url);\n\n        const { url, keepOpen } = await new Promise<MessageData>((resolve, reject) => {\n            const listener = (e: MessageEvent) => {\n                const data: MessageData | undefined = e.data;\n                const origin = params.scriptOrigin ?? window.location.origin;\n                if (e.origin !== origin || data?.source !== messageSource) {\n                    // silently discard events not intended for us\n                    return;\n                }\n                try {\n                    const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n                    if (!state) {\n                        logger.warn(\"no state found in response url\");\n                    }\n                    if (e.source !== this._window && state !== params.state) {\n                        // MessageEvent source is a relatively modern feature, we can't rely on it\n                        // so we also inspect the payload for a matching state key as an alternative\n                        return;\n                    }\n                }\n                catch {\n                    this._dispose();\n                    reject(new Error(\"Invalid response from window\"));\n                }\n                resolve(data);\n            };\n            window.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n            const channel = new BroadcastChannel(`oidc-client-popup-${params.state}`);\n            channel.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => channel.close());\n            this._disposeHandlers.add(this._abort.addHandler((reason) => {\n                this._dispose();\n                reject(reason);\n            }));\n        });\n        logger.debug(\"got response from window\");\n        this._dispose();\n\n        if (!keepOpen) {\n            this.close();\n        }\n\n        return { url };\n    }\n\n    public abstract close(): void;\n\n    private _dispose(): void {\n        this._logger.create(\"_dispose\");\n\n        for (const dispose of this._disposeHandlers) {\n            dispose();\n        }\n        this._disposeHandlers.clear();\n    }\n\n    protected static _notifyParent(parent: Window | null, url: string, keepOpen = false, targetOrigin = window.location.origin): void {\n        const msgData: MessageData = {\n            source: messageSource,\n            url,\n            keepOpen,\n        };\n        const logger = new Logger(\"_notifyParent\");\n        if (parent) {\n            logger.debug(\"With parent. Using parent.postMessage.\");\n            parent.postMessage(msgData, targetOrigin);\n        } else {\n            logger.debug(\"No parent. Using BroadcastChannel.\");\n            const state = new URL(url).searchParams.get(\"state\");\n            if (!state) {\n                throw new Error(\"No parent and no state in URL. Can't complete notification.\");\n            }\n            const channel = new BroadcastChannel(`oidc-client-popup-${state}`);\n            channel.postMessage(msgData);\n            channel.close();\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { PopupWindowFeatures } from \"./utils/PopupUtils\";\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nimport type { StateStore } from \"./StateStore\";\n\nexport const DefaultPopupWindowFeatures: PopupWindowFeatures = {\n    location: false,\n    toolbar: false,\n    height: 640,\n    closePopupWindowAfterInSeconds: -1,\n};\nexport const DefaultPopupTarget = \"_blank\";\nconst DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nconst DefaultCheckSessionIntervalInSeconds = 2;\nexport const DefaultSilentRequestTimeoutInSeconds = 10;\n\n/**\n * The settings used to configure the {@link UserManager}.\n *\n * @public\n */\nexport interface UserManagerSettings extends OidcClientSettings {\n    /** The URL for the page containing the call to signinPopupCallback to handle the callback from the OIDC/OAuth2 */\n    popup_redirect_uri?: string;\n    popup_post_logout_redirect_uri?: string;\n    /**\n     * The features parameter to window.open for the popup signin window. By default, the popup is\n     * placed centered in front of the window opener.\n     * (default: \\{ location: false, menubar: false, height: 640, closePopupWindowAfterInSeconds: -1 \\})\n     */\n    popupWindowFeatures?: PopupWindowFeatures;\n    /** The target parameter to window.open for the popup signin window (default: \"_blank\") */\n    popupWindowTarget?: string;\n    /** The methods window.location method used to redirect (default: \"assign\") */\n    redirectMethod?: \"replace\" | \"assign\";\n    /** The methods target window being redirected (default: \"self\") */\n    redirectTarget?: \"top\" | \"self\";\n\n    /** The target to pass while calling postMessage inside iframe for callback (default: window.location.origin) */\n    iframeNotifyParentOrigin?: string;\n\n    /** The script origin to check during 'message' callback execution while performing silent auth via iframe (default: window.location.origin) */\n    iframeScriptOrigin?: string;\n\n    /** The URL for the page containing the code handling the silent renew */\n    silent_redirect_uri?: string;\n    /** Number of seconds to wait for the silent renew to return before assuming it has failed or timed out (default: 10) */\n    silentRequestTimeoutInSeconds?: number;\n    /** Flag to indicate if there should be an automatic attempt to renew the access token prior to its expiration. The automatic renew attempt starts 1 minute before the access token expires (default: true) */\n    automaticSilentRenew?: boolean;\n    /** Flag to validate user.profile.sub in silent renew calls (default: true) */\n    validateSubOnSilentRenew?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent renew calls (default: false) */\n    includeIdTokenInSilentRenew?: boolean;\n\n    /** Will raise events for when user has performed a signout at the OP (default: false) */\n    monitorSession?: boolean;\n    monitorAnonymousSession?: boolean;\n    /** Interval in seconds to check the user's session (default: 2) */\n    checkSessionIntervalInSeconds?: number;\n    query_status_response_type?: string;\n    stopCheckSessionOnError?: boolean;\n\n    /**\n     * The `token_type_hint`s to pass to the authority server by default (default: [\"access_token\", \"refresh_token\"])\n     *\n     * Token types will be revoked in the same order as they are given here.\n     */\n    revokeTokenTypes?: (\"access_token\" | \"refresh_token\")[];\n    /** Will invoke the revocation endpoint on signout if there is an access token for the user (default: false) */\n    revokeTokensOnSignout?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent signout calls (default: false) */\n    includeIdTokenInSilentSignout?: boolean;\n\n    /** The number of seconds before an access token is to expire to raise the accessTokenExpiring event (default: 60) */\n    accessTokenExpiringNotificationTimeInSeconds?: number;\n\n    /**\n     * Storage object used to persist User for currently authenticated user (default: window.sessionStorage, InMemoryWebStorage iff no window).\n     *  E.g. `userStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    userStore?: StateStore;\n}\n\n/**\n * The settings with defaults applied of the {@link UserManager}.\n * @see {@link UserManagerSettings}\n *\n * @public\n */\nexport class UserManagerSettingsStore extends OidcClientSettingsStore {\n    public readonly popup_redirect_uri: string;\n    public readonly popup_post_logout_redirect_uri: string | undefined;\n    public readonly popupWindowFeatures: PopupWindowFeatures;\n    public readonly popupWindowTarget: string;\n    public readonly redirectMethod: \"replace\" | \"assign\";\n    public readonly redirectTarget: \"top\" | \"self\";\n\n    public readonly iframeNotifyParentOrigin: string | undefined;\n    public readonly iframeScriptOrigin: string | undefined;\n\n    public readonly silent_redirect_uri: string;\n    public readonly silentRequestTimeoutInSeconds: number;\n    public readonly automaticSilentRenew: boolean;\n    public readonly validateSubOnSilentRenew: boolean;\n    public readonly includeIdTokenInSilentRenew: boolean;\n\n    public readonly monitorSession: boolean;\n    public readonly monitorAnonymousSession: boolean;\n    public readonly checkSessionIntervalInSeconds: number;\n    public readonly query_status_response_type: string;\n    public readonly stopCheckSessionOnError: boolean;\n\n    public readonly revokeTokenTypes: (\"access_token\" | \"refresh_token\")[];\n    public readonly revokeTokensOnSignout: boolean;\n    public readonly includeIdTokenInSilentSignout: boolean;\n\n    public readonly accessTokenExpiringNotificationTimeInSeconds: number;\n\n    public readonly userStore: StateStore;\n\n    public constructor(args: UserManagerSettings) {\n        const {\n            popup_redirect_uri = args.redirect_uri,\n            popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n            popupWindowFeatures = DefaultPopupWindowFeatures,\n            popupWindowTarget = DefaultPopupTarget,\n            redirectMethod = \"assign\",\n            redirectTarget = \"self\",\n\n            iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n            iframeScriptOrigin = args.iframeScriptOrigin,\n\n            requestTimeoutInSeconds,\n            silent_redirect_uri = args.redirect_uri,\n            silentRequestTimeoutInSeconds,\n            automaticSilentRenew = true,\n            validateSubOnSilentRenew = true,\n            includeIdTokenInSilentRenew = false,\n\n            monitorSession = false,\n            monitorAnonymousSession = false,\n            checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n            query_status_response_type = \"code\",\n            stopCheckSessionOnError = true,\n\n            revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n            revokeTokensOnSignout = false,\n            includeIdTokenInSilentSignout = false,\n\n            accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n\n            userStore,\n        } = args;\n\n        super(args);\n\n        this.popup_redirect_uri = popup_redirect_uri;\n        this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n        this.popupWindowFeatures = popupWindowFeatures;\n        this.popupWindowTarget = popupWindowTarget;\n        this.redirectMethod = redirectMethod;\n        this.redirectTarget = redirectTarget;\n\n        this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n        this.iframeScriptOrigin = iframeScriptOrigin;\n\n        this.silent_redirect_uri = silent_redirect_uri;\n        this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds || requestTimeoutInSeconds || DefaultSilentRequestTimeoutInSeconds;\n        this.automaticSilentRenew = automaticSilentRenew;\n        this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n        this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n\n        this.monitorSession = monitorSession;\n        this.monitorAnonymousSession = monitorAnonymousSession;\n        this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n        this.stopCheckSessionOnError = stopCheckSessionOnError;\n        this.query_status_response_type = query_status_response_type;\n\n        this.revokeTokenTypes = revokeTokenTypes;\n        this.revokeTokensOnSignout = revokeTokensOnSignout;\n        this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n\n        this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n\n        if (userStore) {\n            this.userStore = userStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n            this.userStore = new WebStorageStateStore({ store });\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { ErrorTimeout } from \"../errors\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport { DefaultSilentRequestTimeoutInSeconds } from \"../UserManagerSettings\";\n\n/**\n * @public\n */\nexport interface IFrameWindowParams {\n    silentRequestTimeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport class IFrameWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"IFrameWindow\");\n    private _frame: HTMLIFrameElement | null;\n    private _timeoutInSeconds: number;\n\n    public constructor({\n        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n    }: IFrameWindowParams) {\n        super();\n        this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n\n        this._frame = IFrameWindow.createHiddenIframe();\n        this._window = this._frame.contentWindow;\n    }\n\n    private static createHiddenIframe(): HTMLIFrameElement {\n        const iframe = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"fixed\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"0\";\n        iframe.width = \"0\";\n        iframe.height = \"0\";\n\n        window.document.body.appendChild(iframe);\n        return iframe;\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n        const timer = setTimeout(() => void this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1000);\n        this._disposeHandlers.add(() => clearTimeout(timer));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._frame) {\n            if (this._frame.parentNode) {\n                this._frame.addEventListener(\"load\", (ev) => {\n                    const frame = ev.target as HTMLIFrameElement;\n                    frame.parentNode?.removeChild(frame);\n                    void this._abort.raise(new Error(\"IFrame removed from DOM\"));\n                }, true);\n                this._frame.contentWindow?.location.replace(\"about:blank\");\n            }\n            this._frame = null;\n        }\n        this._window = null;\n    }\n\n    public static notifyParent(url: string, targetOrigin?: string): void {\n        return super._notifyParent(window.parent, url, false, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport { IFrameWindow, type IFrameWindowParams } from \"./IFrameWindow\";\nimport type { INavigator } from \"./INavigator\";\n\n/**\n * @internal\n */\nexport class IFrameNavigator implements INavigator {\n    private readonly _logger = new Logger(\"IFrameNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds,\n    }: IFrameWindowParams): Promise<IFrameWindow> {\n        return new IFrameWindow({ silentRequestTimeoutInSeconds });\n    }\n\n    public async callback(url: string): Promise<void> {\n        this._logger.create(\"callback\");\n        IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, PopupUtils, type PopupWindowFeatures } from \"../utils\";\nimport { DefaultPopupWindowFeatures, DefaultPopupTarget } from \"../UserManagerSettings\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst checkForPopupClosedInterval = 500;\nconst second = 1000;\n\n/**\n * @public\n */\nexport interface PopupWindowParams {\n    popupWindowFeatures?: PopupWindowFeatures;\n    popupWindowTarget?: string;\n    /** An AbortSignal to set request's signal. */\n    popupSignal?: AbortSignal | null;\n    /** Abort navigator when the popup is lost */\n    popupAbortOnClose?: boolean;\n}\n\n/**\n * @internal\n */\nexport class PopupWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"PopupWindow\");\n\n    protected _window: WindowProxy | null;\n\n    protected abortOnClose: boolean;\n\n    public constructor({\n        popupWindowTarget = DefaultPopupTarget,\n        popupWindowFeatures = {},\n        popupSignal,\n        popupAbortOnClose,\n    }: PopupWindowParams) {\n        super();\n        const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n        this._window = window.open(undefined, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n        this.abortOnClose = Boolean(popupAbortOnClose);\n\n        if (popupSignal) {\n            popupSignal.addEventListener(\"abort\", () => {\n                void this._abort.raise(new Error(popupSignal.reason ?? \"Popup aborted\"));\n            });\n        }\n\n        if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n            setTimeout(() => {\n                if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n                    void this._abort.raise(new Error(\"Popup blocked by user\"));\n                    return;\n                }\n\n                this.close();\n            }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n        }\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._window?.focus();\n\n        const popupClosedInterval = setInterval(() => {\n            if (!this._window || this._window.closed) {\n                this._logger.debug(\"Popup closed by user or isolated by redirect\");\n                clearPopupClosedInterval();\n                this._disposeHandlers.delete(clearPopupClosedInterval);\n                \n                if (this.abortOnClose) {\n                    void this._abort.raise(new Error(\"Popup closed by user\"));\n                }\n            }\n        }, checkForPopupClosedInterval);\n        const clearPopupClosedInterval = () => clearInterval(popupClosedInterval);\n        this._disposeHandlers.add(clearPopupClosedInterval);\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._window) {\n            if (!this._window.closed) {\n                this._window.close();\n                void this._abort.raise(new Error(\"Popup closed\"));\n            }\n        }\n        this._window = null;\n    }\n\n    public static notifyOpener(url: string, keepOpen: boolean): void {\n        super._notifyParent(window.opener, url, keepOpen);\n        if (!keepOpen && !window.opener) {\n            window.close();\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { PopupWindow, type PopupWindowParams } from \"./PopupWindow\";\nimport type { INavigator } from \"./INavigator\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\n\n/**\n * @internal\n */\nexport class PopupNavigator implements INavigator {\n    private readonly _logger = new Logger(\"PopupNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) { }\n\n    public async prepare({\n        popupWindowFeatures = this._settings.popupWindowFeatures,\n        popupWindowTarget = this._settings.popupWindowTarget,\n        popupSignal,\n        popupAbortOnClose,\n    }: PopupWindowParams): Promise<PopupWindow> {\n        return new PopupWindow({\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            popupAbortOnClose,\n        });\n    }\n\n    public async callback(url: string, { keepOpen = false }): Promise<void> {\n        this._logger.create(\"callback\");\n\n        PopupWindow.notifyOpener(url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport type { INavigator } from \"./INavigator\";\nimport type { IWindow, NavigateResponse } from \"./IWindow\";\n\n/**\n * @public\n */\nexport interface RedirectParams {\n    redirectMethod?: \"replace\" | \"assign\";\n    redirectTarget?: \"top\" | \"self\";\n}\n\n/**\n * @internal\n */\nexport class RedirectNavigator implements INavigator {\n    private readonly _logger = new Logger(\"RedirectNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        redirectMethod = this._settings.redirectMethod,\n        redirectTarget = this._settings.redirectTarget,\n    }: RedirectParams): Promise<IWindow> {\n        this._logger.create(\"prepare\");\n        let targetWindow = window.self as Window;\n\n        if (redirectTarget === \"top\") {\n            targetWindow = window.top ?? window.self;\n        }\n    \n        const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location) as (url: string) => void;\n        let abort: (reason: Error) => void;\n        return {\n            navigate: async (params): Promise<NavigateResponse> => {\n                this._logger.create(\"navigate\");\n                const promise = new Promise((resolve, reject) => {\n                    abort = reject;\n                    window.addEventListener(\"pageshow\", () => resolve(window.location.href));\n                    redirect(params.url);\n                });\n                return await (promise as Promise<NavigateResponse>);\n            },\n            close: () => {\n                this._logger.create(\"close\");\n                abort?.(new Error(\"Redirect aborted\"));\n                targetWindow.stop();\n            },\n        };\n    }\n\n    public async callback(): Promise<void> {\n        return;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Event } from \"./utils\";\nimport { AccessTokenEvents } from \"./AccessTokenEvents\";\nimport type { UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type UserLoadedCallback = (user: User) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserUnloadedCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type SilentRenewErrorCallback = (error: Error) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedInCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedOutCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSessionChangedCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport class UserManagerEvents extends AccessTokenEvents {\n    protected readonly _logger = new Logger(\"UserManagerEvents\");\n\n    private readonly _userLoaded = new Event<[User]>(\"User loaded\");\n    private readonly _userUnloaded = new Event<[]>(\"User unloaded\");\n    private readonly _silentRenewError = new Event<[Error]>(\"Silent renew error\");\n    private readonly _userSignedIn = new Event<[]>(\"User signed in\");\n    private readonly _userSignedOut = new Event<[]>(\"User signed out\");\n    private readonly _userSessionChanged = new Event<[]>(\"User session changed\");\n\n    public constructor(settings: UserManagerSettingsStore) {\n        super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    }\n\n    public async load(user: User, raiseEvent=true): Promise<void> {\n        await super.load(user);\n        if (raiseEvent) {\n            await this._userLoaded.raise(user);\n        }\n    }\n\n    public async unload(): Promise<void> {\n        await super.unload();\n        await this._userUnloaded.raise();\n    }\n\n    /**\n     * Add callback: Raised when a user session has been established (or re-established).\n     */\n    public addUserLoaded(cb: UserLoadedCallback): () => void {\n        return this._userLoaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been established (or re-established).\n     */\n    public removeUserLoaded(cb: UserLoadedCallback): void {\n        return this._userLoaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when a user session has been terminated.\n     */\n    public addUserUnloaded(cb: UserUnloadedCallback): () => void {\n        return this._userUnloaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been terminated.\n     */\n    public removeUserUnloaded(cb: UserUnloadedCallback): void {\n        return this._userUnloaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when the automatic silent renew has failed.\n     */\n    public addSilentRenewError(cb: SilentRenewErrorCallback): () => void {\n        return this._silentRenewError.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the automatic silent renew has failed.\n     */\n    public removeSilentRenewError(cb: SilentRenewErrorCallback): void {\n        return this._silentRenewError.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseSilentRenewError(e: Error): Promise<void> {\n        await this._silentRenewError.raise(e);\n    }\n\n    /**\n     * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedIn(cb: UserSignedInCallback): () => void {\n        return this._userSignedIn.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n     */\n    public removeUserSignedIn(cb: UserSignedInCallback): void {\n        this._userSignedIn.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSignedIn(): Promise<void> {\n        await this._userSignedIn.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedOut(cb: UserSignedOutCallback): () => void {\n        return this._userSignedOut.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     */\n    public removeUserSignedOut(cb: UserSignedOutCallback): void {\n        this._userSignedOut.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSignedOut(): Promise<void> {\n        await this._userSignedOut.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user session changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSessionChanged(cb: UserSessionChangedCallback): () => void {\n        return this._userSessionChanged.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n     */\n    public removeUserSessionChanged(cb: UserSessionChangedCallback): void {\n        this._userSessionChanged.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSessionChanged(): Promise<void> {\n        await this._userSessionChanged.raise();\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport { ErrorTimeout } from \"./errors\";\nimport type { UserManager } from \"./UserManager\";\nimport type { AccessTokenCallback } from \"./AccessTokenEvents\";\n\n/**\n * @internal\n */\nexport class SilentRenewService {\n    protected _logger = new Logger(\"SilentRenewService\");\n    private _isStarted = false;\n    private readonly _retryTimer = new Timer(\"Retry Silent Renew\");\n\n    public constructor(private _userManager: UserManager) {}\n\n    public async start(): Promise<void> {\n        const logger = this._logger.create(\"start\");\n        if (!this._isStarted) {\n            this._isStarted = true;\n            this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n            this._retryTimer.addHandler(this._tokenExpiring);\n\n            // this will trigger loading of the user so the expiring events can be initialized\n            try {\n                await this._userManager.getUser();\n                // deliberate nop\n            }\n            catch (err) {\n                // catch to suppress errors since we're in a ctor\n                logger.error(\"getUser error\", err);\n            }\n        }\n    }\n\n    public stop(): void {\n        if (this._isStarted) {\n            this._retryTimer.cancel();\n            this._retryTimer.removeHandler(this._tokenExpiring);\n            this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n            this._isStarted = false;\n        }\n    }\n\n    protected _tokenExpiring: AccessTokenCallback = async () => {\n        const logger = this._logger.create(\"_tokenExpiring\");\n        try {\n            await this._userManager.signinSilent();\n            logger.debug(\"silent token renewal successful\");\n        }\n        catch (err) {\n            if (err instanceof ErrorTimeout) {\n                // no response from authority server, e.g. IFrame timeout, ...\n                logger.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n                this._retryTimer.init(5);\n                return;\n            }\n\n            logger.error(\"Error from signinSilent:\", err);\n            await this._userManager.events._raiseSilentRenewError(err as Error);\n        }\n    };\n}\n","// Copyright (C) AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { UserProfile } from \"./User\";\n\n/**\n * Fake state store implementation necessary for validating refresh token requests.\n *\n * @public\n */\nexport class RefreshState {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public readonly refresh_token: string;\n    public readonly id_token?: string;\n    public readonly session_state: string | null;\n    public readonly scope?: string;\n    public readonly profile: UserProfile;\n\n    constructor(args: {\n        refresh_token: string;\n        id_token?: string;\n        session_state: string | null;\n        scope?: string;\n        profile: UserProfile;\n\n        state?: unknown;\n    }) {\n        this.refresh_token = args.refresh_token;\n        this.id_token = args.id_token;\n        this.session_state = args.session_state;\n        this.scope = args.scope;\n        this.profile = args.profile;\n\n        this.data = args.state;\n\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type NavigateResponse, type PopupWindowParams, type IWindow, type IFrameWindowParams, type RedirectParams, RedirectNavigator, PopupNavigator, IFrameNavigator, type INavigator } from \"./navigators\";\nimport { OidcClient, type CreateSigninRequestArgs, type CreateSignoutRequestArgs, type ProcessResourceOwnerPasswordCredentialsArgs, type UseRefreshTokenArgs } from \"./OidcClient\";\nimport { type UserManagerSettings, UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport { User } from \"./User\";\nimport { UserManagerEvents } from \"./UserManagerEvents\";\nimport { SilentRenewService } from \"./SilentRenewService\";\nimport { SessionMonitor } from \"./SessionMonitor\";\nimport type { SessionStatus } from \"./SessionStatus\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { RefreshState } from \"./RefreshState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { ExtraHeader, DPoPSettings } from \"./OidcClientSettings\";\nimport { DPoPState } from \"./DPoPStore\";\n\n/**\n * @public\n */\nexport type ExtraSigninRequestArgs = Pick<CreateSigninRequestArgs, \"nonce\" | \"extraQueryParams\" | \"extraTokenParams\" | \"state\" | \"redirect_uri\" | \"prompt\" | \"acr_values\" | \"login_hint\" | \"scope\" | \"max_age\" | \"ui_locales\" | \"resource\" | \"url_state\">;\n/**\n * @public\n */\nexport type ExtraSignoutRequestArgs = Pick<CreateSignoutRequestArgs, \"extraQueryParams\" | \"state\" | \"id_token_hint\" | \"post_logout_redirect_uri\" | \"url_state\">;\n\n/**\n * @public\n */\nexport type RevokeTokensTypes = UserManagerSettings[\"revokeTokenTypes\"];\n\n/**\n * @public\n */\nexport type SigninRedirectArgs = RedirectParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninPopupArgs = PopupWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type ExtraSignInSilentArgs = { \n    // forceIframeAuth bypasses refresh token usage and forces iframe-based silent authentication\n    forceIframeAuth?: boolean;\n};\n\n/**\n * @public\n */\nexport type SigninSilentArgs = IFrameWindowParams & ExtraSigninRequestArgs & ExtraSignInSilentArgs;\n\n/**\n * @public\n */\nexport type SigninResourceOwnerCredentialsArgs = ProcessResourceOwnerPasswordCredentialsArgs;\n\n/**\n * @public\n */\nexport type QuerySessionStatusArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutRedirectArgs = RedirectParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutPopupArgs = PopupWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutSilentArgs = IFrameWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * Provides a higher level API for signing a user in, signing out, managing the user's claims returned from the identity provider,\n * and managing an access token returned from the identity provider (OAuth2/OIDC).\n *\n * @public\n */\nexport class UserManager {\n    /** Get the settings used to configure the `UserManager`. */\n    public readonly settings: UserManagerSettingsStore;\n    protected readonly _logger = new Logger(\"UserManager\");\n\n    protected readonly _client: OidcClient;\n    protected readonly _redirectNavigator: INavigator;\n    protected readonly _popupNavigator: INavigator;\n    protected readonly _iframeNavigator: INavigator;\n    protected readonly _events: UserManagerEvents;\n    protected readonly _silentRenewService: SilentRenewService;\n    protected readonly _sessionMonitor: SessionMonitor | null;\n\n    public constructor(settings: UserManagerSettings, redirectNavigator?: INavigator, popupNavigator?: INavigator, iframeNavigator?: INavigator) {\n        this.settings = new UserManagerSettingsStore(settings);\n\n        this._client = new OidcClient(settings);\n\n        this._redirectNavigator = redirectNavigator ?? new RedirectNavigator(this.settings);\n        this._popupNavigator = popupNavigator ?? new PopupNavigator(this.settings);\n        this._iframeNavigator = iframeNavigator ?? new IFrameNavigator(this.settings);\n\n        this._events = new UserManagerEvents(this.settings);\n        this._silentRenewService = new SilentRenewService(this);\n\n        // order is important for the following properties; these services depend upon the events.\n        if (this.settings.automaticSilentRenew) {\n            this.startSilentRenew();\n        }\n\n        this._sessionMonitor = null;\n        if (this.settings.monitorSession) {\n            this._sessionMonitor = new SessionMonitor(this);\n        }\n    }\n\n    /**\n     * Get object used to register for events raised by the `UserManager`.\n     */\n    public get events(): UserManagerEvents {\n        return this._events;\n    }\n\n    /**\n     * Get object used to access the metadata configuration of the identity provider.\n     */\n    public get metadataService(): MetadataService {\n        return this._client.metadataService;\n    }\n\n    /**\n     * Load the `User` object for the currently authenticated user.\n     *\n     * @param raiseEvent - If `true`, the `UserLoaded` event will be raised. Defaults to false.\n     * @returns A promise\n     */\n    public async getUser(raiseEvent = false): Promise<User | null> {\n        const logger = this._logger.create(\"getUser\");\n        const user = await this._loadUser();\n        if (user) {\n            logger.info(\"user loaded\");\n            await this._events.load(user, raiseEvent);\n            return user;\n        }\n\n        logger.info(\"user not found in storage\");\n        return null;\n    }\n\n    /**\n     * Remove from any storage the currently authenticated user.\n     *\n     * @returns A promise\n     */\n    public async removeUser(): Promise<void> {\n        const logger = this._logger.create(\"removeUser\");\n        await this.storeUser(null);\n        logger.info(\"user removed from storage\");\n        await this._events.unload();\n    }\n\n    /**\n     * Trigger a redirect of the current window to the authorization endpoint.\n     *\n     * @returns A promise\n     *\n     * @throws `Error` In cases of wrong authentication.\n     */\n    public async signinRedirect(args: SigninRedirectArgs = {}): Promise<void> {\n        this._logger.create(\"signinRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signinStart({\n            request_type: \"si:r\",\n            dpopJkt,\n            ...requestArgs,\n        }, handle);\n    }\n\n    /**\n     * Process the response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise containing the authenticated `User`.\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinRedirectCallback(url = window.location.href): Promise<User> {\n        const logger = this._logger.create(\"signinRedirectCallback\");\n        const user = await this._signinEnd(url);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        }\n        else {\n            logger.info(\"no subject\");\n        }\n\n        return user;\n    }\n\n    /**\n     * Trigger the signin with user/password.\n     *\n     * @returns A promise containing the authenticated `User`.\n     * @throws {@link ErrorResponse} In cases of wrong authentication.\n     */\n    public async signinResourceOwnerCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n    }: SigninResourceOwnerCredentialsArgs): Promise<User> {\n        const logger = this._logger.create(\"signinResourceOwnerCredential\");\n\n        const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n            username,\n            password,\n            skipUserInfo,\n            extraTokenParams: this.settings.extraTokenParams,\n        });\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        } else {\n            logger.info(\"no subject\");\n        }\n        return user;\n    }\n\n    /**\n     * Trigger a request (via a popup window) to the authorization endpoint.\n     *\n     * @returns A promise containing the authenticated `User`.\n     * @throws `Error` In cases of wrong authentication.\n     */\n    public async signinPopup(args: SigninPopupArgs = {}): Promise<User> {\n        const logger = this._logger.create(\"signinPopup\");\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            popupAbortOnClose,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No popup_redirect_uri configured\"));\n        }\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal, popupAbortOnClose });\n        const user = await this._signin({\n            request_type: \"si:p\",\n            redirect_uri: url,\n            display: \"popup\",\n            dpopJkt,\n            ...requestArgs,\n        }, handle);\n        if (user) {\n            if (user.profile && user.profile.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            } else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    /**\n     * Notify the opening window of response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signinPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    /**\n     * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.\n     *\n     * @returns A promise that contains the authenticated `User`.\n     */\n    public async signinSilent(args: SigninSilentArgs = {}): Promise<User | null> {\n        const logger = this._logger.create(\"signinSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        // first determine if we have a refresh token, or need to use iframe\n        let user = await this._loadUser();\n        // use refresh token unless forceIframeAuth is explicitly true\n        if (!args.forceIframeAuth && user?.refresh_token) {\n            logger.debug(\"using refresh token\");\n            const state = new RefreshState(user as Required<User>);\n            return await this._useRefreshToken({\n                state,\n                redirect_uri: requestArgs.redirect_uri,\n                resource: requestArgs.resource,\n                extraTokenParams: requestArgs.extraTokenParams,\n                timeoutInSeconds: silentRequestTimeoutInSeconds,\n            });\n        }\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        let verifySub: string | undefined;\n        if (user && this.settings.validateSubOnSilentRenew) {\n            logger.debug(\"subject prior to silent renew:\", user.profile.sub);\n            verifySub = user.profile.sub;\n        }\n\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        user = await this._signin({\n            request_type: \"si:s\",\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            dpopJkt,\n            ...requestArgs,\n        }, handle, verifySub);\n        if (user) {\n            if (user.profile?.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    protected async _useRefreshToken(args: UseRefreshTokenArgs): Promise<User> {\n        const response = await this._client.useRefreshToken({\n            timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n            ...args,\n        });\n        const user = new User({ ...args.state, ...response });\n\n        await this.storeUser(user);\n        await this._events.load(user);\n        return user;\n    }\n\n    /**\n     *\n     * Notify the parent window of response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signinSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process any response (callback) from the authorization endpoint, by dispatching the request_type\n     * and executing one of the following functions:\n     * - {@link UserManager.signinRedirectCallback}\n     * - {@link UserManager.signinPopupCallback}\n     * - {@link UserManager.signinSilentCallback}\n     *\n     * @throws `Error` If request_type is unknown or signin cannot be processed.\n     */\n    public async signinCallback(url = window.location.href): Promise<User | undefined> {\n        const { state } = await this._client.readSigninResponseState(url);\n        switch (state.request_type) {\n            case \"si:r\":\n                return await this.signinRedirectCallback(url);\n            case \"si:p\":\n                await this.signinPopupCallback(url);\n                break;\n            case \"si:s\":\n                await this.signinSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Process any response (callback) from the end session endpoint, by dispatching the request_type\n     * and executing one of the following functions:\n     * - {@link UserManager.signoutRedirectCallback}\n     * - {@link UserManager.signoutPopupCallback}\n     * - {@link UserManager.signoutSilentCallback}\n     *\n     * @throws `Error` If request_type is unknown or signout cannot be processed.\n     */\n    public async signoutCallback(url = window.location.href, keepOpen = false): Promise<SignoutResponse | undefined> {\n        const { state } = await this._client.readSignoutResponseState(url);\n        if (!state) {\n            return undefined;\n        }\n\n        switch (state.request_type) {\n            case \"so:r\":\n                return await this.signoutRedirectCallback(url);\n            case \"so:p\":\n                await this.signoutPopupCallback(url, keepOpen);\n                break;\n            case \"so:s\":\n                await this.signoutSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Query OP for user's current signin status.\n     *\n     * @returns A promise object with session_state and subject identifier.\n     */\n    public async querySessionStatus(args: QuerySessionStatusArgs = {}): Promise<SessionStatus | null> {\n        const logger = this._logger.create(\"querySessionStatus\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        const user = await this._loadUser();\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        const navResponse = await this._signinStart({\n            request_type: \"si:s\", // this acts like a signin silent\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            response_type: this.settings.query_status_response_type,\n            scope: \"openid\",\n            skipUserInfo: true,\n            ...requestArgs,\n        }, handle);\n        try {\n            const extraHeaders: Record<string, ExtraHeader> = {};\n            const signinResponse = await this._client.processSigninResponse(navResponse.url, extraHeaders);\n            logger.debug(\"got signin response\");\n\n            if (signinResponse.session_state && signinResponse.profile.sub) {\n                logger.info(\"success for subject\", signinResponse.profile.sub);\n                return {\n                    session_state: signinResponse.session_state,\n                    sub: signinResponse.profile.sub,\n                };\n            }\n\n            logger.info(\"success, user not authenticated\");\n            return null;\n        } catch (err) {\n            if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n                switch (err.error) {\n                    case \"login_required\":\n                    case \"consent_required\":\n                    case \"interaction_required\":\n                    case \"account_selection_required\":\n                        logger.info(\"success for anonymous user\");\n                        return {\n                            session_state: err.session_state!,\n                        };\n                }\n            }\n            throw err;\n        }\n    }\n\n    protected async _signin(args: CreateSigninRequestArgs, handle: IWindow, verifySub?: string): Promise<User> {\n        const navResponse = await this._signinStart(args, handle);\n        return await this._signinEnd(navResponse.url, verifySub);\n    }\n\n    protected async _signinStart(args: CreateSigninRequestArgs, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signinStart\");\n\n        try {\n            const signinRequest = await this._client.createSigninRequest(args);\n            logger.debug(\"got signin request\");\n\n            return await handle.navigate({\n                url: signinRequest.url,\n                state: signinRequest.state.id,\n                response_mode: signinRequest.state.response_mode,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        } catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n\n    protected async _signinEnd(url: string, verifySub?: string): Promise<User> {\n        const logger = this._logger.create(\"_signinEnd\");\n        const extraHeaders: Record<string, ExtraHeader> = {};\n        const signinResponse = await this._client.processSigninResponse(url, extraHeaders);\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse, verifySub);\n        return user;\n    }\n\n    protected async _buildUser(signinResponse: SigninResponse, verifySub?: string) {\n        const logger = this._logger.create(\"_buildUser\");\n        const user = new User(signinResponse);\n        if (verifySub) {\n            if (verifySub !== user.profile.sub) {\n                logger.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n                throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n            }\n            logger.debug(\"current user matches user returned from signin\");\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        await this._events.load(user);\n\n        return user;\n    }\n\n    /**\n     * Trigger a redirect of the current window to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutRedirect(args: SignoutRedirectArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signoutStart({\n            request_type: \"so:r\",\n            post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process response (callback) from the end session endpoint.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise containing signout response\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutRedirectCallback(url = window.location.href): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"signoutRedirectCallback\");\n        const response = await this._signoutEnd(url);\n        logger.info(\"success\");\n        return response;\n    }\n\n    /**\n     * Trigger a redirect of a popup window to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutPopup(args: SignoutPopupArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_post_logout_redirect_uri;\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n        await this._signout({\n            request_type: \"so:p\",\n            post_logout_redirect_uri: url,\n            // we're putting a dummy entry in here because we\n            // need a unique id from the state for notification\n            // to the parent window, which is necessary if we\n            // plan to return back to the client after signout\n            // and so we can close the popup after signout\n            state: url == null ? undefined : {},\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process response (callback) from the end session endpoint from a popup window.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signoutPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    protected async _signout(args: CreateSignoutRequestArgs, handle: IWindow): Promise<SignoutResponse> {\n        const navResponse = await this._signoutStart(args, handle);\n        return await this._signoutEnd(navResponse.url);\n    }\n\n    protected async _signoutStart(args: CreateSignoutRequestArgs = {}, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signoutStart\");\n\n        try {\n            const user = await this._loadUser();\n            logger.debug(\"loaded current user from storage\");\n\n            if (this.settings.revokeTokensOnSignout) {\n                await this._revokeInternal(user);\n            }\n\n            const id_token = args.id_token_hint || user && user.id_token;\n            if (id_token) {\n                logger.debug(\"setting id_token_hint in signout request\");\n                args.id_token_hint = id_token;\n            }\n\n            await this.removeUser();\n            logger.debug(\"user removed, creating signout request\");\n\n            const signoutRequest = await this._client.createSignoutRequest(args);\n            logger.debug(\"got signout request\");\n\n            return await handle.navigate({\n                url: signoutRequest.url,\n                state: signoutRequest.state?.id,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        } catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n\n    protected async _signoutEnd(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"_signoutEnd\");\n        const signoutResponse = await this._client.processSignoutResponse(url);\n        logger.debug(\"got signout response\");\n\n        return signoutResponse;\n    }\n\n    /**\n     * Trigger a silent request (via an iframe) to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutSilent(args: SignoutSilentArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n\n        const id_token_hint = this.settings.includeIdTokenInSilentSignout\n            ? (await this._loadUser())?.id_token\n            : undefined;\n\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        await this._signout({\n            request_type: \"so:s\",\n            post_logout_redirect_uri: url,\n            id_token_hint: id_token_hint,\n            ...requestArgs,\n        }, handle);\n\n        logger.info(\"success\");\n    }\n\n    /**\n     * Notify the parent window of response (callback) from the end session endpoint.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signoutSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async revokeTokens(types?: RevokeTokensTypes): Promise<void> {\n        const user = await this._loadUser();\n        await this._revokeInternal(user, types);\n    }\n\n    protected async _revokeInternal(user: User | null, types = this.settings.revokeTokenTypes): Promise<void> {\n        const logger = this._logger.create(\"_revokeInternal\");\n        if (!user) return;\n\n        const typesPresent = types.filter(type => typeof user[type] === \"string\");\n\n        if (!typesPresent.length) {\n            logger.debug(\"no need to revoke due to no token(s)\");\n            return;\n        }\n\n        // don't Promise.all, order matters\n        for (const type of typesPresent) {\n            await this._client.revokeToken(\n                user[type]!,\n                type,\n            );\n            logger.info(`${type} revoked successfully`);\n            if (type !== \"access_token\") {\n                user[type] = null as never;\n            }\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        await this._events.load(user);\n    }\n\n    /**\n     * Enables silent renew for the `UserManager`.\n     */\n    public startSilentRenew(): void {\n        this._logger.create(\"startSilentRenew\");\n        void this._silentRenewService.start();\n    }\n\n    /**\n     * Disables silent renew for the `UserManager`.\n     */\n    public stopSilentRenew(): void {\n        this._silentRenewService.stop();\n    }\n\n    protected get _userStoreKey(): string {\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\n    }\n\n    protected async _loadUser(): Promise<User | null> {\n        const logger = this._logger.create(\"_loadUser\");\n        const storageString = await this.settings.userStore.get(this._userStoreKey);\n        if (storageString) {\n            logger.debug(\"user storageString loaded\");\n            return User.fromStorageString(storageString);\n        }\n\n        logger.debug(\"no user storageString\");\n        return null;\n    }\n\n    public async storeUser(user: User | null): Promise<void> {\n        const logger = this._logger.create(\"storeUser\");\n        if (user) {\n            logger.debug(\"storing user\");\n            const storageString = user.toStorageString();\n            await this.settings.userStore.set(this._userStoreKey, storageString);\n        } else {\n            this._logger.debug(\"removing user\");\n            await this.settings.userStore.remove(this._userStoreKey);\n            if (this.settings.dpop) {\n                await this.settings.dpop.store.remove(this.settings.client_id);\n            }\n        }\n    }\n\n    /**\n     * Removes stale state entries in storage for incomplete authorize requests.\n     */\n    public async clearStaleState(): Promise<void> {\n        await this._client.clearStaleState();\n    }\n\n    /**\n     * Dynamically generates a DPoP proof for a given user, URL and optional Http method.\n     * This method is useful when you need to make a request to a resource server\n     * with fetch or similar, and you need to include a DPoP proof in a DPoP header.\n     * @param url - The URL to generate the DPoP proof for\n     * @param user - The user to generate the DPoP proof for\n     * @param httpMethod - Optional, defaults to \"GET\"\n     * @param nonce - Optional nonce provided by the resource server\n     *\n     * @returns A promise containing the DPoP proof or undefined if DPoP is not enabled/no user is found.\n     */\n    public async dpopProof(url: string, user: User, httpMethod?: string, nonce?: string): Promise<string | undefined> {\n        const dpopState = await this.settings.dpop?.store?.get(this.settings.client_id);\n        if (dpopState) {\n            return await CryptoUtils.generateDPoPProof({\n                url,\n                accessToken: user?.access_token,\n                httpMethod: httpMethod,\n                keyPair: dpopState.keys,\n                nonce,\n            });\n        }\n        return undefined;\n    }\n\n    async generateDPoPJkt(dpopSettings: DPoPSettings): Promise<string | undefined> {\n        let dpopState = await dpopSettings.store.get(this.settings.client_id);\n        if (!dpopState) {\n            const dpopKeys = await CryptoUtils.generateDPoPKeys();\n            dpopState = new DPoPState(dpopKeys);\n            await dpopSettings.store.set(this.settings.client_id, dpopState);\n        }\n        return await CryptoUtils.generateDPoPJkt(dpopState.keys);\n    }\n}\n","// @ts-expect-error avoid enabling resolveJsonModule to keep build process simple\nimport { version } from \"../package.json\";\n\n/**\n * @public\n */\nexport const Version: string = version;\n","{\n  \"name\": \"oidc-client-ts\",\n  \"version\": \"3.4.1\",\n  \"description\": \"OpenID Connect (OIDC) & OAuth2 client library\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/authts/oidc-client-ts.git\"\n  },\n  \"homepage\": \"https://github.com/authts/oidc-client-ts#readme\",\n  \"license\": \"Apache-2.0\",\n  \"main\": \"dist/umd/oidc-client-ts.js\",\n  \"types\": \"dist/types/oidc-client-ts.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/types/oidc-client-ts.d.ts\",\n      \"import\": \"./dist/esm/oidc-client-ts.js\",\n      \"require\": \"./dist/umd/oidc-client-ts.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"keywords\": [\n    \"authentication\",\n    \"oauth2\",\n    \"oidc\",\n    \"openid\",\n    \"OpenID Connect\"\n  ],\n  \"scripts\": {\n    \"build\": \"node scripts/build.js && npm run build-types\",\n    \"build-types\": \"tsc -p tsconfig.build.json && api-extractor run\",\n    \"clean\": \"git clean -fdX dist lib *.tsbuildinfo\",\n    \"prepack\": \"npm run build\",\n    \"test\": \"tsc && jest\",\n    \"typedoc\": \"typedoc\",\n    \"lint\": \"eslint --max-warnings=0 --cache .\",\n    \"prepare\": \"husky\"\n  },\n  \"dependencies\": {\n    \"jwt-decode\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"@eslint/eslintrc\": \"^3.2.0\",\n    \"@eslint/js\": \"^9.18.0\",\n    \"@microsoft/api-extractor\": \"^7.49.1\",\n    \"@stylistic/eslint-plugin\": \"^2.13.0\",\n    \"@testing-library/jest-dom\": \"^6.6.3\",\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^24.10.1\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.20.0\",\n    \"@typescript-eslint/parser\": \"^8.20.0\",\n    \"esbuild\": \"^0.27.0\",\n    \"eslint\": \"^9.18.0\",\n    \"eslint-plugin-testing-library\": \"^7.1.1\",\n    \"fake-indexeddb\": \"^6.0.0\",\n    \"globals\": \"^16.0.0\",\n    \"http-proxy-middleware\": \"^3.0.3\",\n    \"husky\": \"^9.1.7\",\n    \"jest\": \"^29.7.0\",\n    \"jest-environment-jsdom\": \"^29.7.0\",\n    \"jest-mock\": \"^29.7.0\",\n    \"jose\": \"^5.9.6\",\n    \"lint-staged\": \"^16.1.0\",\n    \"ts-jest\": \"^29.2.5\",\n    \"typedoc\": \"^0.28.0\",\n    \"typescript\": \"~5.8.2\",\n    \"yn\": \"^5.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": \"eslint --cache --fix\"\n  }\n}\n","import { DPoPState, type DPoPStore } from \"./DPoPStore\";\n\n/**\n * Provides a default implementation of the DPoP store using IndexedDB.\n *\n * @public\n */\nexport class IndexedDbDPoPStore implements DPoPStore {\n    readonly _dbName: string = \"oidc\";\n    readonly _storeName: string = \"dpop\";\n\n    public async set(key: string, value: DPoPState): Promise<void> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        await store(\"readwrite\", (str: IDBObjectStore) => {\n            str.put(value, key);\n            return this.promisifyRequest(str.transaction);\n        });\n    }\n\n    public async get(key: string): Promise<DPoPState> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        return await store(\"readonly\", (str) => {\n            return this.promisifyRequest(str.get(key));\n        }) as DPoPState;\n    }\n\n    public async remove(key: string): Promise<DPoPState> {\n        const item = await this.get(key);\n        const store = await this.createStore(this._dbName, this._storeName);\n        await store(\"readwrite\", (str) => {\n            return this.promisifyRequest(str.delete(key));\n        });\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        return await store(\"readonly\", (str) => {\n            return this.promisifyRequest(str.getAllKeys());\n        }) as string[];\n    }\n\n    promisifyRequest<T = undefined>(\n        request: IDBRequest<T> | IDBTransaction): Promise<T> {\n        return new Promise<T>((resolve, reject) => {\n            (request as IDBTransaction).oncomplete = (request as IDBRequest<T>).onsuccess = () => resolve((request as IDBRequest<T>).result);\n            (request as IDBTransaction).onabort = (request as IDBRequest<T>).onerror = () => reject((request as IDBRequest<T>).error as Error);\n        });\n    }\n\n    async createStore<T>(\n        dbName: string,\n        storeName: string,\n    ): Promise<(txMode: IDBTransactionMode, callback: (store: IDBObjectStore) => T | PromiseLike<T>) => Promise<T>> {\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        const db = await this.promisifyRequest<IDBDatabase>(request);\n\n        return async (\n            txMode: IDBTransactionMode,\n            callback: (store: IDBObjectStore) => T | PromiseLike<T>,\n        ) => {\n            const tx = db.transaction(storeName, txMode);\n            const store = tx.objectStore(storeName);\n            return await callback(store);\n        };\n    }\n}\n","var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding)\n          ? 'rtpmap:%d %s/%s/%s'\n          : o.rate\n            ? 'rtpmap:%d %s/%s'\n            : 'rtpmap:%d %s';\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null)\n          ? 'rtcp:%d %s IP%d %s'\n          : 'rtcp:%d';\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%s trr-int %d'\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null)\n          ? 'rtcp-fb:%s %s %s'\n          : 'rtcp-fb:%s %s';\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return (\n          'extmap:%d' +\n          (o.direction ? '/%s' : '%v') +\n          (o['encrypt-uri'] ? ' %s' : '%v') +\n          ' %s' +\n          (o.config ? ' %s' : '')\n        );\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null)\n          ? 'crypto:%d %s %s %s'\n          : 'crypto:%d %s %s';\n      }\n    },\n    {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    },\n    {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      push: 'msid',\n      reg: /^msid:([\\w-]+)(?: ([\\w-]+))?/,\n      names: ['id', 'appdata'],\n      format: 'msid:%s %s'\n    },\n    {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    },\n    {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    },\n    {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null)\n          ? 'sctpmap:%s %s %s'\n          : 'sctpmap:%s %s';\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        // a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        // recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        // a=simulcast:\n        '^simulcast:' +\n        // send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        // space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        // end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push:'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name:'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += (o.id != null ? 'id=%s %s' : '%v%s');\n        str += (o.mediaClockValue != null ? '=%s' : '');\n        str += (o.rateNumerator != null ? ' rate=%s' : '');\n        str += (o.rateDenominator != null ? '/%s' : '');\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    },\n    {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    },\n    {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    },\n    {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    },\n    {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n","var parser = require('./parser');\nvar writer = require('./writer');\nvar grammar = require('./grammar');\n\nexports.grammar = grammar;\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n","var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = require('./grammar');\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n","var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n"],"names":["_objectWithoutProperties","e","t","o","r","i","Object","getOwnPropertySymbols","n","length","indexOf","propertyIsEnumerable","call","_objectWithoutPropertiesLoose","hasOwnProperty","ALPHABET","TypeError","BASE_MAP","Uint8Array","j","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","size","b256","charCode","carry","it3","Error","it4","vch","encode","ArrayBuffer","isView","buffer","byteOffset","byteLength","Array","isArray","from","pbegin","pend","b58","it1","it2","str","repeat","decode","string","PARAM_REGEXP","TEXT_REGEXP","TOKEN_REGEXP","QESC_REGEXP","QUOTE_REGEXP","TYPE_REGEXP","qstring","val","String","test","replace","ContentType","type","this","parameters","create","exports","header","obj","getHeader","headers","getcontenttype","index","slice","trim","toLowerCase","key","match","value","lastIndex","exec","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","ownKeys","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","module","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","prepend","m","events","existing","warning","newListener","emit","unshift","push","warned","w","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","listenerCount","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","pop","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","jwtDecode","InvalidTokenError","base64UrlDecode","output","decodeURIComponent","atob","p","code","toString","toUpperCase","b64DecodeUnicode","token","options","pos","part","split","decoded","JSON","parse","ExtensibleEvents","_NamespacedMap","_InvalidEventError","_MRoomMessage","_MMessage","_message_types","_poll_types","_MPoll","_createForOfIteratorHelper","allowArrayLike","it","Symbol","iterator","minLen","_arrayLikeToArray","constructor","_unsupportedIterableToArray","F","s","done","_e","f","normalCompletion","didErr","step","next","_e2","arr2","_defineProperties","props","descriptor","configurable","writable","_defineProperty","instance","Constructor","_classCallCheck","NamespacedMap","LEGACY_M_ROOM_MESSAGE","parseMRoomMessage","M_MESSAGE","parseMMessage","M_EMOTE","M_NOTICE","M_POLL_START","parseMPoll","M_POLL_RESPONSE","M_POLL_END","protoProps","staticProps","_defaultInstance","defaultInstance","unknownInterpretOrder","wireEventType","interpreter","registerInterpreter","wireFormat","_this$_unknownInterpr","_unknownInterpretOrder","interpreters","hasNamespaced","getNamespaced","_step","_iterator","tryType","has","InvalidEventError","_typeof","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","result","Super","_getPrototypeOf","NewTarget","construct","self","ReferenceError","_assertThisInitialized","_possibleConstructorReturn","_wrapNativeSuper","Class","_cache","Map","fn","Wrapper","_construct","_setPrototypeOf","Parent","a","sham","Proxy","Boolean","valueOf","setPrototypeOf","__proto__","_Error","subClass","superClass","_inherits","_super","initial","internalMap","altName","_createClass","UnstableValue","NamespacedValue","stable","unstable","included","includes","_NamespacedValue","_this","EmoteEvent","_MessageEvent2","_get","property","base","object","_superPropBase","desc","getOwnPropertyDescriptor","_MessageEvent","text","html","_content","content","M_TEXT","M_HTML","primaryEventType","isEventTypeSame","MessageEvent","ExtensibleEvent","_ExtensibleEvent2","_types","enumerableOnly","symbols","filter","sym","_objectSpread","forEach","getOwnPropertyDescriptors","defineProperties","_ExtensibleEvent","mmessage","findIn","wireContent","mtext","mhtml","isProvided","find","mimetype","body","renderings","isOptionalAString","matches","messageRendering","mime","_this$html","serializeMMessageOnly","msgtype","format","formatted_body","NoticeEvent","PollEndEvent","_relationship_types","rel","REFERENCE_RELATION","rel_type","event_id","pollEventId","closingMessage","serialize","PollResponseEvent","validateAgainst","answers","internalAnswerIds","internalSpoiled","poll","response","some","pa","id","maxSelections","spoiled","answerIds","PollStartEvent","PollAnswerSubevent","_toConsumableArray","_arrayWithoutHoles","iter","_iterableToArray","_nonIterableSpread","_super2","_this2","question","rawKind","kind","M_POLL_KIND_DISCLOSED","M_POLL_KIND_UNDISCLOSED","isFinite","max_selections","map","_content2","join","_content3","LETTERS","floor","random","_ExtensibleEvents","_IPartialEvent","_MessageMatchers","_EmoteEvent","_NoticeEvent","_PollStartEvent","_PollResponseEvent","_PollEndEvent","wireEvent","_wireEvent$content","_wireEvent$content2","_wireEvent$content3","_objectSpread2","_objectSpread3","_objectSpread4","LegacyMsgType","isEventLike","event","Text","Emote","Notice","given","expected","expectedNs","givenNs","KnownMembership","ReEmitter","WeakMap","reEmit","reEmittersByEvent","reEmitters","eventName","forSource","stopReEmitting","delete","TypedReEmitter","super","ToDeviceMessageQueue","client","logger","async","retryTimeout","clearTimeout","sending","running","headBatch","debug","store","getOldestToDeviceBatch","sendBatch","removeToDeviceBatch","retryAttempts","retryDelay","MatrixScheduler","RETRY_BACKOFF_RATELIMIT","httpStatus","info","setTimeout","sendQueue","oldState","SyncState","Syncing","start","ClientEvent","Sync","onResumedSync","stop","queueBatch","batch","batches","batchWithTxnId","eventType","txnId","makeTxnId","msgmap","msg","userId","deviceId","payload","ToDeviceMessageId","saveToDeviceBatches","contentMap","MapWithDefault","item","getOrCreate","sendToDevice","toBase64","uint8Array","base64","btoa","reduce","acc","current","fromCharCode","omitPadding","alphabet","encodeBase64","encodeUnpaddedBase64","encodeUnpaddedBase64Url","decodeBase64","fromBase64","c","lastChunkHandling","DecryptionError","details","detailedString","k","detailedStringForDecryptionError","serverNameRegex","mediaIdRegex","getHttpUriForMxc","baseUrl","mxc","width","height","resizeMethod","allowDirectLinks","allowRedirects","useAuthentication","startsWith","serverName","mediaId","rest","validateServerName","validateMediaId","prefix","verb","url","URL","searchParams","round","stringify","href","DEFAULT_BIT_SIZE","deriveRecoveryKeyFromPassphrase","passphrase","salt","iterations","numBits","globalThis","crypto","subtle","TextEncoder","importKey","keybits","deriveBits","hash","sha256","plaintext","utf8","digest","eventMapperFor","preventReEmit","decrypt","mapper","plainOldJsObject","room","getRoom","room_id","state_key","findEventById","status","MatrixEvent","setUnsigned","getUnsigned","unsigned","bundledEdit","getServerAggregatedRelation","RelationType","Replace","replacement","makeReplaced","thread","findThreadForEvent","setThread","isEncrypted","reEmitter","MatrixEventEvent","Decrypted","decryptEventIfNeeded","Replaced","VisibilityChange","BeforeRedaction","ServerSupport","Feature","featureSupportResolver","Thread","unstablePrefixes","matrixVersion","ThreadUnreadNotifications","LoginTokenRequest","RelationBasedRedactions","AccountDataDeletion","RelationsRecursion","IntentionalMentions","buildFeatureSupportMap","versions","supportMap","feature","supportCondition","entries","_versions$versions$in","_versions$versions","_supportCondition$uns","_supportCondition$uns2","supportMatrixVersion","supportUnstablePrefixes","every","unstablePrefix","_versions$unstable_fe","unstable_features","Stable","Unstable","Unsupported","FilterComponent","filterJson","check","_event$getUnsigned","_bundledRelationships","bundledRelationships","relations","relationSenders","THREAD_RELATION_TYPE","current_user_participated","checkFields","getRoomId","getSender","getType","getContent","toJSON","fromEntries","types","not_types","rooms","not_rooms","senders","not_senders","contains_url","FILTER_RELATED_BY_SENDERS","FILTER_RELATED_BY_REL_TYPES","_key","roomId","sender","containsUrl","relationTypes","literalKeys","v","actualValue","filterValue","endsWith","typePrefix","matchesWildcard","matchFunc","notName","disallowedValues","allowedValues","containsUrlFilter","relationTypesFilter","arrayMatchesFilter","relationSendersFilter","values","limit","HTTPError","httpHeaders","isRateLimitError","getRetryAfterMs","_this$httpHeaders","retryAfter","ms","parseInt","date","Date","toUTCString","getTime","now","MatrixError","errorJson","errcode","data","headerValue","isInteger","retry_after_ms","asWidgetApiErrorData","_this$httpStatus","_this$url","_this$errcode","_this$data$error","http_status","http_headers","fromWidgetApiErrorData","Headers","safeGetRetryAfterMs","defaultMs","_error$getRetryAfterM","ConnectionError","cause","TokenRefreshError","_cause$message","TokenRefreshLogoutError","_cause$message2","TokenRefreshOutcome","TokenRefresher","opts","prepareForRequest","refreshIfNeeded","accessToken","refreshToken","expiry","latestTokenRefreshExpiry","tokenRefreshPromise","_handleUnknownToken","handleUnknownToken","snapshot","attempt","Logout","_this$tokenRefreshPro","doTokenRefresh","Success","_this$opts$logger","tokenRefreshFunction","sleep","min","_this$opts$logger2","_this$opts$logger3","_this$opts$logger5","_this$opts$logger4","Failure","FetchHttpApi","eventEmitter","_opts$useAuthorizatio","AbortController","checkObjectHasKeys","onlyData","useAuthorizationHeader","tokenRefresher","abort","abortController","fetch","resource","fetchFn","setIdBaseUrl","idBaseUrl","idServerRequest","method","path","params","queryParams","Method","Get","fullUri","getUrl","json","Authorization","requestOtherUrl","authedRequest","paramOpts","doAuthedRequest","deepCopy","abortSignal","requestSnapshot","access_token","request","outcome","inhibitLogoutEmit","HttpApiEvent","SessionLoggedOut","NoConsent","consent_uri","_opts$localTimeoutMs","_opts$keepAlive","_body$constructor","rawResponseBody","urlForLogs","sanitizeUrlForLogs","assign","jsonResponse","timeout","localTimeoutMs","keepAlive","signals","signal","timeoutSignal","cleanup","anySignal","cacheMode","res","mode","redirect","referrer","referrerPolicy","cache","credentials","keepalive","priority","ok","parseErrorResponse","blob","asUrl","sanitizedQs","URLSearchParams","append","sanitizedQsString","sanitizedQsUrlPiece","origin","pathname","baseUrlWithFallback","baseUrlWithoutTrailingSlash","extraParams","mergedParams","encodeParams","ClientPrefix","IdentityPrefix","MediaPrefix","controller","onAbort","aborted","_contentType","_contentType2","isXhr","getAllResponseHeaders","colonIdx","substring","contentType","parseContentType","getResponseContentType","responseURL","retryNetworkOperation","maxAttempts","callback","attempts","lastConnectionError","pow","calculateRetryBackoff","retryConnectionError","exists","indexedDB","dbName","req","open","onupgradeneeded","onblocked","onsuccess","close","deleteDatabase","onerror","EncryptionManager","updateEncryptionKeyThrottle","_this$joinConfig$upda","_this$joinConfig","joinConfig","makeKeyDelay","_this$joinConfig$make","_this$joinConfig2","useKeyDelay","_this$joinConfig$useK","_this$joinConfig3","getMemberships","transport","statistics","onEncryptionKeysChanged","parentLogger","Set","keysEventUpdateTimeout","lastEncryptionKeyUpdateRequest","joined","myKeys","getKeysForParticipant","indexToSend","latestGeneratedKeyIndex","keyIndexToSend","keyToSend","counters","roomEventEncryptionKeysSent","targets","membership","membershipTs","createdTs","sendKey","resendDelay","sendEncryptionKeysEvent","keyBase64Encoded","timestamp","setEncryptionKey","manageMediaKeys","makeNewKeyTimeout","newKeyIndex","makeNewSenderKey","rootLogger","getChild","getEncryptionKeys","keysMap","userKeys","encryptionKeys","entry","keyIndex","_this$joinConfig$mana","_this$joinConfig4","_this$joinConfig5","KeyTransportEvents","ReceivedKeys","onNewKeyReceived","requestSendCurrentKey","leave","getParticipantId","setNewKeyTimeouts","clear","onMembershipsUpdate","oldMemberships","oldMembershipIds","isMyMembership","getParticipantIdFromMembership","newMembershipIds","anyLeft","anyJoined","oldFingerprints","lastMembershipFingerprints","storeLastMembershipFingerprints","onRotateKeyTimeout","newFingerprints","delayBeforeUse","encryptionKey","secureRandomBase64Url","encryptionKeyIndex","getNewEncryptionKeyIndex","_this$encryptionKeys$","encryptionKeyString","keyBin","participantId","participantKeys","existingKeyAtIndex","b","useKeyTimeout","add","ActionScheduler","membershipLoopHandler","update","actions","_actions","startWithJoin","ts","MembershipActionType","SendDelayedEvent","sort","nextAction","wakeupUpdate","wakeupPromise","wakeup","race","handlerResult","splice","actionUpdate","insert","initiateJoin","_this$wakeup","initiateLeave","_this$wakeup2","SendScheduledDelayedLeaveEvent","MEMBERSHIP_STICKY_DURATION_MS","createInsertActionUpdate","offset","createReplaceActionUpdate","MembershipManager","TypedEventEmitter","isActivated","activated","isJoined","fociPreferred","multiSfuFocus","onError","scheduler","rtcTransport","leavePromiseResolvers","oldStatus","defaultState","catch","finally","_this$leavePromiseRes","MembershipManagerEvent","StatusChanged","withResolvers","_this$leavePromiseRes2","promise","onRTCSessionMemberUpdate","memberships","getUserId","getDeviceId","_ownMembership","sendingMembershipActions","SendJoinEvent","hasMemberStateEvent","updateCallIntent","callIntent","ownMembership","sendJoinEvent","slotDescription","_unstable_sendDelayedStateEvent","delay","delayedLeaveEventDelayMs","EventType","GroupCallMemberPrefix","memberId","myMembership","sendStateEvent","makeMembershipStateKey","delayId","startTime","rateLimitRetries","networkErrorRetries","expireUpdateIterations","probablyLeft","networkErrorRetryMs","_this$joinConfig$netw","membershipEventExpiryMs","_this$joinConfig$memb","DEFAULT_EXPIRE_DURATION","membershipEventExpiryHeadroomMs","_this$joinConfig$memb2","computeNextExpiryActionTs","iteration","_ref","_this$delayedLeaveEve","delayedLeaveEventDelayMsOverride","delayedLeaveEventRestartMs","_this$joinConfig$dela","maximumRateLimitRetryCount","_this$joinConfig$maxi","_this$joinConfig6","maximumNetworkErrorRetryCount","_this$joinConfig$maxi2","_this$joinConfig7","delayedLeaveEventRestartLocalTimeoutMs","_this$joinConfig$dela2","_this$joinConfig8","cancelKnownDelayIdBeforeSendDelayedEvent","sendOrResendDelayedLeaveEvent","RestartDelayedEvent","restartDelayedEvent","sendScheduledDelayedLeaveEventOrFallbackToSendLeaveEvent","SendLeaveEvent","UpdateExpiry","updateExpiryOnJoinedEvent","sendFallbackLeaveEvent","clientSendDelayedDisconnectMembership","then","expectedServerDelayLeaveTs","setAndEmitProbablyLeft","resetRateLimitCounter","delay_id","repeatActionType","manageMaxDelayExceededSituation","actionUpdateFromErrors","isUnsupportedDelayedEndpoint","_unstable_cancelScheduledDelayedEvent","isNotFoundError","ProbablyLeft","durationUntilServerDelayedLeave","abortPromise","_","AbortError","_unstable_restartScheduledDelayedEvent","_unstable_sendScheduledDelayedEvent","clientSendMembership","makeMyMembership","nextExpireUpdateIteration","localUserId","localDeviceId","stateKey","application","getVersion","expires","_this$fociPreferred","_this$fociPreferred2","focusObjects","focus_active","focus_selection","foci_preferred","created_ts","maxDelayAllowed","updateLimit","actionUpdateFromRateLimitError","updateNetwork","actionUpdateFromNetworkErrorRetry","_this$state$rateLimit","_this$state$networkEr","retries","retryDurationString","retryCounterString","retryDuration","UnsupportedDelayedEventsEndpointError","Status","Connecting","Connected","Disconnecting","Unknown","Disconnected","StickyEventMembershipManager","clientWithSticky","sessionDescription","_unstable_sendStickyDelayedEvent","RTCMembership","msc4354_sticky_key","_unstable_sendStickyEvent","_StickyEventMembershi","nameMap","relationObject","eventId","Reference","slot_id","slotDescriptionToId","rtc_transports","member","device_id","user_id","RTCEncryptionManager","OutdatedKeyFilter","_this$logger2","_this$logger","candidateInboundSession","creationTS","_this$logger3","keyBuffer","isOutdated","addKeyToParticipant","roomEventEncryptionKeysReceived","participantKeyRings","_joinConfig$manageMed","_this$logger4","_joinConfig$useKeyDel","_joinConfig$keyRotati","keyRotationGracePeriodMs","ensureKeyDistribution","_this$logger5","_this$logger8","currentKeyDistributionPromise","rolloutOutboundKey","_this$logger6","_this$logger7","needToEnsureKeyAgain","_this$logger9","trace","_this$outboundSession","_this$outboundSession2","outboundSession","generateRandomKey","sharedWith","keyId","toShareWith","alreadySharedWith","outboundKey","toDistributeTo","hasKeyChanged","newOutboundKey","createNewOutboundSession","keyAge","_this$logger0","_this$logger1","_this$logger10","_this$logger11","_this$logger12","_this$logger13","_this$logger14","_this$logger15","nextKeyIndex","getRandomValues","RoomKeyTransport","setParentLogger","RoomEvent","Timeline","ev","consumeCallEncryptionEvent","isRetry","isDecryptionFailure","getId","CallEncryptionKeysPrefix","onEncryptionEvent","decryptionFailureReason","members","call_id","sent_ts","sendEvent","matrixError","cancelPendingEvent","callId","age","getTs","totals","roomEventEncryptionKeysReceivedTotalAge","NotSupportedError","ToDeviceKeyTransport","getValidEventContent","receiveCallKeyEvent","ToDeviceEvent","onToDeviceEvent","claimed_device_id","session","scope","encryptAndSendToDevice","fromUser","_this$tsBuffer$get","tsBuffer","latestTimestamp","MSC3089Branch","indexEvent","directory","getStateKey","isActive","version","_this$indexEvent$getC","UNSTABLE_MSC3089_BRANCH","redactEvent","nextVersion","getVersionHistory","getName","setName","isLocked","setLocked","locked","getFileInfo","file","getFileEvent","getOriginalContent","httpUrl","mxcUrlToHttp","getUnfilteredTimelineSet","getLiveTimeline","getState","EventTimeline","BACKWARDS","paginationToken","scrollback","createNewVersion","encryptedContents","additionalContent","fileEventResponse","createFile","active","fileHistory","timelineEvents","getEvents","reverse","childEvent","parentEvent","replacingEventId","branch","getFile","DEFAULT_TREE_POWER_LEVELS_TEMPLATE","invite","kick","ban","redact","state_default","events_default","users_default","RoomPowerLevels","RoomHistoryVisibility","RoomTombstone","RoomEncryption","RoomName","RoomMessage","RoomMessageEncrypted","Sticker","users","TreePermissions","MSC3089TreeSpace","isTopLevel","parentEvents","currentState","getStateEvents","SpaceParent","_e$getContent","andSubspaces","promises","retryInvite","getDirectories","d","all","simpleRetryOperation","setPermissions","role","_pls$events","currentPls","pls","viewLevel","editLevel","adminLevel","Viewer","Editor","Owner","getPermissions","_pls$events2","_pls$users","userLevel","createDirectory","unstableCreateFileTree","SpaceChild","via","getDomain","trees","children","child","tree","unstableGetFileTreeSpace","getDirectory","subdirectories","dir","kickMemberships","Invite","Knock","Join","RoomMember","getOrderedChildren","ordered","order","lexicographicCompare","_roomA$currentState$g","_roomA$currentState$g2","_roomB$currentState$g","_roomB$currentState$g2","roomA","roomB","createTsA","RoomCreate","createTsB","getParentRoom","parent","parentRoom","getOrder","findIndex","setOrder","_currentChild$getCont2","max","movingUp","prev","newOrder","DEFAULT_ALPHABET","ensureBeforeIsSane","nextString","startOrder","endOrder","averageBetweenStrings","prevString","lastOrder","_currentChild$getCont","currentChild","content_uri","uploadContent","includeFilename","fileContent","MsgType","File","sendMessage","UNSTABLE_MSC3089_LEAF","fileEventId","listFiles","listAllFiles","_this$room$currentSta","compareEventOrdering","leftEventId","rightEventId","leftEvent","rightEvent","isLeftEventInMainTimeline","inMainTimelineForReceipt","isRightEventInMainTimeline","timelineSet","compareSameTimeline","leftTimeline","getTimelineForEvent","rightTimeline","guessOrderBasedOnTimestamp","compareEventsInMainTimeline","leftEventThreadId","threadIdForReceipt","rightEventThreadId","leftThread","getThread","compareEventsInThreads","leftTs","rightTs","EventContext","ourEvent","Direction","Backward","Forward","timeline","getEvent","ourEventIndex","getTimeline","getOurEventIndex","getPaginateToken","backwards","paginateTokens","setPaginateToken","addEvents","atStart","EventStatus","POLICIES_ACCOUNT_EVENT_TYPE","IGNORE_INVITES_ACCOUNT_EVENT_KEY","PolicyRecommendation","PolicyScope","synthesizeReceipt","receiptType","unthreaded","thread_id","Receipt","ReadReceipt","getReadReceiptForUserId","ignoreSynthesized","ReceiptType","Read","_this$receipts$get$ge","_this$receipts$get","realReceipt","syntheticReceipt","receipts","compareReceipts","_this$getUnfilteredTi","getEventReadUpTo","latestReceipt","getLatestReceipt","receiptPointsAtConsistentEvent","receipt","_receipt$data","MAIN_ROOM_TIMELINE","threadRootId","_ref2","publicReadReceipt","privateReadReceipt","ReadPrivate","comparison","addReceiptToStructure","synthetic","_pair$ReceiptPairSynt2","_pair$ReceiptPairSynt3","receiptTypesMap","pair","existingReceipt","_pair$ReceiptPairSynt","wrappedReceipt","ordering","preferSynthetic","cachedReceipt","receiptCacheByEventId","previousEventId","getReceiptsForEvent","fixupNotifications","lastEvent","setUnread","NotificationCountType","Total","Highlight","addLocalEchoReceipt","addReceipt","getUsersReadUpTo","isSupportedReceiptType","RelationsContainer","getChildEventsForEvent","relationType","_this$relations$get","getAllChildEventsForEvent","parentEventId","_this$relations$get2","relationsForEvent","relationsRecord","getRelations","aggregateParentEvent","relationsWithRelType","relationsWithEventType","setTargetEvent","aggregateChildEvent","isRedacted","CANCELLED","relation","getRelation","onEventDecrypted","isBeingDecrypted","shouldAttemptDecryption","relatesToEventId","_this$room","_timelineSet$findEven","Relations","relatesToEvent","getPendingEvent","addEvent","RoomReceipts","danglingReceipts","remove","danglingReceipt","threadedReceipts","unthreadedReceipts","ThreadedReceipts","ReceiptsByUser","DanglingReceipts","onTimelineEvent","receiptContent","eventReceipt","receiptsByUser","DanglingReceipt","hasUserReadEvent","isAfterOrSame","threadId","threaded","userSentLatestEventInThread","_this$room$getThread","ReceiptInfo","UserReceipts","real","receiptInfo","_this$synthetic","getByType","userReceipts","isAfter","_this$data$get","_this$data$get2","createFn","found","created","loggerInstance","RoomStickyEventsEvent","assertIsUserId","RoomStickyEventsStore","MAX_SAFE_INTEGER","removedEvents","nextStickyEventExpiryTs","innerEvents","stickyEventsMap","_this$stickyEventsMap","innerMapKey","currentEvent","previousEvents","unstableStickyExpiresAt","unkeyedStickyEvents","Update","scheduleStickyTimer","sortStickyEvent","eventA","eventB","_eventB$getId","_eventA$getId","stickyMapKey","stickyKey","getStickyEvents","innerMap","getKeyedStickyEvent","_this$stickyEventsMap2","getUnkeyedStickyEvent","addStickyEvent","_this$stickyEventsMap3","_this$stickyEventsMap4","_this$stickyEventsMap5","added","stickyEvent","currentEventSet","prevEvent","addStickyEvents","updated","previous","ex","stickyEventTimer","cleanExpiredStickyEvents","handleRedaction","redactedEvent","redactEventId","_innerMap$get","_this$stickyEventsMap6","mapKey","newEvents","RoomSummary","discoverAndValidateOIDCIssuerWellKnown","issuerOpenIdConfigUrl","issuer","issuerWellKnownResponse","issuerWellKnown","validateAuthMetadataAndKeys","validatedIssuerConfig","validateAuthMetadata","authMetadata","settings","OidcClientSettingsStore","authority","metadata","redirect_uri","client_id","metadataService","MetadataService","signingKeys","getSigningKeys","OidcError","RULEKINDS_IN_ORDER","PushRuleKind","Override","ContentSpecific","RoomSpecific","SenderSpecific","Underride","DEFAULT_OVERRIDE_RULES","rule_id","default","enabled","conditions","ConditionKind","EventPropertyIs","SenderNotificationPermission","PushRuleActionName","Notify","set_tweak","TweakName","EventMatch","pattern","DontNotify","RoomServerAcl","UserDefinedRules","EXPECTED_DEFAULT_OVERRIDE_RULE_IDS","RuleId","Master","SuppressNotices","InviteToSelf","MemberEvent","IsUserMention","ContainsDisplayName","IsRoomMention","AtRoomNotification","Tombstone","DEFAULT_UNDERRIDE_RULES","CallStarted","Sound","EXPECTED_DEFAULT_UNDERRIDE_RULE_IDS","IncomingCall","EncryptedDM","DM","Message","EncryptedMessage","mergeRulesWithDefaults","incomingRules","defaultRules","orderedRuleIds","incomingDefaultRules","rule","incomingCustomRules","insertDefaultPushRule","ruleId","newRules","nextExpectedRuleIdIndex","ruleIndex","PushProcessor","actionListToActionsObject","actionList","actionObj","notify","tweaks","action","rewriteDefaultRules","global","override","underride","getPushRuleGlobRegex","alignToWordBoundary","suffix","cacheKey","cachedGlobToRegex","RegExp","globToRegexp","updateCachedPushRuleKeys","toRemoveKeys","parsedKeys","ruleset","condition","partsForDottedKey","matchingRuleFromKindSet","kindset","rawrule","templateRuleToRaw","ruleMatchesEvent","tprule","eventFulfillsCondition","cond","eventFulfillsEventMatchCondition","eventFulfillsEventPropertyIsCondition","EventPropertyContains","eventFulfillsEventPropertyContains","eventFulfillsDisplayNameCondition","RoomMemberCount","eventFulfillsRoomMemberCountCondition","eventFulfillsSenderNotifPermCondition","CallStartedPrefix","eventFulfillsCallStartedCondition","notifLevelKey","mayTriggerNotifOfType","is","memberCount","getJoinedMemberCount","ineq","rhs","_room$currentState","getClearContent","getMember","displayName","pat","escapeRegExp","search","valueForDottedKey","regex","_cond","getPrevContent","deepCompare","escaped","parts","firstPart","currentIndex","isNullOrUndefined","matchingRuleForEventWithRulesets","rulesets","getSafeUserId","pushActionsForEventAndRulesets","highlight","_rule$conditions","supportsIntentionalMentions","ContainsUserName","actionsForEvent","pushRules","actionsAndRuleForEvent","getPushRuleById","_result$rule","getPushRuleAndKindById","_this$client$pushRule","TIMER_CHECK_PERIOD_MS","realCallbackKey","callbackList","debuglog","func","delayMs","runAt","idx","array","mid","binarySearch","el","scheduleRealCallback","first","runCallbacks","callbacksToRun","cb","RUST_SDK_STORE_PREFIX","QUEUE_MESSAGES","hasAssociation","retryAlgorithm","queueAlgorithm","queueName","peekNextEvent","queues","procFn","removeNextEvent","resolvers","processQueue","waitTimeMs","clearQueue","disableQueue","getQueueForEvent","removeEventFromQueue","removed","removeElement","element","setProcessFunction","startProcessingQueues","queueEvent","eventResolvers","activeQueues","queue","ExtensionE2EE","when","ExtensionState","PreProcess","onRequest","isInitial","markAllTrackedUsersAsDirty","onResponse","device_lists","processDeviceLists","processKeyCounts","device_one_time_keys_count","onSyncCompleted","ExtensionToDevice","cryptoCallbacks","since","nextBatch","receivedToDeviceMessages","preprocessToDeviceMessages","rawEvent","encryptionInfo","processToDeviceMessages","next_batch","ExtensionAccountData","PostProcess","processGlobalAccountData","accountDataEvents","mapEvents","addAccountData","Event","globalAccountData","prevEventsMap","getAccountData","storeAccountDataEvents","accountDataEvent","PushRules","rules","setPushRules","AccountData","ExtensionTyping","processEphemeralEvents","ExtensionReceipts","SlidingSyncSdk","slidingSync","syncOpts","defaultClientOpts","defaultSyncApiOpts","getNotifTimelineSet","TimelineReset","SlidingSyncEvent","Lifecycle","onLifecycle","RoomData","onRoomData","extensions","ext","registerExtension","roomData","_createAndReEmitRoom","processRoomData","resp","SlidingSyncState","Complete","purgeNotifications","lastPos","updateSyncState","Prepared","oldSyncToken","nextSyncToken","catchingUp","fromCache","RequestFinished","failCount","Reconnecting","shouldAbortSync","syncLeftRooms","peek","stopPeeking","setPresence","presence","getSyncState","syncState","getSyncStateData","_this$syncStateData","syncStateData","createRoom","timelineSupport","Room","lazyLoadMembers","pendingEventOrdering","Name","Redaction","RedactionCancelled","Tags","LocalEchoUpdated","MyMembership","registerStateListeners","RoomStateEvent","Events","Members","NewMember","_this$client$getUser","user","getUser","RoomMemberEvent","Typing","PowerLevel","Membership","stateEvent","required_state","origin_server_ts","ensureNameEvent","stateEvents","ephemeralEvents","limited","knownEvents","oldEvents","seenKnownEvent","recvEvent","addEventsToTimeline","prev_batch","encrypted","hasEncryptionStateEvent","notification_count","setUnreadNotificationCount","highlight_count","getUnreadNotificationCount","bump_stamp","setBumpStamp","invited_count","setInvitedMemberCount","joined_count","setJoinedMemberCount","invite_state","inviteStateEvents","injectRoomEvents","recalculate","storeRoom","_roomData$prev_batch","setPaginationToken","num_live","addEphemeralEvents","updateMyMembership","setMSC4186SummaryData","heroes","addNotifications","processRoomEvent","isState","onCryptoEvent","promiseMapSeries","decryptCriticalEvents","stateEventList","timelineEventList","numLive","liveTimeline","timelineWasEmpty","getPushActionsForEvent","initialiseState","setStateEvents","liveTimelineEvents","addLiveEvents","addToState","resolveInvites","resolveInvitesToProfiles","getMembersWithMembership","requestedProfileInfo","avatar_url","avatarUrl","displayname","getProfileInfo","inviteEvent","setMembershipEvent","_err","retryImmediately","sync","isGuest","getPushRules","newState","old","timelineEvent","pushActions","notifEvents","_this$client$getNotif","addLiveEvent","getEventMapper","ephEvents","DB_MIGRATIONS","db","createObjectStore","keyPath","createIndex","autoIncrement","VERSION","selectQuery","keyRange","resultMapper","query","openCursor","results","_query$error","cursor","continue","txnAsPromise","txn","oncomplete","reqAsEventPromise","reqAsCursorPromise","LocalIndexedDBStoreBackend","idbExists","syncAccumulator","SyncAccumulator","connect","onClose","disconnected","oldVersion","_isNewlyCreated","migration","onversionchange","_this$db","onclose","isNewlyCreated","loadAccountData","loadSyncData","accountData","syncData","accumulate","roomsData","account_data","getOutOfBandMembers","roomIndex","transaction","objectStore","range","IDBKeyRange","only","membershipEvents","oobWritten","record","oob_written","setOutOfBandMembers","tx","put","markerObject","clearOutOfBandMembers","roomRange","minStateKeyProm","openKeyCursor","primaryKey","maxStateKeyProm","minStateKey","maxStateKey","writeStore","membersKeyRange","bound","clearDatabase","_this$db2","_req$error","getSavedSync","getJSON","getNextBatchToken","setSyncData","syncToDatabase","userTuples","syncToDatabasePromise","pendingUserPresenceData","doSyncToDatabase","persistUserPresenceEvents","persistAccountData","persistSyncData","promiseTry","clobber","tuples","tuple","getUserPresenceEvents","getClientOptions","_cursor$value","storeClientOptions","resultBatch","destroy","_this$db3","StubStore","getSyncToken","fromToken","setSyncToken","getRooms","removeRoom","getRoomSummaries","storeUser","getUsers","setUserCreator","creator","storeEvents","toStart","storeFilter","getFilter","filterId","getFilterIdByName","filterName","setFilterIdByName","wantsSave","save","startup","getSavedSyncToken","deleteAllData","getPendingEvents","setPendingEvents","getRelationsThreadFilter","_e$content","_e$content2","encryptAESSecretStorageItem","ivStr","iv","aesKey","hmacKey","deriveKeys","encodedData","ciphertext","encrypt","counter","hmac","sign","mac","zeroSalt","hkdfkey","aesProm","hmacProm","PRE_HYDRA_ROOM_VERSIONS","shouldUseHydraForRoomVersion","roomVersion","audioContext","refCount","acquireContext","AudioContext","releaseContext","_audioContext","CallEventHandlerEvent","CallEventHandler","currentEventBuffer","callEventBuffer","eventBufferPromiseChain","evaluateEventBuffer","nextSeqByCall","seq","nextSeq","toDeviceEventBuffers","nextEvent","calls","candidateEventsByCall","onSync","onRoomTimeline","eventBuffer","callEvents","ignoreCallIds","CallAnswer","CallHangup","CallInvite","handleCallEvent","_getGroupCallById","ReceivedVoipEvent","callRoomId","groupCallEventHandler","getGroupCallById","conf_id","groupCallId","senderId","opponentDeviceId","groupCall","GroupCallEvent","GroupCallUnknownDeviceError","dest_session_id","getSessionId","weSentTheEvent","_this$client$getTurnS","_createNewMatrixCall","_groupCall","getLocalAge","lifetime","CallState","Ended","invitee","timeUntilTurnCresExpire","getTurnServersExpiry","createNewMatrixCall","forceTURN","opponentSessionId","sender_session_id","stats","getGroupCallStats","initStats","initWithInvite","_groupCall2","CallError","GroupCallErrorCode","UnknownDevice","onRemoteIceCandidatesReceived","existingCall","thisCall","_call$getOpponentMemb","isCalling","WaitLocalMedia","CreateOffer","InviteSent","direction","CallDirection","Outbound","getOpponentMember","replacedBy","hangup","CallErrorCode","Incoming","CallCandidates","_createNewMatrixCall2","CallReject","onHangupReceived","onRejectReceived","initWithHangup","hasPeerConnection","party_id","ourPartyId","Ringing","onAnsweredElsewhere","onAnswerReceived","CallSelectAnswer","onSelectAnswerReceived","CallNegotiate","onNegotiateReceived","CallAssertedIdentity","CallAssertedIdentityPrefix","onAssertedIdentityReceived","CallSDPStreamMetadataChanged","CallSDPStreamMetadataChangedPrefix","onSDPStreamMetadataChangedReceived","SDPStreamMetadataKey","SDPStreamMetadataPurpose","GroupCallEventHandlerEvent","GroupCallEventHandler","createGroupCallForRoom","GroupCallPrefix","currentGroupCall","groupCalls","terminate","createGroupCallFromRoomStateEvent","onRoomsChanged","onRoomStateChanged","getRoomDeferred","deferred","roomDeferreds","resolveFunc","prom","waitUntilRoomReadyForGroupCalls","sortedCallEvents","callEvent","callType","GroupCallType","GroupCallIntent","isPtt","dataChannelOptions","dataChannelsEnabled","maxPacketLifeTime","maxRetransmits","protocol","GroupCall","isVoipWithNoMediaAllowed","useLivekitForGroupCalls","CallFeedStatsReporter","buildCallFeedReport","opponentMemberId","pc","rtpTransceivers","getTransceivers","transceiver","_t$sender","track","buildTrackStats","currentDirection","callFeeds","label","_track$getSettings","_track$getConstraints","settingDeviceId","getSettings","constrainDeviceId","getConstraints","muted","readyState","expandCallFeedReport","report","feed","audioTracks","stream","getAudioTracks","videoTracks","getVideoTracks","audio","purpose","video","feedStats","isLocal","isVideoMuted","isAudioMuted","ConnectionStats","ConnectionStatsBuilder","buildBandwidthReport","availableIncomingBitrate","availableOutgoingBitrate","download","upload","TransportStatsBuilder","buildReport","conferenceStatsTransport","isFocus","localUsedCandidate","localCandidateId","remoteUsedCandidate","remoteCandidateId","ip","address","port","localIp","localCandidateType","candidateType","remoteCandidateType","networkType","rtt","currentRoundTripTime","NaN","MediaSsrcHandler","local","remote","findMidBySsrc","ssrc","ssrcToMid","ssrcs","description","sdp","parseSdp","media","_m$ssrcs","attribute","getSsrcToMidMap","MediaTrackHandler","getLocalTracks","getTackById","trackId","getLocalTrackIdByMid","_transceiver$sender","getRemoteTrackIdByMid","_transceiver$receiver","getActiveSimulcastStreams","getTransceiverByTrackId","MediaTrackStats","packetsTotal","packetsLost","isDownloadStream","concealedAudio","totalAudioDuration","setLoss","loss","getLoss","setResolution","resolution","getResolution","setFramerate","framerate","getFramerate","setBitrate","bitrate","getBitrate","setCodec","codecShortType","codec","getCodec","resetBitrate","alive","isAlive","isMuted","isEnabled","setJitter","jitter","getJitter","setAudioConcealment","concealedAudioDuration","audioConcealment","getAudioConcealment","MediaTrackStatsHandler","mediaSsrcHandler","mediaTrackHandler","findTrack2Stats","trackID","trackIdentifier","trackStats","track2stats","findLocalVideoTrackStats","getTrack2stats","findTransceiverByTrackId","ValueFormatter","getNonNegativeValue","imput","TrackStatsBuilder","buildFramerateResolution","frameHeight","frameWidth","frameRate","framesPerSecond","calculateSimulcastFramerate","before","layer","timeMs","framesSent","buildCodec","codecId","mimeType","buildBitrateReceived","calculateBitrate","bytesReceived","buildBitrateSend","bytesSent","buildPacketsLost","packetsNow","packetsBefore","packetsDiff","packetsLostNow","packetsLostBefore","packetsLostDiff","bytesNowAny","bytesBeforeAny","nowTimestamp","beforeTimestamp","bytesNow","bytesBefore","bytesProcessed","bitrateKbps","setTrackStatsState","buildTrackSummary","trackStatsList","videoTrackSummary","maxJitter","maxPacketLoss","totalAudio","audioTrackSummary","remoteTrackList","audioTrackList","trackSummary","_stats$getAudioConcea","_stats$getAudioConcea2","buildJitter","statsReport","jitterStr","buildAudioConcealment","totalSamplesDuration","totalSamplesReceived","concealedSamples","ConnectionStatsReportBuilder","build","totalPackets","lostPackets","bitrateDownload","bitrateUpload","resolutions","framerates","codecs","audioBitrateDownload","audioBitrateUpload","videoBitrateDownload","videoBitrateUpload","totalConcealedAudio","audioConcealmentForTrack","packetLoss","total","calculatePacketLoss","totalAudioConcealment","CallStatsReportGatherer","onSignalStateChange","processStats","summary","isFirstCollection","previousStatsReport","receivedMedia","receivedAudioMedia","receivedVideoMedia","statsPromise","getStats","_this$connectionStats","_this$connectionStats2","currentStatsReport","processStatsReport","handleError","connectionStats","_this$currentStatsRep","byteSentStatsReport","nominated","bandwidth","remoteSource","emitByteSendReport","emitCallFeedReport","processAndEmitConnectionStatsReport","setActive","getActive","emitConnectionStatsReport","stopProcessingStats","signalingState","currentRemoteDescription","currentLocalDescription","setOpponentMemberId","StatsReportEmitter","byteSentStats","StatsReport","BYTE_SENT_STATS","CONNECTION_STATS","CALL_FEED_REPORT","emitSummaryStatsReport","SUMMARY_STATS","GroupCallStats","interval","SummaryStatsReportGatherer","reports","timer","setInterval","clearInterval","gatherers","hasStatsReportGatherer","addStatsReportGatherer","peerConnection","removeStatsReportGatherer","getStatsReportGatherer","updateOpponentMember","opponentMember","_this$getStatsReportG","summaryStatsReportGatherer","allSummary","summaryTotalCount","peerConnectionsCount","summaryCounter","receivedAudio","receivedVideo","countTrackListReceivedMedia","countConcealedAudio","buildMaxJitter","buildMaxPacketLoss","percentageReceivedMedia","toFixed","percentageReceivedVideoMedia","percentageReceivedAudioMedia","percentageConcealedAudio","peerConnections","extendSummaryReport","callParticipants","devices","userEntry","device","opponentDevicesInCall","opponentUsersInCall","diffDevicesToPeerConnections","ratioPeerConnectionToDevices","hasReceivedAudio","hasReceivedVideo","level","Log","nopLogger","reset","setLevel","setLogger","Logger","_name","_format","_method","methodLogger","createStatic","staticMethod","staticLogger","JwtUtils","generateSignedJwt","privateKey","encodedToken","CryptoUtils","encodeBase64Url","signature","window","generateSignedJwtWithHmac","secretKey","chr","_randomWord","Uint32Array","generateUUIDv4","generateCodeVerifier","generateCodeChallenge","code_verifier","hashed","generateBasicAuth","client_secret","alg","msgUint8","hashBuffer","customCalculateJwkThumbprint","jwk","jsonObject","kty","crv","y","utf8encodedAndHashed","generateDPoPProof","httpMethod","keyPair","nonce","hashedToken","encodedHash","randomUUID","ath","publicJwk","exportKey","publicKey","generateDPoPJkt","generateDPoPKeys","generateKey","namedCurve","generateClientAssertionJwt","audience","algorithm","hashFunction","encoder","input","_callbacks","_logger","addHandler","removeHandler","lastIndexOf","raise","PopupUtils","center","features","outerWidth","left","screenX","top","screenY","outerHeight","Timer","_timerHandle","_expiration","_callback","diff","getEpochTime","cancel","durationInSeconds","expiration","timerDurationInSeconds","UrlUtils","readParams","responseMode","URL_STATE_DELIMITER","ErrorResponse","form","error_description","error_uri","userState","session_state","url_state","ErrorTimeout","AccessTokenEvents","_expiringTimer","_expiredTimer","_expiringNotificationTimeInSeconds","expiringNotificationTimeInSeconds","load","container","expires_in","duration","expiring","expired","unload","addAccessTokenExpiring","removeAccessTokenExpiring","addAccessTokenExpired","removeAccessTokenExpired","CheckSessionIFrame","_client_id","_intervalInSeconds","_stopOnError","_timer","_session_state","_message","_frame_origin","_frame","contentWindow","parsedUrl","document","createElement","style","visibility","src","onload","appendChild","send","postMessage","InMemoryWebStorage","_data","getItem","setItem","removeItem","ErrorDPoPNonce","JsonService","additionalContentTypes","_jwtHandler","_extraHeaders","_contentTypes","fetchWithTimeout","timeoutInSeconds","initFetch","timeoutId","DOMException","getJson","_appendExtraHeaders","throw","statusText","postForm","basicAuth","initCredentials","extraHeaders","responseText","customKeys","protectedHeaders","preventOverride","headerName","toLocaleLowerCase","_settings","_signingKeys","_metadata","_metadataUrl","metadataUrl","_jsonService","fetchRequestCredentials","_fetchRequestCredentials","resetSigningKeys","getMetadata","requestTimeoutInSeconds","metadataSeed","getIssuer","_getMetadataProperty","getAuthorizationEndpoint","getUserInfoEndpoint","getTokenEndpoint","optional","getCheckSessionIframe","getEndSessionEndpoint","getRevocationEndpoint","getKeysEndpoint","jwks_uri","keySet","WebStorageStateStore","localStorage","_store","_prefix","getAllKeys","substr","response_type","post_logout_redirect_uri","client_authentication","token_endpoint_auth_signing_alg","prompt","display","max_age","ui_locales","acr_values","response_mode","filterProtocolClaims","loadUserInfo","staleStateAgeInSeconds","mergeClaimsStrategy","disablePKCE","stateStore","revokeTokenAdditionalContentTypes","refreshTokenAllowedScope","extraQueryParams","extraTokenParams","dpop","omitScopeWhenRequesting","UserInfoService","_metadataService","_getClaimsFromJwt","getClaims","claims","TokenClient","exchangeCode","grant_type","clientAssertion","exchangeCredentials","exchangeRefreshToken","refresh_token","param","revoke","token_type_hint","ResponseValidator","_claimsService","_userInfoService","_tokenClient","validateSigninResponse","_processSigninState","_processCode","isOpenId","_validateIdTokenAttributes","_processClaims","skipUserInfo","validateCredentialsResponse","shouldValidateSubClaim","id_token","validateRefreshResponse","profile","hasIdToken","validateSignoutResponse","validateSub","sub","mergeClaims","tokenResponse","existingToken","incoming","auth_time","azp","State","request_type","toStorageString","fromStorageString","storageString","clearStaleState","storage","cutoff","SigninState","code_challenge","state_data","dpopJkt","optionalParams","stateParam","SigninRequest","SigninResponse","token_type","splitState","expires_at","SignoutRequest","id_token_hint","SignoutResponse","DefaultProtocolClaims","InternalRequiredProtocolClaims","ClaimsService","protocolClaims","claim","claims1","claims2","mergedValues","DPoPState","OidcClient","_validator","createSigninRequest","request_uri","login_hint","signinRequest","signinState","readSigninResponseState","removeState","storedStateString","processSigninResponse","dpopProof","getDpopProof","dpopStore","dpopState","processResourceOwnerPasswordCredentials","username","password","signinResponse","useRefreshToken","allowableScopes","createSignoutRequest","signoutState","readSignoutResponseState","processSignoutResponse","revokeToken","SessionMonitor","_userManager","_start","_sub","_checkSessionIFrame","intervalInSeconds","checkSessionIntervalInSeconds","stopOnError","stopCheckSessionOnError","checkSessionIFrame","_stop","monitorAnonymousSession","timerHandle","querySessionStatus","tmpUser","raiseEvent","_raiseUserSessionChanged","_raiseUserSignedOut","_raiseUserSignedIn","addUserLoaded","addUserUnloaded","_init","User","scopes","messageSource","AbstractChildWindow","_abort","_disposeHandlers","_window","navigate","location","keepOpen","scriptOrigin","_dispose","channel","BroadcastChannel","reason","dispose","_notifyParent","targetOrigin","msgData","DefaultPopupWindowFeatures","toolbar","closePopupWindowAfterInSeconds","DefaultPopupTarget","DefaultAccessTokenExpiringNotificationTimeInSeconds","DefaultCheckSessionIntervalInSeconds","UserManagerSettingsStore","popup_redirect_uri","popup_post_logout_redirect_uri","popupWindowFeatures","popupWindowTarget","redirectMethod","redirectTarget","iframeNotifyParentOrigin","iframeScriptOrigin","silent_redirect_uri","silentRequestTimeoutInSeconds","automaticSilentRenew","validateSubOnSilentRenew","includeIdTokenInSilentRenew","monitorSession","query_status_response_type","revokeTokenTypes","revokeTokensOnSignout","includeIdTokenInSilentSignout","accessTokenExpiringNotificationTimeInSeconds","userStore","sessionStorage","IFrameWindow","_timeoutInSeconds","createHiddenIframe","iframe","parentNode","_a","frame","removeChild","notifyParent","IFrameNavigator","prepare","PopupWindow","popupSignal","popupAbortOnClose","centeredPopup","abortOnClose","closed","focus","popupClosedInterval","clearPopupClosedInterval","notifyOpener","opener","PopupNavigator","RedirectNavigator","targetWindow","UserManagerEvents","_userLoaded","_userUnloaded","_silentRenewError","_userSignedIn","_userSignedOut","_userSessionChanged","removeUserLoaded","removeUserUnloaded","addSilentRenewError","removeSilentRenewError","_raiseSilentRenewError","addUserSignedIn","removeUserSignedIn","addUserSignedOut","removeUserSignedOut","addUserSessionChanged","removeUserSessionChanged","SilentRenewService","_isStarted","_retryTimer","_tokenExpiring","signinSilent","RefreshState","UserManager","redirectNavigator","popupNavigator","iframeNavigator","_client","_redirectNavigator","_popupNavigator","_iframeNavigator","_silentRenewService","startSilentRenew","_sessionMonitor","_loadUser","removeUser","signinRedirect","requestArgs","bind_authorization_code","handle","_signinStart","signinRedirectCallback","_signinEnd","signinResourceOwnerCredentials","_buildUser","signinPopup","_signin","signinPopupCallback","forceIframeAuth","_useRefreshToken","verifySub","signinSilentCallback","signinCallback","signoutCallback","signoutRedirectCallback","signoutPopupCallback","signoutSilentCallback","navResponse","signoutRedirect","_signoutStart","_signoutEnd","signoutPopup","_signout","_revokeInternal","signoutRequest","signoutResponse","signoutSilent","revokeTokens","typesPresent","stopSilentRenew","_userStoreKey","dpopSettings","dpopKeys","Version","IndexedDbDPoPStore","_dbName","_storeName","createStore","promisifyRequest","onabort","storeName","txMode","grammar","reg","names","u","z","rate","subtype","config","sessionConfig","raddr","tcptype","generation","maxMessageSize","dir2","clksrcExt","mediaClockValue","rateNumerator","rateDenominator","parser","writer","parseParams","parseFmtpConfig","parsePayloads","parseRemoteCandidates","parseImageAttributes","parseSimulcastStreamList","toIntIfInt","parseReg","needsBlank","keyLocation","rawName","attachProperties","validLine","l","rtp","fmtp","paramReducer","expr","candidates","component","scid","paused","formatRegExp","formatStr","makeLine","defaultOuterOrder","defaultInnerOrder","mLine","payloads","outerOrder","innerOrder","rnds8","byteToHex","unsafeStringify","_v4","buf","rnds","rng"],"sourceRoot":""}