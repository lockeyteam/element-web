{"version":3,"file":"bundles/9cacd6575f4c8ee1aedb/9483.js","mappings":"8rBAWO,MAAMA,EAKFC,WAAAA,CACaC,EACAC,EACAC,EACTC,EAAW,IACpBC,EAAAA,EAAAA,GAAA,uBATgC,IAAIC,kBAAiBD,EAAAA,EAAAA,GAAA,wBAAAA,EAAAA,EAAAA,GAAA,gBAEpC,GAAC,KAGAJ,OAAAA,EAAc,KACdC,SAAAA,EAAgB,KAChBC,SAAAA,EAAyB,KAClCC,SAAAA,CACR,CAEIG,UAAAA,CAAWC,GACdC,KAAKC,SAAWF,EAASG,OACzBF,KAAKL,SAAWI,EAASI,KAC7B,CAEOC,KAAAA,GACHJ,KAAKK,gBAAgBD,OACzB,CAEA,aAAWE,GACP,OAAON,KAAKK,gBAAgBE,OAAOC,OACvC,CAEA,SAAWL,GACP,OAAOH,KAAKL,QAChB,CAEA,UAAWO,GACP,OAAOF,KAAKC,QAChB,E,gYCfW,MAAMQ,UAA4BC,EAAAA,UAAwBnB,WAAAA,IAAAoB,GAAA,SAAAA,IAAAf,EAAAA,EAAAA,GAAA,qBAC7C,KACpBI,KAAKY,MAAMC,YAAW,MACzBjB,EAAAA,EAAAA,GAAA,qBAEuB,KACpBI,KAAKY,MAAMC,YAAW,IACzB,CAEMC,MAAAA,GACH,IAAIC,EAEAC,EACJ,GAA8B,IAA1BhB,KAAKY,MAAMK,YAAmD,IAA/BjB,KAAKY,MAAMM,SAASC,OACnDJ,GAAUK,EAAAA,EAAAA,IACN,mCACA,CACIC,OAAO1B,EAAAA,EAAAA,IAASK,KAAKY,MAAMU,gBAAgBC,kBAC3CC,gBAAgB7B,EAAAA,EAAAA,IAASK,KAAKY,MAAMM,SAAS,GAAGO,OAEpD,CACIC,EAAIC,GAAQjB,EAAAA,cAAA,cAASiB,KAG7BX,EACIN,EAAAA,cAACkB,EAAAA,EAAa,CACVC,eAAeT,EAAAA,EAAAA,IAAG,aAClBU,WAAW,EACXC,qBAAsB/B,KAAKgC,cAC3BC,OAAO,SAGZ,GAAIjC,KAAKY,MAAMK,aAAejB,KAAKY,MAAMM,SAASC,OACrDJ,GAAUK,EAAAA,EAAAA,IACN,oCACA,CACIC,OAAO1B,EAAAA,EAAAA,IAASK,KAAKY,MAAMU,gBAAgBC,mBAE/C,CACIG,EAAIC,GAAQjB,EAAAA,cAAA,cAASiB,KAG7BX,EACIN,EAAAA,cAACkB,EAAAA,EAAa,CACVC,eAAeT,EAAAA,EAAAA,IAAG,aAClBU,WAAW,EACXC,qBAAsB/B,KAAKgC,cAC3BC,OAAO,QAGZ,CACHlB,GAAUK,EAAAA,EAAAA,IACN,yCACA,CACIC,OAAO1B,EAAAA,EAAAA,IAASK,KAAKY,MAAMU,gBAAgBC,mBAE/C,CACIG,EAAIC,GAAQjB,EAAAA,cAAA,cAASiB,KAG7B,MAAMO,EAAgBlC,KAAKY,MAAMK,WAAajB,KAAKY,MAAMM,SAASC,OAClEH,EACIN,EAAAA,cAACkB,EAAAA,EAAa,CACVC,eAAeT,EAAAA,EAAAA,IAAG,qCAAsC,CAAEe,MAAOD,IACjEH,qBAAsB/B,KAAKoC,cAC3BN,WAAW,EACXO,cAAcjB,EAAAA,EAAAA,IAAG,iCACjBkB,SAAUtC,KAAKgC,cACfC,OAAO,GAGnB,CAEA,OACIvB,EAAAA,cAAC6B,EAAAA,EAAU,CACPC,UAAU,yBACV3B,WAAYb,KAAKgC,cACjBS,OAAOrB,EAAAA,EAAAA,IAAG,2BACVsB,UAAU,qBAEVhC,EAAAA,cAAA,OAAKiC,GAAG,qBACH5B,OAtET6B,GA0EK5B,EAGb,E,+vBCtDJ,MAAM6B,EAAa,CAAC,EAAM,EAAM,GAAM,GAAM,EAAM,EAAM,GAAM,GAAM,GAE7D,MAAMC,UAA4BC,OAClC,MAAMC,UAA0BD,MAC5BxD,WAAAA,CAAY0D,GACfC,QACAlD,KAAKiD,MAAQA,CACjB,EAkEJ,MAQME,EAA2B,CAAC,aAAc,aAAc,iBAU9DC,eAAeC,EAAiBC,EAA4B9D,EAAgB+D,GACxE,IAAIC,EAAgB,YACG,eAAnBD,EAAUE,OACVD,EAAgB,cAIpB,MAAME,GAAoBC,EAAAA,EAAAA,GAAeJ,GAEnCK,QAhFVR,eAAgCG,GAM5B,MAAMM,EAAM,IAAIC,MACVC,EAAYC,IAAIC,gBAAgBV,GAChCW,EAAa,IAAIC,QAAQ,CAACC,EAASC,KACrCR,EAAIS,OAAS,WACTN,IAAIO,gBAAgBR,GACpBK,EAAQP,EACZ,EACAA,EAAIW,QAAU,SAAUC,GACpBJ,EAAOI,EACX,IAEJZ,EAAIa,IAAMX,EAIV,IAAIY,EAAeR,QAAQC,SAAQ,GACZ,cAAnBb,EAAUE,OAMVkB,EAAeC,EADCrB,GAEXsB,KAAMC,IACH,MAAMC,EAAS,IAAIC,WAAWF,GACxBG,EAASC,IAAiBH,GAChC,IAAK,MAAMI,KAASF,EAChB,GAAmB,SAAfE,EAAMC,KACN,OAAID,EAAME,KAAKC,aAAezC,EAAW1B,QAClCgE,EAAME,KAAKE,MAAM,CAACC,EAAKC,IAAMD,IAAQ3C,EAAW4C,IAG/D,OAAO,IAEVC,MAAOjB,IACJkB,QAAQC,MAAM,sBAAuBnB,IAC9B,KAInB,MAAOoB,SAAe1B,QAAQ2B,IAAI,CAACnB,EAAcT,IAGjD,MAAO,CAAE6B,MAFKF,EAAQhC,EAAIkC,OAAS,EAAIlC,EAAIkC,MAE3BC,OADDH,EAAQhC,EAAImC,QAAU,EAAInC,EAAImC,OACrBnC,MAC5B,CA8B+BoC,CAAiB1C,GAEtC2C,QAAeC,EAAAA,EAAAA,GAAgBvC,EAAaC,IAAKD,EAAamC,MAAOnC,EAAaoC,OAAQxC,GAC1F4C,EAAYF,EAAOG,KAQzB,QALmBC,UADM5C,IAErB0C,EAAU,wCAA0C1C,IAInDP,EAAyBoD,SAAShD,EAAUE,MAAO,CAEpD,MAAM+C,EAAiBjD,EAAU9B,KAAO2E,EAAUK,eAAgBhF,KAClE,GAEI8B,EAAU9B,MA3CiB,OA6C1B+E,GA3C8B,OA4C3BA,GA3C8B,GA2CZjD,EAAU9B,KAGhC,cADO2E,EAA0B,eAC1BA,CAEf,CAEA,MAAMM,QAAqBC,EAAWrD,EAAc9D,EAAQ0G,EAAOU,WAInE,OAFAR,EAAyB,cAAIM,EAAaG,IAC1CT,EAA0B,eAAIM,EAAaI,KACpCV,CACX,CAwCAhD,eAAe2D,EAAiBC,GAC5B,MAAMC,QAjCV,SAA0BD,GACtB,OAAO,IAAI7C,QAAQ,CAACC,EAASC,KAEzB,MAAM4C,EAAQC,SAASC,cAAc,SACrCF,EAAMG,QAAU,WAChBH,EAAMI,OAAQ,EAEd,MAAMC,EAAS,IAAIC,WAEnBD,EAAOhD,OAAS,SAAUkD,GAAU,IAAAC,EAChCR,EAAMS,iBAAmBtE,iBACrBgB,EAAQ6C,EACZ,EACAA,EAAMzC,QAAU,SAAUC,GACtBJ,EAAOI,EACX,EAEAwC,EAAMvC,IAAe,QAAZ+C,EAAGD,EAAGG,cAAM,IAAAF,OAAA,EAATA,EAAWvB,MAC3B,EACAoB,EAAO9C,QAAU,SAAUC,GACvBJ,EAAOI,EACX,EACA6C,EAAOM,cAAcZ,IAE7B,CASwBa,CAAiBb,GACrC,MAAO,CAAEc,SAAUC,KAAKC,KAAsB,IAAjBf,EAAMa,UACvC,CAuDA,SAASG,EAAiB3E,EAA4B9D,EAAgB0I,GAClE,MAEMC,EAAuB,CAAC,EAC9B,OAlDJ,SAA0BD,GACtB,OAAO,IAAI/D,QAAQ,CAACC,EAASC,KAEzB,MAAM+D,EAAQlB,SAASC,cAAc,SACrCiB,EAAMhB,QAAU,WAChBgB,EAAMC,aAAc,EACpBD,EAAMf,OAAQ,EAEd,MAAMC,EAAS,IAAIC,WAEnBD,EAAOhD,OAAS,SAAUkD,GAAU,IAAAc,EAAAC,EAEhCH,EAAMI,aAAepF,iBACjBgB,EAAQgE,GACRA,EAAMK,OACV,EACAL,EAAM5D,QAAU,SAAUC,GACtBJ,EAAOI,EACX,EAEA,IAAIiE,EAAmB,QAAZJ,EAAGd,EAAGG,cAAM,IAAAW,OAAA,EAATA,EAAWpC,OAGd,QAAXqC,EAAIG,SAAO,IAAAH,GAAPA,EAASI,WAAW,2BACpBD,EAAUA,EAAQE,QAAQ,wBAAyB,oBAGvDR,EAAM1D,IAAMgE,EACZN,EAAMS,OACNT,EAAMU,MACV,EACAxB,EAAO9C,QAAU,SAAUC,GACvBJ,EAAOI,EACX,EACA6C,EAAOM,cAAcM,IAE7B,CAcWa,CAAiBb,GACnBrD,KAAMuD,IACHD,EAAUL,SAAWC,KAAKC,KAAsB,IAAjBI,EAAMN,WAC9B3B,EAAAA,EAAAA,GAAgBiC,EAAOA,EAAMY,WAAYZ,EAAMa,YANxC,gBAQjBpE,KAAMqB,IACHgD,OAAOC,OAAOhB,EAAWjC,EAAOG,MACzBM,EAAWrD,EAAc9D,EAAQ0G,EAAOU,aAElD/B,KAAMqB,IACHiC,EAAUiB,cAAgBlD,EAAOW,IACjCsB,EAAUkB,eAAiBnD,EAAOY,KAC3BqB,GAEnB,CAQA,SAASvD,EAAsBkC,GAC3B,OAAO,IAAI3C,QAAQ,CAACC,EAASC,KACzB,MAAMiD,EAAS,IAAIC,WACnBD,EAAOhD,OAAS,SAAUG,GAAS,IAAA6E,EAC/BlF,EAAgB,QAATkF,EAAC7E,EAAEkD,cAAM,IAAA2B,OAAA,EAARA,EAAUpD,OACtB,EACAoB,EAAO9C,QAAU,SAAUC,GACvBJ,EAAOI,EACX,EACA6C,EAAOiC,kBAAkBzC,IAEjC,CAgBO1D,eAAeuD,EAClBrD,EACA9D,EACAsH,EACA0C,EACAC,GAC+C,IAAAC,EAC/C,MAAMrJ,EAAkBoJ,QAAAA,EAAc,IAAI5J,gBAG1C,SAAkC,QAA9B6J,EAAMpG,EAAaqG,mBAAW,IAAAD,OAAA,EAAxBA,EAA0BE,0BAA0BpK,IAAS,CAEnE,MAAM6F,QAAaT,EAAsBkC,GACzC,GAAIzG,EAAgBE,OAAOC,QAAS,MAAM,IAAIsC,EAG9C,MAAM+G,QAAsBC,IAAAA,kBAA0BzE,GACtD,GAAIhF,EAAgBE,OAAOC,QAAS,MAAM,IAAIsC,EAG9C,MAAMiH,EAAO,IAAIC,KAAK,CAACH,EAAcxE,OAErC,IAAIwB,EACJ,MACOoD,YAAapD,SAAcvD,EAAa4G,cAAcH,EAAM,CAC3DP,kBACAnJ,kBACA8J,iBAAiB,EACjB1G,KAAM,6BAEd,CAAE,MAAOgB,GACL,GAAIpE,EAAgBE,OAAOC,QAAS,MAAM,IAAIsC,EAE9C,MADA6C,QAAQC,MAAM,wBAAyBnB,GACjC,IAAIzB,EAAkByB,EAChC,CACA,GAAIpE,EAAgBE,OAAOC,QAAS,MAAM,IAAIsC,EAI9C,MAAO,CACHgE,KAAIsD,EAAAA,EAAA,GACGP,EAAcxD,MAAI,IACrBQ,QAGZ,CAAO,CACH,IAAIA,EACJ,MACOoD,YAAapD,SAAcvD,EAAa4G,cAAcpD,EAAM,CAAE0C,kBAAiBnJ,oBACtF,CAAE,MAAOoE,GACL,GAAIpE,EAAgBE,OAAOC,QAAS,MAAM,IAAIsC,EAE9C,MADA6C,QAAQC,MAAM,wBAAyBnB,GACjC,IAAIzB,EAAkByB,EAChC,CACA,GAAIpE,EAAgBE,OAAOC,QAAS,MAAM,IAAIsC,EAE9C,MAAO,CAAE+D,MACb,CACJ,CAEe,MAAMwD,EAAgB9K,WAAAA,IAAAK,EAAAA,EAAAA,GAAA,kBACE,KAAEA,EAAAA,EAAAA,GAAA,mBACM,KAAI,CAExC0K,wBAAAA,CACHzD,EACArH,EACA+K,EACAlE,EACAmE,EACAlH,GAEA,OAAOmH,EAAAA,EAAAA,GACHjL,EACCkL,GAAyBpH,EAAaqH,mBAAmBD,EAAcH,EAAU1D,EAAKR,EAAMmE,GAC7FlH,GACFoC,MAAOjB,IAEL,MADAmG,EAAAA,GAAOC,KAAK,mCAAmChE,aAAerH,IAAUiF,GAClEA,GAEd,CAEOlD,cAAAA,GAAgC,IAAAuJ,EAAAC,EACnC,OAA0C,QAA1CD,EAAuB,QAAvBC,EAAO/K,KAAKgL,mBAAW,IAAAD,OAAA,EAAhBA,EAAmB,wBAAgB,IAAAD,EAAAA,EAAI,IAClD,CAYA,2BAAaG,CACTC,EACA1L,EACAE,EACAyL,EACA7H,EACA8H,EAAUC,EAAAA,GAAsBC,MAEhC,GAAIhI,EAAaiI,UAEb,YADAC,EAAAA,EAAIC,SAAS,CAAEC,OAAQ,yBAI3B,IAAK1L,KAAKgL,YAAa,CAEnB,MAAMW,EAAQC,EAAAA,GAAMC,aAAaC,EAAAA,OAASxF,EAAW,qBAErD,SADMnC,QAAQ4H,KAAK,CAAC/L,KAAKgM,yBAAyB1I,GAAeqI,EAAMM,YAClEjM,KAAKgL,YAEN,OAEAW,EAAMO,OAEd,CAEA,MAAMC,EAAsB,GACtBC,EAAkB,GAExB,IAAK,MAAMtF,KAAQoE,EACXlL,KAAKqM,qBAAqBvF,GAC1BsF,EAAQE,KAAKxF,GAEbqF,EAAYG,KAAKxF,GAIzB,GAAIqF,EAAYhL,OAAS,EAAG,CACxB,MAAM,SAAE8K,GAAaL,EAAAA,GAAMC,aAAapL,EAAqB,CACzDS,SAAUiL,EACVlL,WAAYiK,EAAM/J,OAClBG,gBAAiBtB,QAEduM,SAAwBN,EAC/B,IAAKM,EAAgB,MACzB,CAEA,IAAIC,GAAY,EAGZC,EAA2BtI,QAAQC,UACvC,IAAK,IAAIqB,EAAI,EAAGA,EAAI2G,EAAQjL,SAAUsE,EAAG,CACrC,MAAMqB,EAAOsF,EAAQ3G,GACfiH,EAAoBD,EAE1B,IAAKD,EAAW,CACZ,MAAM,SAAEP,GAAaL,EAAAA,GAAMC,aAAac,EAAAA,EAAqB,CACzD7F,OACA8F,aAAcnH,EACdxE,WAAYmL,EAAQjL,UAEjBoL,EAAgBM,SAAyBZ,EAChD,IAAKM,EAAgB,MACjBM,IACAL,GAAY,EAEpB,CAEAC,GAAahC,EAAAA,EAAAA,GACTjL,EACCkL,GACG1K,KAAK8M,kBACDhG,EACA4D,EACAhL,EACA4D,EACA6H,QAAAA,OAAgB7E,EAChBoG,GAERpJ,EAER,CAEI6H,GAEAK,EAAAA,EAAIC,SAAS,CACTC,OAAQ,iBACRqB,MAAO,KACP3B,YAKRI,EAAAA,EAAIC,SAAS,CACTC,OAAQsB,EAAAA,EAAOC,yBACf7B,WAER,CAEO8B,iBAAAA,CAAkBxN,GACrB,OAAOM,KAAKmN,WAAWC,OAAQC,IAC3B,MAAMC,GAAc5N,IAAa2N,EAAW3N,SACtC6N,EACF7N,GACA2N,EAAW3N,UACXA,EAAS8N,WAAaH,EAAW3N,SAAS8N,UAC1C9N,EAAS+N,WAAaJ,EAAW3N,SAAS+N,SAE9C,OAAQH,GAAcC,KAAsBF,EAAW/M,WAE/D,CAEOoN,YAAAA,CAAaC,GAChBA,EAAOvN,QACPoL,EAAAA,EAAIC,SAAgC,CAAEC,OAAQsB,EAAAA,EAAOY,eAAgBD,UACzE,CAEA,uBAAab,CACThG,EACAtH,EACAE,EACA4D,EACA6H,EACAsB,GAEA,MAAMhN,EAAWqH,EAAK1B,OAAQhE,EAAAA,EAAAA,IAAG,qBAC3ByM,EAA+E,CACjFC,KAAMrO,EACN4G,KAAM,CACF5E,KAAMqF,EAAKrF,MAEfsM,QAASC,EAAAA,QAAQC,OAIrBC,EAAAA,EAAAA,GAAe5K,EAAa6K,gBAAiBN,EAAS,KAAM1C,IAC5DiD,EAAAA,EAAAA,GAAeP,EAASnO,GACpByL,IACAkD,EAAAA,EAAAA,IAAyBR,EAAS1C,GAGlCmD,EAAAA,EAAcC,SAAS,8CACvBC,EAAAA,EAAAA,GAAyBX,GAIzB/G,EAAKrD,OACLoK,EAAQxH,KAAKoI,SAAW3H,EAAKrD,MAGjC,MAAMkK,EAAS,IAAIrO,EAAWE,EAAQC,EAAUC,EAAUoH,EAAKrF,MAC/DzB,KAAKmN,WAAWb,KAAKqB,GACrBnC,EAAAA,EAAIC,SAA+B,CAAEC,OAAQsB,EAAAA,EAAO0B,cAAef,WAOnE,IACI,GAAI7G,EAAKrD,KAAKkF,WAAW,UAAW,CAChCkF,EAAQE,QAAUC,EAAAA,QAAQlK,MAC1B,IACI,MAAMsC,QAAkB/C,EAAiBC,EAAc9D,EAAQsH,GAC/DoC,OAAOC,OAAO0E,EAAQxH,KAAMD,EAChC,CAAE,MAAO3B,GACL,GAAIA,aAAazB,EAEb,MAAMyB,EAGVmG,EAAAA,GAAOhF,MAAMnB,GACboJ,EAAQE,QAAUC,EAAAA,QAAQC,IAC9B,CACJ,MAAO,GAAInH,EAAKrD,KAAKkF,WAAW,UAAW,CACvCkF,EAAQE,QAAUC,EAAAA,QAAQW,MAC1B,IACI,MAAMC,QAAkB7H,EAAiBD,GACzCoC,OAAOC,OAAO0E,EAAQxH,KAAMuI,EAChC,CAAE,MAAOnK,GAELmG,EAAAA,GAAOhF,MAAMnB,GACboJ,EAAQE,QAAUC,EAAAA,QAAQC,IAC9B,CACJ,MAAO,GAAInH,EAAKrD,KAAKkF,WAAW,UAAW,CACvCkF,EAAQE,QAAUC,EAAAA,QAAQa,MAC1B,IACI,MAAM1G,QAAkBF,EAAiB3E,EAAc9D,EAAQsH,GAC/DoC,OAAOC,OAAO0E,EAAQxH,KAAM8B,EAChC,CAAE,MAAO1D,GAELmG,EAAAA,GAAOhF,MAAMnB,GACboJ,EAAQE,QAAUC,EAAAA,QAAQC,IAC9B,CACJ,MACIJ,EAAQE,QAAUC,EAAAA,QAAQC,KAG9B,GAAIN,EAAOrN,UAAW,MAAM,IAAIwC,EAChC,MAAMoD,QAAeS,EAAWrD,EAAc9D,EAAQsH,EA7C1D,SAAoB/G,GAChB4N,EAAO7N,WAAWC,GAClByL,EAAAA,EAAIC,SAAgC,CAAEC,OAAQsB,EAAAA,EAAO8B,eAAgBnB,UACzE,EA0C4EA,EAAOtN,iBAI/E,GAHAwN,EAAQ/G,KAAOZ,EAAOY,KACtB+G,EAAQhH,IAAMX,EAAOW,IAEjB8G,EAAOrN,UAAW,MAAM,IAAIwC,EAIhC,GAFI2J,SAAkBA,EAElBkB,EAAOrN,UAAW,MAAM,IAAIwC,EAChC,MAAMyH,GAAW7K,aAAQ,EAARA,EAAU8N,YAAauB,EAAAA,qBAAqB3J,KAAO1F,EAAS+N,SAAW,KAElFuB,QAAiB1L,EAAa2L,YAAYzP,EAAQ+K,QAAAA,EAAY,KAAMsD,GAEtES,EAAAA,EAAcC,SAAS,8CACvBW,EAAAA,EAAAA,GAAoB5L,EAAc9D,EAAQwP,EAASvB,UAGvDjC,EAAAA,EAAIC,SAAgC,CAAEC,OAAQsB,EAAAA,EAAOmC,eAAgBxB,WACrEnC,EAAAA,EAAIC,SAAS,CAAEC,OAAQ,gBAC3B,CAAE,MAAO9F,GAEL,MAAMwJ,EAAiBxJ,aAAiB5C,GAAqB4C,EAAM3C,MAAQ2C,EAAM3C,MAAQ2C,EAQzF,GAJIwJ,aAA0BC,EAAAA,WAA2C,MAA9BD,EAAeE,aACtDtP,KAAKgL,YAAc,OAGlB2C,EAAOrN,UAAW,CACnB,IAAIiP,GAAOnO,EAAAA,EAAAA,IAAG,wBAAyB,CAAE3B,SAAUkO,EAAOlO,WACtD2P,aAA0BC,EAAAA,WAA2C,MAA9BD,EAAeE,aACtDC,GAAOnO,EAAAA,EAAAA,IAAG,qBAAsB,CAC5B3B,SAAUkO,EAAOlO,YAGzBmM,EAAAA,GAAMC,aAAa2D,EAAAA,EAAa,CAC5B/M,OAAOrB,EAAAA,EAAAA,IAAG,uBACVqO,YAAaF,IAEjB/D,EAAAA,EAAIC,SAA6B,CAAEC,OAAQsB,EAAAA,EAAO0C,aAAc/B,SAAQ/H,SAC5E,CACJ,CAAE,SACE+J,EAAAA,EAAAA,IAAc3P,KAAKmN,WAAa1I,GAAMA,EAAEmL,UAAYjC,EAAOiC,QAC/D,CACJ,CAEQvD,oBAAAA,CAAqBvF,GAAqB,IAAA+I,EAC9C,aAA4CvJ,KAAxB,QAAhBuJ,EAAA7P,KAAKgL,mBAAW,IAAA6E,OAAA,EAAhBA,EAAmB,mBAAkC/I,EAAKrF,KAAOzB,KAAKgL,YAAY,iBAI1F,CAEQgB,wBAAAA,CAAyB1I,GAC7B,OAAyB,OAArBtD,KAAKgL,YAA6B7G,QAAQC,WAE9CwG,EAAAA,GAAOkF,IAAI,2BACJxM,EACFyM,iBACAlL,KAAMmL,IACHpF,EAAAA,GAAOkF,IAAI,iCAAkCE,GACtCA,IAEVtK,MAAM,KAEHkF,EAAAA,GAAOkF,IAAI,mEACJ,CAAC,IAEXjL,KAAMmL,IACHhQ,KAAKgL,YAAcgF,IAE/B,CAEA,qBAAcC,GAIV,YAHiC3J,IAA7B4J,OAAOC,oBACPD,OAAOC,kBAAoB,IAAI9F,GAE5B6F,OAAOC,iBAClB,E,4DC7rBG,SAAS3B,EAAyBX,GACrCA,EAAQ,kCAAoC,CACxCuC,YAAaC,KAAKC,MAE1B,CASO,SAASpB,EAAoBqB,EAAsBC,EAAkBC,GAExEF,EAAOG,UAAUF,EAAU,gCAAiC,CACxD,iCAAkC,CAC9BC,WAAYA,EACZE,WAAYN,KAAKC,MACjBM,KAAM,cAGlB,C,8ECrCA,IAAIC,EAAQ,EAAQ,kEAEpBC,EAAOC,QASP,SAAwB1L,GACtB,GAAgB,MAAZA,EAAK,GAAa,MAAM,IAAItC,MAAM,4BACtC,GAAgB,KAAZsC,EAAK,GAAa,MAAM,IAAItC,MAAM,4BACtC,GAAgB,KAAZsC,EAAK,GAAa,MAAM,IAAItC,MAAM,4BACtC,GAAgB,KAAZsC,EAAK,GAAa,MAAM,IAAItC,MAAM,4BACtC,GAAgB,KAAZsC,EAAK,GAAa,MAAM,IAAItC,MAAM,iFACtC,GAAgB,KAAZsC,EAAK,GAAa,MAAM,IAAItC,MAAM,iFACtC,GAAgB,KAAZsC,EAAK,GAAa,MAAM,IAAItC,MAAM,4BACtC,GAAgB,KAAZsC,EAAK,GAAa,MAAM,IAAItC,MAAM,iFAEtC,IAAIiO,GAAQ,EACR/L,EAAS,GACTgM,EAAM,EAEV,KAAOA,EAAM5L,EAAKlE,QAAQ,CAGxB+P,EAAM,GAAK7L,EAAK4L,KAChBC,EAAM,GAAK7L,EAAK4L,KAChBC,EAAM,GAAK7L,EAAK4L,KAChBC,EAAM,GAAK7L,EAAK4L,KAGhB,IAAI9P,EAASgQ,EAAO,GAAK,EACrBhM,EAAQ,IAAIH,WAAW7D,GAC3BgE,EAAM,GAAKE,EAAK4L,KAChB9L,EAAM,GAAKE,EAAK4L,KAChB9L,EAAM,GAAKE,EAAK4L,KAChB9L,EAAM,GAAKE,EAAK4L,KAGhB,IAAI7L,EACFgM,OAAOC,aAAalM,EAAM,IAC1BiM,OAAOC,aAAalM,EAAM,IAC1BiM,OAAOC,aAAalM,EAAM,IAC1BiM,OAAOC,aAAalM,EAAM,IAI5B,IAAKF,EAAO9D,QAAmB,SAATiE,EACpB,MAAM,IAAIrC,MAAM,uBAKlB,GAAa,SAATqC,EAAiB,CACnB4L,GAAQ,EACR/L,EAAOqH,KAAK,CACVlH,KAAMA,EACNC,KAAM,IAAIL,WAAW,KAGvB,KACF,CAGA,IAAK,IAAIS,EAAI,EAAGA,EAAItE,EAAQsE,IAC1BN,EAAMM,GAAKJ,EAAK4L,KAKlBC,EAAM,GAAK7L,EAAK4L,KAChBC,EAAM,GAAK7L,EAAK4L,KAChBC,EAAM,GAAK7L,EAAK4L,KAChBC,EAAM,GAAK7L,EAAK4L,KAEhB,IAAIK,EAAYC,EAAM,GAEtB,GADgBV,EAAMW,IAAIrM,KACRmM,EAChB,MAAM,IAAIvO,MACR,kBAAoBqC,EAAO,sDAM/B,IAAIqM,EAAY,IAAIzM,WAAWG,EAAMJ,OAAO2M,MAAM,IAElDzM,EAAOqH,KAAK,CACVlH,KAAMA,EACNC,KAAMoM,GAEV,CAEA,IAAKT,EACH,MAAM,IAAIjO,MAAM,yDAGlB,OAAOkC,CACT,EA9FA,IAAIiM,EAAQ,IAAIlM,WAAW,GACvBuM,EAAQ,IAAII,WAAWT,EAAMnM,QAC7BoM,EAAS,IAAIS,YAAYV,EAAMnM,O,wECPnC,IACW8M,IAgBT,SAASC,GACXA,EAAMC,QAAU,QAqBhB,IAAIC,EAnBJ,WAGC,IAFA,IAAIC,EAAI,EAAGD,EAAQ,IAAIE,MAAM,KAErBC,EAAG,EAAQ,KAALA,IAAYA,EASzBF,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAIE,IACW,UAAaF,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,EAC/CD,EAAMG,GAAKF,EAGZ,MAA6B,oBAAfN,WAA6B,IAAIA,WAAWK,GAASA,CACpE,CAEYI,GAERC,EAA+B,oBAAXC,OAwBxB,SAASC,EAAYf,GACpB,IAAI,IAAIgB,GAAO,EAAG/M,EAAI,EAAGgN,EAAEjB,EAAIrQ,OAAO,EAAGsE,EAAIgN,GAQ5CD,GADAA,GADAA,GADAA,GADAA,GADAA,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,OAEpC,KAAMA,EAAIgN,EAAE,GAAGD,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIhB,EAAI/L,OAClD,OAAc,EAAP+M,CACR,CAyBAV,EAAME,MAAQA,EACdF,EAAMY,KA9DN,SAAoBA,GACnB,GAAGA,EAAKvR,OAAS,OAAUkR,EAAY,OAAOE,EAAY,IAAID,OAAOI,IAErE,IADA,IAAIF,GAAO,EAAGC,EAAIC,EAAKvR,OAAS,EACxBsE,EAAI,EAAGA,EAAIgN,GAClBD,EAAOR,EAAqC,KAA9BQ,EAAME,EAAKC,WAAWlN,OAAiB+M,IAAQ,EAC7DA,EAAOR,EAAqC,KAA9BQ,EAAME,EAAKC,WAAWlN,OAAiB+M,IAAQ,EAG9D,OADG/M,IAAMgN,IAAGD,EAAOA,IAAQ,EAAKR,EAAmC,KAA5BQ,EAAME,EAAKC,WAAWlN,OAC/C,EAAP+M,CACR,EAsDAV,EAAMN,IApDN,SAAmBA,GAClB,GAAGA,EAAIrQ,OAAS,IAAO,OAAOoR,EAAYf,GAC1C,IAAI,IAAIgB,GAAO,EAAG/M,EAAI,EAAGgN,EAAEjB,EAAIrQ,OAAO,EAAGsE,EAAIgN,GAI5CD,GADAA,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,UACpB,EAAKuM,EAAqB,KAAdQ,EAAIhB,EAAI/L,OAEpC,KAAMA,EAAIgN,EAAE,GAAGD,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIhB,EAAI/L,OAClD,OAAc,EAAP+M,CACR,EA2CAV,EAAMc,IAzBN,SAAmBA,GAClB,IAAI,IAAmCX,EAAGY,EAAlCL,GAAO,EAAG/M,EAAI,EAAGgN,EAAEG,EAAIzR,OAAcsE,EAAIgN,IAChDR,EAAIW,EAAID,WAAWlN,MACZ,IACN+M,EAAOA,IAAQ,EAAKR,EAAkB,KAAXQ,EAAMP,IACxBA,EAAI,KAEbO,GADAA,EAAOA,IAAQ,EAAKR,EAAkC,KAA3BQ,GAAO,IAAMP,GAAG,EAAG,SAC/B,EAAKD,EAA6B,KAAtBQ,GAAO,IAAO,GAAFP,KAC9BA,GAAK,OAAUA,EAAI,OAC5BA,EAAa,IAAN,KAAFA,GAAYY,EAA0B,KAAtBD,EAAID,WAAWlN,KAIpC+M,GADAA,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAiC,KAA1BQ,GAAO,IAAMP,GAAG,EAAG,QAC/B,EAAKD,EAAkC,KAA3BQ,GAAO,IAAMP,GAAG,EAAG,SAC/B,EAAKD,EAAwC,KAAjCQ,GAAO,IAAMK,GAAG,EAAG,GAAO,EAAFZ,QACpC,EAAKD,EAA6B,KAAtBQ,GAAO,IAAO,GAAFK,MAIvCL,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAmC,KAA5BQ,GAAO,IAAMP,GAAG,GAAI,SAChC,EAAKD,EAAkC,KAA3BQ,GAAO,IAAMP,GAAG,EAAG,SAC/B,EAAKD,EAA6B,KAAtBQ,GAAO,IAAO,GAAFP,KAGzC,OAAc,EAAPO,CACR,CAKA,EAzGiC,oBAAtBM,kBAERjB,EAAQd,GAWTc,EAAgB,CAAC,E","sources":["webpack://element-web/./src/models/RoomUpload.ts","webpack://element-web/./src/components/views/dialogs/UploadFailureDialog.tsx","webpack://element-web/./src/ContentMessages.ts","webpack://element-web/./src/sendTimePerformanceMetrics.ts","webpack://element-web/./node_modules/png-chunks-extract/index.js","webpack://element-web/./node_modules/png-chunks-extract/node_modules/crc-32/crc32.js"],"sourcesContent":["/*\nCopyright 2024 New Vector Ltd.\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type IEventRelation, type UploadProgress } from \"matrix-js-sdk/src/matrix\";\nimport { type EncryptedFile } from \"matrix-js-sdk/src/types\";\n\nexport class RoomUpload {\n    public readonly abortController = new AbortController();\n    public promise?: Promise<{ url?: string; file?: EncryptedFile }>;\n    private uploaded = 0;\n\n    public constructor(\n        public readonly roomId: string,\n        public readonly fileName: string,\n        public readonly relation?: IEventRelation,\n        public fileSize = 0,\n    ) {}\n\n    public onProgress(progress: UploadProgress): void {\n        this.uploaded = progress.loaded;\n        this.fileSize = progress.total;\n    }\n\n    public abort(): void {\n        this.abortController.abort();\n    }\n\n    public get cancelled(): boolean {\n        return this.abortController.signal.aborted;\n    }\n\n    public get total(): number {\n        return this.fileSize;\n    }\n\n    public get loaded(): number {\n        return this.uploaded;\n    }\n}\n","/*\nCopyright 2019-2024 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport React from \"react\";\n\nimport { _t } from \"../../../languageHandler\";\nimport type ContentMessages from \"../../../ContentMessages\";\nimport BaseDialog from \"./BaseDialog\";\nimport DialogButtons from \"../elements/DialogButtons\";\nimport { fileSize } from \"../../../utils/FileUtils\";\n\ninterface IProps {\n    badFiles: File[];\n    totalFiles: number;\n    contentMessages: ContentMessages;\n    onFinished(upload?: boolean): void;\n}\n\n/*\n * Tells the user about files we know cannot be uploaded before we even try uploading\n * them. This is named fairly generically but the only thing we check right now is\n * the size of the file.\n */\nexport default class UploadFailureDialog extends React.Component<IProps> {\n    private onCancelClick = (): void => {\n        this.props.onFinished(false);\n    };\n\n    private onUploadClick = (): void => {\n        this.props.onFinished(true);\n    };\n\n    public render(): React.ReactNode {\n        let message;\n        let preview;\n        let buttons;\n        if (this.props.totalFiles === 1 && this.props.badFiles.length === 1) {\n            message = _t(\n                \"upload_file|error_file_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                    sizeOfThisFile: fileSize(this.props.badFiles[0].size),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"action|ok\")}\n                    hasCancel={false}\n                    onPrimaryButtonClick={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        } else if (this.props.totalFiles === this.props.badFiles.length) {\n            message = _t(\n                \"upload_file|error_files_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"action|ok\")}\n                    hasCancel={false}\n                    onPrimaryButtonClick={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        } else {\n            message = _t(\n                \"upload_file|error_some_files_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            const howManyOthers = this.props.totalFiles - this.props.badFiles.length;\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"upload_file|upload_n_others_button\", { count: howManyOthers })}\n                    onPrimaryButtonClick={this.onUploadClick}\n                    hasCancel={true}\n                    cancelButton={_t(\"upload_file|cancel_all_button\")}\n                    onCancel={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        }\n\n        return (\n            <BaseDialog\n                className=\"mx_UploadFailureDialog\"\n                onFinished={this.onCancelClick}\n                title={_t(\"upload_file|error_title\")}\n                contentId=\"mx_Dialog_content\"\n            >\n                <div id=\"mx_Dialog_content\">\n                    {message}\n                    {preview}\n                </div>\n\n                {buttons}\n            </BaseDialog>\n        );\n    }\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2020 The Matrix.org Foundation C.I.C.\nCopyright 2019 New Vector Ltd\nCopyright 2015, 2016 OpenMarket Ltd\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport {\n    type MatrixClient,\n    MsgType,\n    HTTPError,\n    type IEventRelation,\n    type ISendEventResponse,\n    type MatrixEvent,\n    type UploadOpts,\n    type UploadProgress,\n    THREAD_RELATION_TYPE,\n} from \"matrix-js-sdk/src/matrix\";\nimport {\n    type ImageInfo,\n    type AudioInfo,\n    type VideoInfo,\n    type EncryptedFile,\n    type MediaEventContent,\n    type MediaEventInfo,\n} from \"matrix-js-sdk/src/types\";\nimport encrypt from \"matrix-encrypt-attachment\";\nimport extractPngChunks from \"png-chunks-extract\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport { removeElement } from \"matrix-js-sdk/src/utils\";\n\nimport dis from \"./dispatcher/dispatcher\";\nimport { _t } from \"./languageHandler\";\nimport Modal from \"./Modal\";\nimport Spinner from \"./components/views/elements/Spinner\";\nimport { Action } from \"./dispatcher/actions\";\nimport {\n    type UploadCanceledPayload,\n    type UploadErrorPayload,\n    type UploadFinishedPayload,\n    type UploadProgressPayload,\n    type UploadStartedPayload,\n} from \"./dispatcher/payloads/UploadPayload\";\nimport { RoomUpload } from \"./models/RoomUpload\";\nimport SettingsStore from \"./settings/SettingsStore\";\nimport { decorateStartSendingTime, sendRoundTripMetric } from \"./sendTimePerformanceMetrics\";\nimport { TimelineRenderingType } from \"./contexts/RoomContext\";\nimport { addReplyToMessageContent } from \"./utils/Reply\";\nimport ErrorDialog from \"./components/views/dialogs/ErrorDialog\";\nimport UploadFailureDialog from \"./components/views/dialogs/UploadFailureDialog\";\nimport UploadConfirmDialog from \"./components/views/dialogs/UploadConfirmDialog\";\nimport { createThumbnail } from \"./utils/image-media\";\nimport { attachMentions, attachRelation } from \"./utils/messages.ts\";\nimport { doMaybeLocalRoomAction } from \"./utils/local-room\";\nimport { blobIsAnimated } from \"./utils/Image.ts\";\n\n// scraped out of a macOS hidpi (5660ppm) screenshot png\n//                  5669 px (x-axis)      , 5669 px (y-axis)      , per metre\nconst PHYS_HIDPI = [0x00, 0x00, 0x16, 0x25, 0x00, 0x00, 0x16, 0x25, 0x01];\n\nexport class UploadCanceledError extends Error {}\nexport class UploadFailedError extends Error {\n    public constructor(cause: any) {\n        super();\n        this.cause = cause;\n    }\n}\n\ninterface IMediaConfig {\n    \"m.upload.size\"?: number;\n}\n\n/**\n * Load a file into a newly created image element.\n *\n * @param {File} imageFile The file to load in an image element.\n * @return {Promise} A promise that resolves with the html image element.\n */\nasync function loadImageElement(imageFile: File): Promise<{\n    width: number;\n    height: number;\n    img: HTMLImageElement;\n}> {\n    // Load the file into an html element\n    const img = new Image();\n    const objectUrl = URL.createObjectURL(imageFile);\n    const imgPromise = new Promise((resolve, reject) => {\n        img.onload = function (): void {\n            URL.revokeObjectURL(objectUrl);\n            resolve(img);\n        };\n        img.onerror = function (e): void {\n            reject(e);\n        };\n    });\n    img.src = objectUrl;\n\n    // check for hi-dpi PNGs and fudge display resolution as needed.\n    // this is mainly needed for macOS screencaps\n    let parsePromise = Promise.resolve(false);\n    if (imageFile.type === \"image/png\") {\n        // in practice macOS happens to order the chunks so they fall in\n        // the first 0x1000 bytes (thanks to a massive ICC header).\n        // Thus we could slice the file down to only sniff the first 0x1000\n        // bytes (but this makes extractPngChunks choke on the corrupt file)\n        const headers = imageFile; //.slice(0, 0x1000);\n        parsePromise = readFileAsArrayBuffer(headers)\n            .then((arrayBuffer) => {\n                const buffer = new Uint8Array(arrayBuffer);\n                const chunks = extractPngChunks(buffer);\n                for (const chunk of chunks) {\n                    if (chunk.name === \"pHYs\") {\n                        if (chunk.data.byteLength !== PHYS_HIDPI.length) return false;\n                        return chunk.data.every((val, i) => val === PHYS_HIDPI[i]);\n                    }\n                }\n                return false;\n            })\n            .catch((e) => {\n                console.error(\"Failed to parse PNG\", e);\n                return false;\n            });\n    }\n\n    const [hidpi] = await Promise.all([parsePromise, imgPromise]);\n    const width = hidpi ? img.width >> 1 : img.width;\n    const height = hidpi ? img.height >> 1 : img.height;\n    return { width, height, img };\n}\n\n// Minimum size for image files before we generate a thumbnail for them.\nconst IMAGE_SIZE_THRESHOLD_THUMBNAIL = 1 << 15; // 32KB\n// Minimum size improvement for image thumbnails, if both are not met then don't bother uploading thumbnail.\nconst IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE = 1 << 16; // 1MB\nconst IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT = 0.1; // 10%\n// We don't apply these thresholds to video thumbnails as a poster image is always useful\n// and videos tend to be much larger.\n\n// Image mime types for which to always include a thumbnail for even if it is larger than the input for wider support.\nconst ALWAYS_INCLUDE_THUMBNAIL = [\"image/avif\", \"image/webp\", \"image/svg+xml\"];\n\n/**\n * Read the metadata for an image file and create and upload a thumbnail of the image.\n *\n * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.\n * @param {String} roomId The ID of the room the image will be uploaded in.\n * @param {File} imageFile The image to read and thumbnail.\n * @return {Promise} A promise that resolves with the attachment info.\n */\nasync function infoForImageFile(matrixClient: MatrixClient, roomId: string, imageFile: File): Promise<ImageInfo> {\n    let thumbnailType = \"image/png\";\n    if (imageFile.type === \"image/jpeg\") {\n        thumbnailType = \"image/jpeg\";\n    }\n\n    // We don't await this immediately so it can happen in the background\n    const isAnimatedPromise = blobIsAnimated(imageFile);\n\n    const imageElement = await loadImageElement(imageFile);\n\n    const result = await createThumbnail(imageElement.img, imageElement.width, imageElement.height, thumbnailType);\n    const imageInfo = result.info;\n\n    const isAnimated = await isAnimatedPromise;\n    if (isAnimated !== undefined) {\n        imageInfo[\"org.matrix.msc4230.is_animated\"] = await isAnimatedPromise;\n    }\n\n    // For lesser supported image types, always include the thumbnail even if it is larger\n    if (!ALWAYS_INCLUDE_THUMBNAIL.includes(imageFile.type)) {\n        // we do all sizing checks here because we still rely on thumbnail generation for making a blurhash from.\n        const sizeDifference = imageFile.size - imageInfo.thumbnail_info!.size!;\n        if (\n            // image is small enough already\n            imageFile.size <= IMAGE_SIZE_THRESHOLD_THUMBNAIL ||\n            // thumbnail is not sufficiently smaller than original\n            (sizeDifference <= IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE &&\n                sizeDifference <= imageFile.size * IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT)\n        ) {\n            delete imageInfo[\"thumbnail_info\"];\n            return imageInfo;\n        }\n    }\n\n    const uploadResult = await uploadFile(matrixClient, roomId, result.thumbnail);\n\n    imageInfo[\"thumbnail_url\"] = uploadResult.url;\n    imageInfo[\"thumbnail_file\"] = uploadResult.file;\n    return imageInfo;\n}\n\n/**\n * Load a file into a newly created audio element and load the metadata\n *\n * @param {File} audioFile The file to load in an audio element.\n * @return {Promise} A promise that resolves with the audio element.\n */\nfunction loadAudioElement(audioFile: File): Promise<HTMLAudioElement> {\n    return new Promise((resolve, reject) => {\n        // Load the file into a html element\n        const audio = document.createElement(\"audio\");\n        audio.preload = \"metadata\";\n        audio.muted = true;\n\n        const reader = new FileReader();\n\n        reader.onload = function (ev): void {\n            audio.onloadedmetadata = async function (): Promise<void> {\n                resolve(audio);\n            };\n            audio.onerror = function (e): void {\n                reject(e);\n            };\n\n            audio.src = ev.target?.result as string;\n        };\n        reader.onerror = function (e): void {\n            reject(e);\n        };\n        reader.readAsDataURL(audioFile);\n    });\n}\n\n/**\n * Read the metadata for an audio file.\n *\n * @param {File} audioFile The audio to read.\n * @return {Promise} A promise that resolves with the attachment info.\n */\nasync function infoForAudioFile(audioFile: File): Promise<AudioInfo> {\n    const audio = await loadAudioElement(audioFile);\n    return { duration: Math.ceil(audio.duration * 1000) };\n}\n\n/**\n * Load a file into a newly created video element and pull some strings\n * in an attempt to guarantee the first frame will be showing.\n *\n * @param {File} videoFile The file to load in a video element.\n * @return {Promise} A promise that resolves with the video element.\n */\nfunction loadVideoElement(videoFile: File): Promise<HTMLVideoElement> {\n    return new Promise((resolve, reject) => {\n        // Load the file into a html element\n        const video = document.createElement(\"video\");\n        video.preload = \"metadata\";\n        video.playsInline = true;\n        video.muted = true;\n\n        const reader = new FileReader();\n\n        reader.onload = function (ev): void {\n            // Wait until we have enough data to thumbnail the first frame.\n            video.onloadeddata = async function (): Promise<void> {\n                resolve(video);\n                video.pause();\n            };\n            video.onerror = function (e): void {\n                reject(e);\n            };\n\n            let dataUrl = ev.target?.result as string;\n            // Chrome chokes on quicktime but likes mp4, and `file.type` is\n            // read only, so do this horrible hack to unbreak quicktime\n            if (dataUrl?.startsWith(\"data:video/quicktime;\")) {\n                dataUrl = dataUrl.replace(\"data:video/quicktime;\", \"data:video/mp4;\");\n            }\n\n            video.src = dataUrl;\n            video.load();\n            video.play();\n        };\n        reader.onerror = function (e): void {\n            reject(e);\n        };\n        reader.readAsDataURL(videoFile);\n    });\n}\n\n/**\n * Read the metadata for a video file and create and upload a thumbnail of the video.\n *\n * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.\n * @param {String} roomId The ID of the room the video will be uploaded to.\n * @param {File} videoFile The video to read and thumbnail.\n * @return {Promise} A promise that resolves with the attachment info.\n */\nfunction infoForVideoFile(matrixClient: MatrixClient, roomId: string, videoFile: File): Promise<VideoInfo> {\n    const thumbnailType = \"image/jpeg\";\n\n    const videoInfo: VideoInfo = {};\n    return loadVideoElement(videoFile)\n        .then((video) => {\n            videoInfo.duration = Math.ceil(video.duration * 1000);\n            return createThumbnail(video, video.videoWidth, video.videoHeight, thumbnailType);\n        })\n        .then((result) => {\n            Object.assign(videoInfo, result.info);\n            return uploadFile(matrixClient, roomId, result.thumbnail);\n        })\n        .then((result) => {\n            videoInfo.thumbnail_url = result.url;\n            videoInfo.thumbnail_file = result.file;\n            return videoInfo;\n        });\n}\n\n/**\n * Read the file as an ArrayBuffer.\n * @param {File} file The file to read\n * @return {Promise} A promise that resolves with an ArrayBuffer when the file\n *   is read.\n */\nfunction readFileAsArrayBuffer(file: File | Blob): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = function (e): void {\n            resolve(e.target?.result as ArrayBuffer);\n        };\n        reader.onerror = function (e): void {\n            reject(e);\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\n\n/**\n * Upload the file to the content repository.\n * If the room is encrypted then encrypt the file before uploading.\n *\n * @param {MatrixClient} matrixClient The matrix client to upload the file with.\n * @param {String} roomId The ID of the room being uploaded to.\n * @param {File} file The file to upload.\n * @param {Function?} progressHandler optional callback to be called when a chunk of\n *    data is uploaded.\n * @param {AbortController?} controller optional abortController to use for this upload.\n * @return {Promise} A promise that resolves with an object.\n *  If the file is unencrypted then the object will have a \"url\" key.\n *  If the file is encrypted then the object will have a \"file\" key.\n */\nexport async function uploadFile(\n    matrixClient: MatrixClient,\n    roomId: string,\n    file: File | Blob,\n    progressHandler?: UploadOpts[\"progressHandler\"],\n    controller?: AbortController,\n): Promise<{ url?: string; file?: EncryptedFile }> {\n    const abortController = controller ?? new AbortController();\n\n    // If the room is encrypted then encrypt the file before uploading it.\n    if (await matrixClient.getCrypto()?.isEncryptionEnabledInRoom(roomId)) {\n        // First read the file into memory.\n        const data = await readFileAsArrayBuffer(file);\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n\n        // Then encrypt the file.\n        const encryptResult = await encrypt.encryptAttachment(data);\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n\n        // Pass the encrypted data as a Blob to the uploader.\n        const blob = new Blob([encryptResult.data]);\n\n        let url: string;\n        try {\n            ({ content_uri: url } = await matrixClient.uploadContent(blob, {\n                progressHandler,\n                abortController,\n                includeFilename: false,\n                type: \"application/octet-stream\",\n            }));\n        } catch (e) {\n            if (abortController.signal.aborted) throw new UploadCanceledError();\n            console.error(\"Failed to upload file\", e);\n            throw new UploadFailedError(e);\n        }\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n\n        // If the attachment is encrypted then bundle the URL along with the information\n        // needed to decrypt the attachment and add it under a file key.\n        return {\n            file: {\n                ...encryptResult.info,\n                url,\n            } as EncryptedFile,\n        };\n    } else {\n        let url: string;\n        try {\n            ({ content_uri: url } = await matrixClient.uploadContent(file, { progressHandler, abortController }));\n        } catch (e) {\n            if (abortController.signal.aborted) throw new UploadCanceledError();\n            console.error(\"Failed to upload file\", e);\n            throw new UploadFailedError(e);\n        }\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n        // If the attachment isn't encrypted then include the URL directly.\n        return { url };\n    }\n}\n\nexport default class ContentMessages {\n    private inprogress: RoomUpload[] = [];\n    private mediaConfig: IMediaConfig | null = null;\n\n    public sendStickerContentToRoom(\n        url: string,\n        roomId: string,\n        threadId: string | null,\n        info: ImageInfo,\n        text: string,\n        matrixClient: MatrixClient,\n    ): Promise<ISendEventResponse> {\n        return doMaybeLocalRoomAction(\n            roomId,\n            (actualRoomId: string) => matrixClient.sendStickerMessage(actualRoomId, threadId, url, info, text),\n            matrixClient,\n        ).catch((e) => {\n            logger.warn(`Failed to send content with URL ${url} to room ${roomId}`, e);\n            throw e;\n        });\n    }\n\n    public getUploadLimit(): number | null {\n        return this.mediaConfig?.[\"m.upload.size\"] ?? null;\n    }\n\n    /**\n     * Sends a list of files to a room.\n     * @param files - The files to send.\n     * @param roomId - The ID of the room to send the files to.\n     * @param relation - The relation to the event being replied to.\n     * @param replyToEvent - The event being replied to, if any.\n     * @param matrixClient - The Matrix client to use for sending the files.\n     * @param context - The context in which the files are being sent.\n     * @returns A promise that resolves when the files have been sent.\n     */\n    public async sendContentListToRoom(\n        files: File[],\n        roomId: string,\n        relation: IEventRelation | undefined,\n        replyToEvent: MatrixEvent | undefined,\n        matrixClient: MatrixClient,\n        context = TimelineRenderingType.Room,\n    ): Promise<void> {\n        if (matrixClient.isGuest()) {\n            dis.dispatch({ action: \"require_registration\" });\n            return;\n        }\n\n        if (!this.mediaConfig) {\n            // hot-path optimization to not flash a spinner if we don't need to\n            const modal = Modal.createDialog(Spinner, undefined, \"mx_Dialog_spinner\");\n            await Promise.race([this.ensureMediaConfigFetched(matrixClient), modal.finished]);\n            if (!this.mediaConfig) {\n                // User cancelled by clicking away on the spinner\n                return;\n            } else {\n                modal.close();\n            }\n        }\n\n        const tooBigFiles: File[] = [];\n        const okFiles: File[] = [];\n\n        for (const file of files) {\n            if (this.isFileSizeAcceptable(file)) {\n                okFiles.push(file);\n            } else {\n                tooBigFiles.push(file);\n            }\n        }\n\n        if (tooBigFiles.length > 0) {\n            const { finished } = Modal.createDialog(UploadFailureDialog, {\n                badFiles: tooBigFiles,\n                totalFiles: files.length,\n                contentMessages: this,\n            });\n            const [shouldContinue] = await finished;\n            if (!shouldContinue) return;\n        }\n\n        let uploadAll = false;\n        // Promise to complete before sending next file into room, used for synchronisation of file-sending\n        // to match the order the files were specified in\n        let promBefore: Promise<any> = Promise.resolve();\n        for (let i = 0; i < okFiles.length; ++i) {\n            const file = okFiles[i];\n            const loopPromiseBefore = promBefore;\n\n            if (!uploadAll) {\n                const { finished } = Modal.createDialog(UploadConfirmDialog, {\n                    file,\n                    currentIndex: i,\n                    totalFiles: okFiles.length,\n                });\n                const [shouldContinue, shouldUploadAll] = await finished;\n                if (!shouldContinue) break;\n                if (shouldUploadAll) {\n                    uploadAll = true;\n                }\n            }\n\n            promBefore = doMaybeLocalRoomAction(\n                roomId,\n                (actualRoomId) =>\n                    this.sendContentToRoom(\n                        file,\n                        actualRoomId,\n                        relation,\n                        matrixClient,\n                        replyToEvent ?? undefined,\n                        loopPromiseBefore,\n                    ),\n                matrixClient,\n            );\n        }\n\n        if (replyToEvent) {\n            // Clear event being replied to\n            dis.dispatch({\n                action: \"reply_to_event\",\n                event: null,\n                context,\n            });\n        }\n\n        // Focus the correct composer\n        dis.dispatch({\n            action: Action.FocusSendMessageComposer,\n            context,\n        });\n    }\n\n    public getCurrentUploads(relation?: IEventRelation): RoomUpload[] {\n        return this.inprogress.filter((roomUpload) => {\n            const noRelation = !relation && !roomUpload.relation;\n            const matchingRelation =\n                relation &&\n                roomUpload.relation &&\n                relation.rel_type === roomUpload.relation.rel_type &&\n                relation.event_id === roomUpload.relation.event_id;\n\n            return (noRelation || matchingRelation) && !roomUpload.cancelled;\n        });\n    }\n\n    public cancelUpload(upload: RoomUpload): void {\n        upload.abort();\n        dis.dispatch<UploadCanceledPayload>({ action: Action.UploadCanceled, upload });\n    }\n\n    public async sendContentToRoom(\n        file: File,\n        roomId: string,\n        relation: IEventRelation | undefined,\n        matrixClient: MatrixClient,\n        replyToEvent: MatrixEvent | undefined,\n        promBefore?: Promise<any>,\n    ): Promise<void> {\n        const fileName = file.name || _t(\"common|attachment\");\n        const content: Omit<MediaEventContent, \"info\"> & { info: Partial<MediaEventInfo> } = {\n            body: fileName,\n            info: {\n                size: file.size,\n            },\n            msgtype: MsgType.File, // set more specifically later\n        };\n\n        // Attach mentions, which really only applies if there's a replyToEvent.\n        attachMentions(matrixClient.getSafeUserId(), content, null, replyToEvent);\n        attachRelation(content, relation);\n        if (replyToEvent) {\n            addReplyToMessageContent(content, replyToEvent);\n        }\n\n        if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\n            decorateStartSendingTime(content);\n        }\n\n        // if we have a mime type for the file, add it to the message metadata\n        if (file.type) {\n            content.info.mimetype = file.type;\n        }\n\n        const upload = new RoomUpload(roomId, fileName, relation, file.size);\n        this.inprogress.push(upload);\n        dis.dispatch<UploadStartedPayload>({ action: Action.UploadStarted, upload });\n\n        function onProgress(progress: UploadProgress): void {\n            upload.onProgress(progress);\n            dis.dispatch<UploadProgressPayload>({ action: Action.UploadProgress, upload });\n        }\n\n        try {\n            if (file.type.startsWith(\"image/\")) {\n                content.msgtype = MsgType.Image;\n                try {\n                    const imageInfo = await infoForImageFile(matrixClient, roomId, file);\n                    Object.assign(content.info, imageInfo);\n                } catch (e) {\n                    if (e instanceof UploadFailedError) {\n                        // re-throw to main upload error handler\n                        throw e;\n                    }\n                    // Otherwise we failed to thumbnail, fall back to uploading an m.file\n                    logger.error(e);\n                    content.msgtype = MsgType.File;\n                }\n            } else if (file.type.startsWith(\"audio/\")) {\n                content.msgtype = MsgType.Audio;\n                try {\n                    const audioInfo = await infoForAudioFile(file);\n                    Object.assign(content.info, audioInfo);\n                } catch (e) {\n                    // Failed to process audio file, fall back to uploading an m.file\n                    logger.error(e);\n                    content.msgtype = MsgType.File;\n                }\n            } else if (file.type.startsWith(\"video/\")) {\n                content.msgtype = MsgType.Video;\n                try {\n                    const videoInfo = await infoForVideoFile(matrixClient, roomId, file);\n                    Object.assign(content.info, videoInfo);\n                } catch (e) {\n                    // Failed to thumbnail, fall back to uploading an m.file\n                    logger.error(e);\n                    content.msgtype = MsgType.File;\n                }\n            } else {\n                content.msgtype = MsgType.File;\n            }\n\n            if (upload.cancelled) throw new UploadCanceledError();\n            const result = await uploadFile(matrixClient, roomId, file, onProgress, upload.abortController);\n            content.file = result.file;\n            content.url = result.url;\n\n            if (upload.cancelled) throw new UploadCanceledError();\n            // Await previous message being sent into the room\n            if (promBefore) await promBefore;\n\n            if (upload.cancelled) throw new UploadCanceledError();\n            const threadId = relation?.rel_type === THREAD_RELATION_TYPE.name ? relation.event_id : null;\n\n            const response = await matrixClient.sendMessage(roomId, threadId ?? null, content as MediaEventContent);\n\n            if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\n                sendRoundTripMetric(matrixClient, roomId, response.event_id);\n            }\n\n            dis.dispatch<UploadFinishedPayload>({ action: Action.UploadFinished, upload });\n            dis.dispatch({ action: \"message_sent\" });\n        } catch (error) {\n            // Unwrap UploadFailedError to get the underlying error\n            const unwrappedError = error instanceof UploadFailedError && error.cause ? error.cause : error;\n\n            // 413: File was too big or upset the server in some way:\n            // clear the media size limit so we fetch it again next time we try to upload\n            if (unwrappedError instanceof HTTPError && unwrappedError.httpStatus === 413) {\n                this.mediaConfig = null;\n            }\n\n            if (!upload.cancelled) {\n                let desc = _t(\"upload_failed_generic\", { fileName: upload.fileName });\n                if (unwrappedError instanceof HTTPError && unwrappedError.httpStatus === 413) {\n                    desc = _t(\"upload_failed_size\", {\n                        fileName: upload.fileName,\n                    });\n                }\n                Modal.createDialog(ErrorDialog, {\n                    title: _t(\"upload_failed_title\"),\n                    description: desc,\n                });\n                dis.dispatch<UploadErrorPayload>({ action: Action.UploadFailed, upload, error });\n            }\n        } finally {\n            removeElement(this.inprogress, (e) => e.promise === upload.promise);\n        }\n    }\n\n    private isFileSizeAcceptable(file: File): boolean {\n        if (this.mediaConfig?.[\"m.upload.size\"] !== undefined && file.size > this.mediaConfig[\"m.upload.size\"]) {\n            return false;\n        }\n        return true;\n    }\n\n    private ensureMediaConfigFetched(matrixClient: MatrixClient): Promise<void> {\n        if (this.mediaConfig !== null) return Promise.resolve();\n\n        logger.log(\"[Media Config] Fetching\");\n        return matrixClient\n            .getMediaConfig()\n            .then((config) => {\n                logger.log(\"[Media Config] Fetched config:\", config);\n                return config;\n            })\n            .catch(() => {\n                // Media repo can't or won't report limits, so provide an empty object (no limits).\n                logger.log(\"[Media Config] Could not fetch config, so not limiting uploads.\");\n                return {};\n            })\n            .then((config) => {\n                this.mediaConfig = config;\n            });\n    }\n\n    public static sharedInstance(): ContentMessages {\n        if (window.mxContentMessages === undefined) {\n            window.mxContentMessages = new ContentMessages();\n        }\n        return window.mxContentMessages;\n    }\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type IContent, type MatrixClient } from \"matrix-js-sdk/src/matrix\";\n\n/**\n * Decorates the given event content object with the \"send start time\". The\n * object will be modified in-place.\n * @param {object} content The event content.\n */\nexport function decorateStartSendingTime(content: IContent): void {\n    content[\"io.element.performance_metrics\"] = {\n        sendStartTs: Date.now(),\n    };\n}\n\n/**\n * Called when an event decorated with `decorateStartSendingTime()` has been sent\n * by the server (the client now knows the event ID).\n * @param {MatrixClient} client The client to send as.\n * @param {string} inRoomId The room ID where the original event was sent.\n * @param {string} forEventId The event ID for the decorated event.\n */\nexport function sendRoundTripMetric(client: MatrixClient, inRoomId: string, forEventId: string): void {\n    // noinspection JSIgnoredPromiseFromCall\n    client.sendEvent(inRoomId, \"io.element.performance_metric\", {\n        \"io.element.performance_metrics\": {\n            forEventId: forEventId,\n            responseTs: Date.now(),\n            kind: \"send_time\",\n        },\n    });\n}\n","var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n","/* crc32.js (C) 2014-2015 SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\nvar CRC32;\n(function (factory) {\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t  factory(CRC32 = {});\n\t\t}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n}(function(CRC32) {\nCRC32.version = '0.3.0';\n/* see perf/crc32table.js */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar table = signed_crc_table();\n/* charCodeAt is the best approach for binary strings */\nvar use_buffer = typeof Buffer !== 'undefined';\nfunction crc32_bstr(bstr) {\n\tif(bstr.length > 32768) if(use_buffer) return crc32_buf_8(new Buffer(bstr));\n\tvar crc = -1, L = bstr.length - 1;\n\tfor(var i = 0; i < L;) {\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t}\n\tif(i === L) crc = (crc >>> 8) ^ table[(crc ^ bstr.charCodeAt(i)) & 0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf(buf) {\n\tif(buf.length > 10000) return crc32_buf_8(buf);\n\tfor(var crc = -1, i = 0, L=buf.length-3; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+3) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf_8(buf) {\n\tfor(var crc = -1, i = 0, L=buf.length-7; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+7) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\n/* much much faster to intertwine utf8 and crc */\nfunction crc32_str(str) {\n\tfor(var crc = -1, i = 0, L=str.length, c, d; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ c) & 0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (192|((c>>6)&31))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++) & 1023;\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (240|((c>>8)&7))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>2)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((d>>6)&15)|(c&3))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(d&63))) & 0xFF];\n\t\t} else {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (224|((c>>12)&15))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>6)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t}\n\t}\n\treturn crc ^ -1;\n}\nCRC32.table = table;\nCRC32.bstr = crc32_bstr;\nCRC32.buf = crc32_buf;\nCRC32.str = crc32_str;\n}));\n"],"names":["RoomUpload","constructor","roomId","fileName","relation","fileSize","_defineProperty","AbortController","onProgress","progress","this","uploaded","loaded","total","abort","abortController","cancelled","signal","aborted","UploadFailureDialog","React","args","props","onFinished","render","message","buttons","totalFiles","badFiles","length","_t","limit","contentMessages","getUploadLimit","sizeOfThisFile","size","b","sub","DialogButtons","primaryButton","hasCancel","onPrimaryButtonClick","onCancelClick","focus","howManyOthers","count","onUploadClick","cancelButton","onCancel","BaseDialog","className","title","contentId","id","preview","PHYS_HIDPI","UploadCanceledError","Error","UploadFailedError","cause","super","ALWAYS_INCLUDE_THUMBNAIL","async","infoForImageFile","matrixClient","imageFile","thumbnailType","type","isAnimatedPromise","blobIsAnimated","imageElement","img","Image","objectUrl","URL","createObjectURL","imgPromise","Promise","resolve","reject","onload","revokeObjectURL","onerror","e","src","parsePromise","readFileAsArrayBuffer","then","arrayBuffer","buffer","Uint8Array","chunks","extractPngChunks","chunk","name","data","byteLength","every","val","i","catch","console","error","hidpi","all","width","height","loadImageElement","result","createThumbnail","imageInfo","info","undefined","includes","sizeDifference","thumbnail_info","uploadResult","uploadFile","thumbnail","url","file","infoForAudioFile","audioFile","audio","document","createElement","preload","muted","reader","FileReader","ev","_ev$target","onloadedmetadata","target","readAsDataURL","loadAudioElement","duration","Math","ceil","infoForVideoFile","videoFile","videoInfo","video","playsInline","_ev$target2","_dataUrl","onloadeddata","pause","dataUrl","startsWith","replace","load","play","loadVideoElement","videoWidth","videoHeight","Object","assign","thumbnail_url","thumbnail_file","_e$target","readAsArrayBuffer","progressHandler","controller","_matrixClient$getCryp","getCrypto","isEncryptionEnabledInRoom","encryptResult","encrypt","blob","Blob","content_uri","uploadContent","includeFilename","_objectSpread","ContentMessages","sendStickerContentToRoom","threadId","text","doMaybeLocalRoomAction","actualRoomId","sendStickerMessage","logger","warn","_this$mediaConfig$mU","_this$mediaConfig","mediaConfig","sendContentListToRoom","files","replyToEvent","context","TimelineRenderingType","Room","isGuest","dis","dispatch","action","modal","Modal","createDialog","Spinner","race","ensureMediaConfigFetched","finished","close","tooBigFiles","okFiles","isFileSizeAcceptable","push","shouldContinue","uploadAll","promBefore","loopPromiseBefore","UploadConfirmDialog","currentIndex","shouldUploadAll","sendContentToRoom","event","Action","FocusSendMessageComposer","getCurrentUploads","inprogress","filter","roomUpload","noRelation","matchingRelation","rel_type","event_id","cancelUpload","upload","UploadCanceled","content","body","msgtype","MsgType","File","attachMentions","getSafeUserId","attachRelation","addReplyToMessageContent","SettingsStore","getValue","decorateStartSendingTime","mimetype","UploadStarted","Audio","audioInfo","Video","UploadProgress","THREAD_RELATION_TYPE","response","sendMessage","sendRoundTripMetric","UploadFinished","unwrappedError","HTTPError","httpStatus","desc","ErrorDialog","description","UploadFailed","removeElement","promise","_this$mediaConfig2","log","getMediaConfig","config","sharedInstance","window","mxContentMessages","sendStartTs","Date","now","client","inRoomId","forEventId","sendEvent","responseTs","kind","crc32","module","exports","ended","idx","uint8","uint32","String","fromCharCode","crcActual","int32","buf","chunkData","slice","Int32Array","Uint32Array","factory","CRC32","version","table","c","Array","n","signed_crc_table","use_buffer","Buffer","crc32_buf_8","crc","L","bstr","charCodeAt","str","d","DO_NOT_EXPORT_CRC"],"sourceRoot":""}