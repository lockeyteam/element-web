{"version":3,"file":"bundles/9cacd6575f4c8ee1aedb/5189.js","mappings":"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","sources":["webpack://element-web/./src/stores/room-list-v3/skip-list/RoomNode.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/utils.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/Level.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/iterators.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/RoomSkipList.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/sorters/utils/getLastTimestamp.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/sorters/BaseRecencySorter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/sorters/RecencySorter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/sorters/AlphabeticSorter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/sorters/UnreadSorter.ts","webpack://element-web/./src/stores/room-list-v3/RoomListStoreV3.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/FavouriteFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/UnreadFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/PeopleFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/RoomsFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/InvitesFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/MentionsFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/LowPriorityFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/index.ts"],"sourcesContent":["/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter, FilterKey } from \"./filters\";\nimport SpaceStore from \"../../spaces/SpaceStore\";\n\n/**\n * Room skip list stores room nodes.\n * These hold the actual room object and provides references to other nodes\n * in different levels.\n */\nexport class RoomNode {\n    private _isInActiveSpace: boolean = false;\n\n    public constructor(public readonly room: Room) {}\n\n    /**\n     * This array holds references to the next node in a given level.\n     * eg: next[i] gives the next room node from this room node in level i.\n     */\n    public next: RoomNode[] = [];\n\n    /**\n     * This array holds references to the previous node in a given level.\n     * eg: previous[i] gives the previous room node from this room node in level i.\n     */\n    public previous: RoomNode[] = [];\n\n    /**\n     * Whether the room associated with this room node belongs to\n     * the currently active space.\n     * @see {@link SpaceStoreClass#activeSpace} to understand what active\n     * space means.\n     */\n    public get isInActiveSpace(): boolean {\n        return this._isInActiveSpace;\n    }\n\n    /**\n     * Check if this room belongs to the active space and store the result\n     * in {@link RoomNode#isInActiveSpace}.\n     */\n    public checkIfRoomBelongsToActiveSpace(): void {\n        const activeSpace = SpaceStore.instance.activeSpace;\n        this._isInActiveSpace = SpaceStore.instance.isRoomInSpace(activeSpace, this.room.roomId);\n    }\n\n    /**\n     * Aggregates all the filter keys that apply to this room.\n     * eg: if filterKeysSet.has(Filter.FavouriteFilter) is true, then this room is a favourite room.\n     */\n    private filterKeysSet: Set<FilterKey> = new Set();\n\n    /**\n     * Returns true if the associated room matches all the provided filters.\n     * Returns false otherwise.\n     * @param filterKeys An array of filter keys to check against.\n     */\n    public doesRoomMatchFilters(filterKeys: FilterKey[]): boolean {\n        return !filterKeys.some((key) => !this.filterKeysSet.has(key));\n    }\n\n    /**\n     * Populates {@link RoomNode#filterKeysSet} by checking if the associated room\n     * satisfies the given filters.\n     * @param filters A list of filters\n     */\n    public applyFilters(filters: Filter[]): void {\n        this.filterKeysSet = new Set();\n        for (const filter of filters) {\n            if (filter.matches(this.room)) this.filterKeysSet.add(filter.key);\n        }\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nexport function shouldPromote(): boolean {\n    return Math.random() < 0.5;\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { RoomNode } from \"./RoomNode\";\nimport { shouldPromote } from \"./utils\";\n\n/**\n * Represents one level of the skip list\n */\nexport class Level {\n    public head?: RoomNode;\n    private current?: RoomNode;\n    private _size: number = 0;\n\n    /**\n     * The number of elements in this level\n     */\n    public get size(): number {\n        return this._size;\n    }\n\n    public constructor(public readonly level: number) {}\n\n    /**\n     * Insert node after current\n     */\n    public setNext(node: RoomNode): void {\n        if (!this.head) this.head = node;\n        if (!this.current) {\n            this.current = node;\n        } else {\n            node.previous[this.level] = this.current;\n            this.current.next[this.level] = node;\n            this.current = node;\n        }\n        this._size++;\n    }\n\n    /**\n     * Iterate through the elements in this level and create\n     * a new level above this level by probabilistically determining\n     * whether a given element must be promoted to the new level.\n     */\n    public generateNextLevel(): Level {\n        const nextLevelSentinel = new Level(this.level + 1);\n        let current = this.head;\n        while (current) {\n            if (shouldPromote()) {\n                nextLevelSentinel.setNext(current);\n            }\n            current = current.next[this.level];\n        }\n        return nextLevelSentinel;\n    }\n\n    /**\n     * Removes a given node from this level.\n     * Does nothing if the given node is not present in this level.\n     */\n    public removeNode(node: RoomNode): void {\n        // Let's first see if this node is even in this level\n        const nodeInThisLevel = this.head === node || node.previous[this.level];\n        if (!nodeInThisLevel) {\n            // This node is not in this sentinel level, so nothing to do.\n            return;\n        }\n        const prev = node.previous[this.level];\n        if (prev) {\n            const nextNode = node.next[this.level];\n            prev.next[this.level] = nextNode;\n            if (nextNode) nextNode.previous[this.level] = prev;\n        } else {\n            // This node was the head since it has no back links!\n            // so update the head.\n            const next = node.next[this.level];\n            this.head = next;\n            if (next) next.previous[this.level] = node.previous[this.level];\n        }\n        this._size--;\n    }\n\n    /**\n     * Put newNode after node in this level. No checks are done to ensure\n     * that node is actually present in this level.\n     */\n    public insertAfter(node: RoomNode, newNode: RoomNode): void {\n        const level = this.level;\n        const nextNode = node.next[level];\n        if (nextNode) {\n            newNode.next[level] = nextNode;\n            nextNode.previous[level] = newNode;\n        }\n        node.next[level] = newNode;\n        newNode.previous[level] = node;\n        this._size++;\n    }\n\n    /**\n     *  Insert a given node at the head of this level.\n     */\n    public insertAtHead(newNode: RoomNode): void {\n        const existingNode = this.head;\n        this.head = newNode;\n        if (existingNode) {\n            newNode.next[this.level] = existingNode;\n            existingNode.previous[this.level] = newNode;\n        }\n        this._size++;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { RoomNode } from \"./RoomNode\";\nimport type { FilterKey } from \"./filters\";\n\nexport class SortedRoomIterator implements Iterator<Room> {\n    public constructor(private current: RoomNode) {}\n\n    public next(): IteratorResult<Room> {\n        const current = this.current;\n        if (!current) return { value: undefined, done: true };\n        this.current = current.next[0];\n        return {\n            value: current.room,\n        };\n    }\n}\n\nexport class SortedSpaceFilteredIterator implements Iterator<Room> {\n    public constructor(\n        private current: RoomNode,\n        private readonly filters: FilterKey[],\n    ) {}\n\n    public [Symbol.iterator](): SortedSpaceFilteredIterator {\n        return this;\n    }\n\n    public next(): IteratorResult<Room> {\n        let current = this.current;\n        while (current) {\n            if (current.isInActiveSpace && current.doesRoomMatchFilters(this.filters)) break;\n            current = current.next[0];\n        }\n        if (!current) return { value: undefined, done: true };\n        this.current = current.next[0];\n        return {\n            value: current.room,\n        };\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Sorter, SortingAlgorithm } from \"./sorters\";\nimport type { Filter, FilterKey } from \"./filters\";\nimport { RoomNode } from \"./RoomNode\";\nimport { shouldPromote } from \"./utils\";\nimport { Level } from \"./Level\";\nimport { SortedRoomIterator, SortedSpaceFilteredIterator } from \"./iterators\";\n\n/**\n * Implements a skip list that stores rooms using a given sorting algorithm.\n * See See https://en.wikipedia.org/wiki/Skip_list\n */\nexport class RoomSkipList implements Iterable<Room> {\n    private levels: Level[] = [new Level(0)];\n    private roomNodeMap: Map<string, RoomNode> = new Map();\n    public initialized: boolean = false;\n\n    public constructor(\n        private sorter: Sorter,\n        private filters: Filter[] = [],\n    ) {}\n\n    private reset(): void {\n        this.levels = [new Level(0)];\n        this.roomNodeMap = new Map();\n    }\n\n    /**\n     * Seed the list with an initial list of rooms.\n     */\n    public seed(rooms: Room[]): void {\n        // 1. First sort the rooms and create a base sorted linked list\n        const sortedRoomNodes = this.sorter.sort(rooms).map((room) => new RoomNode(room));\n        let currentLevel = this.levels[0];\n        for (const node of sortedRoomNodes) {\n            node.applyFilters(this.filters);\n            currentLevel.setNext(node);\n            this.roomNodeMap.set(node.room.roomId, node);\n        }\n\n        // 2. Create the rest of the sub linked lists\n        do {\n            this.levels[currentLevel.level] = currentLevel;\n            currentLevel = currentLevel.generateNextLevel();\n        } while (currentLevel.size > 1);\n\n        // 3. Go through the list of rooms and mark nodes in active space\n        this.calculateActiveSpaceForNodes();\n\n        this.initialized = true;\n    }\n\n    /**\n     * Go through all the room nodes and check if they belong to the active space.\n     */\n    public calculateActiveSpaceForNodes(): void {\n        for (const node of this.roomNodeMap.values()) {\n            node.checkIfRoomBelongsToActiveSpace();\n        }\n    }\n\n    /**\n     * Change the sorting algorithm used by the skip list.\n     * This will reset the list and will rebuild from scratch.\n     */\n    public useNewSorter(sorter: Sorter, rooms: Room[]): void {\n        this.reset();\n        this.sorter = sorter;\n        this.seed(rooms);\n    }\n\n    /**\n     * Removes a given room from the skip list.\n     */\n    public removeRoom(room: Room): void {\n        const existingNode = this.roomNodeMap.get(room.roomId);\n        this.roomNodeMap.delete(room.roomId);\n        if (existingNode) {\n            for (const level of this.levels) {\n                level.removeNode(existingNode);\n            }\n        }\n    }\n\n    /**\n     * Re-inserts a room that is already in the skiplist.\n     * This method does nothing if the room isn't already in the skiplist.\n     * @param room the room to add\n     */\n    public reInsertRoom(room: Room): void {\n        if (!this.roomNodeMap.has(room.roomId)) {\n            return;\n        }\n        this.removeRoom(room);\n        this.addNewRoom(room);\n    }\n\n    /**\n     * Adds a new room to the skiplist.\n     * This method will throw an error if the room is already in the skiplist.\n     * @param room the room to add\n     */\n    public addNewRoom(room: Room): void {\n        if (this.roomNodeMap.has(room.roomId)) {\n            throw new Error(`Can't add room to skiplist: ${room.roomId} is already in the skiplist!`);\n        }\n        this.insertRoom(room);\n    }\n\n    /**\n     * Adds a given room to the correct sorted position in the list.\n     */\n    private insertRoom(room: Room): void {\n        const newNode = new RoomNode(room);\n        newNode.checkIfRoomBelongsToActiveSpace();\n        newNode.applyFilters(this.filters);\n        this.roomNodeMap.set(room.roomId, newNode);\n\n        /**\n         * This array tracks where the new node must be inserted in a\n         * given level.\n         * The index is the level and the value represents where the\n         * insertion must happen.\n         * If the value is null, it simply means that we need to insert\n         * at the head.\n         * If the value is a RoomNode, simply insert after this node.\n         */\n        const insertionNodes: (RoomNode | null)[] = [];\n\n        /**\n         * Now we'll do the actual work of finding where to insert this\n         * node.\n         *\n         * We start at the top most level and move downwards ...\n         */\n        for (let j = this.levels.length - 1; j >= 0; --j) {\n            const level = this.levels[j];\n\n            /**\n             * If the head is undefined, that means this level is empty.\n             * So mark it as such in insertionNodes and skip over this\n             * level.\n             */\n            if (!level.head) {\n                insertionNodes[j] = null;\n                continue;\n            }\n\n            /**\n             * So there's actually some nodes in this level ...\n             * All we need to do is find the node that is smaller or\n             * equal to the node that we wish to insert.\n             */\n            let current = level.head;\n            let previous: RoomNode | null = null;\n            while (current) {\n                if (this.sorter.comparator(current.room, room) < 0) {\n                    previous = current;\n                    current = current.next[j];\n                } else break;\n            }\n\n            /**\n             * previous will now be null if there's no node in this level\n             * smaller than the node we wish to insert or it will be a\n             * RoomNode.\n             * This is exactly what we need to track in insertionNodes!\n             */\n            insertionNodes[j] = previous;\n        }\n\n        /**\n         * We're done with difficult part, now we just need to do the\n         * actual node insertion.\n         */\n        for (const [level, node] of insertionNodes.entries()) {\n            /**\n             * Whether our new node should be present in a level\n             * is decided by coin toss.\n             */\n            if (level === 0 || shouldPromote()) {\n                const levelObj = this.levels[level];\n                if (node) levelObj.insertAfter(node, newNode);\n                else levelObj.insertAtHead(newNode);\n            } else {\n                break;\n            }\n        }\n    }\n\n    public [Symbol.iterator](): SortedRoomIterator {\n        return new SortedRoomIterator(this.levels[0].head!);\n    }\n\n    /**\n     * Returns an iterator that can be used to generate a list of sorted rooms that belong\n     * to the currently active space. Passing filterKeys will further filter the list such\n     * that only rooms that match the filters are returned.\n     *\n     * @example To get an array of rooms:\n     * Array.from(RLS.getRoomsInActiveSpace());\n     *\n     * @example Use a for ... of loop to iterate over rooms:\n     * for(const room of RLS.getRoomsInActiveSpace()) { something(room); }\n     *\n     * @example Additional filtering:\n     * Array.from(RLS.getRoomsInActiveSpace([FilterKeys.Favourite]));\n     */\n    public getRoomsInActiveSpace(filterKeys: FilterKey[] = []): SortedSpaceFilteredIterator {\n        return new SortedSpaceFilteredIterator(this.levels[0].head!, filterKeys);\n    }\n\n    /**\n     * The number of rooms currently in the skip list.\n     */\n    public get size(): number {\n        return this.levels[0].size;\n    }\n\n    /**\n     * The currently active sorting algorithm.\n     */\n    public get activeSortAlgorithm(): SortingAlgorithm {\n        return this.sorter.type;\n    }\n}\n","/*\nCopyright 2026 Element Creations Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { EventTimeline, EventType, type MatrixEvent, type Room } from \"matrix-js-sdk/src/matrix\";\n\nimport { EffectiveMembership, getEffectiveMembership } from \"../../../../../utils/membership\";\nimport * as Unread from \"../../../../../Unread\";\n\nfunction shouldCauseReorder(event: MatrixEvent): boolean {\n    const type = event.getType();\n    const content = event.getContent();\n    const prevContent = event.getPrevContent();\n\n    // Never ignore membership changes\n    if (type === EventType.RoomMember && prevContent.membership !== content.membership) return true;\n\n    // Ignore display name changes\n    if (type === EventType.RoomMember && prevContent.displayname !== content.displayname) return false;\n    // Ignore avatar changes\n    if (type === EventType.RoomMember && prevContent.avatar_url !== content.avatar_url) return false;\n\n    return true;\n}\n\n/**\n * For a given room, this function returns a timestamp that can be used for recency sorting.\n * @param r room for which the timestamp is calculated\n * @param userId mxId of the current user\n * @returns timestamp\n */\nexport const getLastTimestamp = (r: Room, userId: string): number => {\n    const mainTimelineLastTs = ((): number => {\n        const timeline = r.getLiveTimeline().getEvents();\n\n        // MSC4186: Simplified Sliding Sync sets this.\n        // If it's present, sort by it.\n        const bumpStamp = r.getBumpStamp();\n        if (bumpStamp) {\n            return bumpStamp;\n        }\n\n        // If the room hasn't been joined yet, it probably won't have a timeline to\n        // parse. We'll still fall back to the timeline if this fails, but chances\n        // are we'll at least have our own membership event to go off of.\n        const effectiveMembership = getEffectiveMembership(r.getMyMembership());\n        if (effectiveMembership !== EffectiveMembership.Join) {\n            const membershipEvent = r\n                .getLiveTimeline()\n                .getState(EventTimeline.FORWARDS)\n                ?.getStateEvents(EventType.RoomMember, userId);\n            if (membershipEvent && !Array.isArray(membershipEvent)) {\n                return membershipEvent.getTs();\n            }\n        }\n\n        for (let i = timeline.length - 1; i >= 0; --i) {\n            const ev = timeline[i];\n            if (!ev.getTs()) continue; // skip events that don't have timestamps (tests only?)\n\n            if (\n                (ev.getSender() === userId && shouldCauseReorder(ev)) ||\n                Unread.eventTriggersUnreadCount(r.client, ev)\n            ) {\n                return ev.getTs();\n            }\n        }\n\n        // we might only have events that don't trigger the unread indicator,\n        // in which case use the oldest event even if normally it wouldn't count.\n        // This is better than just assuming the last event was forever ago.\n        return timeline[0]?.getTs() ?? 0;\n    })();\n\n    const threadLastEventTimestamps = r.getThreads().map((thread) => {\n        const event = thread.replyToEvent ?? thread.rootEvent;\n        return event?.getTs() ?? 0;\n    });\n\n    return Math.max(mainTimelineLastTs, ...threadLastEventTimestamps);\n};\n","/*\nCopyright 2026 Element Creations Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Sorter, SortingAlgorithm } from \".\";\nimport { getLastTimestamp } from \"./utils/getLastTimestamp\";\n\nexport abstract class BaseRecencySorter implements Sorter {\n    public constructor(protected myUserId: string) {}\n\n    public sort(rooms: Room[]): Room[] {\n        const tsCache: { [roomId: string]: number } = {};\n        return [...rooms].sort((a, b) => this.comparator(a, b, tsCache));\n    }\n\n    public comparator(roomA: Room, roomB: Room, cache?: any): number {\n        // First check if any of the rooms are special cases\n        const exceptionalOrdering = this.getScore(roomA) - this.getScore(roomB);\n        if (exceptionalOrdering !== 0) return exceptionalOrdering;\n\n        // Then check recency; recent rooms should be at the top\n        const roomALastTs = this.getTs(roomA, cache);\n        const roomBLastTs = this.getTs(roomB, cache);\n        return roomBLastTs - roomALastTs;\n    }\n\n    private getTs(room: Room, cache?: { [roomId: string]: number }): number {\n        const ts = cache?.[room.roomId] ?? getLastTimestamp(room, this.myUserId);\n        if (cache) {\n            cache[room.roomId] = ts;\n        }\n        return ts;\n    }\n\n    public abstract get type(): SortingAlgorithm;\n\n    /**\n     * Rooms are sorted based on:\n     * - the score of the room\n     * - the timestamp of the last message in that room\n     *\n     * The score takes precedence over the timestamp of the last message. This allows\n     * some rooms to be sorted before/after others regardless of when the last message\n     * was received in that room. Eg: muted rooms can be placed at the bottom of the list\n     * even if they received messages recently.\n     */\n    protected abstract getScore(room: Room): number;\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport { type Sorter, SortingAlgorithm } from \".\";\nimport { RoomNotificationStateStore } from \"../../../notifications/RoomNotificationStateStore\";\nimport { DefaultTagID } from \"../../../room-list/models\";\nimport { BaseRecencySorter } from \"./BaseRecencySorter\";\n\nexport class RecencySorter extends BaseRecencySorter implements Sorter {\n    public get type(): SortingAlgorithm.Recency {\n        return SortingAlgorithm.Recency;\n    }\n\n    /**\n     * This sorter mostly sorts rooms by recency but there are two exceptions:\n     * 1. Muted rooms are sorted to the bottom of the list.\n     * 2. Low priority rooms are sorted to the bottom of the list but before muted rooms.\n     *\n     * The following method provides a numerical value that takes care of this\n     * exceptional ordering. For two rooms A and B, it works as follows:\n     * - If getScore(A) - getScore(B) > 0, A should come after B\n     * - If getScore(A) - getScore(B) < 0, A should come before B\n     * - If getScore(A) - getScore(B) = 0, no special ordering needed, just use recency\n     */\n    protected getScore(room: Room): number {\n        const isLowPriority = !!room.tags[DefaultTagID.LowPriority];\n        const isMuted = RoomNotificationStateStore.instance.getRoomState(room).muted;\n        // These constants are chosen so that the following order is maintained:\n        // Low priority rooms -> Low priority and muted rooms -> Muted rooms\n        if (isMuted && isLowPriority) return 5;\n        else if (isMuted) return 10;\n        else if (isLowPriority) return 2;\n        else return 0;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport { type Sorter, SortingAlgorithm } from \".\";\n\nexport class AlphabeticSorter implements Sorter {\n    private readonly collator = new Intl.Collator();\n\n    public sort(rooms: Room[]): Room[] {\n        return [...rooms].sort((a, b) => {\n            return this.comparator(a, b);\n        });\n    }\n\n    public comparator(roomA: Room, roomB: Room): number {\n        return this.collator.compare(roomA.name, roomB.name);\n    }\n\n    public get type(): SortingAlgorithm.Alphabetic {\n        return SortingAlgorithm.Alphabetic;\n    }\n}\n","/*\nCopyright 2026 Element Creations Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { KnownMembership, RoomType, type Room } from \"matrix-js-sdk/src/matrix\";\n\nimport { type Sorter, SortingAlgorithm } from \".\";\nimport { RoomNotificationStateStore } from \"../../../notifications/RoomNotificationStateStore\";\nimport { DefaultTagID } from \"../../../room-list/models\";\nimport { CallStore } from \"../../../CallStore\";\nimport { getMarkedUnreadState } from \"../../../../utils/notifications\";\nimport { BaseRecencySorter } from \"./BaseRecencySorter\";\n\n/**\n * Similar to RecencySorter but with the following special order:\n * Invites -> Calls (new and ongoing) -> Mentions (@) -> Count ([1])/ Marked as unread -> Activity (dot) -> None -> Low Priority -> Mute\n */\nexport class UnreadSorter extends BaseRecencySorter implements Sorter {\n    public get type(): SortingAlgorithm.Unread {\n        return SortingAlgorithm.Unread;\n    }\n\n    protected getScore(room: Room): number {\n        // Invites first\n        if (room.getMyMembership() === KnownMembership.Invite) return 100;\n\n        // Then rooms that have calls (but not video rooms)\n        const roomType = room.getType();\n        const isVideoRoom = roomType === RoomType.UnstableCall || roomType === RoomType.ElementVideo;\n        if (!isVideoRoom && !!CallStore.instance.getCall(room.roomId)) return 101;\n\n        const roomNotificationState = RoomNotificationStateStore.instance.getRoomState(room);\n        // Then mentions\n        if (roomNotificationState.isMention) return 102;\n\n        // Then rooms that have a count or was marked as unread\n        if (roomNotificationState.hasUnreadCount || !!getMarkedUnreadState(room)) return 103;\n\n        // Then rooms that have a dot\n        if (roomNotificationState.isActivityNotification) return 104;\n\n        // Then all other non special rooms, see last return\n\n        // Then low priority rooms\n        if (!!room.tags[DefaultTagID.LowPriority]) return 106;\n\n        // Muted rooms at the bottom\n        if (roomNotificationState.muted) return 107;\n\n        return 105;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport { EventType } from \"matrix-js-sdk/src/matrix\";\n\nimport type { EmptyObject, Room } from \"matrix-js-sdk/src/matrix\";\nimport type { MatrixDispatcher } from \"../../dispatcher/dispatcher\";\nimport type { ActionPayload } from \"../../dispatcher/payloads\";\nimport type { FilterKey } from \"./skip-list/filters\";\nimport { AsyncStoreWithClient } from \"../AsyncStoreWithClient\";\nimport SettingsStore from \"../../settings/SettingsStore\";\nimport { VisibilityProvider } from \"../room-list/filters/VisibilityProvider\";\nimport defaultDispatcher from \"../../dispatcher/dispatcher\";\nimport { RoomSkipList } from \"./skip-list/RoomSkipList\";\nimport { RecencySorter } from \"./skip-list/sorters/RecencySorter\";\nimport { AlphabeticSorter } from \"./skip-list/sorters/AlphabeticSorter\";\nimport { readReceiptChangeIsFor } from \"../../utils/read-receipts\";\nimport { EffectiveMembership, getEffectiveMembership, getEffectiveMembershipTag } from \"../../utils/membership\";\nimport SpaceStore from \"../spaces/SpaceStore\";\nimport { type SpaceKey, UPDATE_HOME_BEHAVIOUR, UPDATE_SELECTED_SPACE } from \"../spaces\";\nimport { FavouriteFilter } from \"./skip-list/filters/FavouriteFilter\";\nimport { UnreadFilter } from \"./skip-list/filters/UnreadFilter\";\nimport { PeopleFilter } from \"./skip-list/filters/PeopleFilter\";\nimport { RoomsFilter } from \"./skip-list/filters/RoomsFilter\";\nimport { InvitesFilter } from \"./skip-list/filters/InvitesFilter\";\nimport { MentionsFilter } from \"./skip-list/filters/MentionsFilter\";\nimport { LowPriorityFilter } from \"./skip-list/filters/LowPriorityFilter\";\nimport { type Sorter, SortingAlgorithm } from \"./skip-list/sorters\";\nimport { SettingLevel } from \"../../settings/SettingLevel\";\nimport { MARKED_UNREAD_TYPE_STABLE, MARKED_UNREAD_TYPE_UNSTABLE } from \"../../utils/notifications\";\nimport { getChangedOverrideRoomMutePushRules } from \"../room-list/utils/roomMute\";\nimport { Action } from \"../../dispatcher/actions\";\nimport { UnreadSorter } from \"./skip-list/sorters/UnreadSorter\";\n\n/**\n * These are the filters passed to the room skip list.\n */\nconst FILTERS = [\n    new FavouriteFilter(),\n    new UnreadFilter(),\n    new PeopleFilter(),\n    new RoomsFilter(),\n    new InvitesFilter(),\n    new MentionsFilter(),\n    new LowPriorityFilter(),\n];\n\nexport enum RoomListStoreV3Event {\n    // The event/channel which is called when the room lists have been changed.\n    ListsUpdate = \"lists_update\",\n    // The event which is called when the room list is loaded.\n    ListsLoaded = \"lists_loaded\",\n}\n\n// The result object for returning rooms from the store\nexport type RoomsResult = {\n    // The ID of the active space queried\n    spaceId: SpaceKey;\n    // The filter queried\n    filterKeys?: FilterKey[];\n    // The resulting list of rooms\n    rooms: Room[];\n};\n\nexport const LISTS_UPDATE_EVENT = RoomListStoreV3Event.ListsUpdate;\nexport const LISTS_LOADED_EVENT = RoomListStoreV3Event.ListsLoaded;\n/**\n * This store allows for fast retrieval of the room list in a sorted and filtered manner.\n * This is the third such implementation hence the \"V3\".\n * This store is being actively developed so expect the methods to change in future.\n */\nexport class RoomListStoreV3Class extends AsyncStoreWithClient<EmptyObject> {\n    private roomSkipList?: RoomSkipList;\n    private readonly msc3946ProcessDynamicPredecessor: boolean;\n\n    public constructor(dispatcher: MatrixDispatcher) {\n        super(dispatcher);\n        this.msc3946ProcessDynamicPredecessor = SettingsStore.getValue(\"feature_dynamic_room_predecessors\");\n        SpaceStore.instance.on(UPDATE_SELECTED_SPACE, () => {\n            this.onActiveSpaceChanged();\n        });\n        SpaceStore.instance.on(UPDATE_HOME_BEHAVIOUR, () => this.onActiveSpaceChanged());\n    }\n\n    /**\n     * Get a list of unsorted, unfiltered rooms.\n     */\n    public getRooms(): Room[] {\n        let rooms = this.matrixClient?.getVisibleRooms(this.msc3946ProcessDynamicPredecessor) ?? [];\n        rooms = rooms.filter((r) => VisibilityProvider.instance.isRoomVisible(r));\n        return rooms;\n    }\n\n    /**\n     * Check whether the initial list of rooms has loaded.\n     */\n    public get isLoadingRooms(): boolean {\n        return !this.roomSkipList?.initialized;\n    }\n\n    /**\n     * Get a list of sorted rooms.\n     */\n    public getSortedRooms(): Room[] {\n        if (this.roomSkipList?.initialized) return Array.from(this.roomSkipList);\n        else return [];\n    }\n\n    /**\n     * Get a list of sorted rooms that belong to the currently active space.\n     * If filterKeys is passed, only the rooms that match the given filters are\n     * returned.\n\n     * @param filterKeys Optional array of filters that the rooms must match against.\n     */\n    public getSortedRoomsInActiveSpace(filterKeys?: FilterKey[]): RoomsResult {\n        const spaceId = SpaceStore.instance.activeSpace;\n        if (this.roomSkipList?.initialized)\n            return {\n                spaceId: spaceId,\n                filterKeys,\n                rooms: Array.from(this.roomSkipList.getRoomsInActiveSpace(filterKeys)),\n            };\n        else return { spaceId: spaceId, filterKeys, rooms: [] };\n    }\n\n    /**\n     * Resort the list of rooms using a different algorithm.\n     * @param algorithm The sorting algorithm to use.\n     */\n    public resort(algorithm: SortingAlgorithm): void {\n        if (!this.roomSkipList) throw new Error(\"Cannot resort room list before skip list is created.\");\n        if (!this.matrixClient) throw new Error(\"Cannot resort room list without matrix client.\");\n        if (this.roomSkipList.activeSortAlgorithm === algorithm) return;\n        const sorter = this.getSorterFromSortingAlgorithm(algorithm, this.matrixClient.getSafeUserId());\n        this.roomSkipList.useNewSorter(sorter, this.getRooms());\n        this.emit(LISTS_UPDATE_EVENT);\n        SettingsStore.setValue(\"RoomList.preferredSorting\", null, SettingLevel.DEVICE, algorithm);\n    }\n\n    /**\n     * Currently active sorting algorithm if the store is ready or undefined otherwise.\n     */\n    public get activeSortAlgorithm(): SortingAlgorithm | undefined {\n        return this.roomSkipList?.activeSortAlgorithm;\n    }\n\n    protected async onReady(): Promise<any> {\n        if (this.roomSkipList?.initialized || !this.matrixClient) return;\n        const sorter = this.getPreferredSorter(this.matrixClient.getSafeUserId());\n        this.roomSkipList = new RoomSkipList(sorter, FILTERS);\n        await SpaceStore.instance.storeReadyPromise;\n        const rooms = this.getRooms();\n        this.roomSkipList.seed(rooms);\n        this.emit(LISTS_LOADED_EVENT);\n        this.emit(LISTS_UPDATE_EVENT);\n    }\n\n    protected async onNotReady(): Promise<void> {\n        this.roomSkipList = undefined;\n    }\n\n    protected async onAction(payload: ActionPayload): Promise<void> {\n        if (!this.matrixClient || !this.roomSkipList?.initialized) return;\n\n        /**\n         * For the kind of updates that we care about (represented by the cases below),\n         * we try to find the associated room and simply re-insert it into the\n         * skiplist. If the position of said room in the sorted list changed, re-inserting\n         * would put it in the correct place.\n         */\n        switch (payload.action) {\n            case \"MatrixActions.Room.receipt\": {\n                if (readReceiptChangeIsFor(payload.event, this.matrixClient)) {\n                    const room = payload.room;\n                    if (!room) {\n                        logger.warn(`Own read receipt was in unknown room ${room.roomId}`);\n                        return;\n                    }\n                    this.addRoomAndEmit(room);\n                }\n                break;\n            }\n\n            case \"MatrixActions.Room.tags\": {\n                const room = payload.room;\n                this.addRoomAndEmit(room);\n                break;\n            }\n\n            case \"MatrixActions.Room.accountData\": {\n                const eventType = payload.event_type;\n                if (eventType === MARKED_UNREAD_TYPE_STABLE || eventType === MARKED_UNREAD_TYPE_UNSTABLE) {\n                    const room = payload.room;\n                    this.addRoomAndEmit(room);\n                }\n                break;\n            }\n\n            case \"MatrixActions.Event.decrypted\": {\n                const roomId = payload.event.getRoomId();\n                if (!roomId) return;\n                const room = this.matrixClient.getRoom(roomId);\n                if (!room) {\n                    logger.warn(`Event ${payload.event.getId()} was decrypted in an unknown room ${roomId}`);\n                    return;\n                }\n                this.addRoomAndEmit(room);\n                break;\n            }\n\n            case \"MatrixActions.accountData\": {\n                this.handleAccountDataPayload(payload);\n                break;\n            }\n\n            case \"MatrixActions.Room.timeline\": {\n                // Ignore non-live events (backfill) and notification timeline set events (without a room)\n                if (!payload.isLiveEvent || !payload.isLiveUnfilteredRoomTimelineEvent || !payload.room) return;\n                this.addRoomAndEmit(payload.room);\n                break;\n            }\n\n            case \"MatrixActions.Room.myMembership\": {\n                const oldMembership = getEffectiveMembership(payload.oldMembership);\n                const newMembership = getEffectiveMembershipTag(payload.room, payload.membership);\n\n                // If the user is kicked, re-insert the room and do nothing more.\n                const ownUserId = this.matrixClient.getSafeUserId();\n                const isKicked = (payload.room as Room).getMember(ownUserId)?.isKicked();\n                if (isKicked) {\n                    this.addRoomAndEmit(payload.room);\n                    return;\n                }\n                // If the user has left this room, remove it from the skiplist.\n                if (\n                    (oldMembership === EffectiveMembership.Invite || oldMembership === EffectiveMembership.Join) &&\n                    newMembership === EffectiveMembership.Leave\n                ) {\n                    this.roomSkipList.removeRoom(payload.room);\n                    this.emit(LISTS_UPDATE_EVENT);\n                    return;\n                }\n\n                // If we're joining an upgraded room, we'll want to make sure we don't proliferate\n                // the dead room in the list.\n                if (oldMembership !== EffectiveMembership.Join && newMembership === EffectiveMembership.Join) {\n                    const room: Room = payload.room;\n                    const roomUpgradeHistory = room.client.getRoomUpgradeHistory(\n                        room.roomId,\n                        true,\n                        this.msc3946ProcessDynamicPredecessor,\n                    );\n                    const predecessors = roomUpgradeHistory.slice(0, roomUpgradeHistory.indexOf(room));\n                    for (const predecessor of predecessors) {\n                        this.roomSkipList.removeRoom(predecessor);\n                    }\n                }\n\n                this.addRoomAndEmit(payload.room, oldMembership === EffectiveMembership.Leave);\n                break;\n            }\n\n            case Action.AfterForgetRoom: {\n                const room = payload.room;\n                this.roomSkipList.removeRoom(room);\n                this.emit(LISTS_UPDATE_EVENT);\n                break;\n            }\n        }\n    }\n\n    /**\n     * This method deals with the two types of account data payloads that we care about.\n     */\n    private handleAccountDataPayload(payload: ActionPayload): void {\n        const eventType = payload.event_type;\n        let needsEmit = false;\n        switch (eventType) {\n            // When we're told about new DMs, insert the associated dm rooms.\n            case EventType.Direct: {\n                const dmMap = payload.event.getContent();\n                for (const userId of Object.keys(dmMap)) {\n                    const roomIds = dmMap[userId];\n                    for (const roomId of roomIds) {\n                        const room = this.matrixClient!.getRoom(roomId);\n                        if (!room) {\n                            logger.warn(`${roomId} was found in DMs but the room is not in the store`);\n                            continue;\n                        }\n                        this.roomSkipList!.reInsertRoom(room);\n                        needsEmit = true;\n                    }\n                }\n                break;\n            }\n            case EventType.PushRules: {\n                // When a room becomes muted/unmuted, re-insert that room.\n                const possibleMuteChangeRoomIds = getChangedOverrideRoomMutePushRules(payload);\n                if (!possibleMuteChangeRoomIds) return;\n                const rooms = possibleMuteChangeRoomIds\n                    .map((id) => this.matrixClient?.getRoom(id))\n                    .filter((room) => !!room);\n                for (const room of rooms) {\n                    this.roomSkipList!.reInsertRoom(room);\n                    needsEmit = true;\n                }\n                break;\n            }\n        }\n        if (needsEmit) this.emit(LISTS_UPDATE_EVENT);\n    }\n\n    /**\n     * Create the correct sorter depending on the persisted user preference.\n     * @param myUserId The user-id of our user.\n     * @returns Sorter object that can be passed to the skip list.\n     */\n    private getPreferredSorter(myUserId: string): Sorter {\n        const preferred = SettingsStore.getValue(\"RoomList.preferredSorting\");\n        return this.getSorterFromSortingAlgorithm(preferred, myUserId);\n    }\n\n    /**\n     * Get a sorter instance from the sorting algorithm enum value.\n     * @param algorithm The sorting algorithm\n     * @param myUserId The user-id of the current user\n     * @returns the sorter instance\n     */\n    private getSorterFromSortingAlgorithm(algorithm: SortingAlgorithm, myUserId: string): Sorter {\n        switch (algorithm) {\n            case SortingAlgorithm.Alphabetic:\n                return new AlphabeticSorter();\n            case SortingAlgorithm.Recency:\n                return new RecencySorter(myUserId);\n            case SortingAlgorithm.Unread:\n                return new UnreadSorter(myUserId);\n            default:\n                logger.info(\n                    `RoomListStoreV3: There is no sorting implementation for algorithm ${algorithm}, defaulting to recency sorter`,\n                );\n                return new RecencySorter(myUserId);\n        }\n    }\n\n    /**\n     * Add a room to the skiplist and emit an update.\n     * @param room The room to add to the skiplist\n     * @param isNewRoom Set this to true if this a new room that the isn't already in the skiplist\n     */\n    private addRoomAndEmit(room: Room, isNewRoom = false): void {\n        if (!this.roomSkipList) throw new Error(\"roomSkipList hasn't been created yet!\");\n        if (isNewRoom) {\n            if (!VisibilityProvider.instance.isRoomVisible(room)) {\n                logger.info(\n                    `RoomListStoreV3: Refusing to add new room ${room.roomId} because isRoomVisible returned false.`,\n                );\n                return;\n            }\n            this.roomSkipList.addNewRoom(room);\n        } else {\n            this.roomSkipList.reInsertRoom(room);\n        }\n        this.emit(LISTS_UPDATE_EVENT);\n    }\n\n    private onActiveSpaceChanged(): void {\n        if (!this.roomSkipList) return;\n        this.roomSkipList.calculateActiveSpaceForNodes();\n        this.emit(LISTS_UPDATE_EVENT);\n    }\n}\n\nexport default class RoomListStoreV3 {\n    private static internalInstance: RoomListStoreV3Class;\n\n    public static get instance(): RoomListStoreV3Class {\n        if (!RoomListStoreV3.internalInstance) {\n            const instance = new RoomListStoreV3Class(defaultDispatcher);\n            instance.start();\n            RoomListStoreV3.internalInstance = instance;\n        }\n\n        return this.internalInstance;\n    }\n}\n\nwindow.getRoomListStoreV3 = () => RoomListStoreV3.instance;\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { DefaultTagID } from \"../../../room-list/models\";\n\nexport class FavouriteFilter implements Filter {\n    public matches(room: Room): boolean {\n        return !!room.tags[DefaultTagID.Favourite];\n    }\n\n    public get key(): FilterKey.FavouriteFilter {\n        return FilterKey.FavouriteFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { RoomNotificationStateStore } from \"../../../notifications/RoomNotificationStateStore\";\nimport { getMarkedUnreadState } from \"../../../../utils/notifications\";\n\nexport class UnreadFilter implements Filter {\n    public matches(room: Room): boolean {\n        return RoomNotificationStateStore.instance.getRoomState(room).hasUnreadCount || !!getMarkedUnreadState(room);\n    }\n\n    public get key(): FilterKey.UnreadFilter {\n        return FilterKey.UnreadFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport DMRoomMap from \"../../../../utils/DMRoomMap\";\n\nexport class PeopleFilter implements Filter {\n    public matches(room: Room): boolean {\n        // Match rooms that are DMs\n        return !!DMRoomMap.shared().getUserIdForRoomId(room.roomId);\n    }\n\n    public get key(): FilterKey.PeopleFilter {\n        return FilterKey.PeopleFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport DMRoomMap from \"../../../../utils/DMRoomMap\";\n\nexport class RoomsFilter implements Filter {\n    public matches(room: Room): boolean {\n        // This should filter rooms that are not DMs\n        return !DMRoomMap.shared().getUserIdForRoomId(room.roomId);\n    }\n\n    public get key(): FilterKey.RoomsFilter {\n        return FilterKey.RoomsFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type Room, KnownMembership } from \"matrix-js-sdk/src/matrix\";\n\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\n\nexport class InvitesFilter implements Filter {\n    public matches(room: Room): boolean {\n        return room.getMyMembership() === KnownMembership.Invite;\n    }\n\n    public get key(): FilterKey.InvitesFilter {\n        return FilterKey.InvitesFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { RoomNotificationStateStore } from \"../../../notifications/RoomNotificationStateStore\";\n\nexport class MentionsFilter implements Filter {\n    public matches(room: Room): boolean {\n        return RoomNotificationStateStore.instance.getRoomState(room).isMention;\n    }\n\n    public get key(): FilterKey.MentionsFilter {\n        return FilterKey.MentionsFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { DefaultTagID } from \"../../../room-list/models\";\n\nexport class LowPriorityFilter implements Filter {\n    public matches(room: Room): boolean {\n        return !!room.tags[DefaultTagID.LowPriority];\n    }\n\n    public get key(): FilterKey.LowPriorityFilter {\n        return FilterKey.LowPriorityFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\n\nexport const enum FilterKey {\n    FavouriteFilter,\n    UnreadFilter,\n    PeopleFilter,\n    RoomsFilter,\n    LowPriorityFilter,\n    MentionsFilter,\n    InvitesFilter,\n}\n\nexport interface Filter {\n    /**\n     * Boolean return value indicates whether this room satisfies\n     * the filter condition.\n     */\n    matches(room: Room): boolean;\n\n    /**\n     * Used to identify this particular filter.\n     */\n    key: FilterKey;\n}\n"],"names":["RoomNode","constructor","room","_defineProperty","Set","isInActiveSpace","this","_isInActiveSpace","checkIfRoomBelongsToActiveSpace","activeSpace","SpaceStore","instance","isRoomInSpace","roomId","doesRoomMatchFilters","filterKeys","some","key","filterKeysSet","has","applyFilters","filters","filter","matches","add","shouldPromote","Math","random","Level","size","_size","level","setNext","node","head","current","previous","next","generateNextLevel","nextLevelSentinel","removeNode","prev","nextNode","insertAfter","newNode","insertAtHead","existingNode","SortedRoomIterator","value","undefined","done","SortedSpaceFilteredIterator","Symbol","iterator","RoomSkipList","sorter","Map","reset","levels","roomNodeMap","seed","rooms","sortedRoomNodes","sort","map","currentLevel","set","calculateActiveSpaceForNodes","initialized","values","useNewSorter","removeRoom","get","delete","reInsertRoom","addNewRoom","Error","insertRoom","insertionNodes","j","length","comparator","entries","levelObj","getRoomsInActiveSpace","activeSortAlgorithm","type","shouldCauseReorder","event","getType","content","getContent","prevContent","getPrevContent","EventType","RoomMember","membership","displayname","avatar_url","BaseRecencySorter","myUserId","tsCache","a","b","roomA","roomB","cache","exceptionalOrdering","getScore","roomALastTs","getTs","_cache$room$roomId","ts","getLastTimestamp","r","userId","mainTimelineLastTs","_timeline$0$getTs","_timeline$","timeline","getLiveTimeline","getEvents","bumpStamp","getBumpStamp","getEffectiveMembership","getMyMembership","EffectiveMembership","Join","_r$getLiveTimeline$ge","membershipEvent","getState","EventTimeline","FORWARDS","getStateEvents","Array","isArray","i","ev","getSender","Unread","client","threadLastEventTimestamps","getThreads","thread","_thread$replyToEvent","_event$getTs","replyToEvent","rootEvent","max","RecencySorter","SortingAlgorithm","Recency","isLowPriority","tags","DefaultTagID","LowPriority","isMuted","RoomNotificationStateStore","getRoomState","muted","AlphabeticSorter","Intl","Collator","collator","compare","name","Alphabetic","UnreadSorter","KnownMembership","Invite","roomType","RoomType","UnstableCall","ElementVideo","CallStore","getCall","roomNotificationState","isMention","hasUnreadCount","getMarkedUnreadState","isActivityNotification","FILTERS","Favourite","FilterKey","FavouriteFilter","UnreadFilter","DMRoomMap","shared","getUserIdForRoomId","PeopleFilter","RoomsFilter","InvitesFilter","MentionsFilter","LowPriorityFilter","RoomListStoreV3Event","LISTS_UPDATE_EVENT","ListsUpdate","LISTS_LOADED_EVENT","ListsLoaded","RoomListStoreV3Class","AsyncStoreWithClient","dispatcher","super","msc3946ProcessDynamicPredecessor","SettingsStore","getValue","on","UPDATE_SELECTED_SPACE","onActiveSpaceChanged","UPDATE_HOME_BEHAVIOUR","getRooms","_this$matrixClient$ge","_this$matrixClient","matrixClient","getVisibleRooms","VisibilityProvider","isRoomVisible","isLoadingRooms","_this$roomSkipList","roomSkipList","getSortedRooms","_this$roomSkipList2","from","getSortedRoomsInActiveSpace","_this$roomSkipList3","spaceId","resort","algorithm","getSorterFromSortingAlgorithm","getSafeUserId","emit","setValue","SettingLevel","DEVICE","_this$roomSkipList4","onReady","_this$roomSkipList5","getPreferredSorter","storeReadyPromise","onNotReady","onAction","payload","_this$roomSkipList6","action","readReceiptChangeIsFor","logger","warn","addRoomAndEmit","eventType","event_type","MARKED_UNREAD_TYPE_STABLE","MARKED_UNREAD_TYPE_UNSTABLE","getRoomId","getRoom","getId","handleAccountDataPayload","isLiveEvent","isLiveUnfilteredRoomTimelineEvent","_getMember","oldMembership","newMembership","getEffectiveMembershipTag","ownUserId","getMember","isKicked","Leave","roomUpgradeHistory","getRoomUpgradeHistory","predecessors","slice","indexOf","predecessor","Action","AfterForgetRoom","needsEmit","Direct","dmMap","Object","keys","roomIds","PushRules","possibleMuteChangeRoomIds","getChangedOverrideRoomMutePushRules","id","_this$matrixClient2","preferred","info","isNewRoom","RoomListStoreV3","internalInstance","defaultDispatcher","start","window","getRoomListStoreV3"],"sourceRoot":""}