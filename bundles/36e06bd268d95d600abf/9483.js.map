{"version":3,"file":"bundles/36e06bd268d95d600abf/9483.js","mappings":"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","sources":["webpack://element-web/./node_modules/png-chunks-extract/index.js","webpack://element-web/./node_modules/png-chunks-extract/node_modules/crc-32/crc32.js","webpack://element-web/./src/models/RoomUpload.ts","webpack://element-web/./src/components/views/dialogs/UploadFailureDialog.tsx","webpack://element-web/./src/ContentMessages.ts","webpack://element-web/./src/sendTimePerformanceMetrics.ts"],"sourcesContent":["var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n","/* crc32.js (C) 2014-2015 SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\nvar CRC32;\n(function (factory) {\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t  factory(CRC32 = {});\n\t\t}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n}(function(CRC32) {\nCRC32.version = '0.3.0';\n/* see perf/crc32table.js */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar table = signed_crc_table();\n/* charCodeAt is the best approach for binary strings */\nvar use_buffer = typeof Buffer !== 'undefined';\nfunction crc32_bstr(bstr) {\n\tif(bstr.length > 32768) if(use_buffer) return crc32_buf_8(new Buffer(bstr));\n\tvar crc = -1, L = bstr.length - 1;\n\tfor(var i = 0; i < L;) {\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t}\n\tif(i === L) crc = (crc >>> 8) ^ table[(crc ^ bstr.charCodeAt(i)) & 0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf(buf) {\n\tif(buf.length > 10000) return crc32_buf_8(buf);\n\tfor(var crc = -1, i = 0, L=buf.length-3; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+3) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf_8(buf) {\n\tfor(var crc = -1, i = 0, L=buf.length-7; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+7) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\n/* much much faster to intertwine utf8 and crc */\nfunction crc32_str(str) {\n\tfor(var crc = -1, i = 0, L=str.length, c, d; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ c) & 0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (192|((c>>6)&31))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++) & 1023;\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (240|((c>>8)&7))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>2)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((d>>6)&15)|(c&3))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(d&63))) & 0xFF];\n\t\t} else {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (224|((c>>12)&15))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>6)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t}\n\t}\n\treturn crc ^ -1;\n}\nCRC32.table = table;\nCRC32.bstr = crc32_bstr;\nCRC32.buf = crc32_buf;\nCRC32.str = crc32_str;\n}));\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type IEventRelation, type UploadProgress } from \"matrix-js-sdk/src/matrix\";\nimport { type EncryptedFile } from \"matrix-js-sdk/src/types\";\n\nexport class RoomUpload {\n    public readonly abortController = new AbortController();\n    public promise?: Promise<{ url?: string; file?: EncryptedFile }>;\n    private uploaded = 0;\n\n    public constructor(\n        public readonly roomId: string,\n        public readonly fileName: string,\n        public readonly relation?: IEventRelation,\n        public fileSize = 0,\n    ) {}\n\n    public onProgress(progress: UploadProgress): void {\n        this.uploaded = progress.loaded;\n        this.fileSize = progress.total;\n    }\n\n    public abort(): void {\n        this.abortController.abort();\n    }\n\n    public get cancelled(): boolean {\n        return this.abortController.signal.aborted;\n    }\n\n    public get total(): number {\n        return this.fileSize;\n    }\n\n    public get loaded(): number {\n        return this.uploaded;\n    }\n}\n","/*\nCopyright 2019-2024 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport React from \"react\";\n\nimport { _t } from \"../../../languageHandler\";\nimport type ContentMessages from \"../../../ContentMessages\";\nimport BaseDialog from \"./BaseDialog\";\nimport DialogButtons from \"../elements/DialogButtons\";\nimport { fileSize } from \"../../../utils/FileUtils\";\n\ninterface IProps {\n    badFiles: File[];\n    totalFiles: number;\n    contentMessages: ContentMessages;\n    onFinished(upload?: boolean): void;\n}\n\n/*\n * Tells the user about files we know cannot be uploaded before we even try uploading\n * them. This is named fairly generically but the only thing we check right now is\n * the size of the file.\n */\nexport default class UploadFailureDialog extends React.Component<IProps> {\n    private onCancelClick = (): void => {\n        this.props.onFinished(false);\n    };\n\n    private onUploadClick = (): void => {\n        this.props.onFinished(true);\n    };\n\n    public render(): React.ReactNode {\n        let message;\n        let preview;\n        let buttons;\n        if (this.props.totalFiles === 1 && this.props.badFiles.length === 1) {\n            message = _t(\n                \"upload_file|error_file_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                    sizeOfThisFile: fileSize(this.props.badFiles[0].size),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"action|ok\")}\n                    hasCancel={false}\n                    onPrimaryButtonClick={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        } else if (this.props.totalFiles === this.props.badFiles.length) {\n            message = _t(\n                \"upload_file|error_files_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"action|ok\")}\n                    hasCancel={false}\n                    onPrimaryButtonClick={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        } else {\n            message = _t(\n                \"upload_file|error_some_files_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            const howManyOthers = this.props.totalFiles - this.props.badFiles.length;\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"upload_file|upload_n_others_button\", { count: howManyOthers })}\n                    onPrimaryButtonClick={this.onUploadClick}\n                    hasCancel={true}\n                    cancelButton={_t(\"upload_file|cancel_all_button\")}\n                    onCancel={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        }\n\n        return (\n            <BaseDialog\n                className=\"mx_UploadFailureDialog\"\n                onFinished={this.onCancelClick}\n                title={_t(\"upload_file|error_title\")}\n                contentId=\"mx_Dialog_content\"\n            >\n                <div id=\"mx_Dialog_content\">\n                    {message}\n                    {preview}\n                </div>\n\n                {buttons}\n            </BaseDialog>\n        );\n    }\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2020 The Matrix.org Foundation C.I.C.\nCopyright 2019 New Vector Ltd\nCopyright 2015, 2016 OpenMarket Ltd\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport {\n    type MatrixClient,\n    MsgType,\n    HTTPError,\n    type IEventRelation,\n    type ISendEventResponse,\n    type MatrixEvent,\n    type UploadOpts,\n    type UploadProgress,\n    THREAD_RELATION_TYPE,\n} from \"matrix-js-sdk/src/matrix\";\nimport {\n    type ImageInfo,\n    type AudioInfo,\n    type VideoInfo,\n    type EncryptedFile,\n    type MediaEventContent,\n    type MediaEventInfo,\n} from \"matrix-js-sdk/src/types\";\nimport encrypt from \"matrix-encrypt-attachment\";\nimport extractPngChunks from \"png-chunks-extract\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport { removeElement } from \"matrix-js-sdk/src/utils\";\n\nimport dis from \"./dispatcher/dispatcher\";\nimport { _t } from \"./languageHandler\";\nimport Modal from \"./Modal\";\nimport Spinner from \"./components/views/elements/Spinner\";\nimport { Action } from \"./dispatcher/actions\";\nimport {\n    type UploadCanceledPayload,\n    type UploadErrorPayload,\n    type UploadFinishedPayload,\n    type UploadProgressPayload,\n    type UploadStartedPayload,\n} from \"./dispatcher/payloads/UploadPayload\";\nimport { RoomUpload } from \"./models/RoomUpload\";\nimport SettingsStore from \"./settings/SettingsStore\";\nimport { decorateStartSendingTime, sendRoundTripMetric } from \"./sendTimePerformanceMetrics\";\nimport { TimelineRenderingType } from \"./contexts/RoomContext\";\nimport { addReplyToMessageContent } from \"./utils/Reply\";\nimport ErrorDialog from \"./components/views/dialogs/ErrorDialog\";\nimport UploadFailureDialog from \"./components/views/dialogs/UploadFailureDialog\";\nimport UploadConfirmDialog from \"./components/views/dialogs/UploadConfirmDialog\";\nimport { createThumbnail } from \"./utils/image-media\";\nimport { attachMentions, attachRelation } from \"./utils/messages.ts\";\nimport { doMaybeLocalRoomAction } from \"./utils/local-room\";\nimport { blobIsAnimated } from \"./utils/Image.ts\";\n\n// scraped out of a macOS hidpi (5660ppm) screenshot png\n//                  5669 px (x-axis)      , 5669 px (y-axis)      , per metre\nconst PHYS_HIDPI = [0x00, 0x00, 0x16, 0x25, 0x00, 0x00, 0x16, 0x25, 0x01];\n\nexport class UploadCanceledError extends Error {}\nexport class UploadFailedError extends Error {\n    public constructor(cause: any) {\n        super();\n        this.cause = cause;\n    }\n}\n\ninterface IMediaConfig {\n    \"m.upload.size\"?: number;\n}\n\n/**\n * Load a file into a newly created image element.\n *\n * @param {File} imageFile The file to load in an image element.\n * @return {Promise} A promise that resolves with the html image element.\n */\nasync function loadImageElement(imageFile: File): Promise<{\n    width: number;\n    height: number;\n    img: HTMLImageElement;\n}> {\n    // Load the file into an html element\n    const img = new Image();\n    const objectUrl = URL.createObjectURL(imageFile);\n    const imgPromise = new Promise((resolve, reject) => {\n        img.onload = function (): void {\n            URL.revokeObjectURL(objectUrl);\n            resolve(img);\n        };\n        img.onerror = function (e): void {\n            reject(e);\n        };\n    });\n    img.src = objectUrl;\n\n    // check for hi-dpi PNGs and fudge display resolution as needed.\n    // this is mainly needed for macOS screencaps\n    let parsePromise = Promise.resolve(false);\n    if (imageFile.type === \"image/png\") {\n        // in practice macOS happens to order the chunks so they fall in\n        // the first 0x1000 bytes (thanks to a massive ICC header).\n        // Thus we could slice the file down to only sniff the first 0x1000\n        // bytes (but this makes extractPngChunks choke on the corrupt file)\n        const headers = imageFile; //.slice(0, 0x1000);\n        parsePromise = readFileAsArrayBuffer(headers)\n            .then((arrayBuffer) => {\n                const buffer = new Uint8Array(arrayBuffer);\n                const chunks = extractPngChunks(buffer);\n                for (const chunk of chunks) {\n                    if (chunk.name === \"pHYs\") {\n                        if (chunk.data.byteLength !== PHYS_HIDPI.length) return false;\n                        return chunk.data.every((val, i) => val === PHYS_HIDPI[i]);\n                    }\n                }\n                return false;\n            })\n            .catch((e) => {\n                console.error(\"Failed to parse PNG\", e);\n                return false;\n            });\n    }\n\n    const [hidpi] = await Promise.all([parsePromise, imgPromise]);\n    const width = hidpi ? img.width >> 1 : img.width;\n    const height = hidpi ? img.height >> 1 : img.height;\n    return { width, height, img };\n}\n\n// Minimum size for image files before we generate a thumbnail for them.\nconst IMAGE_SIZE_THRESHOLD_THUMBNAIL = 1 << 15; // 32KB\n// Minimum size improvement for image thumbnails, if both are not met then don't bother uploading thumbnail.\nconst IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE = 1 << 16; // 1MB\nconst IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT = 0.1; // 10%\n// We don't apply these thresholds to video thumbnails as a poster image is always useful\n// and videos tend to be much larger.\n\n// Image mime types for which to always include a thumbnail for even if it is larger than the input for wider support.\nconst ALWAYS_INCLUDE_THUMBNAIL = [\"image/avif\", \"image/webp\"];\n\n/**\n * Read the metadata for an image file and create and upload a thumbnail of the image.\n *\n * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.\n * @param {String} roomId The ID of the room the image will be uploaded in.\n * @param {File} imageFile The image to read and thumbnail.\n * @return {Promise} A promise that resolves with the attachment info.\n */\nasync function infoForImageFile(matrixClient: MatrixClient, roomId: string, imageFile: File): Promise<ImageInfo> {\n    let thumbnailType = \"image/png\";\n    if (imageFile.type === \"image/jpeg\") {\n        thumbnailType = \"image/jpeg\";\n    }\n\n    // We don't await this immediately so it can happen in the background\n    const isAnimatedPromise = blobIsAnimated(imageFile);\n\n    const imageElement = await loadImageElement(imageFile);\n\n    const result = await createThumbnail(imageElement.img, imageElement.width, imageElement.height, thumbnailType);\n    const imageInfo = result.info;\n\n    const isAnimated = await isAnimatedPromise;\n    if (isAnimated !== undefined) {\n        imageInfo[\"org.matrix.msc4230.is_animated\"] = await isAnimatedPromise;\n    }\n\n    // For lesser supported image types, always include the thumbnail even if it is larger\n    if (!ALWAYS_INCLUDE_THUMBNAIL.includes(imageFile.type)) {\n        // we do all sizing checks here because we still rely on thumbnail generation for making a blurhash from.\n        const sizeDifference = imageFile.size - imageInfo.thumbnail_info!.size!;\n        if (\n            // image is small enough already\n            imageFile.size <= IMAGE_SIZE_THRESHOLD_THUMBNAIL ||\n            // thumbnail is not sufficiently smaller than original\n            (sizeDifference <= IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE &&\n                sizeDifference <= imageFile.size * IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT)\n        ) {\n            delete imageInfo[\"thumbnail_info\"];\n            return imageInfo;\n        }\n    }\n\n    const uploadResult = await uploadFile(matrixClient, roomId, result.thumbnail);\n\n    imageInfo[\"thumbnail_url\"] = uploadResult.url;\n    imageInfo[\"thumbnail_file\"] = uploadResult.file;\n    return imageInfo;\n}\n\n/**\n * Load a file into a newly created audio element and load the metadata\n *\n * @param {File} audioFile The file to load in an audio element.\n * @return {Promise} A promise that resolves with the audio element.\n */\nfunction loadAudioElement(audioFile: File): Promise<HTMLAudioElement> {\n    return new Promise((resolve, reject) => {\n        // Load the file into a html element\n        const audio = document.createElement(\"audio\");\n        audio.preload = \"metadata\";\n        audio.muted = true;\n\n        const reader = new FileReader();\n\n        reader.onload = function (ev): void {\n            audio.onloadedmetadata = async function (): Promise<void> {\n                resolve(audio);\n            };\n            audio.onerror = function (e): void {\n                reject(e);\n            };\n\n            audio.src = ev.target?.result as string;\n        };\n        reader.onerror = function (e): void {\n            reject(e);\n        };\n        reader.readAsDataURL(audioFile);\n    });\n}\n\n/**\n * Read the metadata for an audio file.\n *\n * @param {File} audioFile The audio to read.\n * @return {Promise} A promise that resolves with the attachment info.\n */\nasync function infoForAudioFile(audioFile: File): Promise<AudioInfo> {\n    const audio = await loadAudioElement(audioFile);\n    return { duration: Math.ceil(audio.duration * 1000) };\n}\n\n/**\n * Load a file into a newly created video element and pull some strings\n * in an attempt to guarantee the first frame will be showing.\n *\n * @param {File} videoFile The file to load in a video element.\n * @return {Promise} A promise that resolves with the video element.\n */\nfunction loadVideoElement(videoFile: File): Promise<HTMLVideoElement> {\n    return new Promise((resolve, reject) => {\n        // Load the file into a html element\n        const video = document.createElement(\"video\");\n        video.preload = \"metadata\";\n        video.playsInline = true;\n        video.muted = true;\n\n        const reader = new FileReader();\n\n        reader.onload = function (ev): void {\n            // Wait until we have enough data to thumbnail the first frame.\n            video.onloadeddata = async function (): Promise<void> {\n                resolve(video);\n                video.pause();\n            };\n            video.onerror = function (e): void {\n                reject(e);\n            };\n\n            let dataUrl = ev.target?.result as string;\n            // Chrome chokes on quicktime but likes mp4, and `file.type` is\n            // read only, so do this horrible hack to unbreak quicktime\n            if (dataUrl?.startsWith(\"data:video/quicktime;\")) {\n                dataUrl = dataUrl.replace(\"data:video/quicktime;\", \"data:video/mp4;\");\n            }\n\n            video.src = dataUrl;\n            video.load();\n            video.play();\n        };\n        reader.onerror = function (e): void {\n            reject(e);\n        };\n        reader.readAsDataURL(videoFile);\n    });\n}\n\n/**\n * Read the metadata for a video file and create and upload a thumbnail of the video.\n *\n * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.\n * @param {String} roomId The ID of the room the video will be uploaded to.\n * @param {File} videoFile The video to read and thumbnail.\n * @return {Promise} A promise that resolves with the attachment info.\n */\nfunction infoForVideoFile(matrixClient: MatrixClient, roomId: string, videoFile: File): Promise<VideoInfo> {\n    const thumbnailType = \"image/jpeg\";\n\n    const videoInfo: VideoInfo = {};\n    return loadVideoElement(videoFile)\n        .then((video) => {\n            videoInfo.duration = Math.ceil(video.duration * 1000);\n            return createThumbnail(video, video.videoWidth, video.videoHeight, thumbnailType);\n        })\n        .then((result) => {\n            Object.assign(videoInfo, result.info);\n            return uploadFile(matrixClient, roomId, result.thumbnail);\n        })\n        .then((result) => {\n            videoInfo.thumbnail_url = result.url;\n            videoInfo.thumbnail_file = result.file;\n            return videoInfo;\n        });\n}\n\n/**\n * Read the file as an ArrayBuffer.\n * @param {File} file The file to read\n * @return {Promise} A promise that resolves with an ArrayBuffer when the file\n *   is read.\n */\nfunction readFileAsArrayBuffer(file: File | Blob): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = function (e): void {\n            resolve(e.target?.result as ArrayBuffer);\n        };\n        reader.onerror = function (e): void {\n            reject(e);\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\n\n/**\n * Upload the file to the content repository.\n * If the room is encrypted then encrypt the file before uploading.\n *\n * @param {MatrixClient} matrixClient The matrix client to upload the file with.\n * @param {String} roomId The ID of the room being uploaded to.\n * @param {File} file The file to upload.\n * @param {Function?} progressHandler optional callback to be called when a chunk of\n *    data is uploaded.\n * @param {AbortController?} controller optional abortController to use for this upload.\n * @return {Promise} A promise that resolves with an object.\n *  If the file is unencrypted then the object will have a \"url\" key.\n *  If the file is encrypted then the object will have a \"file\" key.\n */\nexport async function uploadFile(\n    matrixClient: MatrixClient,\n    roomId: string,\n    file: File | Blob,\n    progressHandler?: UploadOpts[\"progressHandler\"],\n    controller?: AbortController,\n): Promise<{ url?: string; file?: EncryptedFile }> {\n    const abortController = controller ?? new AbortController();\n\n    // If the room is encrypted then encrypt the file before uploading it.\n    if (await matrixClient.getCrypto()?.isEncryptionEnabledInRoom(roomId)) {\n        // First read the file into memory.\n        const data = await readFileAsArrayBuffer(file);\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n\n        // Then encrypt the file.\n        const encryptResult = await encrypt.encryptAttachment(data);\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n\n        // Pass the encrypted data as a Blob to the uploader.\n        const blob = new Blob([encryptResult.data]);\n\n        let url: string;\n        try {\n            ({ content_uri: url } = await matrixClient.uploadContent(blob, {\n                progressHandler,\n                abortController,\n                includeFilename: false,\n                type: \"application/octet-stream\",\n            }));\n        } catch (e) {\n            if (abortController.signal.aborted) throw new UploadCanceledError();\n            console.error(\"Failed to upload file\", e);\n            throw new UploadFailedError(e);\n        }\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n\n        // If the attachment is encrypted then bundle the URL along with the information\n        // needed to decrypt the attachment and add it under a file key.\n        return {\n            file: {\n                ...encryptResult.info,\n                url,\n            } as EncryptedFile,\n        };\n    } else {\n        let url: string;\n        try {\n            ({ content_uri: url } = await matrixClient.uploadContent(file, { progressHandler, abortController }));\n        } catch (e) {\n            if (abortController.signal.aborted) throw new UploadCanceledError();\n            console.error(\"Failed to upload file\", e);\n            throw new UploadFailedError(e);\n        }\n        if (abortController.signal.aborted) throw new UploadCanceledError();\n        // If the attachment isn't encrypted then include the URL directly.\n        return { url };\n    }\n}\n\nexport default class ContentMessages {\n    private inprogress: RoomUpload[] = [];\n    private mediaConfig: IMediaConfig | null = null;\n\n    public sendStickerContentToRoom(\n        url: string,\n        roomId: string,\n        threadId: string | null,\n        info: ImageInfo,\n        text: string,\n        matrixClient: MatrixClient,\n    ): Promise<ISendEventResponse> {\n        return doMaybeLocalRoomAction(\n            roomId,\n            (actualRoomId: string) => matrixClient.sendStickerMessage(actualRoomId, threadId, url, info, text),\n            matrixClient,\n        ).catch((e) => {\n            logger.warn(`Failed to send content with URL ${url} to room ${roomId}`, e);\n            throw e;\n        });\n    }\n\n    public getUploadLimit(): number | null {\n        return this.mediaConfig?.[\"m.upload.size\"] ?? null;\n    }\n\n    /**\n     * Sends a list of files to a room.\n     * @param files - The files to send.\n     * @param roomId - The ID of the room to send the files to.\n     * @param relation - The relation to the event being replied to.\n     * @param replyToEvent - The event being replied to, if any.\n     * @param matrixClient - The Matrix client to use for sending the files.\n     * @param context - The context in which the files are being sent.\n     * @returns A promise that resolves when the files have been sent.\n     */\n    public async sendContentListToRoom(\n        files: File[],\n        roomId: string,\n        relation: IEventRelation | undefined,\n        replyToEvent: MatrixEvent | undefined,\n        matrixClient: MatrixClient,\n        context = TimelineRenderingType.Room,\n    ): Promise<void> {\n        if (matrixClient.isGuest()) {\n            dis.dispatch({ action: \"require_registration\" });\n            return;\n        }\n\n        if (!this.mediaConfig) {\n            // hot-path optimization to not flash a spinner if we don't need to\n            const modal = Modal.createDialog(Spinner, undefined, \"mx_Dialog_spinner\");\n            await Promise.race([this.ensureMediaConfigFetched(matrixClient), modal.finished]);\n            if (!this.mediaConfig) {\n                // User cancelled by clicking away on the spinner\n                return;\n            } else {\n                modal.close();\n            }\n        }\n\n        const tooBigFiles: File[] = [];\n        const okFiles: File[] = [];\n\n        for (const file of files) {\n            if (this.isFileSizeAcceptable(file)) {\n                okFiles.push(file);\n            } else {\n                tooBigFiles.push(file);\n            }\n        }\n\n        if (tooBigFiles.length > 0) {\n            const { finished } = Modal.createDialog(UploadFailureDialog, {\n                badFiles: tooBigFiles,\n                totalFiles: files.length,\n                contentMessages: this,\n            });\n            const [shouldContinue] = await finished;\n            if (!shouldContinue) return;\n        }\n\n        let uploadAll = false;\n        // Promise to complete before sending next file into room, used for synchronisation of file-sending\n        // to match the order the files were specified in\n        let promBefore: Promise<any> = Promise.resolve();\n        for (let i = 0; i < okFiles.length; ++i) {\n            const file = okFiles[i];\n            const loopPromiseBefore = promBefore;\n\n            if (!uploadAll) {\n                const { finished } = Modal.createDialog(UploadConfirmDialog, {\n                    file,\n                    currentIndex: i,\n                    totalFiles: okFiles.length,\n                });\n                const [shouldContinue, shouldUploadAll] = await finished;\n                if (!shouldContinue) break;\n                if (shouldUploadAll) {\n                    uploadAll = true;\n                }\n            }\n\n            promBefore = doMaybeLocalRoomAction(\n                roomId,\n                (actualRoomId) =>\n                    this.sendContentToRoom(\n                        file,\n                        actualRoomId,\n                        relation,\n                        matrixClient,\n                        replyToEvent ?? undefined,\n                        loopPromiseBefore,\n                    ),\n                matrixClient,\n            );\n        }\n\n        if (replyToEvent) {\n            // Clear event being replied to\n            dis.dispatch({\n                action: \"reply_to_event\",\n                event: null,\n                context,\n            });\n        }\n\n        // Focus the correct composer\n        dis.dispatch({\n            action: Action.FocusSendMessageComposer,\n            context,\n        });\n    }\n\n    public getCurrentUploads(relation?: IEventRelation): RoomUpload[] {\n        return this.inprogress.filter((roomUpload) => {\n            const noRelation = !relation && !roomUpload.relation;\n            const matchingRelation =\n                relation &&\n                roomUpload.relation &&\n                relation.rel_type === roomUpload.relation.rel_type &&\n                relation.event_id === roomUpload.relation.event_id;\n\n            return (noRelation || matchingRelation) && !roomUpload.cancelled;\n        });\n    }\n\n    public cancelUpload(upload: RoomUpload): void {\n        upload.abort();\n        dis.dispatch<UploadCanceledPayload>({ action: Action.UploadCanceled, upload });\n    }\n\n    public async sendContentToRoom(\n        file: File,\n        roomId: string,\n        relation: IEventRelation | undefined,\n        matrixClient: MatrixClient,\n        replyToEvent: MatrixEvent | undefined,\n        promBefore?: Promise<any>,\n    ): Promise<void> {\n        const fileName = file.name || _t(\"common|attachment\");\n        const content: Omit<MediaEventContent, \"info\"> & { info: Partial<MediaEventInfo> } = {\n            body: fileName,\n            info: {\n                size: file.size,\n            },\n            msgtype: MsgType.File, // set more specifically later\n        };\n\n        // Attach mentions, which really only applies if there's a replyToEvent.\n        attachMentions(matrixClient.getSafeUserId(), content, null, replyToEvent);\n        attachRelation(content, relation);\n        if (replyToEvent) {\n            addReplyToMessageContent(content, replyToEvent);\n        }\n\n        if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\n            decorateStartSendingTime(content);\n        }\n\n        // if we have a mime type for the file, add it to the message metadata\n        if (file.type) {\n            content.info.mimetype = file.type;\n        }\n\n        const upload = new RoomUpload(roomId, fileName, relation, file.size);\n        this.inprogress.push(upload);\n        dis.dispatch<UploadStartedPayload>({ action: Action.UploadStarted, upload });\n\n        function onProgress(progress: UploadProgress): void {\n            upload.onProgress(progress);\n            dis.dispatch<UploadProgressPayload>({ action: Action.UploadProgress, upload });\n        }\n\n        try {\n            if (file.type.startsWith(\"image/\")) {\n                content.msgtype = MsgType.Image;\n                try {\n                    const imageInfo = await infoForImageFile(matrixClient, roomId, file);\n                    Object.assign(content.info, imageInfo);\n                } catch (e) {\n                    if (e instanceof UploadFailedError) {\n                        // re-throw to main upload error handler\n                        throw e;\n                    }\n                    // Otherwise we failed to thumbnail, fall back to uploading an m.file\n                    logger.error(e);\n                    content.msgtype = MsgType.File;\n                }\n            } else if (file.type.startsWith(\"audio/\")) {\n                content.msgtype = MsgType.Audio;\n                try {\n                    const audioInfo = await infoForAudioFile(file);\n                    Object.assign(content.info, audioInfo);\n                } catch (e) {\n                    // Failed to process audio file, fall back to uploading an m.file\n                    logger.error(e);\n                    content.msgtype = MsgType.File;\n                }\n            } else if (file.type.startsWith(\"video/\")) {\n                content.msgtype = MsgType.Video;\n                try {\n                    const videoInfo = await infoForVideoFile(matrixClient, roomId, file);\n                    Object.assign(content.info, videoInfo);\n                } catch (e) {\n                    // Failed to thumbnail, fall back to uploading an m.file\n                    logger.error(e);\n                    content.msgtype = MsgType.File;\n                }\n            } else {\n                content.msgtype = MsgType.File;\n            }\n\n            if (upload.cancelled) throw new UploadCanceledError();\n            const result = await uploadFile(matrixClient, roomId, file, onProgress, upload.abortController);\n            content.file = result.file;\n            content.url = result.url;\n\n            if (upload.cancelled) throw new UploadCanceledError();\n            // Await previous message being sent into the room\n            if (promBefore) await promBefore;\n\n            if (upload.cancelled) throw new UploadCanceledError();\n            const threadId = relation?.rel_type === THREAD_RELATION_TYPE.name ? relation.event_id : null;\n\n            const response = await matrixClient.sendMessage(roomId, threadId ?? null, content as MediaEventContent);\n\n            if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\n                sendRoundTripMetric(matrixClient, roomId, response.event_id);\n            }\n\n            dis.dispatch<UploadFinishedPayload>({ action: Action.UploadFinished, upload });\n            dis.dispatch({ action: \"message_sent\" });\n        } catch (error) {\n            // Unwrap UploadFailedError to get the underlying error\n            const unwrappedError = error instanceof UploadFailedError && error.cause ? error.cause : error;\n\n            // 413: File was too big or upset the server in some way:\n            // clear the media size limit so we fetch it again next time we try to upload\n            if (unwrappedError instanceof HTTPError && unwrappedError.httpStatus === 413) {\n                this.mediaConfig = null;\n            }\n\n            if (!upload.cancelled) {\n                let desc = _t(\"upload_failed_generic\", { fileName: upload.fileName });\n                if (unwrappedError instanceof HTTPError && unwrappedError.httpStatus === 413) {\n                    desc = _t(\"upload_failed_size\", {\n                        fileName: upload.fileName,\n                    });\n                }\n                Modal.createDialog(ErrorDialog, {\n                    title: _t(\"upload_failed_title\"),\n                    description: desc,\n                });\n                dis.dispatch<UploadErrorPayload>({ action: Action.UploadFailed, upload, error });\n            }\n        } finally {\n            removeElement(this.inprogress, (e) => e.promise === upload.promise);\n        }\n    }\n\n    private isFileSizeAcceptable(file: File): boolean {\n        if (this.mediaConfig?.[\"m.upload.size\"] !== undefined && file.size > this.mediaConfig[\"m.upload.size\"]) {\n            return false;\n        }\n        return true;\n    }\n\n    private ensureMediaConfigFetched(matrixClient: MatrixClient): Promise<void> {\n        if (this.mediaConfig !== null) return Promise.resolve();\n\n        logger.log(\"[Media Config] Fetching\");\n        return matrixClient\n            .getMediaConfig()\n            .then((config) => {\n                logger.log(\"[Media Config] Fetched config:\", config);\n                return config;\n            })\n            .catch(() => {\n                // Media repo can't or won't report limits, so provide an empty object (no limits).\n                logger.log(\"[Media Config] Could not fetch config, so not limiting uploads.\");\n                return {};\n            })\n            .then((config) => {\n                this.mediaConfig = config;\n            });\n    }\n\n    public static sharedInstance(): ContentMessages {\n        if (window.mxContentMessages === undefined) {\n            window.mxContentMessages = new ContentMessages();\n        }\n        return window.mxContentMessages;\n    }\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type IContent, type MatrixClient } from \"matrix-js-sdk/src/matrix\";\n\n/**\n * Decorates the given event content object with the \"send start time\". The\n * object will be modified in-place.\n * @param {object} content The event content.\n */\nexport function decorateStartSendingTime(content: IContent): void {\n    content[\"io.element.performance_metrics\"] = {\n        sendStartTs: Date.now(),\n    };\n}\n\n/**\n * Called when an event decorated with `decorateStartSendingTime()` has been sent\n * by the server (the client now knows the event ID).\n * @param {MatrixClient} client The client to send as.\n * @param {string} inRoomId The room ID where the original event was sent.\n * @param {string} forEventId The event ID for the decorated event.\n */\nexport function sendRoundTripMetric(client: MatrixClient, inRoomId: string, forEventId: string): void {\n    // noinspection JSIgnoredPromiseFromCall\n    client.sendEvent(inRoomId, \"io.element.performance_metric\", {\n        \"io.element.performance_metrics\": {\n            forEventId: forEventId,\n            responseTs: Date.now(),\n            kind: \"send_time\",\n        },\n    });\n}\n"],"names":["crc32","module","exports","data","Error","ended","chunks","idx","length","uint8","uint32","chunk","Uint8Array","name","String","fromCharCode","push","i","crcActual","int32","buf","chunkData","buffer","slice","Int32Array","Uint32Array","factory","CRC32","version","table","c","Array","n","signed_crc_table","use_buffer","Buffer","crc32_buf_8","crc","L","bstr","charCodeAt","str","d","DO_NOT_EXPORT_CRC","RoomUpload","constructor","roomId","fileName","relation","fileSize","_defineProperty","AbortController","onProgress","progress","this","uploaded","loaded","total","abort","abortController","cancelled","signal","aborted","UploadFailureDialog","React","args","props","onFinished","render","message","buttons","totalFiles","badFiles","_t","limit","contentMessages","getUploadLimit","sizeOfThisFile","size","b","sub","DialogButtons","primaryButton","hasCancel","onPrimaryButtonClick","onCancelClick","focus","howManyOthers","count","onUploadClick","cancelButton","onCancel","BaseDialog","className","title","contentId","id","preview","PHYS_HIDPI","UploadCanceledError","UploadFailedError","cause","super","ALWAYS_INCLUDE_THUMBNAIL","async","infoForImageFile","matrixClient","imageFile","thumbnailType","type","isAnimatedPromise","blobIsAnimated","imageElement","img","Image","objectUrl","URL","createObjectURL","imgPromise","Promise","resolve","reject","onload","revokeObjectURL","onerror","e","src","parsePromise","readFileAsArrayBuffer","then","arrayBuffer","extractPngChunks","byteLength","every","val","catch","console","error","hidpi","all","width","height","loadImageElement","result","createThumbnail","imageInfo","info","undefined","includes","sizeDifference","thumbnail_info","uploadResult","uploadFile","thumbnail","url","file","infoForAudioFile","audioFile","audio","document","createElement","preload","muted","reader","FileReader","ev","_ev$target","onloadedmetadata","target","readAsDataURL","loadAudioElement","duration","Math","ceil","infoForVideoFile","videoFile","videoInfo","video","playsInline","_ev$target2","_dataUrl","onloadeddata","pause","dataUrl","startsWith","replace","load","play","loadVideoElement","videoWidth","videoHeight","Object","assign","thumbnail_url","thumbnail_file","_e$target","readAsArrayBuffer","progressHandler","controller","_matrixClient$getCryp","getCrypto","isEncryptionEnabledInRoom","encryptResult","encrypt","blob","Blob","content_uri","uploadContent","includeFilename","_objectSpread","ContentMessages","sendStickerContentToRoom","threadId","text","doMaybeLocalRoomAction","actualRoomId","sendStickerMessage","logger","warn","_this$mediaConfig$mU","_this$mediaConfig","mediaConfig","sendContentListToRoom","files","replyToEvent","context","TimelineRenderingType","Room","isGuest","dis","dispatch","action","modal","Modal","createDialog","Spinner","race","ensureMediaConfigFetched","finished","close","tooBigFiles","okFiles","isFileSizeAcceptable","shouldContinue","uploadAll","promBefore","loopPromiseBefore","UploadConfirmDialog","currentIndex","shouldUploadAll","sendContentToRoom","event","Action","FocusSendMessageComposer","getCurrentUploads","inprogress","filter","roomUpload","noRelation","matchingRelation","rel_type","event_id","cancelUpload","upload","UploadCanceled","content","body","msgtype","MsgType","File","attachMentions","getSafeUserId","attachRelation","addReplyToMessageContent","SettingsStore","getValue","decorateStartSendingTime","mimetype","UploadStarted","Audio","audioInfo","Video","UploadProgress","THREAD_RELATION_TYPE","response","sendMessage","sendRoundTripMetric","UploadFinished","unwrappedError","HTTPError","httpStatus","desc","ErrorDialog","description","UploadFailed","removeElement","promise","_this$mediaConfig2","log","getMediaConfig","config","sharedInstance","window","mxContentMessages","sendStartTs","Date","now","client","inRoomId","forEventId","sendEvent","responseTs","kind"],"sourceRoot":""}