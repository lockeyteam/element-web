{"version":3,"file":"bundles/ae0ae3bc04d76eaf7997/234.js","mappings":"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","sources":["webpack://element-web/./src/components/views/dialogs/security/RestoreKeyBackupDialog.tsx","webpack://element-web/./src/async-components/views/dialogs/security/NewRecoveryMethodDialog.tsx"],"sourcesContent":["/*\nCopyright 2024 New Vector Ltd.\nCopyright 2020 The Matrix.org Foundation C.I.C.\nCopyright 2018, 2019 New Vector Ltd\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport React, { type ChangeEvent } from \"react\";\nimport { MatrixClient, MatrixError } from \"matrix-js-sdk/src/matrix\";\nimport { decodeRecoveryKey, type KeyBackupInfo, type KeyBackupRestoreResult } from \"matrix-js-sdk/src/crypto-api\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\n\nimport { MatrixClientPeg } from \"../../../../MatrixClientPeg\";\nimport { _t } from \"../../../../languageHandler\";\nimport { accessSecretStorage } from \"../../../../SecurityManager\";\nimport Spinner from \"../../elements/Spinner\";\nimport DialogButtons from \"../../elements/DialogButtons\";\nimport AccessibleButton from \"../../elements/AccessibleButton\";\nimport BaseDialog from \"../BaseDialog\";\n\nenum RestoreType {\n    Passphrase = \"passphrase\",\n    RecoveryKey = \"recovery_key\",\n    SecretStorage = \"secret_storage\",\n}\n\nenum ProgressState {\n    PreFetch = \"prefetch\",\n    Fetch = \"fetch\",\n    LoadKeys = \"load_keys\",\n}\n\ninterface IProps {\n    // if false, will close the dialog as soon as the restore completes successfully\n    // default: true\n    showSummary?: boolean;\n    onFinished(done?: boolean): void;\n}\n\ninterface IState {\n    backupInfo: KeyBackupInfo | null;\n    loading: boolean;\n    loadError: boolean | null;\n    restoreError: unknown | null;\n    recoveryKey: string;\n    recoverInfo: KeyBackupRestoreResult | null;\n    recoveryKeyValid: boolean;\n    forceRecoveryKey: boolean;\n    passPhrase: string;\n    restoreType: RestoreType | null;\n    progress: {\n        stage: ProgressState | string;\n        total?: number;\n        successes?: number;\n        failures?: number;\n    };\n}\n\n/*\n * Dialog for restoring e2e keys from a backup and the user's recovery key\n */\nexport default class RestoreKeyBackupDialog extends React.PureComponent<IProps, IState> {\n    public static defaultProps: Partial<IProps> = {\n        showSummary: true,\n    };\n\n    public constructor(props: IProps) {\n        super(props);\n        this.state = {\n            backupInfo: null,\n            loading: false,\n            loadError: null,\n            restoreError: null,\n            recoveryKey: \"\",\n            recoverInfo: null,\n            recoveryKeyValid: false,\n            forceRecoveryKey: false,\n            passPhrase: \"\",\n            restoreType: null,\n            progress: { stage: ProgressState.PreFetch },\n        };\n    }\n\n    public componentDidMount(): void {\n        this.loadBackupStatus();\n    }\n\n    private onCancel = (): void => {\n        this.props.onFinished(false);\n    };\n\n    private onDone = (): void => {\n        this.props.onFinished(true);\n    };\n\n    private onUseRecoveryKeyClick = (): void => {\n        this.setState({\n            forceRecoveryKey: true,\n        });\n    };\n\n    private progressCallback = (data: IState[\"progress\"]): void => {\n        this.setState({\n            progress: data,\n        });\n    };\n\n    private onResetRecoveryClick = (): void => {\n        this.props.onFinished(false);\n        accessSecretStorage(async (): Promise<void> => {}, { forceReset: true });\n    };\n\n    /**\n     * Check if the recovery key is valid\n     * @param recoveryKey\n     * @private\n     */\n    private isValidRecoveryKey(recoveryKey: string): boolean {\n        try {\n            decodeRecoveryKey(recoveryKey);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    private onRecoveryKeyChange = (e: ChangeEvent<HTMLInputElement>): void => {\n        this.setState({\n            recoveryKey: e.target.value,\n            recoveryKeyValid: this.isValidRecoveryKey(e.target.value),\n        });\n    };\n\n    private onPassPhraseNext = async (): Promise<void> => {\n        const crypto = MatrixClientPeg.safeGet().getCrypto();\n        if (!crypto) return;\n        this.setState({\n            loading: true,\n            restoreError: null,\n            restoreType: RestoreType.Passphrase,\n        });\n        try {\n            // We do still restore the key backup: we must ensure that the key backup key\n            // is the right one and restoring it is currently the only way we can do this.\n            const recoverInfo = await crypto.restoreKeyBackupWithPassphrase(this.state.passPhrase, {\n                progressCallback: this.progressCallback,\n            });\n\n            if (!this.props.showSummary) {\n                this.props.onFinished(true);\n                return;\n            }\n            this.setState({\n                loading: false,\n                recoverInfo,\n            });\n        } catch (e) {\n            logger.log(\"Error restoring backup\", e);\n            this.setState({\n                loading: false,\n                restoreError: e,\n            });\n        }\n    };\n\n    private onRecoveryKeyNext = async (): Promise<void> => {\n        const crypto = MatrixClientPeg.safeGet().getCrypto();\n        if (!this.state.recoveryKeyValid || !this.state.backupInfo?.version || !crypto) return;\n\n        this.setState({\n            loading: true,\n            restoreError: null,\n            restoreType: RestoreType.RecoveryKey,\n        });\n        try {\n            await crypto.storeSessionBackupPrivateKey(\n                decodeRecoveryKey(this.state.recoveryKey),\n                this.state.backupInfo.version,\n            );\n            const recoverInfo = await crypto.restoreKeyBackup({\n                progressCallback: this.progressCallback,\n            });\n\n            if (!this.props.showSummary) {\n                this.props.onFinished(true);\n                return;\n            }\n            this.setState({\n                loading: false,\n                recoverInfo,\n            });\n        } catch (e) {\n            logger.log(\"Error restoring backup\", e);\n            this.setState({\n                loading: false,\n                restoreError: e,\n            });\n        }\n    };\n\n    private onPassPhraseChange = (e: ChangeEvent<HTMLInputElement>): void => {\n        this.setState({\n            passPhrase: e.target.value,\n        });\n    };\n\n    private async restoreWithSecretStorage(): Promise<boolean> {\n        const crypto = MatrixClientPeg.safeGet().getCrypto();\n        if (!crypto) return false;\n\n        this.setState({\n            restoreError: null,\n            restoreType: RestoreType.SecretStorage,\n        });\n        try {\n            let recoverInfo: KeyBackupRestoreResult | null = null;\n            // `accessSecretStorage` may prompt for storage access as needed.\n            await accessSecretStorage(async (): Promise<void> => {\n                await crypto.loadSessionBackupPrivateKeyFromSecretStorage();\n                recoverInfo = await crypto.restoreKeyBackup({ progressCallback: this.progressCallback });\n            });\n            this.setState({\n                loading: false,\n                recoverInfo,\n            });\n            return true;\n        } catch (e) {\n            logger.log(\"restoreWithSecretStorage failed:\", e);\n            this.setState({\n                restoreError: e,\n                loading: false,\n            });\n            return false;\n        }\n    }\n\n    private async restoreWithCachedKey(backupInfo: KeyBackupInfo | null): Promise<boolean> {\n        const crypto = MatrixClientPeg.safeGet().getCrypto();\n        if (!crypto) return false;\n        try {\n            const recoverInfo = await crypto.restoreKeyBackup({ progressCallback: this.progressCallback });\n            this.setState({\n                recoverInfo,\n            });\n            return true;\n        } catch (e) {\n            logger.log(\"restoreWithCachedKey failed:\", e);\n            return false;\n        }\n    }\n\n    private async loadBackupStatus(): Promise<void> {\n        this.setState({\n            loading: true,\n            loadError: null,\n        });\n        try {\n            const cli = MatrixClientPeg.safeGet();\n            const backupInfo = (await cli.getCrypto()?.getKeyBackupInfo()) ?? null;\n            const has4S = await cli.secretStorage.hasKey();\n            const backupKeyStored = has4S ? await cli.isKeyBackupKeyStored() : null;\n            this.setState({\n                backupInfo,\n            });\n\n            const gotCache = await this.restoreWithCachedKey(backupInfo);\n            if (gotCache) {\n                logger.log(\"RestoreKeyBackupDialog: found cached backup key\");\n                this.setState({\n                    loading: false,\n                });\n                return;\n            }\n\n            const hasBackupFromSS = backupKeyStored && (await this.restoreWithSecretStorage());\n            if (hasBackupFromSS) {\n                logger.log(\"RestoreKeyBackupDialog: found backup key in secret storage\");\n                this.setState({\n                    loading: false,\n                });\n                return;\n            }\n\n            this.setState({\n                loadError: null,\n                loading: false,\n            });\n        } catch (e) {\n            logger.log(\"Error loading backup status\", e);\n            this.setState({\n                loadError: true,\n                loading: false,\n            });\n        }\n    }\n\n    public render(): React.ReactNode {\n        const backupHasPassphrase =\n            this.state.backupInfo &&\n            this.state.backupInfo.auth_data &&\n            this.state.backupInfo.auth_data.private_key_salt &&\n            this.state.backupInfo.auth_data.private_key_iterations;\n\n        let content;\n        let title;\n        if (this.state.loading) {\n            title = _t(\"encryption|access_secret_storage_dialog|restoring\");\n            let details;\n            if (this.state.progress.stage === ProgressState.Fetch) {\n                details = _t(\"restore_key_backup_dialog|key_fetch_in_progress\");\n            } else if (this.state.progress.stage === ProgressState.LoadKeys) {\n                const { total, successes, failures } = this.state.progress;\n                details = _t(\"restore_key_backup_dialog|load_keys_progress\", {\n                    total,\n                    completed: (successes ?? 0) + (failures ?? 0),\n                });\n            } else if (this.state.progress.stage === ProgressState.PreFetch) {\n                details = _t(\"restore_key_backup_dialog|key_fetch_in_progress\");\n            }\n            content = (\n                <div>\n                    <div>{details}</div>\n                    <Spinner />\n                </div>\n            );\n        } else if (this.state.loadError) {\n            title = _t(\"common|error\");\n            content = _t(\"restore_key_backup_dialog|load_error_content\");\n        } else if (this.state.restoreError) {\n            if (\n                this.state.restoreError instanceof MatrixError &&\n                this.state.restoreError.errcode === MatrixClient.RESTORE_BACKUP_ERROR_BAD_KEY\n            ) {\n                if (this.state.restoreType === RestoreType.RecoveryKey) {\n                    title = _t(\"restore_key_backup_dialog|recovery_key_mismatch_title\");\n                    content = (\n                        <div>\n                            <p>{_t(\"restore_key_backup_dialog|recovery_key_mismatch_description\")}</p>\n                        </div>\n                    );\n                } else {\n                    title = _t(\"restore_key_backup_dialog|incorrect_security_phrase_title\");\n                    content = (\n                        <div>\n                            <p>{_t(\"restore_key_backup_dialog|incorrect_security_phrase_dialog\")}</p>\n                        </div>\n                    );\n                }\n            } else {\n                title = _t(\"common|error\");\n                content = _t(\"restore_key_backup_dialog|restore_failed_error\");\n            }\n        } else if (this.state.backupInfo === null) {\n            title = _t(\"common|error\");\n            content = _t(\"restore_key_backup_dialog|no_backup_error\");\n        } else if (this.state.recoverInfo) {\n            title = _t(\"restore_key_backup_dialog|keys_restored_title\");\n            let failedToDecrypt;\n            if (this.state.recoverInfo.total > this.state.recoverInfo.imported) {\n                failedToDecrypt = (\n                    <p>\n                        {_t(\"restore_key_backup_dialog|count_of_decryption_failures\", {\n                            failedCount: this.state.recoverInfo.total - this.state.recoverInfo.imported,\n                        })}\n                    </p>\n                );\n            }\n            content = (\n                <div>\n                    <p>\n                        {_t(\"restore_key_backup_dialog|count_of_successfully_restored_keys\", {\n                            sessionCount: this.state.recoverInfo.imported,\n                        })}\n                    </p>\n                    {failedToDecrypt}\n                    <DialogButtons\n                        primaryButton={_t(\"action|ok\")}\n                        onPrimaryButtonClick={this.onDone}\n                        hasCancel={false}\n                        focus={true}\n                    />\n                </div>\n            );\n        } else if (backupHasPassphrase && !this.state.forceRecoveryKey) {\n            title = _t(\"restore_key_backup_dialog|enter_phrase_title\");\n            content = (\n                <div>\n                    <p>\n                        {_t(\"restore_key_backup_dialog|key_backup_warning\", {}, { b: (sub) => <strong>{sub}</strong> })}\n                    </p>\n                    <p>{_t(\"restore_key_backup_dialog|enter_phrase_description\")}</p>\n\n                    <form className=\"mx_RestoreKeyBackupDialog_primaryContainer\">\n                        <input\n                            data-testid=\"passphraseInput\"\n                            type=\"password\"\n                            className=\"mx_RestoreKeyBackupDialog_passPhraseInput\"\n                            onChange={this.onPassPhraseChange}\n                            value={this.state.passPhrase}\n                            autoFocus={true}\n                        />\n                        <DialogButtons\n                            primaryButton={_t(\"action|next\")}\n                            onPrimaryButtonClick={this.onPassPhraseNext}\n                            primaryIsSubmit={true}\n                            hasCancel={true}\n                            onCancel={this.onCancel}\n                            focus={false}\n                        />\n                    </form>\n                    {_t(\n                        \"restore_key_backup_dialog|phrase_forgotten_text\",\n                        {},\n                        {\n                            button1: (s) => (\n                                <AccessibleButton kind=\"link_inline\" onClick={this.onUseRecoveryKeyClick}>\n                                    {s}\n                                </AccessibleButton>\n                            ),\n                            button2: (s) => (\n                                <AccessibleButton kind=\"link_inline\" onClick={this.onResetRecoveryClick}>\n                                    {s}\n                                </AccessibleButton>\n                            ),\n                        },\n                    )}\n                </div>\n            );\n        } else {\n            title = _t(\"restore_key_backup_dialog|enter_key_title\");\n\n            let keyStatus;\n            if (this.state.recoveryKey.length === 0) {\n                keyStatus = <div className=\"mx_RestoreKeyBackupDialog_keyStatus\" />;\n            } else if (this.state.recoveryKeyValid) {\n                keyStatus = (\n                    <div className=\"mx_RestoreKeyBackupDialog_keyStatus\">\n                        {\"\\uD83D\\uDC4D \"}\n                        {_t(\"restore_key_backup_dialog|key_is_valid\")}\n                    </div>\n                );\n            } else {\n                keyStatus = (\n                    <div className=\"mx_RestoreKeyBackupDialog_keyStatus\">\n                        {\"\\uD83D\\uDC4E \"}\n                        {_t(\"restore_key_backup_dialog|key_is_invalid\")}\n                    </div>\n                );\n            }\n\n            content = (\n                <div>\n                    <p>\n                        {_t(\"restore_key_backup_dialog|key_backup_warning\", {}, { b: (sub) => <strong>{sub}</strong> })}\n                    </p>\n                    <p>{_t(\"restore_key_backup_dialog|enter_key_description\")}</p>\n\n                    <div className=\"mx_RestoreKeyBackupDialog_primaryContainer\">\n                        <input\n                            className=\"mx_RestoreKeyBackupDialog_recoveryKeyInput\"\n                            onChange={this.onRecoveryKeyChange}\n                            value={this.state.recoveryKey}\n                            autoFocus={true}\n                        />\n                        {keyStatus}\n                        <DialogButtons\n                            primaryButton={_t(\"action|next\")}\n                            onPrimaryButtonClick={this.onRecoveryKeyNext}\n                            hasCancel={true}\n                            onCancel={this.onCancel}\n                            focus={false}\n                            primaryDisabled={!this.state.recoveryKeyValid}\n                        />\n                    </div>\n                    {_t(\n                        \"restore_key_backup_dialog|key_forgotten_text\",\n                        {},\n                        {\n                            button: (s) => (\n                                <AccessibleButton kind=\"link_inline\" onClick={this.onResetRecoveryClick}>\n                                    {s}\n                                </AccessibleButton>\n                            ),\n                        },\n                    )}\n                </div>\n            );\n        }\n\n        return (\n            <BaseDialog className=\"mx_RestoreKeyBackupDialog\" onFinished={this.props.onFinished} title={title}>\n                <div className=\"mx_RestoreKeyBackupDialog_content\">{content}</div>\n            </BaseDialog>\n        );\n    }\n}\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2020 The Matrix.org Foundation C.I.C.\nCopyright 2018, 2019 New Vector Ltd\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport React, { type JSX, useEffect, useState } from \"react\";\n\nimport dis from \"../../../../dispatcher/dispatcher\";\nimport { _t } from \"../../../../languageHandler\";\nimport Modal from \"../../../../Modal\";\nimport RestoreKeyBackupDialog from \"../../../../components/views/dialogs/security/RestoreKeyBackupDialog\";\nimport { Action } from \"../../../../dispatcher/actions\";\nimport DialogButtons from \"../../../../components/views/elements/DialogButtons\";\nimport BaseDialog from \"../../../../components/views/dialogs/BaseDialog\";\nimport { useMatrixClientContext } from \"../../../../contexts/MatrixClientContext.tsx\";\n\n/**\n * Properties for {@link NewRecoveryMethodDialog}.\n */\ninterface NewRecoveryMethodDialogProps {\n    /**\n     * Callback when the dialog is dismissed.\n     */\n    onFinished(): void;\n}\n\n// Export as default instead of a named export so that it can be dynamically imported with React lazy\n\n/**\n * Dialog to inform the user that a new recovery method has been detected.\n */\nexport default function NewRecoveryMethodDialog({ onFinished }: NewRecoveryMethodDialogProps): JSX.Element {\n    const matrixClient = useMatrixClientContext();\n    const [isKeyBackupEnabled, setIsKeyBackupEnabled] = useState(false);\n    useEffect(() => {\n        const checkBackupEnabled = async (): Promise<void> => {\n            const crypto = matrixClient.getCrypto();\n            setIsKeyBackupEnabled(Boolean(crypto && (await crypto.getActiveSessionBackupVersion()) !== null));\n        };\n\n        checkBackupEnabled();\n    }, [matrixClient]);\n\n    function onClick(): void {\n        if (isKeyBackupEnabled) {\n            onFinished();\n        } else {\n            const { finished } = Modal.createDialog(RestoreKeyBackupDialog, {}, undefined, false, true);\n            finished.then(onFinished);\n        }\n    }\n\n    return (\n        <BaseDialog\n            className=\"mx_KeyBackupFailedDialog\"\n            onFinished={onFinished}\n            title={\n                <span className=\"mx_KeyBackupFailedDialog_title\">\n                    {_t(\"encryption|new_recovery_method_detected|title\")}\n                </span>\n            }\n        >\n            <p>{_t(\"encryption|new_recovery_method_detected|description_1\")}</p>\n            {isKeyBackupEnabled && <p>{_t(\"encryption|new_recovery_method_detected|description_2\")}</p>}\n            <strong className=\"warning\">{_t(\"encryption|new_recovery_method_detected|warning\")}</strong>\n            <DialogButtons\n                primaryButton={_t(\"common|setup_secure_messages\")}\n                onPrimaryButtonClick={onClick}\n                cancelButton={_t(\"common|go_to_settings\")}\n                onCancel={() => {\n                    onFinished();\n                    dis.fire(Action.ViewUserSettings);\n                }}\n            />\n        </BaseDialog>\n    );\n}\n"],"names":["RestoreType","ProgressState","RestoreKeyBackupDialog","React","constructor","props","super","_defineProperty","this","onFinished","setState","forceRecoveryKey","data","progress","accessSecretStorage","async","forceReset","e","recoveryKey","target","value","recoveryKeyValid","isValidRecoveryKey","crypto","MatrixClientPeg","safeGet","getCrypto","loading","restoreError","restoreType","Passphrase","recoverInfo","restoreKeyBackupWithPassphrase","state","passPhrase","progressCallback","showSummary","logger","log","_this$state$backupInf","backupInfo","version","RecoveryKey","storeSessionBackupPrivateKey","decodeRecoveryKey","restoreKeyBackup","loadError","stage","PreFetch","componentDidMount","loadBackupStatus","restoreWithSecretStorage","SecretStorage","loadSessionBackupPrivateKeyFromSecretStorage","restoreWithCachedKey","_await$cli$getCrypto$","_cli$getCrypto","cli","getKeyBackupInfo","backupKeyStored","secretStorage","hasKey","isKeyBackupKeyStored","render","backupHasPassphrase","auth_data","private_key_salt","private_key_iterations","content","title","details","_t","Fetch","LoadKeys","total","successes","failures","completed","Spinner","MatrixError","errcode","MatrixClient","RESTORE_BACKUP_ERROR_BAD_KEY","failedToDecrypt","imported","failedCount","sessionCount","DialogButtons","primaryButton","onPrimaryButtonClick","onDone","hasCancel","focus","b","sub","className","type","onChange","onPassPhraseChange","autoFocus","onPassPhraseNext","primaryIsSubmit","onCancel","button1","s","AccessibleButton","kind","onClick","onUseRecoveryKeyClick","button2","onResetRecoveryClick","keyStatus","length","onRecoveryKeyChange","onRecoveryKeyNext","primaryDisabled","button","BaseDialog","NewRecoveryMethodDialog","matrixClient","useMatrixClientContext","isKeyBackupEnabled","setIsKeyBackupEnabled","useState","useEffect","Boolean","getActiveSessionBackupVersion","checkBackupEnabled","finished","Modal","createDialog","undefined","then","cancelButton","dis","fire","Action","ViewUserSettings"],"sourceRoot":""}