{"version":3,"file":"bundles/c63939549511ecf2b427/1436.js","mappings":"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","sources":["webpack://element-web/./src/stores/room-list-v3/skip-list/RoomNode.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/utils.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/Level.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/iterators.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/RoomSkipList.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/sorters/RecencySorter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/sorters/AlphabeticSorter.ts","webpack://element-web/./src/stores/room-list-v3/RoomListStoreV3.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/FavouriteFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/UnreadFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/PeopleFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/RoomsFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/InvitesFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/MentionsFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/LowPriorityFilter.ts","webpack://element-web/./src/stores/room-list-v3/skip-list/filters/index.ts"],"sourcesContent":["/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter, FilterKey } from \"./filters\";\nimport SpaceStore from \"../../spaces/SpaceStore\";\n\n/**\n * Room skip list stores room nodes.\n * These hold the actual room object and provides references to other nodes\n * in different levels.\n */\nexport class RoomNode {\n    private _isInActiveSpace: boolean = false;\n\n    public constructor(public readonly room: Room) {}\n\n    /**\n     * This array holds references to the next node in a given level.\n     * eg: next[i] gives the next room node from this room node in level i.\n     */\n    public next: RoomNode[] = [];\n\n    /**\n     * This array holds references to the previous node in a given level.\n     * eg: previous[i] gives the previous room node from this room node in level i.\n     */\n    public previous: RoomNode[] = [];\n\n    /**\n     * Whether the room associated with this room node belongs to\n     * the currently active space.\n     * @see {@link SpaceStoreClass#activeSpace} to understand what active\n     * space means.\n     */\n    public get isInActiveSpace(): boolean {\n        return this._isInActiveSpace;\n    }\n\n    /**\n     * Check if this room belongs to the active space and store the result\n     * in {@link RoomNode#isInActiveSpace}.\n     */\n    public checkIfRoomBelongsToActiveSpace(): void {\n        const activeSpace = SpaceStore.instance.activeSpace;\n        this._isInActiveSpace = SpaceStore.instance.isRoomInSpace(activeSpace, this.room.roomId);\n    }\n\n    /**\n     * Aggregates all the filter keys that apply to this room.\n     * eg: if filterKeysSet.has(Filter.FavouriteFilter) is true, then this room is a favourite room.\n     */\n    private filterKeysSet: Set<FilterKey> = new Set();\n\n    /**\n     * Returns true if the associated room matches all the provided filters.\n     * Returns false otherwise.\n     * @param filterKeys An array of filter keys to check against.\n     */\n    public doesRoomMatchFilters(filterKeys: FilterKey[]): boolean {\n        return !filterKeys.some((key) => !this.filterKeysSet.has(key));\n    }\n\n    /**\n     * Populates {@link RoomNode#filterKeysSet} by checking if the associated room\n     * satisfies the given filters.\n     * @param filters A list of filters\n     */\n    public applyFilters(filters: Filter[]): void {\n        this.filterKeysSet = new Set();\n        for (const filter of filters) {\n            if (filter.matches(this.room)) this.filterKeysSet.add(filter.key);\n        }\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nexport function shouldPromote(): boolean {\n    return Math.random() < 0.5;\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { RoomNode } from \"./RoomNode\";\nimport { shouldPromote } from \"./utils\";\n\n/**\n * Represents one level of the skip list\n */\nexport class Level {\n    public head?: RoomNode;\n    private current?: RoomNode;\n    private _size: number = 0;\n\n    /**\n     * The number of elements in this level\n     */\n    public get size(): number {\n        return this._size;\n    }\n\n    public constructor(public readonly level: number) {}\n\n    /**\n     * Insert node after current\n     */\n    public setNext(node: RoomNode): void {\n        if (!this.head) this.head = node;\n        if (!this.current) {\n            this.current = node;\n        } else {\n            node.previous[this.level] = this.current;\n            this.current.next[this.level] = node;\n            this.current = node;\n        }\n        this._size++;\n    }\n\n    /**\n     * Iterate through the elements in this level and create\n     * a new level above this level by probabilistically determining\n     * whether a given element must be promoted to the new level.\n     */\n    public generateNextLevel(): Level {\n        const nextLevelSentinel = new Level(this.level + 1);\n        let current = this.head;\n        while (current) {\n            if (shouldPromote()) {\n                nextLevelSentinel.setNext(current);\n            }\n            current = current.next[this.level];\n        }\n        return nextLevelSentinel;\n    }\n\n    /**\n     * Removes a given node from this level.\n     * Does nothing if the given node is not present in this level.\n     */\n    public removeNode(node: RoomNode): void {\n        // Let's first see if this node is even in this level\n        const nodeInThisLevel = this.head === node || node.previous[this.level];\n        if (!nodeInThisLevel) {\n            // This node is not in this sentinel level, so nothing to do.\n            return;\n        }\n        const prev = node.previous[this.level];\n        if (prev) {\n            const nextNode = node.next[this.level];\n            prev.next[this.level] = nextNode;\n            if (nextNode) nextNode.previous[this.level] = prev;\n        } else {\n            // This node was the head since it has no back links!\n            // so update the head.\n            const next = node.next[this.level];\n            this.head = next;\n            if (next) next.previous[this.level] = node.previous[this.level];\n        }\n        this._size--;\n    }\n\n    /**\n     * Put newNode after node in this level. No checks are done to ensure\n     * that node is actually present in this level.\n     */\n    public insertAfter(node: RoomNode, newNode: RoomNode): void {\n        const level = this.level;\n        const nextNode = node.next[level];\n        if (nextNode) {\n            newNode.next[level] = nextNode;\n            nextNode.previous[level] = newNode;\n        }\n        node.next[level] = newNode;\n        newNode.previous[level] = node;\n        this._size++;\n    }\n\n    /**\n     *  Insert a given node at the head of this level.\n     */\n    public insertAtHead(newNode: RoomNode): void {\n        const existingNode = this.head;\n        this.head = newNode;\n        if (existingNode) {\n            newNode.next[this.level] = existingNode;\n            existingNode.previous[this.level] = newNode;\n        }\n        this._size++;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { RoomNode } from \"./RoomNode\";\nimport type { FilterKey } from \"./filters\";\n\nexport class SortedRoomIterator implements Iterator<Room> {\n    public constructor(private current: RoomNode) {}\n\n    public next(): IteratorResult<Room> {\n        const current = this.current;\n        if (!current) return { value: undefined, done: true };\n        this.current = current.next[0];\n        return {\n            value: current.room,\n        };\n    }\n}\n\nexport class SortedSpaceFilteredIterator implements Iterator<Room> {\n    public constructor(\n        private current: RoomNode,\n        private readonly filters: FilterKey[],\n    ) {}\n\n    public [Symbol.iterator](): SortedSpaceFilteredIterator {\n        return this;\n    }\n\n    public next(): IteratorResult<Room> {\n        let current = this.current;\n        while (current) {\n            if (current.isInActiveSpace && current.doesRoomMatchFilters(this.filters)) break;\n            current = current.next[0];\n        }\n        if (!current) return { value: undefined, done: true };\n        this.current = current.next[0];\n        return {\n            value: current.room,\n        };\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Sorter, SortingAlgorithm } from \"./sorters\";\nimport type { Filter, FilterKey } from \"./filters\";\nimport { RoomNode } from \"./RoomNode\";\nimport { shouldPromote } from \"./utils\";\nimport { Level } from \"./Level\";\nimport { SortedRoomIterator, SortedSpaceFilteredIterator } from \"./iterators\";\n\n/**\n * Implements a skip list that stores rooms using a given sorting algorithm.\n * See See https://en.wikipedia.org/wiki/Skip_list\n */\nexport class RoomSkipList implements Iterable<Room> {\n    private levels: Level[] = [new Level(0)];\n    private roomNodeMap: Map<string, RoomNode> = new Map();\n    public initialized: boolean = false;\n\n    public constructor(\n        private sorter: Sorter,\n        private filters: Filter[] = [],\n    ) {}\n\n    private reset(): void {\n        this.levels = [new Level(0)];\n        this.roomNodeMap = new Map();\n    }\n\n    /**\n     * Seed the list with an initial list of rooms.\n     */\n    public seed(rooms: Room[]): void {\n        // 1. First sort the rooms and create a base sorted linked list\n        const sortedRoomNodes = this.sorter.sort(rooms).map((room) => new RoomNode(room));\n        let currentLevel = this.levels[0];\n        for (const node of sortedRoomNodes) {\n            node.applyFilters(this.filters);\n            currentLevel.setNext(node);\n            this.roomNodeMap.set(node.room.roomId, node);\n        }\n\n        // 2. Create the rest of the sub linked lists\n        do {\n            this.levels[currentLevel.level] = currentLevel;\n            currentLevel = currentLevel.generateNextLevel();\n        } while (currentLevel.size > 1);\n\n        // 3. Go through the list of rooms and mark nodes in active space\n        this.calculateActiveSpaceForNodes();\n\n        this.initialized = true;\n    }\n\n    /**\n     * Go through all the room nodes and check if they belong to the active space.\n     */\n    public calculateActiveSpaceForNodes(): void {\n        for (const node of this.roomNodeMap.values()) {\n            node.checkIfRoomBelongsToActiveSpace();\n        }\n    }\n\n    /**\n     * Change the sorting algorithm used by the skip list.\n     * This will reset the list and will rebuild from scratch.\n     */\n    public useNewSorter(sorter: Sorter, rooms: Room[]): void {\n        this.reset();\n        this.sorter = sorter;\n        this.seed(rooms);\n    }\n\n    /**\n     * Removes a given room from the skip list.\n     */\n    public removeRoom(room: Room): void {\n        const existingNode = this.roomNodeMap.get(room.roomId);\n        this.roomNodeMap.delete(room.roomId);\n        if (existingNode) {\n            for (const level of this.levels) {\n                level.removeNode(existingNode);\n            }\n        }\n    }\n\n    /**\n     * Re-inserts a room that is already in the skiplist.\n     * This method does nothing if the room isn't already in the skiplist.\n     * @param room the room to add\n     */\n    public reInsertRoom(room: Room): void {\n        if (!this.roomNodeMap.has(room.roomId)) {\n            return;\n        }\n        this.removeRoom(room);\n        this.addNewRoom(room);\n    }\n\n    /**\n     * Adds a new room to the skiplist.\n     * This method will throw an error if the room is already in the skiplist.\n     * @param room the room to add\n     */\n    public addNewRoom(room: Room): void {\n        if (this.roomNodeMap.has(room.roomId)) {\n            throw new Error(`Can't add room to skiplist: ${room.roomId} is already in the skiplist!`);\n        }\n        this.insertRoom(room);\n    }\n\n    /**\n     * Adds a given room to the correct sorted position in the list.\n     */\n    private insertRoom(room: Room): void {\n        const newNode = new RoomNode(room);\n        newNode.checkIfRoomBelongsToActiveSpace();\n        newNode.applyFilters(this.filters);\n        this.roomNodeMap.set(room.roomId, newNode);\n\n        /**\n         * This array tracks where the new node must be inserted in a\n         * given level.\n         * The index is the level and the value represents where the\n         * insertion must happen.\n         * If the value is null, it simply means that we need to insert\n         * at the head.\n         * If the value is a RoomNode, simply insert after this node.\n         */\n        const insertionNodes: (RoomNode | null)[] = [];\n\n        /**\n         * Now we'll do the actual work of finding where to insert this\n         * node.\n         *\n         * We start at the top most level and move downwards ...\n         */\n        for (let j = this.levels.length - 1; j >= 0; --j) {\n            const level = this.levels[j];\n\n            /**\n             * If the head is undefined, that means this level is empty.\n             * So mark it as such in insertionNodes and skip over this\n             * level.\n             */\n            if (!level.head) {\n                insertionNodes[j] = null;\n                continue;\n            }\n\n            /**\n             * So there's actually some nodes in this level ...\n             * All we need to do is find the node that is smaller or\n             * equal to the node that we wish to insert.\n             */\n            let current = level.head;\n            let previous: RoomNode | null = null;\n            while (current) {\n                if (this.sorter.comparator(current.room, room) < 0) {\n                    previous = current;\n                    current = current.next[j];\n                } else break;\n            }\n\n            /**\n             * previous will now be null if there's no node in this level\n             * smaller than the node we wish to insert or it will be a\n             * RoomNode.\n             * This is exactly what we need to track in insertionNodes!\n             */\n            insertionNodes[j] = previous;\n        }\n\n        /**\n         * We're done with difficult part, now we just need to do the\n         * actual node insertion.\n         */\n        for (const [level, node] of insertionNodes.entries()) {\n            /**\n             * Whether our new node should be present in a level\n             * is decided by coin toss.\n             */\n            if (level === 0 || shouldPromote()) {\n                const levelObj = this.levels[level];\n                if (node) levelObj.insertAfter(node, newNode);\n                else levelObj.insertAtHead(newNode);\n            } else {\n                break;\n            }\n        }\n    }\n\n    public [Symbol.iterator](): SortedRoomIterator {\n        return new SortedRoomIterator(this.levels[0].head!);\n    }\n\n    /**\n     * Returns an iterator that can be used to generate a list of sorted rooms that belong\n     * to the currently active space. Passing filterKeys will further filter the list such\n     * that only rooms that match the filters are returned.\n     *\n     * @example To get an array of rooms:\n     * Array.from(RLS.getRoomsInActiveSpace());\n     *\n     * @example Use a for ... of loop to iterate over rooms:\n     * for(const room of RLS.getRoomsInActiveSpace()) { something(room); }\n     *\n     * @example Additional filtering:\n     * Array.from(RLS.getRoomsInActiveSpace([FilterKeys.Favourite]));\n     */\n    public getRoomsInActiveSpace(filterKeys: FilterKey[] = []): SortedSpaceFilteredIterator {\n        return new SortedSpaceFilteredIterator(this.levels[0].head!, filterKeys);\n    }\n\n    /**\n     * The number of rooms currently in the skip list.\n     */\n    public get size(): number {\n        return this.levels[0].size;\n    }\n\n    /**\n     * The currently active sorting algorithm.\n     */\n    public get activeSortAlgorithm(): SortingAlgorithm {\n        return this.sorter.type;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport { type Sorter, SortingAlgorithm } from \".\";\nimport { getLastTs } from \"../../../room-list/algorithms/tag-sorting/RecentAlgorithm\";\nimport { RoomNotificationStateStore } from \"../../../notifications/RoomNotificationStateStore\";\nimport { DefaultTagID } from \"../../../room-list/models\";\n\nexport class RecencySorter implements Sorter {\n    public constructor(private myUserId: string) {}\n\n    public sort(rooms: Room[]): Room[] {\n        const tsCache: { [roomId: string]: number } = {};\n        return [...rooms].sort((a, b) => this.comparator(a, b, tsCache));\n    }\n\n    public comparator(roomA: Room, roomB: Room, cache?: any): number {\n        // First check if the rooms are low priority or muted\n        const exceptionalOrdering = this.getScore(roomA) - this.getScore(roomB);\n        if (exceptionalOrdering !== 0) return exceptionalOrdering;\n\n        // Then check recency; recent rooms should be at the top\n        const roomALastTs = this.getTs(roomA, cache);\n        const roomBLastTs = this.getTs(roomB, cache);\n        return roomBLastTs - roomALastTs;\n    }\n\n    public get type(): SortingAlgorithm.Recency {\n        return SortingAlgorithm.Recency;\n    }\n\n    /**\n     * This sorter mostly sorts rooms by recency but there are two exceptions:\n     * 1. Muted rooms are sorted to the bottom of the list.\n     * 2. Low priority rooms are sorted to the bottom of the list but before muted rooms.\n     *\n     * The following method provides a numerical value that takes care of this\n     * exceptional ordering. For two rooms A and B, it works as follows:\n     * - If getScore(A) - getScore(B) > 0, A should come after B\n     * - If getScore(A) - getScore(B) < 0, A should come before B\n     * - If getScore(A) - getScore(B) = 0, no special ordering needed, just use recency\n     */\n    private getScore(room: Room): number {\n        const isLowPriority = !!room.tags[DefaultTagID.LowPriority];\n        const isMuted = RoomNotificationStateStore.instance.getRoomState(room).muted;\n        // These constants are chosen so that the following order is maintained:\n        // Low priority rooms -> Low priority and muted rooms -> Muted rooms\n        if (isMuted && isLowPriority) return 5;\n        else if (isMuted) return 10;\n        else if (isLowPriority) return 2;\n        else return 0;\n    }\n\n    private getTs(room: Room, cache?: { [roomId: string]: number }): number {\n        const ts = cache?.[room.roomId] ?? getLastTs(room, this.myUserId);\n        if (cache) {\n            cache[room.roomId] = ts;\n        }\n        return ts;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport { type Sorter, SortingAlgorithm } from \".\";\n\nexport class AlphabeticSorter implements Sorter {\n    private readonly collator = new Intl.Collator();\n\n    public sort(rooms: Room[]): Room[] {\n        return [...rooms].sort((a, b) => {\n            return this.comparator(a, b);\n        });\n    }\n\n    public comparator(roomA: Room, roomB: Room): number {\n        return this.collator.compare(roomA.name, roomB.name);\n    }\n\n    public get type(): SortingAlgorithm.Alphabetic {\n        return SortingAlgorithm.Alphabetic;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport { EventType } from \"matrix-js-sdk/src/matrix\";\n\nimport type { EmptyObject, Room } from \"matrix-js-sdk/src/matrix\";\nimport type { MatrixDispatcher } from \"../../dispatcher/dispatcher\";\nimport type { ActionPayload } from \"../../dispatcher/payloads\";\nimport type { FilterKey } from \"./skip-list/filters\";\nimport { AsyncStoreWithClient } from \"../AsyncStoreWithClient\";\nimport SettingsStore from \"../../settings/SettingsStore\";\nimport { VisibilityProvider } from \"../room-list/filters/VisibilityProvider\";\nimport defaultDispatcher from \"../../dispatcher/dispatcher\";\nimport { RoomSkipList } from \"./skip-list/RoomSkipList\";\nimport { RecencySorter } from \"./skip-list/sorters/RecencySorter\";\nimport { AlphabeticSorter } from \"./skip-list/sorters/AlphabeticSorter\";\nimport { readReceiptChangeIsFor } from \"../../utils/read-receipts\";\nimport { EffectiveMembership, getEffectiveMembership, getEffectiveMembershipTag } from \"../../utils/membership\";\nimport SpaceStore from \"../spaces/SpaceStore\";\nimport { type SpaceKey, UPDATE_HOME_BEHAVIOUR, UPDATE_SELECTED_SPACE } from \"../spaces\";\nimport { FavouriteFilter } from \"./skip-list/filters/FavouriteFilter\";\nimport { UnreadFilter } from \"./skip-list/filters/UnreadFilter\";\nimport { PeopleFilter } from \"./skip-list/filters/PeopleFilter\";\nimport { RoomsFilter } from \"./skip-list/filters/RoomsFilter\";\nimport { InvitesFilter } from \"./skip-list/filters/InvitesFilter\";\nimport { MentionsFilter } from \"./skip-list/filters/MentionsFilter\";\nimport { LowPriorityFilter } from \"./skip-list/filters/LowPriorityFilter\";\nimport { type Sorter, SortingAlgorithm } from \"./skip-list/sorters\";\nimport { SettingLevel } from \"../../settings/SettingLevel\";\nimport { MARKED_UNREAD_TYPE_STABLE, MARKED_UNREAD_TYPE_UNSTABLE } from \"../../utils/notifications\";\nimport { getChangedOverrideRoomMutePushRules } from \"../room-list/utils/roomMute\";\nimport { Action } from \"../../dispatcher/actions\";\n\n/**\n * These are the filters passed to the room skip list.\n */\nconst FILTERS = [\n    new FavouriteFilter(),\n    new UnreadFilter(),\n    new PeopleFilter(),\n    new RoomsFilter(),\n    new InvitesFilter(),\n    new MentionsFilter(),\n    new LowPriorityFilter(),\n];\n\nexport enum RoomListStoreV3Event {\n    // The event/channel which is called when the room lists have been changed.\n    ListsUpdate = \"lists_update\",\n    // The event which is called when the room list is loaded.\n    ListsLoaded = \"lists_loaded\",\n}\n\n// The result object for returning rooms from the store\nexport type RoomsResult = {\n    // The ID of the active space queried\n    spaceId: SpaceKey;\n    // The filter queried\n    filterKeys?: FilterKey[];\n    // The resulting list of rooms\n    rooms: Room[];\n};\n\nexport const LISTS_UPDATE_EVENT = RoomListStoreV3Event.ListsUpdate;\nexport const LISTS_LOADED_EVENT = RoomListStoreV3Event.ListsLoaded;\n/**\n * This store allows for fast retrieval of the room list in a sorted and filtered manner.\n * This is the third such implementation hence the \"V3\".\n * This store is being actively developed so expect the methods to change in future.\n */\nexport class RoomListStoreV3Class extends AsyncStoreWithClient<EmptyObject> {\n    private roomSkipList?: RoomSkipList;\n    private readonly msc3946ProcessDynamicPredecessor: boolean;\n\n    public constructor(dispatcher: MatrixDispatcher) {\n        super(dispatcher);\n        this.msc3946ProcessDynamicPredecessor = SettingsStore.getValue(\"feature_dynamic_room_predecessors\");\n        SpaceStore.instance.on(UPDATE_SELECTED_SPACE, () => {\n            this.onActiveSpaceChanged();\n        });\n        SpaceStore.instance.on(UPDATE_HOME_BEHAVIOUR, () => this.onActiveSpaceChanged());\n    }\n\n    /**\n     * Get a list of unsorted, unfiltered rooms.\n     */\n    public getRooms(): Room[] {\n        let rooms = this.matrixClient?.getVisibleRooms(this.msc3946ProcessDynamicPredecessor) ?? [];\n        rooms = rooms.filter((r) => VisibilityProvider.instance.isRoomVisible(r));\n        return rooms;\n    }\n\n    /**\n     * Check whether the initial list of rooms has loaded.\n     */\n    public get isLoadingRooms(): boolean {\n        return !this.roomSkipList?.initialized;\n    }\n\n    /**\n     * Get a list of sorted rooms.\n     */\n    public getSortedRooms(): Room[] {\n        if (this.roomSkipList?.initialized) return Array.from(this.roomSkipList);\n        else return [];\n    }\n\n    /**\n     * Get a list of sorted rooms that belong to the currently active space.\n     * If filterKeys is passed, only the rooms that match the given filters are\n     * returned.\n\n     * @param filterKeys Optional array of filters that the rooms must match against.\n     */\n    public getSortedRoomsInActiveSpace(filterKeys?: FilterKey[]): RoomsResult {\n        const spaceId = SpaceStore.instance.activeSpace;\n        if (this.roomSkipList?.initialized)\n            return {\n                spaceId: spaceId,\n                filterKeys,\n                rooms: Array.from(this.roomSkipList.getRoomsInActiveSpace(filterKeys)),\n            };\n        else return { spaceId: spaceId, filterKeys, rooms: [] };\n    }\n\n    /**\n     * Resort the list of rooms using a different algorithm.\n     * @param algorithm The sorting algorithm to use.\n     */\n    public resort(algorithm: SortingAlgorithm): void {\n        if (!this.roomSkipList) throw new Error(\"Cannot resort room list before skip list is created.\");\n        if (!this.matrixClient) throw new Error(\"Cannot resort room list without matrix client.\");\n        if (this.roomSkipList.activeSortAlgorithm === algorithm) return;\n        const sorter =\n            algorithm === SortingAlgorithm.Alphabetic\n                ? new AlphabeticSorter()\n                : new RecencySorter(this.matrixClient.getSafeUserId());\n        this.roomSkipList.useNewSorter(sorter, this.getRooms());\n        this.emit(LISTS_UPDATE_EVENT);\n        SettingsStore.setValue(\"RoomList.preferredSorting\", null, SettingLevel.DEVICE, algorithm);\n    }\n\n    /**\n     * Currently active sorting algorithm if the store is ready or undefined otherwise.\n     */\n    public get activeSortAlgorithm(): SortingAlgorithm | undefined {\n        return this.roomSkipList?.activeSortAlgorithm;\n    }\n\n    protected async onReady(): Promise<any> {\n        if (this.roomSkipList?.initialized || !this.matrixClient) return;\n        const sorter = this.getPreferredSorter(this.matrixClient.getSafeUserId());\n        this.roomSkipList = new RoomSkipList(sorter, FILTERS);\n        await SpaceStore.instance.storeReadyPromise;\n        const rooms = this.getRooms();\n        this.roomSkipList.seed(rooms);\n        this.emit(LISTS_LOADED_EVENT);\n        this.emit(LISTS_UPDATE_EVENT);\n    }\n\n    protected async onAction(payload: ActionPayload): Promise<void> {\n        if (!this.matrixClient || !this.roomSkipList?.initialized) return;\n\n        /**\n         * For the kind of updates that we care about (represented by the cases below),\n         * we try to find the associated room and simply re-insert it into the\n         * skiplist. If the position of said room in the sorted list changed, re-inserting\n         * would put it in the correct place.\n         */\n        switch (payload.action) {\n            case \"MatrixActions.Room.receipt\": {\n                if (readReceiptChangeIsFor(payload.event, this.matrixClient)) {\n                    const room = payload.room;\n                    if (!room) {\n                        logger.warn(`Own read receipt was in unknown room ${room.roomId}`);\n                        return;\n                    }\n                    this.addRoomAndEmit(room);\n                }\n                break;\n            }\n\n            case \"MatrixActions.Room.tags\": {\n                const room = payload.room;\n                this.addRoomAndEmit(room);\n                break;\n            }\n\n            case \"MatrixActions.Room.accountData\": {\n                const eventType = payload.event_type;\n                if (eventType === MARKED_UNREAD_TYPE_STABLE || eventType === MARKED_UNREAD_TYPE_UNSTABLE) {\n                    const room = payload.room;\n                    this.addRoomAndEmit(room);\n                }\n                break;\n            }\n\n            case \"MatrixActions.Event.decrypted\": {\n                const roomId = payload.event.getRoomId();\n                if (!roomId) return;\n                const room = this.matrixClient.getRoom(roomId);\n                if (!room) {\n                    logger.warn(`Event ${payload.event.getId()} was decrypted in an unknown room ${roomId}`);\n                    return;\n                }\n                this.addRoomAndEmit(room);\n                break;\n            }\n\n            case \"MatrixActions.accountData\": {\n                this.handleAccountDataPayload(payload);\n                break;\n            }\n\n            case \"MatrixActions.Room.timeline\": {\n                // Ignore non-live events (backfill) and notification timeline set events (without a room)\n                if (!payload.isLiveEvent || !payload.isLiveUnfilteredRoomTimelineEvent || !payload.room) return;\n                this.addRoomAndEmit(payload.room);\n                break;\n            }\n\n            case \"MatrixActions.Room.myMembership\": {\n                const oldMembership = getEffectiveMembership(payload.oldMembership);\n                const newMembership = getEffectiveMembershipTag(payload.room, payload.membership);\n\n                // If the user is kicked, re-insert the room and do nothing more.\n                const ownUserId = this.matrixClient.getSafeUserId();\n                const isKicked = (payload.room as Room).getMember(ownUserId)?.isKicked();\n                if (isKicked) {\n                    this.addRoomAndEmit(payload.room);\n                    return;\n                }\n                // If the user has left this room, remove it from the skiplist.\n                if (\n                    (oldMembership === EffectiveMembership.Invite || oldMembership === EffectiveMembership.Join) &&\n                    newMembership === EffectiveMembership.Leave\n                ) {\n                    this.roomSkipList.removeRoom(payload.room);\n                    this.emit(LISTS_UPDATE_EVENT);\n                    return;\n                }\n\n                // If we're joining an upgraded room, we'll want to make sure we don't proliferate\n                // the dead room in the list.\n                if (oldMembership !== EffectiveMembership.Join && newMembership === EffectiveMembership.Join) {\n                    const room: Room = payload.room;\n                    const roomUpgradeHistory = room.client.getRoomUpgradeHistory(\n                        room.roomId,\n                        true,\n                        this.msc3946ProcessDynamicPredecessor,\n                    );\n                    const predecessors = roomUpgradeHistory.slice(0, roomUpgradeHistory.indexOf(room));\n                    for (const predecessor of predecessors) {\n                        this.roomSkipList.removeRoom(predecessor);\n                    }\n                }\n\n                this.addRoomAndEmit(payload.room, oldMembership === EffectiveMembership.Leave);\n                break;\n            }\n\n            case Action.AfterForgetRoom: {\n                const room = payload.room;\n                this.roomSkipList.removeRoom(room);\n                this.emit(LISTS_UPDATE_EVENT);\n                break;\n            }\n        }\n    }\n\n    /**\n     * This method deals with the two types of account data payloads that we care about.\n     */\n    private handleAccountDataPayload(payload: ActionPayload): void {\n        const eventType = payload.event_type;\n        let needsEmit = false;\n        switch (eventType) {\n            // When we're told about new DMs, insert the associated dm rooms.\n            case EventType.Direct: {\n                const dmMap = payload.event.getContent();\n                for (const userId of Object.keys(dmMap)) {\n                    const roomIds = dmMap[userId];\n                    for (const roomId of roomIds) {\n                        const room = this.matrixClient!.getRoom(roomId);\n                        if (!room) {\n                            logger.warn(`${roomId} was found in DMs but the room is not in the store`);\n                            continue;\n                        }\n                        this.roomSkipList!.reInsertRoom(room);\n                        needsEmit = true;\n                    }\n                }\n                break;\n            }\n            case EventType.PushRules: {\n                // When a room becomes muted/unmuted, re-insert that room.\n                const possibleMuteChangeRoomIds = getChangedOverrideRoomMutePushRules(payload);\n                if (!possibleMuteChangeRoomIds) return;\n                const rooms = possibleMuteChangeRoomIds\n                    .map((id) => this.matrixClient?.getRoom(id))\n                    .filter((room) => !!room);\n                for (const room of rooms) {\n                    this.roomSkipList!.reInsertRoom(room);\n                    needsEmit = true;\n                }\n                break;\n            }\n        }\n        if (needsEmit) this.emit(LISTS_UPDATE_EVENT);\n    }\n\n    /**\n     * Create the correct sorter depending on the persisted user preference.\n     * @param myUserId The user-id of our user.\n     * @returns Sorter object that can be passed to the skip list.\n     */\n    private getPreferredSorter(myUserId: string): Sorter {\n        const preferred = SettingsStore.getValue(\"RoomList.preferredSorting\");\n        switch (preferred) {\n            case SortingAlgorithm.Alphabetic:\n                return new AlphabeticSorter();\n            case SortingAlgorithm.Recency:\n                return new RecencySorter(myUserId);\n            default:\n                throw new Error(`Got unknown sort preference from RoomList.preferredSorting setting`);\n        }\n    }\n\n    /**\n     * Add a room to the skiplist and emit an update.\n     * @param room The room to add to the skiplist\n     * @param isNewRoom Set this to true if this a new room that the isn't already in the skiplist\n     */\n    private addRoomAndEmit(room: Room, isNewRoom = false): void {\n        if (!this.roomSkipList) throw new Error(\"roomSkipList hasn't been created yet!\");\n        if (isNewRoom) {\n            if (!VisibilityProvider.instance.isRoomVisible(room)) {\n                logger.info(\n                    `RoomListStoreV3: Refusing to add new room ${room.roomId} because isRoomVisible returned false.`,\n                );\n                return;\n            }\n            this.roomSkipList.addNewRoom(room);\n        } else {\n            this.roomSkipList.reInsertRoom(room);\n        }\n        this.emit(LISTS_UPDATE_EVENT);\n    }\n\n    private onActiveSpaceChanged(): void {\n        if (!this.roomSkipList) return;\n        this.roomSkipList.calculateActiveSpaceForNodes();\n        this.emit(LISTS_UPDATE_EVENT);\n    }\n}\n\nexport default class RoomListStoreV3 {\n    private static internalInstance: RoomListStoreV3Class;\n\n    public static get instance(): RoomListStoreV3Class {\n        if (!RoomListStoreV3.internalInstance) {\n            const instance = new RoomListStoreV3Class(defaultDispatcher);\n            instance.start();\n            RoomListStoreV3.internalInstance = instance;\n        }\n\n        return this.internalInstance;\n    }\n}\n\nwindow.getRoomListStoreV3 = () => RoomListStoreV3.instance;\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { DefaultTagID } from \"../../../room-list/models\";\n\nexport class FavouriteFilter implements Filter {\n    public matches(room: Room): boolean {\n        return !!room.tags[DefaultTagID.Favourite];\n    }\n\n    public get key(): FilterKey.FavouriteFilter {\n        return FilterKey.FavouriteFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { RoomNotificationStateStore } from \"../../../notifications/RoomNotificationStateStore\";\nimport { getMarkedUnreadState } from \"../../../../utils/notifications\";\n\nexport class UnreadFilter implements Filter {\n    public matches(room: Room): boolean {\n        return RoomNotificationStateStore.instance.getRoomState(room).hasUnreadCount || !!getMarkedUnreadState(room);\n    }\n\n    public get key(): FilterKey.UnreadFilter {\n        return FilterKey.UnreadFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport DMRoomMap from \"../../../../utils/DMRoomMap\";\n\nexport class PeopleFilter implements Filter {\n    public matches(room: Room): boolean {\n        // Match rooms that are DMs\n        return !!DMRoomMap.shared().getUserIdForRoomId(room.roomId);\n    }\n\n    public get key(): FilterKey.PeopleFilter {\n        return FilterKey.PeopleFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport DMRoomMap from \"../../../../utils/DMRoomMap\";\n\nexport class RoomsFilter implements Filter {\n    public matches(room: Room): boolean {\n        // This should filter rooms that are not DMs\n        return !DMRoomMap.shared().getUserIdForRoomId(room.roomId);\n    }\n\n    public get key(): FilterKey.RoomsFilter {\n        return FilterKey.RoomsFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type Room, KnownMembership } from \"matrix-js-sdk/src/matrix\";\n\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\n\nexport class InvitesFilter implements Filter {\n    public matches(room: Room): boolean {\n        return room.getMyMembership() === KnownMembership.Invite;\n    }\n\n    public get key(): FilterKey.InvitesFilter {\n        return FilterKey.InvitesFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { RoomNotificationStateStore } from \"../../../notifications/RoomNotificationStateStore\";\n\nexport class MentionsFilter implements Filter {\n    public matches(room: Room): boolean {\n        return RoomNotificationStateStore.instance.getRoomState(room).isMention;\n    }\n\n    public get key(): FilterKey.MentionsFilter {\n        return FilterKey.MentionsFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\nimport type { Filter } from \".\";\nimport { FilterKey } from \".\";\nimport { DefaultTagID } from \"../../../room-list/models\";\n\nexport class LowPriorityFilter implements Filter {\n    public matches(room: Room): boolean {\n        return !!room.tags[DefaultTagID.LowPriority];\n    }\n\n    public get key(): FilterKey.LowPriorityFilter {\n        return FilterKey.LowPriorityFilter;\n    }\n}\n","/*\nCopyright 2025 New Vector Ltd.\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport type { Room } from \"matrix-js-sdk/src/matrix\";\n\nexport const enum FilterKey {\n    FavouriteFilter,\n    UnreadFilter,\n    PeopleFilter,\n    RoomsFilter,\n    LowPriorityFilter,\n    MentionsFilter,\n    InvitesFilter,\n}\n\nexport interface Filter {\n    /**\n     * Boolean return value indicates whether this room satisfies\n     * the filter condition.\n     */\n    matches(room: Room): boolean;\n\n    /**\n     * Used to identify this particular filter.\n     */\n    key: FilterKey;\n}\n"],"names":["RoomNode","constructor","room","_defineProperty","Set","isInActiveSpace","this","_isInActiveSpace","checkIfRoomBelongsToActiveSpace","activeSpace","SpaceStore","instance","isRoomInSpace","roomId","doesRoomMatchFilters","filterKeys","some","key","filterKeysSet","has","applyFilters","filters","filter","matches","add","shouldPromote","Math","random","Level","size","_size","level","setNext","node","head","current","previous","next","generateNextLevel","nextLevelSentinel","removeNode","prev","nextNode","insertAfter","newNode","insertAtHead","existingNode","SortedRoomIterator","value","undefined","done","SortedSpaceFilteredIterator","Symbol","iterator","RoomSkipList","sorter","Map","reset","levels","roomNodeMap","seed","rooms","sortedRoomNodes","sort","map","currentLevel","set","calculateActiveSpaceForNodes","initialized","values","useNewSorter","removeRoom","get","delete","reInsertRoom","addNewRoom","Error","insertRoom","insertionNodes","j","length","comparator","entries","levelObj","getRoomsInActiveSpace","activeSortAlgorithm","type","RecencySorter","myUserId","tsCache","a","b","roomA","roomB","cache","exceptionalOrdering","getScore","roomALastTs","getTs","SortingAlgorithm","Recency","isLowPriority","tags","DefaultTagID","LowPriority","isMuted","RoomNotificationStateStore","getRoomState","muted","_cache$room$roomId","ts","getLastTs","AlphabeticSorter","Intl","Collator","collator","compare","name","Alphabetic","FILTERS","Favourite","FilterKey","FavouriteFilter","hasUnreadCount","getMarkedUnreadState","UnreadFilter","DMRoomMap","shared","getUserIdForRoomId","PeopleFilter","RoomsFilter","getMyMembership","KnownMembership","Invite","InvitesFilter","isMention","MentionsFilter","LowPriorityFilter","RoomListStoreV3Event","LISTS_UPDATE_EVENT","ListsUpdate","LISTS_LOADED_EVENT","ListsLoaded","RoomListStoreV3Class","AsyncStoreWithClient","dispatcher","super","msc3946ProcessDynamicPredecessor","SettingsStore","getValue","on","UPDATE_SELECTED_SPACE","onActiveSpaceChanged","UPDATE_HOME_BEHAVIOUR","getRooms","_this$matrixClient$ge","_this$matrixClient","matrixClient","getVisibleRooms","r","VisibilityProvider","isRoomVisible","isLoadingRooms","_this$roomSkipList","roomSkipList","getSortedRooms","_this$roomSkipList2","Array","from","getSortedRoomsInActiveSpace","_this$roomSkipList3","spaceId","resort","algorithm","getSafeUserId","emit","setValue","SettingLevel","DEVICE","_this$roomSkipList4","onReady","_this$roomSkipList5","getPreferredSorter","storeReadyPromise","onAction","payload","_this$roomSkipList6","action","readReceiptChangeIsFor","event","logger","warn","addRoomAndEmit","eventType","event_type","MARKED_UNREAD_TYPE_STABLE","MARKED_UNREAD_TYPE_UNSTABLE","getRoomId","getRoom","getId","handleAccountDataPayload","isLiveEvent","isLiveUnfilteredRoomTimelineEvent","_getMember","oldMembership","getEffectiveMembership","newMembership","getEffectiveMembershipTag","membership","ownUserId","getMember","isKicked","EffectiveMembership","Join","Leave","roomUpgradeHistory","client","getRoomUpgradeHistory","predecessors","slice","indexOf","predecessor","Action","AfterForgetRoom","needsEmit","EventType","Direct","dmMap","getContent","userId","Object","keys","roomIds","PushRules","possibleMuteChangeRoomIds","getChangedOverrideRoomMutePushRules","id","_this$matrixClient2","isNewRoom","info","RoomListStoreV3","internalInstance","defaultDispatcher","start","window","getRoomListStoreV3"],"ignoreList":[],"sourceRoot":""}