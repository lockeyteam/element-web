{"version":3,"file":"bundles/2766ac378aff218c8ed0/4387.js","mappings":"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","sources":["webpack://element-web/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://element-web/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://element-web/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://element-web/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://element-web/./node_modules/loglevel/lib/loglevel.js","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/PushRules.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/beacon.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/event.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/extensible_events.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/location.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/partials.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/polls.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/read_receipts.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/requests.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/search.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/sync.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/@types/topic.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/NamespacedValue.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/autodiscovery.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/client.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/content-helpers.ts","webpack://element-web/./node_modules/bs58/src/esm/index.js","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto-api/recovery-key.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto-api/CryptoEvent.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto-api/index.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/crypto-api/verification.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/errors.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/extensible_events_v1/utilities.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/filter.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/http-api/index.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/store/indexeddb-store-worker.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/logger.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/CallMembership.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/IMembershipManager.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/MatrixRTCSession.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/MatrixRTCSessionManager.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/matrixrtc/types.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/beacon.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/event-timeline-set.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/event-timeline.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/event.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/invites-ignorer.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/poll.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/relations.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/room-member.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/room-state.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/room.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/search-result.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/thread.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/typed-event-emitter.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/models/user.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/oidc/register.ts","webpack://element-web/./node_modules/jwt-decode/build/esm/index.js","webpack://element-web/./node_modules/matrix-js-sdk/src/oidc/validate.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/randomstring.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/secret-storage.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/serverCapabilities.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/service-types.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/sliding-sync.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/receipt-accumulator.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/sync-accumulator.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/sync.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/utils.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/utils/decryptAESSecretStorageItem.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/version-support.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/call.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/callFeed.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/groupCall.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/mediaHandler.ts","webpack://element-web/./node_modules/matrix-js-sdk/src/webrtc/stats/statsReport.ts","webpack://element-web/./node_modules/is-network-error/index.js","webpack://element-web/./node_modules/p-retry/index.js","webpack://element-web/./node_modules/unhomoglyph/index.js"],"sourcesContent":["import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// allow camelcase as these are things that go onto the wire\n/* eslint-disable camelcase */\n\nexport enum PushRuleActionName {\n    DontNotify = \"dont_notify\",\n    Notify = \"notify\",\n    Coalesce = \"coalesce\",\n}\n\nexport enum TweakName {\n    Highlight = \"highlight\",\n    Sound = \"sound\",\n}\n\nexport type Tweak<N extends TweakName, V> = {\n    set_tweak: N;\n    value?: V;\n};\n\nexport type TweakHighlight = Tweak<TweakName.Highlight, boolean>;\nexport type TweakSound = Tweak<TweakName.Sound, string>;\n\nexport type Tweaks = TweakHighlight | TweakSound;\n\nexport enum ConditionOperator {\n    ExactEquals = \"==\",\n    LessThan = \"<\",\n    GreaterThan = \">\",\n    GreaterThanOrEqual = \">=\",\n    LessThanOrEqual = \"<=\",\n}\n\nexport type PushRuleAction = Tweaks | PushRuleActionName;\n\nexport type MemberCountCondition<N extends number, Op extends ConditionOperator = ConditionOperator.ExactEquals> =\n    | `${Op}${N}`\n    | (Op extends ConditionOperator.ExactEquals ? `${N}` : never);\n\nexport type AnyMemberCountCondition = MemberCountCondition<number, ConditionOperator>;\n\nexport const DMMemberCountCondition: MemberCountCondition<2> = \"2\";\n\nexport function isDmMemberCountCondition(condition: AnyMemberCountCondition): boolean {\n    return condition === \"==2\" || condition === \"2\";\n}\n\nexport enum ConditionKind {\n    EventMatch = \"event_match\",\n    EventPropertyIs = \"event_property_is\",\n    EventPropertyContains = \"event_property_contains\",\n    ContainsDisplayName = \"contains_display_name\",\n    RoomMemberCount = \"room_member_count\",\n    SenderNotificationPermission = \"sender_notification_permission\",\n    CallStarted = \"call_started\",\n    CallStartedPrefix = \"org.matrix.msc3914.call_started\",\n}\n\nexport interface IPushRuleCondition<N extends ConditionKind | string> {\n    [k: string]: any; // for custom conditions, there can be other fields here\n    kind: N;\n}\n\nexport interface IEventMatchCondition extends IPushRuleCondition<ConditionKind.EventMatch> {\n    key: string;\n    pattern?: string;\n    // Note that value property is an optimization for patterns which do not do\n    // any globbing and when the key is not \"content.body\".\n    value?: string;\n}\n\nexport interface IEventPropertyIsCondition extends IPushRuleCondition<ConditionKind.EventPropertyIs> {\n    key: string;\n    value: string | boolean | null | number;\n}\n\nexport interface IEventPropertyContainsCondition extends IPushRuleCondition<ConditionKind.EventPropertyContains> {\n    key: string;\n    value: string | boolean | null | number;\n}\n\nexport interface IContainsDisplayNameCondition extends IPushRuleCondition<ConditionKind.ContainsDisplayName> {\n    // no additional fields\n}\n\nexport interface IRoomMemberCountCondition extends IPushRuleCondition<ConditionKind.RoomMemberCount> {\n    is: AnyMemberCountCondition;\n}\n\nexport interface ISenderNotificationPermissionCondition extends IPushRuleCondition<ConditionKind.SenderNotificationPermission> {\n    key: string;\n}\n\nexport interface ICallStartedCondition extends IPushRuleCondition<ConditionKind.CallStarted> {\n    // no additional fields\n}\n\nexport interface ICallStartedPrefixCondition extends IPushRuleCondition<ConditionKind.CallStartedPrefix> {\n    // no additional fields\n}\n\n// XXX: custom conditions are possible but always fail, and break the typescript discriminated union so ignore them here\n// IPushRuleCondition<Exclude<string, ConditionKind>> unfortunately does not resolve this at the time of writing.\nexport type PushRuleCondition =\n    | IEventMatchCondition\n    | IEventPropertyIsCondition\n    | IEventPropertyContainsCondition\n    | IContainsDisplayNameCondition\n    | IRoomMemberCountCondition\n    | ISenderNotificationPermissionCondition\n    | ICallStartedCondition\n    | ICallStartedPrefixCondition;\n\nexport enum PushRuleKind {\n    Override = \"override\",\n    ContentSpecific = \"content\",\n    RoomSpecific = \"room\",\n    SenderSpecific = \"sender\",\n    Underride = \"underride\",\n}\n\nexport enum RuleId {\n    Master = \".m.rule.master\",\n    IsUserMention = \".m.rule.is_user_mention\",\n    IsRoomMention = \".m.rule.is_room_mention\",\n    ContainsDisplayName = \".m.rule.contains_display_name\",\n    ContainsUserName = \".m.rule.contains_user_name\",\n    AtRoomNotification = \".m.rule.roomnotif\",\n    DM = \".m.rule.room_one_to_one\",\n    EncryptedDM = \".m.rule.encrypted_room_one_to_one\",\n    Message = \".m.rule.message\",\n    EncryptedMessage = \".m.rule.encrypted\",\n    InviteToSelf = \".m.rule.invite_for_me\",\n    MemberEvent = \".m.rule.member_event\",\n    IncomingCall = \".m.rule.call\",\n    SuppressNotices = \".m.rule.suppress_notices\",\n    Tombstone = \".m.rule.tombstone\",\n    PollStart = \".m.rule.poll_start\",\n    PollStartUnstable = \".org.matrix.msc3930.rule.poll_start\",\n    PollEnd = \".m.rule.poll_end\",\n    PollEndUnstable = \".org.matrix.msc3930.rule.poll_end\",\n    PollStartOneToOne = \".m.rule.poll_start_one_to_one\",\n    PollStartOneToOneUnstable = \".org.matrix.msc3930.rule.poll_start_one_to_one\",\n    PollEndOneToOne = \".m.rule.poll_end_one_to_one\",\n    PollEndOneToOneUnstable = \".org.matrix.msc3930.rule.poll_end_one_to_one\",\n}\n\nexport type PushRuleSet = {\n    [k in PushRuleKind]?: IPushRule[];\n};\n\nexport interface IPushRule {\n    actions: PushRuleAction[];\n    conditions?: PushRuleCondition[];\n    default: boolean;\n    enabled: boolean;\n    pattern?: string;\n    rule_id: RuleId | string;\n}\n\nexport interface IAnnotatedPushRule extends IPushRule {\n    kind: PushRuleKind;\n}\n\nexport interface IPushRules {\n    global: PushRuleSet;\n    device?: PushRuleSet;\n}\n\nexport interface IPusher {\n    \"app_display_name\": string;\n    \"app_id\": string;\n    \"data\": {\n        format?: string;\n        url?: string; // TODO: Required if kind==http\n        brand?: string; // TODO: For email notifications only? Unspecced field\n    };\n    \"device_display_name\": string;\n    \"kind\": \"http\" | string;\n    \"lang\": string;\n    \"profile_tag\"?: string;\n    \"pushkey\": string;\n    \"enabled\"?: boolean | null;\n    \"org.matrix.msc3881.enabled\"?: boolean | null;\n    \"device_id\"?: string | null;\n    \"org.matrix.msc3881.device_id\"?: string | null;\n}\n\nexport interface IPusherRequest extends Omit<IPusher, \"device_id\" | \"org.matrix.msc3881.device_id\"> {\n    append?: boolean;\n}\n\n/* eslint-enable camelcase */\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type RelatesToRelationship, type REFERENCE_RELATION } from \"./extensible_events.ts\";\nimport { UnstableValue } from \"../NamespacedValue.ts\";\nimport { type MAssetEvent, type MLocationEvent, type MTimestampEvent } from \"./location.ts\";\n\n/**\n * Beacon info and beacon event types as described in MSC3672\n * https://github.com/matrix-org/matrix-spec-proposals/pull/3672\n */\n\n/**\n * Beacon info events are state events.\n * We have two requirements for these events:\n * 1. they can only be written by their owner\n * 2. a user can have an arbitrary number of beacon_info events\n *\n * 1. is achieved by setting the state_key to the owners mxid.\n * Event keys in room state are a combination of `type` + `state_key`.\n * To achieve an arbitrary number of only owner-writable state events\n * we introduce a variable suffix to the event type\n *\n * @example\n * ```\n * {\n *      \"type\": \"m.beacon_info.@matthew:matrix.org.1\",\n *      \"state_key\": \"@matthew:matrix.org\",\n *      \"content\": {\n *          \"m.beacon_info\": {\n *              \"description\": \"The Matthew Tracker\",\n *              \"timeout\": 86400000,\n *          },\n *          // more content as described below\n *      }\n * },\n * {\n *      \"type\": \"m.beacon_info.@matthew:matrix.org.2\",\n *      \"state_key\": \"@matthew:matrix.org\",\n *      \"content\": {\n *          \"m.beacon_info\": {\n *              \"description\": \"Another different Matthew tracker\",\n *              \"timeout\": 400000,\n *          },\n *          // more content as described below\n *      }\n * }\n * ```\n */\n\n/**\n * Non-variable type for m.beacon_info event content\n */\nexport const M_BEACON_INFO = new UnstableValue(\"m.beacon_info\", \"org.matrix.msc3672.beacon_info\");\nexport const M_BEACON = new UnstableValue(\"m.beacon\", \"org.matrix.msc3672.beacon\");\n\nexport type MBeaconInfoContent = {\n    description?: string;\n    // how long from the last event until we consider the beacon inactive in milliseconds\n    timeout: number;\n    // true when this is a live location beacon\n    // https://github.com/matrix-org/matrix-spec-proposals/pull/3672\n    live?: boolean;\n};\n\n/**\n * m.beacon_info Event example from the spec\n * https://github.com/matrix-org/matrix-spec-proposals/pull/3672\n * @example\n * ```\n * {\n *   \"type\": \"m.beacon_info\",\n *   \"state_key\": \"@matthew:matrix.org\",\n *   \"content\": {\n *     \"m.beacon_info\": {\n *       \"description\": \"The Matthew Tracker\", // same as an `m.location` description\n *       \"timeout\": 86400000, // how long from the last event until we consider the beacon inactive in milliseconds\n *     },\n *     \"m.ts\": 1436829458432, // creation timestamp of the beacon on the client\n *     \"m.asset\": {\n *       \"type\": \"m.self\" // the type of asset being tracked as per MSC3488\n *     }\n *   }\n * }\n * ```\n */\n\n/**\n * m.beacon_info.* event content\n */\nexport type MBeaconInfoEventContent = MBeaconInfoContent &\n    // creation timestamp of the beacon on the client\n    MTimestampEvent &\n    // the type of asset being tracked as per MSC3488\n    MAssetEvent;\n\n/**\n * m.beacon event example\n * https://github.com/matrix-org/matrix-spec-proposals/pull/3672\n * @example\n * ```\n * {\n *   \"type\": \"m.beacon\",\n *   \"sender\": \"@matthew:matrix.org\",\n *   \"content\": {\n *       \"m.relates_to\": { // from MSC2674: https://github.com/matrix-org/matrix-doc/pull/2674\n *           \"rel_type\": \"m.reference\", // from MSC3267: https://github.com/matrix-org/matrix-doc/pull/3267\n *           \"event_id\": \"$beacon_info\"\n *       },\n *       \"m.location\": {\n *           \"uri\": \"geo:51.5008,0.1247;u=35\",\n *           \"description\": \"Arbitrary beacon information\"\n *       },\n *       \"m.ts\": 1636829458432,\n *   }\n * }\n * ```\n */\n\n/**\n * Content of an m.beacon event\n */\nexport type MBeaconEventContent = MLocationEvent &\n    // timestamp when location was taken\n    MTimestampEvent &\n    // relates to a beacon_info event\n    RelatesToRelationship<typeof REFERENCE_RELATION>;\n","/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { NamespacedValue, UnstableValue } from \"../NamespacedValue.ts\";\nimport {\n    type PolicyRuleEventContent,\n    type RoomAvatarEventContent,\n    type RoomCanonicalAliasEventContent,\n    type RoomCreateEventContent,\n    type RoomEncryptionEventContent,\n    type RoomGuestAccessEventContent,\n    type RoomHistoryVisibilityEventContent,\n    type RoomJoinRulesEventContent,\n    type RoomMemberEventContent,\n    type RoomNameEventContent,\n    type RoomPinnedEventsEventContent,\n    type RoomPolicyContent,\n    type RoomPowerLevelsEventContent,\n    type RoomServerAclEventContent,\n    type RoomThirdPartyInviteEventContent,\n    type RoomTombstoneEventContent,\n    type RoomTopicEventContent,\n    type SpaceChildEventContent,\n    type SpaceParentEventContent,\n} from \"./state_events.ts\";\nimport { type IGroupCallRoomMemberState, type IGroupCallRoomState } from \"../webrtc/groupCall.ts\";\nimport { type MSC3089EventContent } from \"../models/MSC3089Branch.ts\";\nimport { type M_BEACON, type M_BEACON_INFO, type MBeaconEventContent, type MBeaconInfoEventContent } from \"./beacon.ts\";\nimport { type EmptyObject } from \"./common.ts\";\nimport { type ReactionEventContent, type RoomMessageEventContent, type StickerEventContent } from \"./events.ts\";\nimport {\n    type MCallAnswer,\n    type MCallBase,\n    type MCallCandidates,\n    type MCallHangupReject,\n    type MCallInviteNegotiate,\n    type MCallReplacesEvent,\n    type MCallSelectAnswer,\n    type SDPStreamMetadata,\n    type SDPStreamMetadataKey,\n} from \"../webrtc/callEventTypes.ts\";\nimport {\n    type IRTCNotificationContent,\n    type IRTCDeclineContent,\n    type EncryptionKeysEventContent,\n    type ICallNotifyContent,\n} from \"../matrixrtc/types.ts\";\nimport { type M_POLL_END, type M_POLL_START, type PollEndEventContent, type PollStartEventContent } from \"./polls.ts\";\nimport { type RtcMembershipData, type SessionMembershipData } from \"../matrixrtc/CallMembership.ts\";\nimport { type LocalNotificationSettings } from \"./local_notifications.ts\";\nimport { type IPushRules } from \"./PushRules.ts\";\nimport { type SecretInfo, type SecretStorageKeyDescription } from \"../secret-storage.ts\";\nimport { type POLICIES_ACCOUNT_EVENT_TYPE } from \"../models/invites-ignorer-types.ts\";\n\nexport enum EventType {\n    // Room state events\n    RoomCanonicalAlias = \"m.room.canonical_alias\",\n    RoomCreate = \"m.room.create\",\n    RoomJoinRules = \"m.room.join_rules\",\n    RoomMember = \"m.room.member\",\n    RoomThirdPartyInvite = \"m.room.third_party_invite\",\n    RoomPowerLevels = \"m.room.power_levels\",\n    RoomName = \"m.room.name\",\n    RoomTopic = \"m.room.topic\",\n    RoomAvatar = \"m.room.avatar\",\n    RoomPinnedEvents = \"m.room.pinned_events\",\n    RoomEncryption = \"m.room.encryption\",\n    RoomHistoryVisibility = \"m.room.history_visibility\",\n    RoomGuestAccess = \"m.room.guest_access\",\n    RoomServerAcl = \"m.room.server_acl\",\n    RoomTombstone = \"m.room.tombstone\",\n    RoomPredecessor = \"org.matrix.msc3946.room_predecessor\",\n\n    // Moderation policy lists\n    PolicyRuleUser = \"m.policy.rule.user\",\n    PolicyRuleRoom = \"m.policy.rule.room\",\n    PolicyRuleServer = \"m.policy.rule.server\",\n\n    SpaceChild = \"m.space.child\",\n    SpaceParent = \"m.space.parent\",\n\n    // Room timeline events\n    RoomRedaction = \"m.room.redaction\",\n    RoomMessage = \"m.room.message\",\n    RoomMessageEncrypted = \"m.room.encrypted\",\n    Sticker = \"m.sticker\",\n    CallInvite = \"m.call.invite\",\n    CallCandidates = \"m.call.candidates\",\n    CallAnswer = \"m.call.answer\",\n    CallHangup = \"m.call.hangup\",\n    CallReject = \"m.call.reject\",\n    CallSelectAnswer = \"m.call.select_answer\",\n    CallNegotiate = \"m.call.negotiate\",\n    CallSDPStreamMetadataChanged = \"m.call.sdp_stream_metadata_changed\",\n    CallSDPStreamMetadataChangedPrefix = \"org.matrix.call.sdp_stream_metadata_changed\",\n    CallReplaces = \"m.call.replaces\",\n    CallAssertedIdentity = \"m.call.asserted_identity\",\n    CallAssertedIdentityPrefix = \"org.matrix.call.asserted_identity\",\n    CallEncryptionKeysPrefix = \"io.element.call.encryption_keys\",\n    KeyVerificationRequest = \"m.key.verification.request\",\n    KeyVerificationStart = \"m.key.verification.start\",\n    KeyVerificationCancel = \"m.key.verification.cancel\",\n    KeyVerificationMac = \"m.key.verification.mac\",\n    KeyVerificationDone = \"m.key.verification.done\",\n    KeyVerificationKey = \"m.key.verification.key\",\n    KeyVerificationAccept = \"m.key.verification.accept\",\n    // Not used directly - see READY_TYPE in VerificationRequest.\n    KeyVerificationReady = \"m.key.verification.ready\",\n    // use of this is discouraged https://matrix.org/docs/spec/client_server/r0.6.1#m-room-message-feedback\n    RoomMessageFeedback = \"m.room.message.feedback\",\n    Reaction = \"m.reaction\",\n    PollStart = \"org.matrix.msc3381.poll.start\",\n\n    // Room ephemeral events\n    Typing = \"m.typing\",\n    Receipt = \"m.receipt\",\n    Presence = \"m.presence\",\n\n    // Room account_data events\n    FullyRead = \"m.fully_read\",\n    Tag = \"m.tag\",\n    SpaceOrder = \"org.matrix.msc3230.space_order\", // MSC3230\n\n    // User account_data events\n    PushRules = \"m.push_rules\",\n    Direct = \"m.direct\",\n    IgnoredUserList = \"m.ignored_user_list\",\n\n    // to_device events\n    RoomKey = \"m.room_key\",\n    RoomKeyRequest = \"m.room_key_request\",\n    ForwardedRoomKey = \"m.forwarded_room_key\",\n    Dummy = \"m.dummy\",\n    SecretRequest = \"m.secret.request\",\n    SecretSend = \"m.secret.send\",\n\n    // Group call events\n    GroupCallPrefix = \"org.matrix.msc3401.call\",\n    GroupCallMemberPrefix = \"org.matrix.msc3401.call.member\",\n\n    // MatrixRTC events\n    RTCMembership = \"org.matrix.msc4143.rtc.member\",\n    CallNotify = \"org.matrix.msc4075.call.notify\",\n    RTCNotification = \"org.matrix.msc4075.rtc.notification\",\n    RTCDecline = \"org.matrix.msc4310.rtc.decline\",\n\n    // Policy servers\n    RoomPolicy = \"org.matrix.msc4284.policy\",\n}\n\nexport enum RelationType {\n    Annotation = \"m.annotation\",\n    Replace = \"m.replace\",\n    Reference = \"m.reference\",\n\n    // Don't use this yet: it's only the stable version. The code still assumes we support the unstable prefix and,\n    // moreover, our tests currently use the unstable prefix. Use THREAD_RELATION_TYPE.name.\n    // Once we support *only* the stable prefix, THREAD_RELATION_TYPE can die and we can switch to this.\n    Thread = \"m.thread\",\n}\n\nexport enum MsgType {\n    Text = \"m.text\",\n    Emote = \"m.emote\",\n    Notice = \"m.notice\",\n    Image = \"m.image\",\n    File = \"m.file\",\n    Audio = \"m.audio\",\n    Location = \"m.location\",\n    Video = \"m.video\",\n    KeyVerificationRequest = \"m.key.verification.request\",\n}\n\nexport const RoomCreateTypeField = \"type\";\n\nexport enum RoomType {\n    Space = \"m.space\",\n    UnstableCall = \"org.matrix.msc3417.call\",\n    ElementVideo = \"io.element.video\",\n}\n\nexport const ToDeviceMessageId = \"org.matrix.msgid\";\n\n/**\n * Identifier for an [MSC3088](https://github.com/matrix-org/matrix-doc/pull/3088)\n * room purpose. Note that this reference is UNSTABLE and subject to breaking changes,\n * including its eventual removal.\n */\nexport const UNSTABLE_MSC3088_PURPOSE = new UnstableValue(\"m.room.purpose\", \"org.matrix.msc3088.purpose\");\n\n/**\n * Enabled flag for an [MSC3088](https://github.com/matrix-org/matrix-doc/pull/3088)\n * room purpose. Note that this reference is UNSTABLE and subject to breaking changes,\n * including its eventual removal.\n */\nexport const UNSTABLE_MSC3088_ENABLED = new UnstableValue(\"m.enabled\", \"org.matrix.msc3088.enabled\");\n\n/**\n * Subtype for an [MSC3089](https://github.com/matrix-org/matrix-doc/pull/3089) space-room.\n * Note that this reference is UNSTABLE and subject to breaking changes, including its\n * eventual removal.\n */\nexport const UNSTABLE_MSC3089_TREE_SUBTYPE = new UnstableValue(\"m.data_tree\", \"org.matrix.msc3089.data_tree\");\n\n/**\n * Leaf type for an event in a [MSC3089](https://github.com/matrix-org/matrix-doc/pull/3089) space-room.\n * Note that this reference is UNSTABLE and subject to breaking changes, including its\n * eventual removal.\n */\nexport const UNSTABLE_MSC3089_LEAF = new UnstableValue(\"m.leaf\", \"org.matrix.msc3089.leaf\");\n\n/**\n * Branch (Leaf Reference) type for the index approach in a\n * [MSC3089](https://github.com/matrix-org/matrix-doc/pull/3089) space-room. Note that this reference is\n * UNSTABLE and subject to breaking changes, including its eventual removal.\n */\nexport const UNSTABLE_MSC3089_BRANCH = new UnstableValue(\"m.branch\", \"org.matrix.msc3089.branch\");\n\n/**\n * Marker event type to point back at imported historical content in a room. See\n * [MSC2716](https://github.com/matrix-org/matrix-spec-proposals/pull/2716).\n * Note that this reference is UNSTABLE and subject to breaking changes,\n * including its eventual removal.\n */\nexport const UNSTABLE_MSC2716_MARKER = new UnstableValue(\"m.room.marker\", \"org.matrix.msc2716.marker\");\n\n/**\n * Name of the request property for relation based redactions.\n * {@link https://github.com/matrix-org/matrix-spec-proposals/pull/3912}\n */\nexport const MSC3912_RELATION_BASED_REDACTIONS_PROP = new UnstableValue(\n    \"with_rel_types\",\n    \"org.matrix.msc3912.with_relations\",\n);\n\n/**\n * Functional members type for declaring a purpose of room members (e.g. helpful bots).\n * Note that this reference is UNSTABLE and subject to breaking changes, including its\n * eventual removal.\n *\n * Schema (TypeScript):\n * ```\n * {\n *   service_members?: string[]\n * }\n * ```\n *\n * @example\n * ```\n * {\n *   \"service_members\": [\n *     \"@helperbot:localhost\",\n *     \"@reminderbot:alice.tdl\"\n *   ]\n * }\n * ```\n */\nexport const UNSTABLE_ELEMENT_FUNCTIONAL_USERS = new UnstableValue(\n    \"io.element.functional_members\",\n    \"io.element.functional_members\",\n);\n\n/**\n * A type of message that affects visibility of a message,\n * as per https://github.com/matrix-org/matrix-doc/pull/3531\n *\n * @experimental\n */\nexport const EVENT_VISIBILITY_CHANGE_TYPE = new UnstableValue(\"m.visibility\", \"org.matrix.msc3531.visibility\");\n\n/**\n * https://github.com/matrix-org/matrix-doc/pull/3881\n *\n * @experimental\n */\nexport const PUSHER_ENABLED = new UnstableValue(\"enabled\", \"org.matrix.msc3881.enabled\");\n\n/**\n * https://github.com/matrix-org/matrix-doc/pull/3881\n *\n * @experimental\n */\nexport const PUSHER_DEVICE_ID = new UnstableValue(\"device_id\", \"org.matrix.msc3881.device_id\");\n\n/**\n * https://github.com/matrix-org/matrix-doc/pull/3890\n *\n * @experimental\n */\nexport const LOCAL_NOTIFICATION_SETTINGS_PREFIX = new UnstableValue(\n    \"m.local_notification_settings\",\n    \"org.matrix.msc3890.local_notification_settings\",\n);\n\n/**\n * https://github.com/matrix-org/matrix-doc/pull/4023\n *\n * @experimental\n */\nexport const UNSIGNED_THREAD_ID_FIELD = new UnstableValue(\"thread_id\", \"org.matrix.msc4023.thread_id\");\n\n/**\n * https://github.com/matrix-org/matrix-spec-proposals/pull/4115\n *\n * @experimental\n */\nexport const UNSIGNED_MEMBERSHIP_FIELD = new NamespacedValue(\"membership\", \"io.element.msc4115.membership\");\n\n/**\n * Mapped type from event type to content type for all specified non-state room events.\n */\nexport interface TimelineEvents {\n    [EventType.RoomMessage]: RoomMessageEventContent;\n    [EventType.Sticker]: StickerEventContent;\n    [EventType.Reaction]: ReactionEventContent;\n    [EventType.CallReplaces]: MCallReplacesEvent;\n    [EventType.CallAnswer]: MCallAnswer;\n    [EventType.CallSelectAnswer]: MCallSelectAnswer;\n    [EventType.CallNegotiate]: Omit<MCallInviteNegotiate, \"offer\">;\n    [EventType.CallInvite]: MCallInviteNegotiate;\n    [EventType.CallCandidates]: MCallCandidates;\n    [EventType.CallHangup]: MCallHangupReject;\n    [EventType.CallReject]: MCallHangupReject;\n    [EventType.CallSDPStreamMetadataChangedPrefix]: MCallBase & { [SDPStreamMetadataKey]: SDPStreamMetadata };\n    [EventType.CallEncryptionKeysPrefix]: EncryptionKeysEventContent;\n    [EventType.CallNotify]: ICallNotifyContent;\n    [EventType.RTCNotification]: IRTCNotificationContent;\n    [EventType.RTCDecline]: IRTCDeclineContent;\n    [M_BEACON.name]: MBeaconEventContent;\n    [M_POLL_START.name]: PollStartEventContent;\n    [M_POLL_END.name]: PollEndEventContent;\n    [EventType.RTCMembership]: RtcMembershipData | { msc4354_sticky_key: string }; // An object containing just the sticky key is empty.\n}\n\n/**\n * Mapped type from event type to content type for all specified room state events.\n */\nexport interface StateEvents {\n    [EventType.RoomCanonicalAlias]: RoomCanonicalAliasEventContent;\n    [EventType.RoomCreate]: RoomCreateEventContent;\n    [EventType.RoomJoinRules]: RoomJoinRulesEventContent;\n    [EventType.RoomMember]: RoomMemberEventContent;\n    // XXX: Spec says this event has 3 required fields but kicking such an invitation requires sending `{}`\n    [EventType.RoomThirdPartyInvite]: RoomThirdPartyInviteEventContent | EmptyObject;\n    [EventType.RoomPowerLevels]: RoomPowerLevelsEventContent;\n    [EventType.RoomName]: RoomNameEventContent;\n    [EventType.RoomTopic]: RoomTopicEventContent;\n    [EventType.RoomAvatar]: RoomAvatarEventContent;\n    [EventType.RoomPinnedEvents]: RoomPinnedEventsEventContent;\n    [EventType.RoomEncryption]: RoomEncryptionEventContent;\n    [EventType.RoomHistoryVisibility]: RoomHistoryVisibilityEventContent;\n    [EventType.RoomGuestAccess]: RoomGuestAccessEventContent;\n    [EventType.RoomServerAcl]: RoomServerAclEventContent;\n    [EventType.RoomTombstone]: RoomTombstoneEventContent;\n    [EventType.SpaceChild]: SpaceChildEventContent;\n    [EventType.SpaceParent]: SpaceParentEventContent;\n\n    [EventType.PolicyRuleUser]: PolicyRuleEventContent | EmptyObject;\n    [EventType.PolicyRuleRoom]: PolicyRuleEventContent | EmptyObject;\n    [EventType.PolicyRuleServer]: PolicyRuleEventContent | EmptyObject;\n\n    // MSC4284: Policy servers\n    [EventType.RoomPolicy]: RoomPolicyContent | EmptyObject;\n\n    // MSC3401\n    [EventType.GroupCallPrefix]: IGroupCallRoomState;\n    [EventType.GroupCallMemberPrefix]: IGroupCallRoomMemberState | SessionMembershipData | EmptyObject;\n    [EventType.RTCMembership]: RtcMembershipData | EmptyObject;\n    // MSC3089\n    [UNSTABLE_MSC3089_BRANCH.name]: MSC3089EventContent;\n\n    // MSC3672\n    [M_BEACON_INFO.name]: MBeaconInfoEventContent;\n}\n\n/**\n * Mapped type from event type to content type for all specified global account_data events.\n */\nexport interface AccountDataEvents extends SecretStorageAccountDataEvents {\n    [EventType.PushRules]: IPushRules;\n    [EventType.Direct]: { [userId: string]: string[] };\n    [EventType.IgnoredUserList]: { ignored_users: { [userId: string]: EmptyObject } };\n    \"m.secret_storage.default_key\": { key: string };\n    // Flag set by the rust SDK (Element X) and also used by us to mark that the user opted out of backup\n    // (I don't know why it's m.org.matrix...)\n    \"m.org.matrix.custom.backup_disabled\": { disabled: boolean };\n    \"m.identity_server\": { base_url: string | null };\n    [key: `${typeof LOCAL_NOTIFICATION_SETTINGS_PREFIX.name}.${string}`]: LocalNotificationSettings;\n    [key: `m.secret_storage.key.${string}`]: SecretStorageKeyDescription;\n\n    // Invites-ignorer events\n    [POLICIES_ACCOUNT_EVENT_TYPE.name]: { [key: string]: any };\n    [POLICIES_ACCOUNT_EVENT_TYPE.altName]: { [key: string]: any };\n}\n\n/**\n * Mapped type from event type to content type for all specified global events encrypted by secret storage.\n *\n * See https://spec.matrix.org/v1.13/client-server-api/#msecret_storagev1aes-hmac-sha2-1\n */\nexport interface SecretStorageAccountDataEvents {\n    \"m.megolm_backup.v1\": SecretInfo;\n    \"m.cross_signing.master\": SecretInfo;\n    \"m.cross_signing.self_signing\": SecretInfo;\n    \"m.cross_signing.user_signing\": SecretInfo;\n    \"org.matrix.msc3814\": SecretInfo;\n}\n","/*\nCopyright 2021 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type EitherAnd, NamespacedValue, UnstableValue } from \"matrix-events-sdk\";\n\nimport { isProvided } from \"../extensible_events_v1/utilities.ts\";\n\n// Types and utilities for MSC1767: Extensible events (version 1) in Matrix\n\n/**\n * Represents the stable and unstable values of a given namespace.\n */\nexport type TSNamespace<N> =\n    N extends NamespacedValue<infer S, infer U> ? TSNamespaceValue<S> | TSNamespaceValue<U> : never;\n\n/**\n * Represents a namespaced value, if the value is a string. Used to extract provided types\n * from a TSNamespace<N> (in cases where only stable *or* unstable is provided).\n */\nexport type TSNamespaceValue<V> = V extends string ? V : never;\n\n/**\n * Creates a type which is V when T is `never`, otherwise T.\n */\n// See https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887 for details on the array syntax.\nexport type DefaultNever<T, V> = [T] extends [never] ? V : T;\n\n/**\n * The namespaced value for m.message\n */\nexport const M_MESSAGE = new UnstableValue(\"m.message\", \"org.matrix.msc1767.message\");\n\n/**\n * An m.message event rendering\n */\nexport interface IMessageRendering {\n    body: string;\n    mimetype?: string;\n}\n\n/**\n * The content for an m.message event\n */\nexport type ExtensibleMessageEventContent = EitherAnd<\n    { [M_MESSAGE.name]: IMessageRendering[] },\n    { [M_MESSAGE.altName]: IMessageRendering[] }\n>;\n\n/**\n * The namespaced value for m.text\n */\nexport const M_TEXT = new UnstableValue(\"m.text\", \"org.matrix.msc1767.text\");\n\n/**\n * The content for an m.text event\n */\nexport type TextEventContent = EitherAnd<{ [M_TEXT.name]: string }, { [M_TEXT.altName]: string }>;\n\n/**\n * The namespaced value for m.html\n */\nexport const M_HTML = new UnstableValue(\"m.html\", \"org.matrix.msc1767.html\");\n\n/**\n * The content for an m.html event\n */\nexport type HtmlEventContent = EitherAnd<{ [M_HTML.name]: string }, { [M_HTML.altName]: string }>;\n\n/**\n * The content for an m.message, m.text, or m.html event\n */\nexport type ExtensibleAnyMessageEventContent = ExtensibleMessageEventContent | TextEventContent | HtmlEventContent;\n\n/**\n * The namespaced value for an m.reference relation\n */\nexport const REFERENCE_RELATION = new NamespacedValue(\"m.reference\");\n\n/**\n * Represents any relation type\n */\nexport type AnyRelation = TSNamespace<typeof REFERENCE_RELATION> | string;\n\n/**\n * An m.relates_to relationship\n */\nexport type RelatesToRelationship<R = never> = {\n    \"m.relates_to\": {\n        // See https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887 for array syntax\n        rel_type: [R] extends [never] ? AnyRelation : TSNamespace<R>;\n        event_id: string;\n    };\n};\n\n/**\n * Partial types for a Matrix Event.\n */\nexport interface IPartialEvent<TContent> {\n    type: string;\n    content: TContent;\n}\n\n/**\n * Represents a potentially namespaced event type.\n */\nexport type ExtensibleEventType = NamespacedValue<string, string> | string;\n\n/**\n * Determines if two event types are the same, including namespaces.\n * @param given - The given event type. This will be compared\n * against the expected type.\n * @param expected - The expected event type.\n * @returns True if the given type matches the expected type.\n */\nexport function isEventTypeSame(given: ExtensibleEventType | null, expected: ExtensibleEventType | null): boolean {\n    if (typeof given === \"string\") {\n        if (typeof expected === \"string\") {\n            return expected === given;\n        } else {\n            return (expected as NamespacedValue<string, string>).matches(given as string);\n        }\n    } else {\n        if (typeof expected === \"string\") {\n            return (given as NamespacedValue<string, string>).matches(expected as string);\n        } else {\n            const expectedNs = expected as NamespacedValue<string, string>;\n            const givenNs = given as NamespacedValue<string, string>;\n            return (\n                expectedNs.matches(givenNs.name) ||\n                (isProvided(givenNs.altName) && expectedNs.matches(givenNs.altName!))\n            );\n        }\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// Types for MSC3488 - m.location: Extending events with location data\nimport { type EitherAnd } from \"matrix-events-sdk\";\n\nimport { UnstableValue } from \"../NamespacedValue.ts\";\nimport { type M_TEXT } from \"./extensible_events.ts\";\n\nexport enum LocationAssetType {\n    Self = \"m.self\",\n    Pin = \"m.pin\",\n}\n\nexport const M_ASSET = new UnstableValue(\"m.asset\", \"org.matrix.msc3488.asset\");\nexport type MAssetContent = { type: LocationAssetType };\n/**\n * The event definition for an m.asset event (in content)\n */\nexport type MAssetEvent = EitherAnd<{ [M_ASSET.name]: MAssetContent }, { [M_ASSET.altName]: MAssetContent }>;\n\nexport const M_TIMESTAMP = new UnstableValue(\"m.ts\", \"org.matrix.msc3488.ts\");\n/**\n * The event definition for an m.ts event (in content)\n */\nexport type MTimestampEvent = EitherAnd<{ [M_TIMESTAMP.name]: number }, { [M_TIMESTAMP.altName]: number }>;\n\nexport const M_LOCATION = new UnstableValue(\"m.location\", \"org.matrix.msc3488.location\");\n\nexport type MLocationContent = {\n    uri: string;\n    description?: string | null;\n};\n\nexport type MLocationEvent = EitherAnd<\n    { [M_LOCATION.name]: MLocationContent },\n    { [M_LOCATION.altName]: MLocationContent }\n>;\n\nexport type MTextEvent = EitherAnd<{ [M_TEXT.name]: string }, { [M_TEXT.altName]: string }>;\n\n/* From the spec at:\n * https://github.com/matrix-org/matrix-doc/blob/matthew/location/proposals/3488-location.md\n{\n    \"type\": \"m.room.message\",\n    \"content\": {\n        \"body\": \"Matthew was at geo:51.5008,0.1247;u=35 as of Sat Nov 13 18:50:58 2021\",\n        \"msgtype\": \"m.location\",\n        \"geo_uri\": \"geo:51.5008,0.1247;u=35\",\n        \"m.location\": {\n            \"uri\": \"geo:51.5008,0.1247;u=35\",\n            \"description\": \"Matthew's whereabouts\",\n        },\n        \"m.asset\": {\n            \"type\": \"m.self\"\n        },\n        \"m.text\": \"Matthew was at geo:51.5008,0.1247;u=35 as of Sat Nov 13 18:50:58 2021\",\n        \"m.ts\": 1636829458432,\n    }\n}\n*/\ntype OptionalTimestampEvent = MTimestampEvent | undefined;\n/**\n * The content for an m.location event\n */\nexport type MLocationEventContent = MLocationEvent & MAssetEvent & MTextEvent & OptionalTimestampEvent;\n\nexport type LegacyLocationEventContent = {\n    body: string;\n    msgtype: string;\n    geo_uri: string;\n};\n\n/**\n * Possible content for location events as sent over the wire\n */\nexport type LocationEventWireContent = Partial<LegacyLocationEventContent & MLocationEventContent>;\n\nexport type ILocationContent = MLocationEventContent & LegacyLocationEventContent;\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum Visibility {\n    Public = \"public\",\n    Private = \"private\",\n}\n\nexport enum Preset {\n    PrivateChat = \"private_chat\",\n    TrustedPrivateChat = \"trusted_private_chat\",\n    PublicChat = \"public_chat\",\n}\n\nexport type ResizeMethod = \"crop\" | \"scale\";\n\nexport type IdServerUnbindResult = \"no-support\" | \"success\";\n\n// Knock and private are reserved keywords which are not yet implemented.\nexport enum JoinRule {\n    Public = \"public\",\n    Invite = \"invite\",\n    /**\n     * @deprecated Reserved keyword. Should not be used. Not yet implemented.\n     */\n    Private = \"private\",\n    Knock = \"knock\",\n    Restricted = \"restricted\",\n}\n\nexport enum RestrictedAllowType {\n    RoomMembership = \"m.room_membership\",\n}\n\nexport enum GuestAccess {\n    CanJoin = \"can_join\",\n    Forbidden = \"forbidden\",\n}\n\nexport enum HistoryVisibility {\n    Invited = \"invited\",\n    Joined = \"joined\",\n    Shared = \"shared\",\n    WorldReadable = \"world_readable\",\n}\n\nexport interface IUsageLimit {\n    // \"hs_disabled\" is NOT a specced string, but is used in Synapse\n    // This is tracked over at https://github.com/matrix-org/synapse/issues/9237\n    // eslint-disable-next-line camelcase\n    limit_type: \"monthly_active_user\" | \"hs_disabled\" | string;\n    // eslint-disable-next-line camelcase\n    admin_contact?: string;\n}\n\n/**\n * A policy name & url in a specific internationalisation\n * @see https://spec.matrix.org/v1.13/identity-service-api/#get_matrixidentityv2terms_response-200_internationalised-policy\n */\nexport interface InternationalisedPolicy {\n    name: string;\n    url: string;\n}\n\n/**\n * A versioned policy with internationalised variants\n * @see https://spec.matrix.org/v1.13/identity-service-api/#get_matrixidentityv2terms_response-200_policy-object\n */\nexport interface Policy {\n    /**\n     * The version for the policy.\n     * There are no requirements on what this might be and could be alpha, semantically versioned, or arbitrary.\n     */\n    version: string;\n    /**\n     * The policy information for the specified language.\n     * @remarks the type has to include a union with string due to limitations in the type system.\n     */\n    [lang: string]: InternationalisedPolicy | string;\n}\n\n/**\n * Response from the Terms API for Identity servers\n * @see https://spec.matrix.org/v1.13/identity-service-api/#get_matrixidentityv2terms\n */\nexport interface Terms {\n    policies: {\n        [policyName: string]: Policy;\n    };\n}\n","/*\nCopyright 2022 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type EitherAnd, UnstableValue } from \"matrix-events-sdk\";\n\nimport {\n    type ExtensibleAnyMessageEventContent,\n    type REFERENCE_RELATION,\n    type RelatesToRelationship,\n    type TSNamespace,\n} from \"./extensible_events.ts\";\nimport { type EmptyObject } from \"./common.ts\";\n\n/**\n * Identifier for a disclosed poll.\n */\nexport const M_POLL_KIND_DISCLOSED = new UnstableValue(\"m.poll.disclosed\", \"org.matrix.msc3381.poll.disclosed\");\n\n/**\n * Identifier for an undisclosed poll.\n */\nexport const M_POLL_KIND_UNDISCLOSED = new UnstableValue(\"m.poll.undisclosed\", \"org.matrix.msc3381.poll.undisclosed\");\n\n/**\n * Any poll kind.\n */\nexport type PollKind = TSNamespace<typeof M_POLL_KIND_DISCLOSED> | TSNamespace<typeof M_POLL_KIND_UNDISCLOSED> | string;\n\n/**\n * Known poll kind namespaces.\n */\nexport type KnownPollKind = typeof M_POLL_KIND_DISCLOSED | typeof M_POLL_KIND_UNDISCLOSED;\n\n/**\n * The namespaced value for m.poll.start\n */\nexport const M_POLL_START = new UnstableValue(\"m.poll.start\", \"org.matrix.msc3381.poll.start\");\n\n/**\n * The m.poll.start type within event content\n */\nexport type PollStartSubtype = {\n    question: ExtensibleAnyMessageEventContent;\n    kind: PollKind;\n    max_selections?: number; // default 1, always positive\n    answers: PollAnswer[];\n};\n\n/**\n * A poll answer.\n */\nexport type PollAnswer = ExtensibleAnyMessageEventContent & { id: string };\n\n/**\n * The event definition for an m.poll.start event (in content)\n */\nexport type PollStartEvent = EitherAnd<\n    { [M_POLL_START.name]: PollStartSubtype },\n    { [M_POLL_START.altName]: PollStartSubtype }\n>;\n\n/**\n * The content for an m.poll.start event\n */\nexport type PollStartEventContent = PollStartEvent & ExtensibleAnyMessageEventContent;\n\n/**\n * The namespaced value for m.poll.response\n */\nexport const M_POLL_RESPONSE = new UnstableValue(\"m.poll.response\", \"org.matrix.msc3381.poll.response\");\n\n/**\n * The m.poll.response type within event content\n */\nexport type PollResponseSubtype = {\n    answers: string[];\n};\n\n/**\n * The event definition for an m.poll.response event (in content)\n */\nexport type PollResponseEvent = EitherAnd<\n    { [M_POLL_RESPONSE.name]: PollResponseSubtype },\n    { [M_POLL_RESPONSE.altName]: PollResponseSubtype }\n>;\n\n/**\n * The content for an m.poll.response event\n */\nexport type PollResponseEventContent = PollResponseEvent & RelatesToRelationship<typeof REFERENCE_RELATION>;\n\n/**\n * The namespaced value for m.poll.end\n */\nexport const M_POLL_END = new UnstableValue(\"m.poll.end\", \"org.matrix.msc3381.poll.end\");\n\n/**\n * The event definition for an m.poll.end event (in content)\n */\nexport type PollEndEvent = EitherAnd<{ [M_POLL_END.name]: EmptyObject }, { [M_POLL_END.altName]: EmptyObject }>;\n\n/**\n * The content for an m.poll.end event\n */\nexport type PollEndEventContent = PollEndEvent &\n    RelatesToRelationship<typeof REFERENCE_RELATION> &\n    ExtensibleAnyMessageEventContent;\n","/*\nCopyright 2022 imon Brandner <simon.bra.ag@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum ReceiptType {\n    Read = \"m.read\",\n    FullyRead = \"m.fully_read\",\n    ReadPrivate = \"m.read.private\",\n}\n\nexport const MAIN_ROOM_TIMELINE = \"main\";\n\nexport interface Receipt {\n    ts: number;\n    thread_id?: string;\n}\n\nexport interface WrappedReceipt {\n    eventId: string;\n    data: Receipt;\n}\n\nexport interface CachedReceipt {\n    type: ReceiptType;\n    userId: string;\n    data: Receipt;\n}\n\nexport type ReceiptCache = Map<string, CachedReceipt[]>;\n\nexport interface ReceiptContent {\n    [eventId: string]: {\n        [key in ReceiptType | string]: {\n            [userId: string]: Receipt;\n        };\n    };\n}\n\n// We will only hold a synthetic receipt if we do not have a real receipt or the synthetic is newer.\n// map: receipt type  user Id  receipt\nexport type Receipts = Map<string, Map<string, [real: WrappedReceipt | null, synthetic: WrappedReceipt | null]>>;\n\nexport type CachedReceiptStructure = {\n    eventId: string;\n    receiptType: string | ReceiptType;\n    userId: string;\n    receipt: Receipt;\n    synthetic: boolean;\n};\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IContent, type IEvent } from \"../models/event.ts\";\nimport { type Preset, type Visibility } from \"./partials.ts\";\nimport { type IEventWithRoomId, type SearchKey } from \"./search.ts\";\nimport { type IRoomEventFilter } from \"../filter.ts\";\nimport { type Direction } from \"../models/event-timeline.ts\";\nimport { type PushRuleAction } from \"./PushRules.ts\";\nimport { type MatrixError } from \"../matrix.ts\";\nimport { type IRoomEvent } from \"../sync-accumulator.ts\";\nimport { type EventType, type RelationType, type RoomType } from \"./event.ts\";\n\n// allow camelcase as these are things that go onto the wire\n/* eslint-disable camelcase */\n\nexport interface IJoinRoomOpts {\n    /**\n     * If the caller has a keypair 3pid invite, the signing URL is passed in this parameter.\n     */\n    inviteSignUrl?: string;\n\n    /**\n     * The server names to try and join through in addition to those that are automatically chosen.\n     * Only the first 3 are actually used in the request, to avoid HTTP 414 Request-URI Too Long responses.\n     */\n    viaServers?: string[];\n\n    /**\n     * When accepting an invite, whether to accept encrypted history shared by the inviter via the experimental\n     * support for [MSC4268](https://github.com/matrix-org/matrix-spec-proposals/pull/4268).\n     *\n     * @experimental\n     */\n    acceptSharedHistory?: boolean;\n}\n\n/** Options object for {@link MatrixClient.invite}. */\nexport interface InviteOpts {\n    /**\n     * The reason for the invite.\n     */\n    reason?: string;\n\n    /**\n     * Before sending the invite, if the room is encrypted, share the keys for any messages sent while the history\n     * visibility was `shared`, via the experimental\n     * support for [MSC4268](https://github.com/matrix-org/matrix-spec-proposals/pull/4268).\n     *\n     * @experimental\n     */\n    shareEncryptedHistory?: boolean;\n}\n\nexport interface KnockRoomOpts {\n    /**\n     * The reason for the knock.\n     */\n    reason?: string;\n\n    /**\n     * The server names to try and knock through in addition to those that are automatically chosen.\n     * Only the first 3 are actually used in the request, to avoid HTTP 414 Request-URI Too Long responses.\n     */\n    viaServers?: string | string[];\n}\n\nexport interface IRedactOpts {\n    reason?: string;\n    /**\n     * If specified, then any events which relate to the event being redacted with\n     * any of the relationship types listed will also be redacted.\n     * Provide a \"*\" list item to tell the server to redact relations of any type.\n     *\n     * <b>Raises an Error if the server does not support it.</b>\n     * Check for server-side support before using this param with\n     * <code>client.canSupport.get(Feature.RelationBasedRedactions)</code>.\n     * {@link https://github.com/matrix-org/matrix-spec-proposals/pull/3912}\n     */\n    with_rel_types?: Array<RelationType | \"*\">;\n}\n\nexport interface ISendEventResponse {\n    event_id: string;\n}\n\nexport type SendDelayedEventRequestOpts = { parent_delay_id: string } | { delay: number; parent_delay_id?: string };\n\nexport function isSendDelayedEventRequestOpts(opts: object): opts is SendDelayedEventRequestOpts {\n    if (\"parent_delay_id\" in opts && typeof opts.parent_delay_id !== \"string\") {\n        // Invalid type, reject\n        return false;\n    }\n    if (\"delay\" in opts && typeof opts.delay !== \"number\") {\n        // Invalid type, reject.\n        return true;\n    }\n    // At least one of these fields must be specified.\n    return \"delay\" in opts || \"parent_delay_id\" in opts;\n}\nexport type SendDelayedEventResponse = {\n    delay_id: string;\n};\n\nexport enum UpdateDelayedEventAction {\n    Cancel = \"cancel\",\n    Restart = \"restart\",\n    Send = \"send\",\n}\n\nexport type UpdateDelayedEventRequestOpts = SendDelayedEventResponse & {\n    action: UpdateDelayedEventAction;\n};\n\ntype DelayedPartialTimelineEvent = {\n    room_id: string;\n    type: string;\n    content: IContent;\n};\n\ntype DelayedPartialStateEvent = DelayedPartialTimelineEvent & {\n    state_key: string;\n};\n\ntype DelayedPartialEvent = DelayedPartialTimelineEvent | DelayedPartialStateEvent;\n\nexport type DelayedEventInfoItem = DelayedPartialEvent &\n    SendDelayedEventResponse &\n    SendDelayedEventRequestOpts & {\n        running_since: number;\n    };\n\nexport type DelayedEventInfo = {\n    scheduled?: DelayedEventInfoItem[];\n    finalised?: {\n        delayed_event: DelayedEventInfoItem;\n        outcome: \"send\" | \"cancel\";\n        reason: \"error\" | \"action\" | \"delay\";\n        error?: MatrixError[\"data\"];\n        event_id?: string;\n        origin_server_ts?: number;\n    }[];\n    next_batch?: string;\n};\n\nexport interface IPresenceOpts {\n    // One of \"online\", \"offline\" or \"unavailable\"\n    presence: \"online\" | \"offline\" | \"unavailable\";\n    // The status message to attach.\n    status_msg?: string;\n}\n\nexport interface IPaginateOpts {\n    // true to fill backwards, false to go forwards\n    backwards?: boolean;\n    // number of events to request\n    limit?: number;\n}\n\nexport interface IGuestAccessOpts {\n    /**\n     * True to allow guests to join this room. This\n     * implicitly gives guests write access. If false or not given, guests are\n     * explicitly forbidden from joining the room.\n     */\n    allowJoin: boolean;\n    /**\n     * True to set history visibility to\n     * be world_readable. This gives guests read access *from this point forward*.\n     * If false or not given, history visibility is not modified.\n     */\n    allowRead: boolean;\n}\n\nexport interface ISearchOpts {\n    keys?: SearchKey[];\n    query: string;\n}\n\nexport interface IEventSearchOpts {\n    // a JSON filter object to pass in the request\n    filter?: IRoomEventFilter;\n    // the term to search for\n    term: string;\n}\n\nexport interface IInvite3PID {\n    id_server: string;\n    id_access_token?: string; // this gets injected by the js-sdk\n    medium: string;\n    address: string;\n}\n\nexport interface ICreateRoomStateEvent {\n    type: string;\n    state_key?: string; // defaults to an empty string\n    content: IContent;\n}\n\nexport interface ICreateRoomOpts {\n    // The alias localpart to assign to this room.\n    room_alias_name?: string;\n    // Either 'public' or 'private'.\n    visibility?: Visibility;\n    // The name to give this room.\n    name?: string;\n    // The topic to give this room.\n    topic?: string;\n    preset?: Preset;\n    power_level_content_override?: {\n        ban?: number;\n        events?: Record<EventType | string, number>;\n        events_default?: number;\n        invite?: number;\n        kick?: number;\n        notifications?: Record<string, number>;\n        redact?: number;\n        state_default?: number;\n        users?: Record<string, number>;\n        users_default?: number;\n    };\n    creation_content?: object;\n    initial_state?: ICreateRoomStateEvent[];\n    // A list of user IDs to invite to this room.\n    invite?: string[];\n    invite_3pid?: IInvite3PID[];\n    is_direct?: boolean;\n    room_version?: string;\n}\n\nexport interface IRoomDirectoryOptions {\n    /**\n     * The remote server to query for the room list.\n     * Optional. If unspecified, get the local homeserver's public room list.\n     */\n    server?: string;\n    /**\n     * Maximum number of entries to return\n     */\n    limit?: number;\n    /**\n     * Token to paginate from\n     */\n    since?: string;\n\n    /** Filter parameters */\n    filter?: {\n        // String to search for\n        generic_search_term?: string;\n        room_types?: Array<RoomType | null>;\n    };\n    include_all_networks?: boolean;\n    third_party_instance_id?: string;\n}\n\nexport interface IAddThreePidOnlyBody {\n    auth?: {\n        type: string;\n        session?: string;\n    };\n    client_secret: string;\n    sid: string;\n}\n\nexport interface IBindThreePidBody {\n    client_secret: string;\n    id_server: string;\n    // Some older identity servers have no auth enabled\n    id_access_token: string | null;\n    sid: string;\n}\n\nexport interface IRelationsRequestOpts {\n    from?: string;\n    to?: string;\n    limit?: number;\n    dir?: Direction;\n    recurse?: boolean; // MSC3981 Relations Recursion https://github.com/matrix-org/matrix-spec-proposals/pull/3981\n}\n\nexport interface IRelationsResponse {\n    chunk: IEvent[];\n    next_batch?: string;\n    prev_batch?: string;\n}\n\nexport interface IContextResponse {\n    end?: string;\n    start?: string;\n    state?: IEventWithRoomId[];\n    events_before?: IEventWithRoomId[];\n    events_after?: IEventWithRoomId[];\n    event?: IEventWithRoomId;\n}\n\nexport interface IEventsResponse {\n    chunk: IEventWithRoomId[];\n    end: string;\n    start: string;\n}\n\nexport interface INotification {\n    actions: PushRuleAction[];\n    event: IRoomEvent;\n    profile_tag?: string;\n    read: boolean;\n    room_id: string;\n    ts: number;\n}\n\nexport interface INotificationsResponse {\n    next_token: string;\n    notifications: INotification[];\n}\n\nexport interface IFilterResponse {\n    filter_id: string;\n}\n\nexport interface ITagsResponse {\n    tags: {\n        [tagId: string]: {\n            order: number;\n        };\n    };\n}\n\nexport interface IStatusResponse extends IPresenceOpts {\n    currently_active?: boolean;\n    last_active_ago?: number;\n}\n\n/* eslint-enable camelcase */\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// Types relating to the /search API\n\nimport { type IRoomEvent, type IStateEvent } from \"../sync-accumulator.ts\";\nimport { type IRoomEventFilter } from \"../filter.ts\";\nimport { type SearchResult } from \"../models/search-result.ts\";\n\n/* eslint-disable camelcase */\nexport interface IEventWithRoomId extends IRoomEvent {\n    room_id: string;\n}\n\nexport interface IStateEventWithRoomId extends IStateEvent {\n    room_id: string;\n}\n\nexport interface IMatrixProfile {\n    avatar_url?: string;\n    displayname?: string;\n}\n\nexport interface IResultContext {\n    events_before: IEventWithRoomId[];\n    events_after: IEventWithRoomId[];\n    profile_info: Record<string, IMatrixProfile>;\n    start?: string;\n    end?: string;\n}\n\nexport interface ISearchResult {\n    rank: number;\n    result: IEventWithRoomId;\n    context: IResultContext;\n}\n\nenum GroupKey {\n    RoomId = \"room_id\",\n    Sender = \"sender\",\n}\n\nexport interface IResultRoomEvents {\n    count?: number;\n    highlights?: string[];\n    results?: ISearchResult[];\n    state?: { [roomId: string]: IStateEventWithRoomId[] };\n    groups?: {\n        [groupKey in GroupKey]: {\n            [value: string]: {\n                next_batch?: string;\n                order: number;\n                results: string[];\n            };\n        };\n    };\n    next_batch?: string;\n}\n\ninterface IResultCategories {\n    room_events: IResultRoomEvents;\n}\n\nexport type SearchKey = \"content.body\" | \"content.name\" | \"content.topic\";\n\nexport enum SearchOrderBy {\n    Recent = \"recent\",\n    Rank = \"rank\",\n}\n\nexport interface ISearchRequestBody {\n    search_categories: {\n        room_events: {\n            search_term: string;\n            keys?: SearchKey[];\n            filter?: IRoomEventFilter;\n            order_by?: SearchOrderBy;\n            event_context?: {\n                before_limit?: number;\n                after_limit?: number;\n                include_profile?: boolean;\n            };\n            include_state?: boolean;\n            groupings?: {\n                group_by: {\n                    key: GroupKey;\n                }[];\n            };\n        };\n    };\n}\n\nexport interface ISearchResponse {\n    search_categories: IResultCategories;\n}\n\nexport interface ISearchResults {\n    _query?: ISearchRequestBody;\n    results: SearchResult[];\n    highlights: string[];\n    count?: number;\n    next_batch?: string;\n    pendingRequest?: Promise<ISearchResults>;\n    abortSignal?: AbortSignal;\n}\n/* eslint-enable camelcase */\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ServerControlledNamespacedValue } from \"../NamespacedValue.ts\";\n\n/**\n * https://github.com/matrix-org/matrix-doc/pull/3773\n *\n * @experimental\n */\nexport const UNREAD_THREAD_NOTIFICATIONS = new ServerControlledNamespacedValue(\n    \"unread_thread_notifications\",\n    \"org.matrix.msc3773.unread_thread_notifications\",\n);\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { NamespacedValue } from \"../NamespacedValue.ts\";\nimport { type IMessageRendering } from \"./extensible_events.ts\";\n\n/**\n * Extensible topic event type based on MSC3765\n * https://github.com/matrix-org/matrix-spec-proposals/pull/3765\n *\n * @example\n * ```\n * {\n *      \"type\": \"m.room.topic,\n *      \"state_key\": \"\",\n *      \"content\": {\n *          \"topic\": \"All about **pizza**\",\n *          \"m.topic\": [{\n *              \"body\": \"All about **pizza**\",\n *              \"mimetype\": \"text/plain\",\n *          }, {\n *              \"body\": \"All about <b>pizza</b>\",\n *              \"mimetype\": \"text/html\",\n *          }],\n *      }\n * }\n * ```\n */\n\n/**\n * The event type for an m.topic event (in content)\n */\nexport const M_TOPIC = new NamespacedValue(\"m.topic\");\n\n/**\n * The event content for an m.topic event (in content)\n */\nexport type MTopicContent = { \"m.text\": IMessageRendering[] };\n\n/**\n * A previous incorrect form of m.topic used by matrix-js-sdk\n * TODO remove this after a few releases\n *      https://github.com/matrix-org/matrix-js-sdk/pull/4984#pullrequestreview-3174251065\n */\nexport type MalformedMTopicEvent = { \"m.topic\": IMessageRendering[] };\n\n/**\n * The event definition for an m.topic event (in content)\n */\nexport type MTopicEvent = { \"m.topic\": MTopicContent } | MalformedMTopicEvent;\n\n/**\n * The event content for an m.room.topic event\n */\nexport type MRoomTopicEventContent = {\n    topic: string | null | undefined;\n} & Partial<MTopicEvent>;\n","/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Represents a simple Matrix namespaced value. This will assume that if a stable prefix\n * is provided that the stable prefix should be used when representing the identifier.\n */\nexport class NamespacedValue<S extends string, U extends string> {\n    // Stable is optional, but one of the two parameters is required, hence the weird-looking types.\n    // Goal is to to have developers explicitly say there is no stable value (if applicable).\n    public constructor(stable: S, unstable: U);\n    public constructor(stable: S, unstable?: U);\n    public constructor(stable: null | undefined, unstable: U);\n    public constructor(\n        public readonly stable?: S | null,\n        public readonly unstable?: U,\n    ) {\n        if (!this.unstable && !this.stable) {\n            throw new Error(\"One of stable or unstable values must be supplied\");\n        }\n    }\n\n    public get name(): U | S {\n        if (this.stable) {\n            return this.stable;\n        }\n        return this.unstable!;\n    }\n\n    public get altName(): U | S | null | undefined {\n        if (!this.stable) {\n            return null;\n        }\n        return this.unstable;\n    }\n\n    public get names(): (U | S)[] {\n        const names = [this.name];\n        const altName = this.altName;\n        if (altName) names.push(altName);\n        return names;\n    }\n\n    public matches(val: string): boolean {\n        return this.name === val || this.altName === val;\n    }\n\n    // this desperately wants https://github.com/microsoft/TypeScript/pull/26349 at the top level of the class\n    // so we can instantiate `NamespacedValue<string, _, _>` as a default type for that namespace.\n    public findIn<T>(obj: any): T | undefined {\n        let val: T | undefined = undefined;\n        if (this.name) {\n            val = obj?.[this.name];\n        }\n        if (!val && this.altName) {\n            val = obj?.[this.altName];\n        }\n        return val;\n    }\n\n    public includedIn(arr: any[]): boolean {\n        let included = false;\n        if (this.name) {\n            included = arr.includes(this.name);\n        }\n        if (!included && this.altName) {\n            included = arr.includes(this.altName);\n        }\n        return included;\n    }\n}\n\nexport class ServerControlledNamespacedValue<S extends string, U extends string> extends NamespacedValue<S, U> {\n    private preferUnstable = false;\n\n    public setPreferUnstable(preferUnstable: boolean): void {\n        this.preferUnstable = preferUnstable;\n    }\n\n    public get name(): U | S {\n        if (this.stable && !this.preferUnstable) {\n            return this.stable;\n        }\n        return this.unstable!;\n    }\n}\n\n/**\n * Represents a namespaced value which prioritizes the unstable value over the stable\n * value.\n */\nexport class UnstableValue<S extends string, U extends string> extends NamespacedValue<S, U> {\n    // Note: Constructor difference is that `unstable` is *required*.\n    public constructor(stable: S, unstable: U) {\n        super(stable, unstable);\n        if (!this.unstable) {\n            throw new Error(\"Unstable value must be supplied\");\n        }\n    }\n\n    public get name(): U {\n        return this.unstable!;\n    }\n\n    public get altName(): S {\n        return this.stable!;\n    }\n}\n","/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IClientWellKnown, type IWellKnownConfig, type IServerVersions } from \"./client.ts\";\nimport { logger } from \"./logger.ts\";\nimport { type MatrixError, Method, timeoutSignal } from \"./http-api/index.ts\";\nimport { SUPPORTED_MATRIX_VERSIONS } from \"./version-support.ts\";\n\n// Dev note: Auto discovery is part of the spec.\n// See: https://matrix.org/docs/spec/client_server/r0.4.0.html#server-discovery\n\nexport enum AutoDiscoveryAction {\n    SUCCESS = \"SUCCESS\",\n    IGNORE = \"IGNORE\",\n    PROMPT = \"PROMPT\",\n    FAIL_PROMPT = \"FAIL_PROMPT\",\n    FAIL_ERROR = \"FAIL_ERROR\",\n}\n\nexport enum AutoDiscoveryError {\n    Invalid = \"Invalid homeserver discovery response\",\n    GenericFailure = \"Failed to get autodiscovery configuration from server\",\n    InvalidHsBaseUrl = \"Invalid base_url for m.homeserver\",\n    InvalidHomeserver = \"Homeserver URL does not appear to be a valid Matrix homeserver\",\n    InvalidIsBaseUrl = \"Invalid base_url for m.identity_server\",\n    InvalidIdentityServer = \"Identity server URL does not appear to be a valid identity server\",\n    InvalidIs = \"Invalid identity server discovery response\",\n    MissingWellknown = \"No .well-known JSON file found\",\n    InvalidJson = \"Invalid JSON\",\n    UnsupportedHomeserverSpecVersion = \"The homeserver does not meet the version requirements\",\n\n    // TODO: Implement when Sydent supports the `/versions` endpoint - https://github.com/matrix-org/sydent/issues/424\n    //IdentityServerTooOld = \"The identity server does not meet the minimum version requirements\",\n}\n\ninterface AutoDiscoveryState {\n    state: AutoDiscoveryAction;\n    error?: IWellKnownConfig[\"error\"] | null;\n}\ninterface WellKnownConfig extends Omit<IWellKnownConfig, \"error\">, AutoDiscoveryState {}\n\nexport interface ClientConfig extends Omit<IClientWellKnown, \"m.homeserver\" | \"m.identity_server\"> {\n    \"m.homeserver\": WellKnownConfig;\n    \"m.identity_server\": WellKnownConfig;\n}\n\n/**\n * Utilities for automatically discovery resources, such as homeservers\n * for users to log in to.\n */\nexport class AutoDiscovery {\n    // Dev note: the constants defined here are related to but not\n    // exactly the same as those in the spec. This is to hopefully\n    // translate the meaning of the states in the spec, but also\n    // support our own if needed.\n\n    public static readonly ERROR_INVALID = AutoDiscoveryError.Invalid;\n\n    public static readonly ERROR_GENERIC_FAILURE = AutoDiscoveryError.GenericFailure;\n\n    public static readonly ERROR_INVALID_HS_BASE_URL = AutoDiscoveryError.InvalidHsBaseUrl;\n\n    public static readonly ERROR_INVALID_HOMESERVER = AutoDiscoveryError.InvalidHomeserver;\n\n    public static readonly ERROR_INVALID_IS_BASE_URL = AutoDiscoveryError.InvalidIsBaseUrl;\n\n    public static readonly ERROR_INVALID_IDENTITY_SERVER = AutoDiscoveryError.InvalidIdentityServer;\n\n    public static readonly ERROR_INVALID_IS = AutoDiscoveryError.InvalidIs;\n\n    public static readonly ERROR_MISSING_WELLKNOWN = AutoDiscoveryError.MissingWellknown;\n\n    public static readonly ERROR_INVALID_JSON = AutoDiscoveryError.InvalidJson;\n\n    public static readonly ERROR_UNSUPPORTED_HOMESERVER_SPEC_VERSION =\n        AutoDiscoveryError.UnsupportedHomeserverSpecVersion;\n\n    public static readonly ALL_ERRORS = Object.keys(AutoDiscoveryError) as AutoDiscoveryError[];\n\n    /**\n     * The auto discovery failed. The client is expected to communicate\n     * the error to the user and refuse logging in.\n     */\n    public static readonly FAIL_ERROR = AutoDiscoveryAction.FAIL_ERROR;\n\n    /**\n     * The auto discovery failed, however the client may still recover\n     * from the problem. The client is recommended to that the same\n     * action it would for PROMPT while also warning the user about\n     * what went wrong. The client may also treat this the same as\n     * a FAIL_ERROR state.\n     */\n    public static readonly FAIL_PROMPT = AutoDiscoveryAction.FAIL_PROMPT;\n\n    /**\n     * The auto discovery didn't fail but did not find anything of\n     * interest. The client is expected to prompt the user for more\n     * information, or fail if it prefers.\n     */\n    public static readonly PROMPT = AutoDiscoveryAction.PROMPT;\n\n    /**\n     * The auto discovery was successful.\n     */\n    public static readonly SUCCESS = AutoDiscoveryAction.SUCCESS;\n\n    /**\n     * Validates and verifies client configuration information for purposes\n     * of logging in. Such information includes the homeserver URL\n     * and identity server URL the client would want. Additional details\n     * may also be included, and will be transparently brought into the\n     * response object unaltered.\n     * @param wellknown - The configuration object itself, as returned\n     * by the .well-known auto-discovery endpoint.\n     * @returns Promise which resolves to the verified\n     * configuration, which may include error states. Rejects on unexpected\n     * failure, not when verification fails.\n     */\n    public static async fromDiscoveryConfig(wellknown?: IClientWellKnown): Promise<ClientConfig> {\n        // Step 1 is to get the config, which is provided to us here.\n\n        // We default to an error state to make the first few checks easier to\n        // write. We'll update the properties of this object over the duration\n        // of this function.\n        const clientConfig: ClientConfig = {\n            \"m.homeserver\": {\n                state: AutoDiscovery.FAIL_ERROR,\n                error: AutoDiscovery.ERROR_INVALID,\n                base_url: null,\n            },\n            \"m.identity_server\": {\n                // Technically, we don't have a problem with the identity server\n                // config at this point.\n                state: AutoDiscovery.PROMPT,\n                error: null,\n                base_url: null,\n            },\n        };\n\n        if (!wellknown?.[\"m.homeserver\"]) {\n            logger.error(\"No m.homeserver key in config\");\n\n            clientConfig[\"m.homeserver\"].state = AutoDiscovery.FAIL_PROMPT;\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID;\n\n            return Promise.resolve(clientConfig);\n        }\n\n        if (!wellknown[\"m.homeserver\"][\"base_url\"]) {\n            logger.error(\"No m.homeserver base_url in config\");\n\n            clientConfig[\"m.homeserver\"].state = AutoDiscovery.FAIL_PROMPT;\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID_HS_BASE_URL;\n\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 2: Make sure the homeserver URL is valid *looking*. We'll make\n        // sure it points to a homeserver in Step 3.\n        const hsUrl = this.sanitizeWellKnownUrl(wellknown[\"m.homeserver\"][\"base_url\"]);\n        if (!hsUrl) {\n            logger.error(\"Invalid base_url for m.homeserver\");\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID_HS_BASE_URL;\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 3: Make sure the homeserver URL points to a homeserver.\n        const hsVersions = await this.fetchWellKnownObject<IServerVersions>(`${hsUrl}/_matrix/client/versions`);\n        if (!hsVersions || !Array.isArray(hsVersions.raw?.[\"versions\"])) {\n            logger.error(\"Invalid /versions response\");\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID_HOMESERVER;\n\n            // Supply the base_url to the caller because they may be ignoring liveliness\n            // errors, like this one.\n            clientConfig[\"m.homeserver\"].base_url = hsUrl;\n\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 3.1: Non-spec check to ensure the server will actually work for us. We need to check if\n        // any of the versions in `SUPPORTED_MATRIX_VERSIONS` are listed in the /versions response.\n        const hsVersionSet = new Set(hsVersions.raw![\"versions\"]);\n        let supportedVersionFound = false;\n        for (const version of SUPPORTED_MATRIX_VERSIONS) {\n            if (hsVersionSet.has(version)) {\n                supportedVersionFound = true;\n                break;\n            }\n        }\n        if (!supportedVersionFound) {\n            logger.error(\"Homeserver does not meet version requirements\");\n            clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_UNSUPPORTED_HOMESERVER_SPEC_VERSION;\n\n            // Supply the base_url to the caller because they may be ignoring liveliness\n            // errors, like this one.\n            clientConfig[\"m.homeserver\"].base_url = hsUrl;\n\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 4: Now that the homeserver looks valid, update our client config.\n        clientConfig[\"m.homeserver\"] = {\n            state: AutoDiscovery.SUCCESS,\n            error: null,\n            base_url: hsUrl,\n        };\n\n        // Step 5: Try to pull out the identity server configuration\n        let isUrl: string | boolean = \"\";\n        if (wellknown[\"m.identity_server\"]) {\n            // We prepare a failing identity server response to save lines later\n            // in this branch.\n            const failingClientConfig: ClientConfig = {\n                \"m.homeserver\": clientConfig[\"m.homeserver\"],\n                \"m.identity_server\": {\n                    state: AutoDiscovery.FAIL_PROMPT,\n                    error: AutoDiscovery.ERROR_INVALID_IS,\n                    base_url: null,\n                },\n            };\n\n            // Step 5a: Make sure the URL is valid *looking*. We'll make sure it\n            // points to an identity server in Step 5b.\n            isUrl = this.sanitizeWellKnownUrl(wellknown[\"m.identity_server\"][\"base_url\"]);\n            if (!isUrl) {\n                logger.error(\"Invalid base_url for m.identity_server\");\n                failingClientConfig[\"m.identity_server\"].error = AutoDiscovery.ERROR_INVALID_IS_BASE_URL;\n                return Promise.resolve(failingClientConfig);\n            }\n\n            // Step 5b: Verify there is an identity server listening on the provided\n            // URL.\n            const isResponse = await this.fetchWellKnownObject(`${isUrl}/_matrix/identity/v2`);\n            if (!isResponse?.raw || isResponse.action !== AutoDiscoveryAction.SUCCESS) {\n                logger.error(\"Invalid /v2 response\");\n                failingClientConfig[\"m.identity_server\"].error = AutoDiscovery.ERROR_INVALID_IDENTITY_SERVER;\n\n                // Supply the base_url to the caller because they may be ignoring\n                // liveliness errors, like this one.\n                failingClientConfig[\"m.identity_server\"].base_url = isUrl;\n\n                return Promise.resolve(failingClientConfig);\n            }\n        }\n\n        // Step 6: Now that the identity server is valid, or never existed,\n        // populate the IS section.\n        if (isUrl && isUrl.toString().length > 0) {\n            clientConfig[\"m.identity_server\"] = {\n                state: AutoDiscovery.SUCCESS,\n                error: null,\n                base_url: isUrl,\n            };\n        }\n\n        // Step 7: Copy any other keys directly into the clientConfig. This is for\n        // things like custom configuration of services.\n        Object.keys(wellknown).forEach((k: keyof IClientWellKnown) => {\n            if (k === \"m.homeserver\" || k === \"m.identity_server\") {\n                // Only copy selected parts of the config to avoid overwriting\n                // properties computed by the validation logic above.\n                const notProps = [\"error\", \"state\", \"base_url\"];\n                for (const prop of Object.keys(wellknown[k]!)) {\n                    if (notProps.includes(prop)) continue;\n                    type Prop = Exclude<keyof IWellKnownConfig, \"error\" | \"state\" | \"base_url\">;\n                    // @ts-ignore - ts gets unhappy as we're mixing types here\n                    clientConfig[k][prop as Prop] = wellknown[k]![prop as Prop];\n                }\n            } else {\n                // Just copy the whole thing over otherwise\n                clientConfig[k] = wellknown[k];\n            }\n        });\n\n        // Step 8: Give the config to the caller (finally)\n        return Promise.resolve(clientConfig);\n    }\n\n    /**\n     * Attempts to automatically discover client configuration information\n     * prior to logging in. Such information includes the homeserver URL\n     * and identity server URL the client would want. Additional details\n     * may also be discovered, and will be transparently included in the\n     * response object unaltered.\n     * @param domain - The homeserver domain to perform discovery\n     * on. For example, \"matrix.org\".\n     * @returns Promise which resolves to the discovered\n     * configuration, which may include error states. Rejects on unexpected\n     * failure, not when discovery fails.\n     */\n    public static async findClientConfig(domain: string): Promise<ClientConfig> {\n        if (!domain || typeof domain !== \"string\" || domain.length === 0) {\n            throw new Error(\"'domain' must be a string of non-zero length\");\n        }\n\n        // We use a .well-known lookup for all cases. According to the spec, we\n        // can do other discovery mechanisms if we want such as custom lookups\n        // however we won't bother with that here (mostly because the spec only\n        // supports .well-known right now).\n        //\n        // By using .well-known, we need to ensure we at least pull out a URL\n        // for the homeserver. We don't really need an identity server configuration\n        // but will return one anyways (with state PROMPT) to make development\n        // easier for clients. If we can't get a homeserver URL, all bets are\n        // off on the rest of the config and we'll assume it is invalid too.\n\n        // We default to an error state to make the first few checks easier to\n        // write. We'll update the properties of this object over the duration\n        // of this function.\n        const clientConfig: ClientConfig = {\n            \"m.homeserver\": {\n                state: AutoDiscovery.FAIL_ERROR,\n                error: AutoDiscovery.ERROR_INVALID,\n                base_url: null,\n            },\n            \"m.identity_server\": {\n                // Technically, we don't have a problem with the identity server\n                // config at this point.\n                state: AutoDiscovery.PROMPT,\n                error: null,\n                base_url: null,\n            },\n        };\n\n        // Step 1: Actually request the .well-known JSON file and make sure it\n        // at least has a homeserver definition.\n        const domainWithProtocol = domain.includes(\"://\") ? domain : `https://${domain}`;\n        const wellknown = await this.fetchWellKnownObject(`${domainWithProtocol}/.well-known/matrix/client`);\n        if (!wellknown || wellknown.action !== AutoDiscoveryAction.SUCCESS) {\n            logger.error(\"No response or error when parsing .well-known\");\n            if (wellknown.reason) logger.error(wellknown.reason);\n            if (wellknown.action === AutoDiscoveryAction.IGNORE) {\n                clientConfig[\"m.homeserver\"] = {\n                    state: AutoDiscovery.PROMPT,\n                    error: null,\n                    base_url: null,\n                };\n            } else {\n                // this can only ever be FAIL_PROMPT at this point.\n                clientConfig[\"m.homeserver\"].state = AutoDiscovery.FAIL_PROMPT;\n                clientConfig[\"m.homeserver\"].error = AutoDiscovery.ERROR_INVALID;\n            }\n            return Promise.resolve(clientConfig);\n        }\n\n        // Step 2: Validate and parse the config\n        return AutoDiscovery.fromDiscoveryConfig(wellknown.raw!);\n    }\n\n    /**\n     * Gets the raw discovery client configuration for the given domain name.\n     * Should only be used if there's no validation to be done on the resulting\n     * object, otherwise use findClientConfig().\n     * @param domain - The domain to get the client config for.\n     * @returns Promise which resolves to the domain's client config. Can\n     * be an empty object.\n     */\n    public static async getRawClientConfig(domain?: string): Promise<IClientWellKnown> {\n        if (!domain || typeof domain !== \"string\" || domain.length === 0) {\n            throw new Error(\"'domain' must be a string of non-zero length\");\n        }\n\n        const response = await this.fetchWellKnownObject(`https://${domain}/.well-known/matrix/client`);\n        if (!response) return {};\n        return response.raw ?? {};\n    }\n\n    /**\n     * Sanitizes a given URL to ensure it is either an HTTP or HTTP URL and\n     * is suitable for the requirements laid out by .well-known auto discovery.\n     * If valid, the URL will also be stripped of any trailing slashes.\n     * @param url - The potentially invalid URL to sanitize.\n     * @returns The sanitized URL or a falsey value if the URL is invalid.\n     * @internal\n     */\n    private static sanitizeWellKnownUrl(url?: string | null): string | false {\n        if (!url) return false;\n\n        try {\n            let parsed: URL | undefined;\n            try {\n                parsed = new URL(url);\n            } catch (e) {\n                logger.error(\"Could not parse url\", e);\n            }\n\n            if (!parsed?.hostname) return false;\n            if (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") return false;\n\n            const port = parsed.port ? `:${parsed.port}` : \"\";\n            const path = parsed.pathname ? parsed.pathname : \"\";\n            let saferUrl = `${parsed.protocol}//${parsed.hostname}${port}${path}`;\n            if (saferUrl.endsWith(\"/\")) {\n                saferUrl = saferUrl.substring(0, saferUrl.length - 1);\n            }\n            return saferUrl;\n        } catch (e) {\n            logger.error(e);\n            return false;\n        }\n    }\n\n    private static fetch(resource: URL | string, options?: RequestInit): ReturnType<typeof globalThis.fetch> {\n        if (this.fetchFn) {\n            return this.fetchFn(resource, options);\n        }\n        return globalThis.fetch(resource, options);\n    }\n\n    private static fetchFn?: typeof globalThis.fetch;\n\n    public static setFetchFn(fetchFn: typeof globalThis.fetch): void {\n        AutoDiscovery.fetchFn = fetchFn;\n    }\n\n    /**\n     * Fetches a JSON object from a given URL, as expected by all .well-known\n     * related lookups. If the server gives a 404 then the `action` will be\n     * IGNORE. If the server returns something that isn't JSON, the `action`\n     * will be FAIL_PROMPT. For any other failure the `action` will be FAIL_PROMPT.\n     *\n     * The returned object will be a result of the call in object form with\n     * the following properties:\n     *   raw: The JSON object returned by the server.\n     *   action: One of SUCCESS, IGNORE, or FAIL_PROMPT.\n     *   reason: Relatively human-readable description of what went wrong.\n     *   error: The actual Error, if one exists.\n     * @param url - The URL to fetch a JSON object from.\n     * @returns Promise which resolves to the returned state.\n     * @internal\n     */\n    private static async fetchWellKnownObject<T = IWellKnownConfig>(\n        url: string,\n    ): Promise<IWellKnownConfig<Partial<T>>> {\n        let response: Response;\n\n        try {\n            response = await AutoDiscovery.fetch(url, {\n                method: Method.Get,\n                signal: timeoutSignal(5000),\n            });\n\n            if (response.status === 404) {\n                return {\n                    raw: {},\n                    action: AutoDiscoveryAction.IGNORE,\n                    reason: AutoDiscovery.ERROR_MISSING_WELLKNOWN,\n                };\n            }\n\n            if (response.status !== 200) {\n                return {\n                    raw: {},\n                    action: AutoDiscoveryAction.FAIL_PROMPT,\n                    reason: \"General failure\",\n                };\n            }\n        } catch (err) {\n            const error = err as AutoDiscoveryError | string | undefined;\n            let reason = \"\";\n            if (typeof error === \"object\") {\n                reason = (<Error>error)?.message;\n            }\n\n            return {\n                error,\n                raw: {},\n                action: AutoDiscoveryAction.FAIL_PROMPT,\n                reason: reason || \"General failure\",\n            };\n        }\n\n        try {\n            return {\n                raw: await response.json(),\n                action: AutoDiscoveryAction.SUCCESS,\n            };\n        } catch (err) {\n            const error = err as Error;\n            return {\n                error,\n                raw: {},\n                action: AutoDiscoveryAction.FAIL_PROMPT,\n                reason:\n                    (error as MatrixError)?.name === \"SyntaxError\"\n                        ? AutoDiscovery.ERROR_INVALID_JSON\n                        : AutoDiscovery.ERROR_INVALID,\n            };\n        }\n    }\n}\n","/*\nCopyright 2015-2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixClient} for the public class.\n */\n\nimport type { IDeviceKeys, IOneTimeKey } from \"./@types/crypto.ts\";\nimport { type ISyncStateData, type SetPresence, SyncApi, type SyncApiOptions, SyncState } from \"./sync.ts\";\nimport {\n    EventStatus,\n    type IContent,\n    type IDecryptOptions,\n    type IEvent,\n    MatrixEvent,\n    MatrixEventEvent,\n    type MatrixEventHandlerMap,\n    type PushDetails,\n} from \"./models/event.ts\";\nimport { StubStore } from \"./store/stub.ts\";\nimport {\n    type CallEvent,\n    type CallEventHandlerMap,\n    createNewMatrixCall,\n    type MatrixCall,\n    supportsMatrixCall,\n} from \"./webrtc/call.ts\";\nimport { Filter, type IFilterDefinition, type IRoomEventFilter } from \"./filter.ts\";\nimport {\n    CallEventHandler,\n    type CallEventHandlerEvent,\n    type CallEventHandlerEventHandlerMap,\n} from \"./webrtc/callEventHandler.ts\";\nimport {\n    GroupCallEventHandler,\n    type GroupCallEventHandlerEvent,\n    type GroupCallEventHandlerEventHandlerMap,\n} from \"./webrtc/groupCallEventHandler.ts\";\nimport * as utils from \"./utils.ts\";\nimport { deepCompare, noUnsafeEventProps, type QueryDict, replaceParam, safeSet, sleep } from \"./utils.ts\";\nimport { Direction, EventTimeline } from \"./models/event-timeline.ts\";\nimport { type IActionsObject, PushProcessor } from \"./pushprocessor.ts\";\nimport { AutoDiscovery, type AutoDiscoveryAction } from \"./autodiscovery.ts\";\nimport { encodeUnpaddedBase64Url } from \"./base64.ts\";\nimport { TypedReEmitter } from \"./ReEmitter.ts\";\nimport { logger, type Logger } from \"./logger.ts\";\nimport { SERVICE_TYPES } from \"./service-types.ts\";\nimport {\n    type Body,\n    ClientPrefix,\n    type FileType,\n    type HttpApiEvent,\n    type HttpApiEventHandlerMap,\n    type HTTPError,\n    IdentityPrefix,\n    type IHttpOpts,\n    type IRequestOpts,\n    MatrixError,\n    MatrixHttpApi,\n    MediaPrefix,\n    Method,\n    retryNetworkOperation,\n    type TokenRefreshFunction,\n    type Upload,\n    type UploadOpts,\n    type UploadResponse,\n} from \"./http-api/index.ts\";\nimport { User, UserEvent, type UserEventHandlerMap } from \"./models/user.ts\";\nimport { getHttpUriForMxc } from \"./content-repo.ts\";\nimport { SearchResult } from \"./models/search-result.ts\";\nimport { type IIdentityServerProvider } from \"./@types/IIdentityServerProvider.ts\";\nimport { type MatrixScheduler } from \"./scheduler.ts\";\nimport { type BeaconEvent, type BeaconEventHandlerMap } from \"./models/beacon.ts\";\nimport { type AuthDict } from \"./interactive-auth.ts\";\nimport {\n    type IMinimalEvent,\n    type IRoomEvent,\n    type IStateEvent,\n    type ReceivedToDeviceMessage,\n} from \"./sync-accumulator.ts\";\nimport type { EventTimelineSet } from \"./models/event-timeline-set.ts\";\nimport * as ContentHelpers from \"./content-helpers.ts\";\nimport {\n    NotificationCountType,\n    type Room,\n    type RoomEvent,\n    type RoomEventHandlerMap,\n    type RoomNameState,\n} from \"./models/room.ts\";\nimport { RoomMemberEvent, type RoomMemberEventHandlerMap } from \"./models/room-member.ts\";\nimport { type IPowerLevelsContent, type RoomStateEvent, type RoomStateEventHandlerMap } from \"./models/room-state.ts\";\nimport {\n    isSendDelayedEventRequestOpts,\n    UpdateDelayedEventAction,\n    type DelayedEventInfo,\n    type IAddThreePidOnlyBody,\n    type IBindThreePidBody,\n    type IContextResponse,\n    type ICreateRoomOpts,\n    type IEventSearchOpts,\n    type IFilterResponse,\n    type IGuestAccessOpts,\n    type IJoinRoomOpts,\n    type INotificationsResponse,\n    type InviteOpts,\n    type IPaginateOpts,\n    type IPresenceOpts,\n    type IRedactOpts,\n    type IRelationsRequestOpts,\n    type IRelationsResponse,\n    type IRoomDirectoryOptions,\n    type ISearchOpts,\n    type ISendEventResponse,\n    type IStatusResponse,\n    type ITagsResponse,\n    type KnockRoomOpts,\n    type SendDelayedEventRequestOpts,\n    type SendDelayedEventResponse,\n} from \"./@types/requests.ts\";\nimport {\n    type AccountDataEvents,\n    EventType,\n    LOCAL_NOTIFICATION_SETTINGS_PREFIX,\n    MSC3912_RELATION_BASED_REDACTIONS_PROP,\n    MsgType,\n    PUSHER_ENABLED,\n    RelationType,\n    RoomCreateTypeField,\n    RoomType,\n    type StateEvents,\n    type TimelineEvents,\n    UNSTABLE_MSC3088_ENABLED,\n    UNSTABLE_MSC3088_PURPOSE,\n    UNSTABLE_MSC3089_TREE_SUBTYPE,\n} from \"./@types/event.ts\";\nimport {\n    GuestAccess,\n    HistoryVisibility,\n    type IdServerUnbindResult,\n    type JoinRule,\n    Preset,\n    type Terms,\n    type Visibility,\n} from \"./@types/partials.ts\";\nimport { type EventMapper, eventMapperFor, type MapperOpts } from \"./event-mapper.ts\";\nimport { secureRandomString } from \"./randomstring.ts\";\nimport { DEFAULT_TREE_POWER_LEVELS_TEMPLATE, MSC3089TreeSpace } from \"./models/MSC3089TreeSpace.ts\";\nimport { type ISignatures } from \"./@types/signed.ts\";\nimport { type IStore } from \"./store/index.ts\";\nimport {\n    type IEventWithRoomId,\n    type ISearchRequestBody,\n    type ISearchResponse,\n    type ISearchResults,\n    type IStateEventWithRoomId,\n    SearchOrderBy,\n} from \"./@types/search.ts\";\nimport { type ISynapseAdminDeactivateResponse, type ISynapseAdminWhoisResponse } from \"./@types/synapse.ts\";\nimport { type IHierarchyRoom } from \"./@types/spaces.ts\";\nimport {\n    type IPusher,\n    type IPusherRequest,\n    type IPushRule,\n    type IPushRules,\n    type PushRuleAction,\n    PushRuleActionName,\n    PushRuleKind,\n    type RuleId,\n} from \"./@types/PushRules.ts\";\nimport { type IThreepid } from \"./@types/threepids.ts\";\nimport { type CryptoStore } from \"./crypto/store/base.ts\";\nimport {\n    GroupCall,\n    type GroupCallIntent,\n    type GroupCallType,\n    type IGroupCallDataChannelOptions,\n} from \"./webrtc/groupCall.ts\";\nimport { MediaHandler } from \"./webrtc/mediaHandler.ts\";\nimport {\n    type ILoginFlowsResponse,\n    type IRefreshTokenResponse,\n    type LoginRequest,\n    type LoginResponse,\n    type LoginTokenPostResponse,\n    type SSOAction,\n} from \"./@types/auth.ts\";\nimport { TypedEventEmitter } from \"./models/typed-event-emitter.ts\";\nimport { MAIN_ROOM_TIMELINE, ReceiptType } from \"./@types/read_receipts.ts\";\nimport { type MSC3575SlidingSyncRequest, type MSC3575SlidingSyncResponse, type SlidingSync } from \"./sliding-sync.ts\";\nimport { SlidingSyncSdk } from \"./sliding-sync-sdk.ts\";\nimport {\n    determineFeatureSupport,\n    FeatureSupport,\n    Thread,\n    THREAD_RELATION_TYPE,\n    ThreadFilterType,\n    threadFilterTypeToFilter,\n} from \"./models/thread.ts\";\nimport { M_BEACON_INFO, type MBeaconInfoEventContent } from \"./@types/beacon.ts\";\nimport { NamespacedValue, UnstableValue } from \"./NamespacedValue.ts\";\nimport { ToDeviceMessageQueue } from \"./ToDeviceMessageQueue.ts\";\nimport { type ToDeviceBatch, type ToDevicePayload } from \"./models/ToDeviceMessage.ts\";\nimport { IgnoredInvites } from \"./models/invites-ignorer.ts\";\nimport { type UIARequest } from \"./@types/uia.ts\";\nimport { type LocalNotificationSettings } from \"./@types/local_notifications.ts\";\nimport { buildFeatureSupportMap, Feature, ServerSupport } from \"./feature.ts\";\nimport { type CryptoBackend } from \"./common-crypto/CryptoBackend.ts\";\nimport { RUST_SDK_STORE_PREFIX } from \"./rust-crypto/constants.ts\";\nimport {\n    type CrossSigningKeyInfo,\n    type CryptoApi,\n    type CryptoCallbacks,\n    CryptoEvent,\n    type CryptoEventHandlerMap,\n} from \"./crypto-api/index.ts\";\nimport {\n    type SecretStorageKeyDescription,\n    type ServerSideSecretStorage,\n    ServerSideSecretStorageImpl,\n} from \"./secret-storage.ts\";\nimport { type RegisterRequest, type RegisterResponse } from \"./@types/registration.ts\";\nimport { MatrixRTCSessionManager } from \"./matrixrtc/MatrixRTCSessionManager.ts\";\nimport { getRelationsThreadFilter } from \"./thread-utils.ts\";\nimport { KnownMembership, type Membership } from \"./@types/membership.ts\";\nimport { type RoomMessageEventContent, type StickerEventContent } from \"./@types/events.ts\";\nimport { type ImageInfo } from \"./@types/media.ts\";\nimport { type Capabilities, ServerCapabilities } from \"./serverCapabilities.ts\";\nimport { sha256 } from \"./digest.ts\";\nimport {\n    discoverAndValidateOIDCIssuerWellKnown,\n    type OidcClientConfig,\n    validateAuthMetadataAndKeys,\n} from \"./oidc/index.ts\";\nimport { type EmptyObject } from \"./@types/common.ts\";\nimport { UnsupportedDelayedEventsEndpointError, UnsupportedStickyEventsEndpointError } from \"./errors.ts\";\nimport { type Transport } from \"./matrixrtc/index.ts\";\n\nexport type Store = IStore;\n\nexport type ResetTimelineCallback = (roomId: string) => boolean;\n\nconst SCROLLBACK_DELAY_MS = 3000;\n\nconst TURN_CHECK_INTERVAL = 10 * 60 * 1000; // poll for turn credentials every 10 minutes\n\nexport const UNSTABLE_MSC3852_LAST_SEEN_UA = new UnstableValue(\n    \"last_seen_user_agent\",\n    \"org.matrix.msc3852.last_seen_user_agent\",\n);\n\nexport interface IKeysUploadResponse {\n    one_time_key_counts: {\n        // eslint-disable-line camelcase\n        [algorithm: string]: number;\n    };\n}\n\nexport interface ICreateClientOpts {\n    baseUrl: string;\n\n    idBaseUrl?: string;\n\n    /**\n     * The data store used for sync data from the homeserver. If not specified,\n     * this client will not store any HTTP responses. The `createClient` helper\n     * will create a default store if needed.\n     */\n    store?: Store;\n\n    /**\n     * A store to be used for end-to-end crypto session data.\n     * The `createClient` helper will create a default store if needed. Calls the factory supplied to\n     * {@link setCryptoStoreFactory} if unspecified; or if no factory has been\n     * specified, uses a default implementation (indexeddb in the browser,\n     * in-memory otherwise).\n     *\n     * This is only used for the legacy crypto implementation,\n     * but if you use the rust crypto implementation ({@link MatrixClient#initRustCrypto}) and the device\n     * previously used legacy crypto (so must be migrated), then this must still be provided, so that the\n     * data can be migrated from the legacy store.\n     */\n    cryptoStore?: CryptoStore;\n\n    /**\n     * The scheduler to use. If not\n     * specified, this client will not retry requests on failure. This client\n     * will supply its own processing function to\n     * {@link MatrixScheduler#setProcessFunction}.\n     */\n    scheduler?: MatrixScheduler;\n\n    /**\n     * The function to invoke for HTTP requests.\n     * Most supported environments have a global `fetch` registered to which this will fall back.\n     */\n    fetchFn?: typeof globalThis.fetch;\n\n    userId?: string;\n\n    /**\n     * A unique identifier for this device; used for tracking things like crypto\n     * keys and access tokens. If not specified, end-to-end encryption will be\n     * disabled.\n     */\n    deviceId?: string;\n\n    accessToken?: string;\n    refreshToken?: string;\n\n    /**\n     * Function used to attempt refreshing access and refresh tokens\n     * Called by http-api when a possibly expired token is encountered\n     * and a refreshToken is found\n     */\n    tokenRefreshFunction?: TokenRefreshFunction;\n\n    /**\n     * Identity server provider to retrieve the user's access token when accessing\n     * the identity server. See also https://github.com/vector-im/element-web/issues/10615\n     * which seeks to replace the previous approach of manual access tokens params\n     * with this callback throughout the SDK.\n     */\n    identityServer?: IIdentityServerProvider;\n\n    /**\n     * The default maximum amount of\n     * time to wait before timing out HTTP requests. If not specified, there is no timeout.\n     */\n    localTimeoutMs?: number;\n\n    /**\n     * Set to false to send the access token to the server via a query parameter rather\n     * than the Authorization HTTP header.\n     *\n     * Note that as of v1.11 of the Matrix spec, sending the access token via a query\n     * is deprecated.\n     *\n     * Default true.\n     */\n    useAuthorizationHeader?: boolean;\n\n    /**\n     * Set to true to enable\n     * improved timeline support, see {@link MatrixClient#getEventTimeline}.\n     * It is disabled by default for compatibility with older clients - in particular to\n     * maintain support for back-paginating the live timeline after a '/sync'\n     * result with a gap.\n     */\n    timelineSupport?: boolean;\n\n    /**\n     * Extra query parameters to append\n     * to all requests with this client. Useful for application services which require\n     * `?user_id=`.\n     */\n    queryParams?: QueryDict;\n\n    /**\n     * Encryption key used for encrypting sensitive data (such as e2ee keys) in {@link ICreateClientOpts#cryptoStore}.\n     *\n     * This must be set to the same value every time the client is initialised for the same device.\n     *\n     * This is only used for the legacy crypto implementation,\n     * but if you use the rust crypto implementation ({@link MatrixClient#initRustCrypto}) and the device\n     * previously used legacy crypto (so must be migrated), then this must still be provided, so that the\n     * data can be migrated from the legacy store.\n     */\n    pickleKey?: string;\n\n    /**\n     * Verification methods we should offer to the other side when performing an interactive verification.\n     * If unset, we will offer all known methods. Currently these are: showing a QR code, scanning a QR code, and SAS\n     * (aka \"emojis\").\n     *\n     * See {@link types.VerificationMethod} for a set of useful constants for this parameter.\n     */\n    verificationMethods?: Array<string>;\n\n    /**\n     * Whether relaying calls through a TURN server should be forced. Default false.\n     */\n    forceTURN?: boolean;\n\n    /**\n     * Up to this many ICE candidates will be gathered when an incoming call arrives.\n     * Gathering does not send data to the caller, but will communicate with the configured TURN\n     * server. Default 0.\n     */\n    iceCandidatePoolSize?: number;\n\n    /**\n     * True to advertise support for call transfers to other parties on Matrix calls. Default false.\n     */\n    supportsCallTransfer?: boolean;\n\n    /**\n     * Whether to allow a fallback ICE server should be used for negotiating a\n     * WebRTC connection if the homeserver doesn't provide any servers. Defaults to false.\n     */\n    fallbackICEServerAllowed?: boolean;\n\n    /**\n     * If true, to-device signalling for group calls will be encrypted\n     * with Olm. Default: true.\n     */\n    useE2eForGroupCall?: boolean;\n\n    livekitServiceURL?: string;\n\n    /**\n     * Crypto callbacks provided by the application\n     */\n    cryptoCallbacks?: CryptoCallbacks;\n\n    /**\n     * Enable encrypted state events.\n     */\n    enableEncryptedStateEvents?: boolean;\n\n    /**\n     * Method to generate room names for empty rooms and rooms names based on membership.\n     * Defaults to a built-in English handler with basic pluralisation.\n     */\n    roomNameGenerator?: (roomId: string, state: RoomNameState) => string | null;\n\n    /**\n     * If true, participant can join group call without video and audio this has to be allowed. By default, a local\n     * media stream is needed to establish a group call.\n     * Default: false.\n     */\n    isVoipWithNoMediaAllowed?: boolean;\n\n    /**\n     * Disable VoIP support (prevents fetching TURN servers, etc.)\n     * Default: false (VoIP enabled)\n     */\n    disableVoip?: boolean;\n\n    /**\n     * If true, group calls will not establish media connectivity and only create the signaling events,\n     * so that livekit media can be used in the application layer (js-sdk contains no livekit code).\n     */\n    useLivekitForGroupCalls?: boolean;\n\n    /**\n     * A logger to associate with this MatrixClient.\n     * Defaults to the built-in global logger; see {@link DebugLogger} for an alternative.\n     */\n    logger?: Logger;\n}\n\nexport interface IMatrixClientCreateOpts extends ICreateClientOpts {\n    /**\n     * Whether to allow sending messages to encrypted rooms when encryption\n     * is not available internally within this SDK. This is useful if you are using an external\n     * E2E proxy, for example. Defaults to false.\n     */\n    usingExternalCrypto?: boolean;\n}\n\nexport enum PendingEventOrdering {\n    Chronological = \"chronological\",\n    Detached = \"detached\",\n}\n\nexport interface IStartClientOpts {\n    /**\n     * The event `limit=` to apply to initial sync. Default: 8.\n     */\n    initialSyncLimit?: number;\n\n    /**\n     * True to put `archived=true</code> on the <code>/initialSync` request. Default: false.\n     */\n    includeArchivedRooms?: boolean;\n\n    /**\n     * True to do /profile requests on every invite event if the displayname/avatar_url is not known for this user ID. Default: false.\n     */\n    resolveInvitesToProfiles?: boolean;\n\n    /**\n     * Controls where pending messages appear in a room's timeline. If \"<b>chronological</b>\", messages will\n     * appear in the timeline when the call to `sendEvent` was made. If \"<b>detached</b>\",\n     * pending messages will appear in a separate list, accessible via {@link Room#getPendingEvents}.\n     * Default: \"chronological\".\n     */\n    pendingEventOrdering?: PendingEventOrdering;\n\n    /**\n     * The number of milliseconds to wait on /sync. Default: 30000 (30 seconds).\n     */\n    pollTimeout?: number;\n\n    /**\n     * The filter to apply to /sync calls.\n     */\n    filter?: Filter;\n\n    /**\n     * True to perform syncing without automatically updating presence.\n     */\n    disablePresence?: boolean;\n\n    /**\n     * True to not load all membership events during initial sync but fetch them when needed by calling\n     * `loadOutOfBandMembers` This will override the filter option at this moment.\n     */\n    lazyLoadMembers?: boolean;\n\n    /**\n     * The number of seconds between polls to /.well-known/matrix/client, undefined to disable.\n     * This should be in the order of hours. Default: undefined.\n     */\n    clientWellKnownPollPeriod?: number;\n\n    /**\n     * Will organises events in threaded conversations when\n     * a thread relation is encountered\n     */\n    threadSupport?: boolean;\n\n    /**\n     * @experimental\n     */\n    slidingSync?: SlidingSync;\n}\n\nexport interface IStoredClientOpts extends IStartClientOpts {}\n\nexport const GET_LOGIN_TOKEN_CAPABILITY = new NamespacedValue(\n    \"m.get_login_token\",\n    \"org.matrix.msc3882.get_login_token\",\n);\n\nexport const UNSTABLE_MSC2666_SHARED_ROOMS = \"uk.half-shot.msc2666\";\nexport const UNSTABLE_MSC2666_MUTUAL_ROOMS = \"uk.half-shot.msc2666.mutual_rooms\";\nexport const UNSTABLE_MSC2666_QUERY_MUTUAL_ROOMS = \"uk.half-shot.msc2666.query_mutual_rooms\";\n\nexport const UNSTABLE_MSC4140_DELAYED_EVENTS = \"org.matrix.msc4140\";\nexport const UNSTABLE_MSC4354_STICKY_EVENTS = \"org.matrix.msc4354\";\n\nexport const UNSTABLE_MSC4133_EXTENDED_PROFILES = \"uk.tcpip.msc4133\";\nexport const STABLE_MSC4133_EXTENDED_PROFILES = \"uk.tcpip.msc4133.stable\";\n\nenum CrossSigningKeyType {\n    MasterKey = \"master_key\",\n    SelfSigningKey = \"self_signing_key\",\n    UserSigningKey = \"user_signing_key\",\n}\n\nexport type CrossSigningKeys = Record<CrossSigningKeyType, CrossSigningKeyInfo>;\n\nexport type SendToDeviceContentMap = Map<string, Map<string, Record<string, any>>>;\n\nexport interface ISignedKey {\n    keys: Record<string, string>;\n    signatures: ISignatures;\n    user_id: string;\n    algorithms: string[];\n    device_id: string;\n}\n\nexport type KeySignatures = Record<string, Record<string, CrossSigningKeyInfo | ISignedKey>>;\nexport interface IUploadKeySignaturesResponse {\n    failures: Record<\n        string,\n        Record<\n            string,\n            {\n                errcode: string;\n                error: string;\n            }\n        >\n    >;\n}\n\nexport interface IPreviewUrlResponse {\n    [key: string]: undefined | string | number;\n    \"og:title\": string;\n    \"og:type\": string;\n    \"og:url\": string;\n    \"og:image\"?: string;\n    \"og:image:type\"?: string;\n    \"og:image:height\"?: number;\n    \"og:image:width\"?: number;\n    \"og:description\"?: string;\n    \"matrix:image:size\"?: number;\n}\n\nexport interface ITurnServerResponse {\n    uris: string[];\n    username: string;\n    password: string;\n    ttl: number;\n}\n\nexport interface ITurnServer {\n    urls: string[];\n    username: string;\n    credential: string;\n}\n\nexport interface IServerVersions {\n    versions: string[];\n    unstable_features: Record<string, boolean>;\n}\n\nexport interface IClientWellKnown {\n    [key: string]: any;\n    \"m.homeserver\"?: IWellKnownConfig;\n    \"m.identity_server\"?: IWellKnownConfig;\n}\n\nexport interface IWellKnownConfig<T = IClientWellKnown> {\n    raw?: T;\n    action?: AutoDiscoveryAction;\n    reason?: string;\n    error?: Error | string;\n    // eslint-disable-next-line\n    base_url?: string | null;\n    // XXX: this is undocumented\n    server_name?: string;\n}\n\ninterface IKeyBackupPath {\n    path: string;\n    queryData?: {\n        version: string;\n    };\n}\n\ninterface IMediaConfig {\n    [key: string]: any; // extensible\n    \"m.upload.size\"?: number;\n}\n\ninterface IThirdPartySigned {\n    sender: string;\n    mxid: string;\n    token: string;\n    signatures: ISignatures;\n}\n\ninterface IJoinRequestBody {\n    third_party_signed?: IThirdPartySigned;\n}\n\ninterface ITagMetadata {\n    [key: string]: any;\n    order?: number;\n}\n\ninterface IMessagesResponse {\n    start?: string;\n    end?: string;\n    chunk: IRoomEvent[];\n    state?: IStateEvent[];\n}\n\ninterface IThreadedMessagesResponse {\n    prev_batch: string;\n    next_batch: string;\n    chunk: IRoomEvent[];\n    state: IStateEvent[];\n}\n\nexport interface IRequestTokenResponse {\n    sid: string;\n    submit_url?: string;\n}\n\nexport interface IRequestMsisdnTokenResponse extends IRequestTokenResponse {\n    msisdn: string;\n    success: boolean;\n    intl_fmt: string;\n}\n\nexport interface IUploadKeysRequest {\n    \"device_keys\"?: Required<IDeviceKeys>;\n    \"one_time_keys\"?: Record<string, IOneTimeKey>;\n    \"org.matrix.msc2732.fallback_keys\"?: Record<string, IOneTimeKey>;\n}\n\nexport interface IQueryKeysRequest {\n    device_keys: { [userId: string]: string[] };\n    timeout?: number;\n    token?: string;\n}\n\nexport interface IClaimKeysRequest {\n    one_time_keys: { [userId: string]: { [deviceId: string]: string } };\n    timeout?: number;\n}\n\nexport interface IOpenIDToken {\n    access_token: string;\n    token_type: \"Bearer\" | string;\n    matrix_server_name: string;\n    expires_in: number;\n}\n\ninterface IRoomInitialSyncResponse {\n    room_id: string;\n    membership: Membership;\n    messages?: {\n        start?: string;\n        end?: string;\n        chunk: IEventWithRoomId[];\n    };\n    state?: IStateEventWithRoomId[];\n    visibility: Visibility;\n    account_data?: IMinimalEvent[];\n    presence: Partial<IEvent>; // legacy and undocumented, api is deprecated so this won't get attention\n}\n\ninterface IJoinedRoomsResponse {\n    joined_rooms: string[];\n}\n\ninterface IJoinedMembersResponse {\n    joined: {\n        [userId: string]: {\n            display_name: string;\n            avatar_url: string;\n        };\n    };\n}\n\n// Re-export for backwards compatibility\nexport type IRegisterRequestParams = RegisterRequest;\n\nexport interface IPublicRoomsChunkRoom {\n    room_id: string;\n    name?: string;\n    avatar_url?: string;\n    topic?: string;\n    canonical_alias?: string;\n    aliases?: string[];\n    world_readable: boolean;\n    guest_can_join: boolean;\n    num_joined_members: number;\n    room_type?: RoomType | string; // Added by MSC3827\n    join_rule?: JoinRule.Knock | JoinRule.Public; // Added by MSC2403\n}\n\ninterface IPublicRoomsResponse {\n    chunk: IPublicRoomsChunkRoom[];\n    next_batch?: string;\n    prev_batch?: string;\n    total_room_count_estimate?: number;\n}\n\ninterface IUserDirectoryResponse {\n    results: {\n        user_id: string;\n        display_name?: string;\n        avatar_url?: string;\n    }[];\n    limited: boolean;\n}\n\nexport interface IMyDevice {\n    \"device_id\": string;\n    \"display_name\"?: string;\n    \"last_seen_ip\"?: string;\n    \"last_seen_ts\"?: number;\n    // UNSTABLE_MSC3852_LAST_SEEN_UA\n    \"last_seen_user_agent\"?: string;\n    \"org.matrix.msc3852.last_seen_user_agent\"?: string;\n}\n\nexport interface Keys {\n    keys: { [keyId: string]: string };\n    usage: string[];\n    user_id: string;\n}\n\nexport interface SigningKeys extends Keys {\n    signatures: ISignatures;\n}\n\nexport interface DeviceKeys {\n    [deviceId: string]: IDeviceKeys & {\n        unsigned?: {\n            device_display_name: string;\n        };\n    };\n}\n\nexport interface IDownloadKeyResult {\n    failures: { [serverName: string]: object };\n    device_keys: { [userId: string]: DeviceKeys };\n    // the following three fields were added in 1.1\n    master_keys?: { [userId: string]: Keys };\n    self_signing_keys?: { [userId: string]: SigningKeys };\n    user_signing_keys?: { [userId: string]: SigningKeys };\n}\n\nexport interface IClaimOTKsResult {\n    failures: { [serverName: string]: object };\n    one_time_keys: {\n        [userId: string]: {\n            [deviceId: string]: {\n                [keyId: string]: {\n                    key: string;\n                    signatures: ISignatures;\n                };\n            };\n        };\n    };\n}\n\nexport interface IFieldType {\n    regexp: string;\n    placeholder: string;\n}\n\nexport interface IInstance {\n    desc: string;\n    icon?: string;\n    fields: object;\n    network_id: string;\n    // XXX: this is undocumented but we rely on it: https://github.com/matrix-org/matrix-doc/issues/3203\n    instance_id: string;\n}\n\nexport interface IProtocol {\n    user_fields: string[];\n    location_fields: string[];\n    icon: string;\n    field_types: Record<string, IFieldType>;\n    instances: IInstance[];\n}\n\ninterface IThirdPartyLocation {\n    alias: string;\n    protocol: string;\n    fields: object;\n}\n\ninterface IThirdPartyUser {\n    userid: string;\n    protocol: string;\n    fields: object;\n}\n\n/**\n * The summary of a room as defined by an initial version of MSC3266 and implemented in Synapse\n * Proposed at https://github.com/matrix-org/matrix-doc/pull/3266\n */\nexport interface RoomSummary extends Omit<IPublicRoomsChunkRoom, \"canonical_alias\" | \"aliases\"> {\n    /**\n     * The current membership of this user in the room.\n     * Usually \"leave\" if the room is fetched over federation.\n     */\n    \"membership\"?: Membership;\n    /**\n     * Version of the room.\n     */\n    \"im.nheko.summary.room_version\"?: string;\n    /**\n     * The encryption algorithm used for this room, if the room is encrypted.\n     */\n    \"im.nheko.summary.encryption\"?: string;\n}\n\ninterface IRoomHierarchy {\n    rooms: IHierarchyRoom[];\n    next_batch?: string;\n}\n\nexport interface TimestampToEventResponse {\n    event_id: string;\n    origin_server_ts: number;\n}\n\ninterface IWhoamiResponse {\n    user_id: string;\n    device_id?: string;\n    is_guest?: boolean;\n}\n/* eslint-enable camelcase */\n\n// We're using this constant for methods overloading and inspect whether a variable\n// contains an eventId or not. This was required to ensure backwards compatibility\n// of methods for threads\n// Probably not the most graceful solution but does a good enough job for now\nconst EVENT_ID_PREFIX = \"$\";\n\nexport enum ClientEvent {\n    /**\n     * Fires whenever the SDK's syncing state is updated. The state can be one of:\n     * <ul>\n     *\n     * <li>PREPARED: The client has synced with the server at least once and is\n     * ready for methods to be called on it. This will be immediately followed by\n     * a state of SYNCING. <i>This is the equivalent of \"syncComplete\" in the\n     * previous API.</i></li>\n     *\n     * <li>CATCHUP: The client has detected the connection to the server might be\n     * available again and will now try to do a sync again. As this sync might take\n     * a long time (depending how long ago was last synced, and general server\n     * performance) the client is put in this mode so the UI can reflect trying\n     * to catch up with the server after losing connection.</li>\n     *\n     * <li>SYNCING : The client is currently polling for new events from the server.\n     * This will be called <i>after</i> processing latest events from a sync.</li>\n     *\n     * <li>ERROR : The client has had a problem syncing with the server. If this is\n     * called <i>before</i> PREPARED then there was a problem performing the initial\n     * sync. If this is called <i>after</i> PREPARED then there was a problem polling\n     * the server for updates. This may be called multiple times even if the state is\n     * already ERROR. <i>This is the equivalent of \"syncError\" in the previous\n     * API.</i></li>\n     *\n     * <li>RECONNECTING: The sync connection has dropped, but not (yet) in a way that\n     * should be considered erroneous.\n     * </li>\n     *\n     * <li>STOPPED: The client has stopped syncing with server due to stopClient\n     * being called.\n     * </li>\n     * </ul>\n     * State transition diagram:\n     * ```\n     *                                          +---->STOPPED\n     *                                          |\n     *              +----->PREPARED -------> SYNCING <--+\n     *              |                        ^  |  ^    |\n     *              |      CATCHUP ----------+  |  |    |\n     *              |        ^                  V  |    |\n     *   null ------+        |  +------- RECONNECTING   |\n     *              |        V  V                       |\n     *              +------->ERROR ---------------------+\n     *\n     * NB: 'null' will never be emitted by this event.\n     *\n     * ```\n     * Transitions:\n     * <ul>\n     *\n     * <li>`null -> PREPARED` : Occurs when the initial sync is completed\n     * first time. This involves setting up filters and obtaining push rules.\n     *\n     * <li>`null -> ERROR` : Occurs when the initial sync failed first time.\n     *\n     * <li>`ERROR -> PREPARED` : Occurs when the initial sync succeeds\n     * after previously failing.\n     *\n     * <li>`PREPARED -> SYNCING` : Occurs immediately after transitioning\n     * to PREPARED. Starts listening for live updates rather than catching up.\n     *\n     * <li>`SYNCING -> RECONNECTING` : Occurs when the live update fails.\n     *\n     * <li>`RECONNECTING -> RECONNECTING` : Can occur if the update calls\n     * continue to fail, but the keepalive calls (to /versions) succeed.\n     *\n     * <li>`RECONNECTING -> ERROR` : Occurs when the keepalive call also fails\n     *\n     * <li>`ERROR -> SYNCING` : Occurs when the client has performed a\n     * live update after having previously failed.\n     *\n     * <li>`ERROR -> ERROR` : Occurs when the client has failed to keepalive\n     * for a second time or more.</li>\n     *\n     * <li>`SYNCING -> SYNCING` : Occurs when the client has performed a live\n     * update. This is called <i>after</i> processing.</li>\n     *\n     * <li>`* -> STOPPED` : Occurs once the client has stopped syncing or\n     * trying to sync after stopClient has been called.</li>\n     * </ul>\n     *\n     * The payloads consits of the following 3 parameters:\n     *\n     * - state - An enum representing the syncing state. One of \"PREPARED\",\n     * \"SYNCING\", \"ERROR\", \"STOPPED\".\n     *\n     * - prevState - An enum representing the previous syncing state.\n     * One of \"PREPARED\", \"SYNCING\", \"ERROR\", \"STOPPED\" <b>or null</b>.\n     *\n     * - data - Data about this transition.\n     *\n     * @example\n     * ```\n     * matrixClient.on(\"sync\", function(state, prevState, data) {\n     *   switch (state) {\n     *     case \"ERROR\":\n     *       // update UI to say \"Connection Lost\"\n     *       break;\n     *     case \"SYNCING\":\n     *       // update UI to remove any \"Connection Lost\" message\n     *       break;\n     *     case \"PREPARED\":\n     *       // the client instance is ready to be queried.\n     *       var rooms = matrixClient.getRooms();\n     *       break;\n     *   }\n     * });\n     * ```\n     */\n    Sync = \"sync\",\n    /**\n     * Fires whenever the SDK receives a new event.\n     * <p>\n     * This is only fired for live events received via /sync - it is not fired for\n     * events received over context, search, or pagination APIs.\n     *\n     * The payload is the matrix event which caused this event to fire.\n     * @example\n     * ```\n     * matrixClient.on(\"event\", function(event){\n     *   var sender = event.getSender();\n     * });\n     * ```\n     */\n    Event = \"event\",\n    /** @deprecated Use {@link ReceivedToDeviceMessage}.\n     * Fires whenever the SDK receives a new to-device event.\n     * The payload is the matrix event ({@link MatrixEvent}) which caused this event to fire.\n     * @example\n     * ```\n     * matrixClient.on(\"toDeviceEvent\", function(event){\n     *   var sender = event.getSender();\n     * });\n     * ```\n     */\n    ToDeviceEvent = \"toDeviceEvent\",\n    /**\n     * Fires whenever the SDK receives a new (potentially decrypted) to-device message.\n     * The payload is the to-device message and the encryption info for that message ({@link ReceivedToDeviceMessage}).\n     * @example\n     * ```\n     * matrixClient.on(\"receivedToDeviceMessage\", function(payload){\n     *   const { message, encryptionInfo } = payload;\n     *   var claimed_sender = encryptionInfo ? encryptionInfo.sender : message.sender;\n     *   var isVerified = encryptionInfo ? encryptionInfo.verified : false;\n     *   var type = message.type;\n     * });\n     */\n    ReceivedToDeviceMessage = \"receivedToDeviceMessage\",\n    /**\n     * Fires whenever new user-scoped account_data is added.\n     * The payload is a pair of event ({@link MatrixEvent}) describing the account_data just added, and the previous event, if known:\n     *  - event: The event describing the account_data just added\n     *  - oldEvent: The previous account data, if known.\n     * @example\n     * ```\n     * matrixClient.on(\"accountData\", function(event, oldEvent){\n     *   myAccountData[event.type] = event.content;\n     * });\n     * ```\n     */\n    AccountData = \"accountData\",\n    /**\n     * Fires whenever a new Room is added. This will fire when you are invited to a\n     * room, as well as when you join a room. <strong>This event is experimental and\n     * may change.</strong>\n     *\n     * The payload is the newly created room, fully populated.\n     * @example\n     * ```\n     * matrixClient.on(\"Room\", function(room){\n     *   var roomId = room.roomId;\n     * });\n     * ```\n     */\n    Room = \"Room\",\n    /**\n     * Fires whenever a Room is removed. This will fire when you forget a room.\n     * <strong>This event is experimental and may change.</strong>\n     * The payload is the roomId of the deleted room.\n     * @example\n     * ```\n     * matrixClient.on(\"deleteRoom\", function(roomId){\n     *   // update UI from getRooms()\n     * });\n     * ```\n     */\n    DeleteRoom = \"deleteRoom\",\n    SyncUnexpectedError = \"sync.unexpectedError\",\n    /**\n     * Fires when the client .well-known info is fetched.\n     * The payload is the JSON object (see {@link IClientWellKnown}) returned by the server\n     */\n    ClientWellKnown = \"WellKnown.client\",\n    ReceivedVoipEvent = \"received_voip_event\",\n    TurnServers = \"turnServers\",\n    TurnServersError = \"turnServers.error\",\n}\n\ntype RoomEvents =\n    | RoomEvent.Name\n    | RoomEvent.Redaction\n    | RoomEvent.RedactionCancelled\n    | RoomEvent.Receipt\n    | RoomEvent.Tags\n    | RoomEvent.LocalEchoUpdated\n    | RoomEvent.HistoryImportedWithinTimeline\n    | RoomEvent.AccountData\n    | RoomEvent.MyMembership\n    | RoomEvent.Timeline\n    | RoomEvent.TimelineReset;\n\ntype RoomStateEvents =\n    | RoomStateEvent.Events\n    | RoomStateEvent.Members\n    | RoomStateEvent.NewMember\n    | RoomStateEvent.Update\n    | RoomStateEvent.Marker;\n\ntype CryptoEvents = (typeof CryptoEvent)[keyof typeof CryptoEvent];\n\ntype MatrixEventEvents = MatrixEventEvent.Decrypted | MatrixEventEvent.Replaced | MatrixEventEvent.VisibilityChange;\n\ntype RoomMemberEvents =\n    | RoomMemberEvent.Name\n    | RoomMemberEvent.Typing\n    | RoomMemberEvent.PowerLevel\n    | RoomMemberEvent.Membership;\n\ntype UserEvents =\n    | UserEvent.AvatarUrl\n    | UserEvent.DisplayName\n    | UserEvent.Presence\n    | UserEvent.CurrentlyActive\n    | UserEvent.LastPresenceTs;\n\nexport type EmittedEvents =\n    | ClientEvent\n    | RoomEvents\n    | RoomStateEvents\n    | CryptoEvents\n    | MatrixEventEvents\n    | RoomMemberEvents\n    | UserEvents\n    | CallEvent // re-emitted by call.ts using Object.values\n    | CallEventHandlerEvent.Incoming\n    | GroupCallEventHandlerEvent.Incoming\n    | GroupCallEventHandlerEvent.Outgoing\n    | GroupCallEventHandlerEvent.Ended\n    | GroupCallEventHandlerEvent.Participants\n    | HttpApiEvent.SessionLoggedOut\n    | HttpApiEvent.NoConsent\n    | BeaconEvent;\n\nexport type ClientEventHandlerMap = {\n    [ClientEvent.Sync]: (state: SyncState, prevState: SyncState | null, data?: ISyncStateData) => void;\n    [ClientEvent.Event]: (event: MatrixEvent) => void;\n    [ClientEvent.ToDeviceEvent]: (event: MatrixEvent) => void;\n    [ClientEvent.ReceivedToDeviceMessage]: (payload: ReceivedToDeviceMessage) => void;\n    [ClientEvent.AccountData]: (event: MatrixEvent, lastEvent?: MatrixEvent) => void;\n    [ClientEvent.Room]: (room: Room) => void;\n    [ClientEvent.DeleteRoom]: (roomId: string) => void;\n    [ClientEvent.SyncUnexpectedError]: (error: Error) => void;\n    [ClientEvent.ClientWellKnown]: (data: IClientWellKnown) => void;\n    [ClientEvent.ReceivedVoipEvent]: (event: MatrixEvent) => void;\n    [ClientEvent.TurnServers]: (servers: ITurnServer[]) => void;\n    [ClientEvent.TurnServersError]: (error: Error, fatal: boolean) => void;\n} & RoomEventHandlerMap &\n    RoomStateEventHandlerMap &\n    CryptoEventHandlerMap &\n    MatrixEventHandlerMap &\n    RoomMemberEventHandlerMap &\n    UserEventHandlerMap &\n    CallEventHandlerEventHandlerMap &\n    GroupCallEventHandlerEventHandlerMap &\n    CallEventHandlerMap &\n    HttpApiEventHandlerMap &\n    BeaconEventHandlerMap;\n\nconst SSO_ACTION_PARAM = new UnstableValue(\"action\", \"org.matrix.msc3824.action\");\n\n/**\n * Represents a Matrix Client. Only directly construct this if you want to use\n * custom modules. Normally, {@link createClient} should be used\n * as it specifies 'sensible' defaults for these modules.\n */\nexport class MatrixClient extends TypedEventEmitter<EmittedEvents, ClientEventHandlerMap> {\n    public static readonly RESTORE_BACKUP_ERROR_BAD_KEY = \"RESTORE_BACKUP_ERROR_BAD_KEY\";\n\n    private readonly logger: Logger;\n\n    public reEmitter = new TypedReEmitter<EmittedEvents, ClientEventHandlerMap>(this);\n    public olmVersion: [number, number, number] | null = null; // populated after initLegacyCrypto\n    public usingExternalCrypto = false;\n    private _store!: Store;\n    public deviceId: string | null;\n    public credentials: { userId: string | null };\n\n    /**\n     * Encryption key used for encrypting sensitive data (such as e2ee keys) in storage.\n     *\n     * As supplied in the constructor via {@link IMatrixClientCreateOpts#pickleKey}.\n     * Used for migration from the legacy crypto to the rust crypto\n     */\n    private readonly legacyPickleKey?: string;\n\n    public scheduler?: MatrixScheduler;\n    public clientRunning = false;\n    public timelineSupport = false;\n    public urlPreviewCache: { [key: string]: Promise<IPreviewUrlResponse> } = {};\n    public identityServer?: IIdentityServerProvider;\n    public http: MatrixHttpApi<IHttpOpts & { onlyData: true }>; // XXX: Intended private, used in code.\n\n    private cryptoBackend?: CryptoBackend; // one of crypto or rustCrypto\n\n    /**\n     * Support MSC4362: Simplified Encrypted State Events.\n     *\n     * The client must be recreated for changes to this setting to take effect\n     * reliably.\n     *\n     * When this setting is true, if we find a state event that is encrypted\n     * (within a room that supports encrypted state), we will attempt to decrypt\n     * it as specified in MSC4362. If the user was in the room at the time an\n     * encrypted state event was received (meaning we have the key), even if\n     * this setting was set to false at the time it was received, recreating the\n     * client with this setting set to true will allow decrypting that event.\n     *\n     * When this setting is false, any state event that is encrypted will not be\n     * decrypted, meaning it will have no effect. This matched the behaviour of\n     * a client that does not support MSC4362.\n     */\n    public enableEncryptedStateEvents: boolean;\n\n    public cryptoCallbacks: CryptoCallbacks; // XXX: Intended private, used in code.\n    public callEventHandler?: CallEventHandler; // XXX: Intended private, used in code.\n    public groupCallEventHandler?: GroupCallEventHandler;\n    public supportsCallTransfer = false; // XXX: Intended private, used in code.\n    public forceTURN = false; // XXX: Intended private, used in code.\n    public iceCandidatePoolSize = 0; // XXX: Intended private, used in code.\n    public idBaseUrl?: string;\n    public baseUrl: string;\n    public readonly isVoipWithNoMediaAllowed;\n    public disableVoip: boolean;\n\n    public useLivekitForGroupCalls: boolean;\n\n    // Note: these are all `protected` to let downstream consumers make mistakes if they want to.\n    // We don't technically support this usage, but have reasons to do this.\n\n    protected canSupportVoip = false;\n    protected peekSync: SyncApi | null = null;\n    protected isGuestAccount = false;\n    protected ongoingScrollbacks: { [roomId: string]: { promise?: Promise<Room>; errorTs?: number } } = {};\n    protected notifTimelineSet: EventTimelineSet | null = null;\n\n    /**\n     * Legacy crypto store used for migration from the legacy crypto to the rust crypto\n     * @private\n     */\n    private readonly legacyCryptoStore?: CryptoStore;\n    protected verificationMethods?: string[];\n    protected fallbackICEServerAllowed = false;\n    protected syncApi?: SlidingSyncSdk | SyncApi;\n    public roomNameGenerator?: ICreateClientOpts[\"roomNameGenerator\"];\n    public pushRules?: IPushRules;\n    protected syncLeftRoomsPromise?: Promise<Room[]>;\n    protected syncedLeftRooms = false;\n    protected clientOpts?: IStoredClientOpts;\n    protected clientWellKnownIntervalID?: ReturnType<typeof setInterval>;\n    protected canResetTimelineCallback?: ResetTimelineCallback;\n\n    public canSupport = new Map<Feature, ServerSupport>();\n\n    // The pushprocessor caches useful things, so keep one and re-use it\n    public readonly pushProcessor = new PushProcessor(this);\n\n    // Promise to a response of the server's /versions response\n    // TODO: This should expire: https://github.com/matrix-org/matrix-js-sdk/issues/1020\n    protected serverVersionsPromise?: Promise<IServerVersions>;\n\n    protected clientWellKnown?: IClientWellKnown;\n    protected clientWellKnownPromise?: Promise<IClientWellKnown>;\n    protected turnServers: ITurnServer[] = [];\n    protected turnServersExpiry = 0;\n    protected checkTurnServersIntervalID?: ReturnType<typeof setInterval>;\n    protected txnCtr = 0;\n    protected mediaHandler = new MediaHandler(this);\n    protected sessionId: string;\n\n    /** IDs of events which are currently being encrypted.\n     *\n     * This is part of the cancellation mechanism: if the event is no longer listed here when encryption completes,\n     * that tells us that it has been cancelled, and we should not send it.\n     */\n    private eventsBeingEncrypted = new Set<string>();\n\n    private useE2eForGroupCall = true;\n    private toDeviceMessageQueue: ToDeviceMessageQueue;\n    public livekitServiceURL?: string;\n\n    private _secretStorage: ServerSideSecretStorageImpl;\n\n    // A manager for determining which invites should be ignored.\n    public readonly ignoredInvites: IgnoredInvites;\n\n    public readonly matrixRTC: MatrixRTCSessionManager;\n\n    private serverCapabilitiesService: ServerCapabilities;\n\n    public constructor(opts: IMatrixClientCreateOpts) {\n        super();\n\n        // If a custom logger is provided, use it. Otherwise, default to the global\n        // one in logger.ts.\n        this.logger = opts.logger ?? logger;\n\n        opts.baseUrl = utils.ensureNoTrailingSlash(opts.baseUrl);\n        opts.idBaseUrl = utils.ensureNoTrailingSlash(opts.idBaseUrl);\n\n        this.baseUrl = opts.baseUrl;\n        this.idBaseUrl = opts.idBaseUrl;\n        this.identityServer = opts.identityServer;\n\n        this.usingExternalCrypto = opts.usingExternalCrypto ?? false;\n        this.store = opts.store || new StubStore();\n        this.deviceId = opts.deviceId || null;\n        this.sessionId = secureRandomString(10);\n\n        const userId = opts.userId || null;\n        this.credentials = { userId };\n\n        this.http = new MatrixHttpApi(this as ConstructorParameters<typeof MatrixHttpApi>[0], {\n            fetchFn: opts.fetchFn,\n            baseUrl: opts.baseUrl,\n            idBaseUrl: opts.idBaseUrl,\n            accessToken: opts.accessToken,\n            refreshToken: opts.refreshToken,\n            tokenRefreshFunction: opts.tokenRefreshFunction,\n            prefix: ClientPrefix.V3,\n            onlyData: true,\n            extraParams: opts.queryParams,\n            localTimeoutMs: opts.localTimeoutMs,\n            useAuthorizationHeader: opts.useAuthorizationHeader,\n            logger: this.logger,\n        });\n\n        if (opts.pickleKey) {\n            this.legacyPickleKey = opts.pickleKey;\n        }\n\n        this.useLivekitForGroupCalls = Boolean(opts.useLivekitForGroupCalls);\n\n        this.scheduler = opts.scheduler;\n        if (this.scheduler) {\n            this.scheduler.setProcessFunction(async (eventToSend: MatrixEvent) => {\n                const room = this.getRoom(eventToSend.getRoomId());\n                if (eventToSend.status !== EventStatus.SENDING) {\n                    this.updatePendingEventStatus(room, eventToSend, EventStatus.SENDING);\n                }\n                const res = await this.sendEventHttpRequest(eventToSend);\n                if (room) {\n                    // ensure we update pending event before the next scheduler run so that any listeners to event id\n                    // updates on the synchronous event emitter get a chance to run first.\n                    room.updatePendingEvent(eventToSend, EventStatus.SENT, res.event_id);\n                }\n                return res;\n            });\n        }\n\n        this.disableVoip = opts.disableVoip ?? false;\n\n        if (!this.disableVoip && supportsMatrixCall()) {\n            this.callEventHandler = new CallEventHandler(this);\n            this.groupCallEventHandler = new GroupCallEventHandler(this);\n            this.canSupportVoip = true;\n            // Start listening for calls after the initial sync is done\n            // We do not need to backfill the call event buffer\n            // with encrypted events that might never get decrypted\n            this.on(ClientEvent.Sync, this.startCallEventHandler);\n        }\n\n        // NB. We initialise MatrixRTC whether we have call support or not: this is just\n        // the underlying session management and doesn't use any actual media capabilities\n        this.matrixRTC = new MatrixRTCSessionManager(this.logger, this);\n\n        this.serverCapabilitiesService = new ServerCapabilities(this.logger, this.http);\n\n        this.on(ClientEvent.Sync, this.fixupRoomNotifications);\n\n        this.timelineSupport = Boolean(opts.timelineSupport);\n\n        this.legacyCryptoStore = opts.cryptoStore;\n        this.verificationMethods = opts.verificationMethods;\n        this.cryptoCallbacks = opts.cryptoCallbacks || {};\n        this.enableEncryptedStateEvents = opts.enableEncryptedStateEvents ?? false;\n\n        this.forceTURN = opts.forceTURN || false;\n        this.iceCandidatePoolSize = opts.iceCandidatePoolSize === undefined ? 0 : opts.iceCandidatePoolSize;\n        this.supportsCallTransfer = opts.supportsCallTransfer || false;\n        this.fallbackICEServerAllowed = opts.fallbackICEServerAllowed || false;\n        this.isVoipWithNoMediaAllowed = opts.isVoipWithNoMediaAllowed || false;\n\n        if (opts.useE2eForGroupCall !== undefined) this.useE2eForGroupCall = opts.useE2eForGroupCall;\n\n        this.livekitServiceURL = opts.livekitServiceURL;\n\n        this.roomNameGenerator = opts.roomNameGenerator;\n\n        this.toDeviceMessageQueue = new ToDeviceMessageQueue(this, this.logger);\n\n        // The SDK doesn't really provide a clean way for events to recalculate the push\n        // actions for themselves, so we have to kinda help them out when they are encrypted.\n        // We do this so that push rules are correctly executed on events in their decrypted\n        // state, such as highlights when the user's name is mentioned.\n        this.on(MatrixEventEvent.Decrypted, (event) => {\n            fixNotificationCountOnDecryption(this, event);\n        });\n\n        this.ignoredInvites = new IgnoredInvites(this);\n        this._secretStorage = new ServerSideSecretStorageImpl(this, opts.cryptoCallbacks ?? {});\n\n        // having lots of event listeners is not unusual. 0 means \"unlimited\".\n        this.setMaxListeners(0);\n    }\n\n    public set store(newStore: Store) {\n        this._store = newStore;\n        this._store.setUserCreator((userId) => User.createUser(userId, this));\n    }\n\n    public get store(): Store {\n        return this._store;\n    }\n\n    /**\n     * High level helper method to begin syncing and poll for new events. To listen for these\n     * events, add a listener for {@link ClientEvent.Event}\n     * via {@link MatrixClient#on}. Alternatively, listen for specific\n     * state change events.\n     * @param opts - Options to apply when syncing.\n     */\n    public async startClient(opts?: IStartClientOpts): Promise<void> {\n        if (this.clientRunning) {\n            // client is already running.\n            return;\n        }\n        this.clientRunning = true;\n\n        this.on(ClientEvent.Sync, this.startMatrixRTC);\n\n        // Create our own user object artificially (instead of waiting for sync)\n        // so it's always available, even if the user is not in any rooms etc.\n        const userId = this.getUserId();\n        if (userId) {\n            this.store.storeUser(new User(userId));\n        }\n\n        // periodically poll for turn servers if we support voip\n        if (this.supportsVoip()) {\n            this.checkTurnServersIntervalID = setInterval(() => {\n                this.checkTurnServers();\n            }, TURN_CHECK_INTERVAL);\n            // noinspection ES6MissingAwait\n            this.checkTurnServers();\n        }\n\n        if (this.syncApi) {\n            // This shouldn't happen since we thought the client was not running\n            this.logger.error(\"Still have sync object whilst not running: stopping old one\");\n            this.syncApi.stop();\n        }\n\n        try {\n            await this.getVersions();\n\n            // This should be done with `canSupport`\n            // TODO: https://github.com/vector-im/element-web/issues/23643\n            const { threads, list, fwdPagination } = await this.doesServerSupportThread();\n            Thread.setServerSideSupport(threads);\n            Thread.setServerSideListSupport(list);\n            Thread.setServerSideFwdPaginationSupport(fwdPagination);\n        } catch (e) {\n            this.logger.error(\n                \"Can't fetch server versions, continuing to initialise sync, this will be retried later\",\n                e,\n            );\n        }\n\n        this.clientOpts = opts ?? {};\n        if (this.clientOpts.slidingSync) {\n            this.syncApi = new SlidingSyncSdk(\n                this.clientOpts.slidingSync,\n                this,\n                this.clientOpts,\n                this.buildSyncApiOptions(),\n            );\n        } else {\n            this.syncApi = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n        }\n\n        this.syncApi.sync().catch((e) => this.logger.info(\"Sync startup aborted with an error:\", e));\n\n        if (this.clientOpts.clientWellKnownPollPeriod !== undefined) {\n            this.clientWellKnownIntervalID = setInterval(() => {\n                this.fetchClientWellKnown();\n            }, 1000 * this.clientOpts.clientWellKnownPollPeriod);\n            this.fetchClientWellKnown();\n        }\n\n        this.toDeviceMessageQueue.start();\n        this.serverCapabilitiesService.start();\n    }\n\n    /**\n     * Construct a SyncApiOptions for this client, suitable for passing into the SyncApi constructor\n     */\n    protected buildSyncApiOptions(): SyncApiOptions {\n        return {\n            cryptoCallbacks: this.cryptoBackend,\n            canResetEntireTimeline: (roomId: string): boolean => {\n                if (!this.canResetTimelineCallback) {\n                    return false;\n                }\n                return this.canResetTimelineCallback(roomId);\n            },\n            logger: this.logger.getChild(\"sync\"),\n        };\n    }\n\n    /**\n     * High level helper method to stop the client from polling and allow a\n     * clean shutdown.\n     */\n    public stopClient(): void {\n        this.cryptoBackend?.stop(); // crypto might have been initialised even if the client wasn't fully started\n\n        this.off(ClientEvent.Sync, this.startMatrixRTC);\n\n        if (!this.clientRunning) return; // already stopped\n\n        this.logger.debug(\"stopping MatrixClient\");\n\n        this.clientRunning = false;\n\n        this.syncApi?.stop();\n        this.syncApi = undefined;\n\n        this.peekSync?.stopPeeking();\n\n        this.callEventHandler?.stop();\n        this.groupCallEventHandler?.stop();\n        this.callEventHandler = undefined;\n        this.groupCallEventHandler = undefined;\n\n        globalThis.clearInterval(this.checkTurnServersIntervalID);\n        this.checkTurnServersIntervalID = undefined;\n\n        if (this.clientWellKnownIntervalID !== undefined) {\n            globalThis.clearInterval(this.clientWellKnownIntervalID);\n        }\n\n        this.toDeviceMessageQueue.stop();\n\n        this.matrixRTC.stop();\n\n        this.serverCapabilitiesService.stop();\n    }\n\n    /**\n     * Clear any data out of the persistent stores used by the client.\n     *\n     * @param args.cryptoDatabasePrefix - The database name to use for indexeddb, defaults to 'matrix-js-sdk'.\n     * @returns Promise which resolves when the stores have been cleared.\n     */\n    public clearStores(\n        args: {\n            cryptoDatabasePrefix?: string;\n        } = {},\n    ): Promise<void> {\n        if (this.clientRunning) {\n            throw new Error(\"Cannot clear stores while client is running\");\n        }\n\n        const promises: Promise<void>[] = [];\n\n        promises.push(this.store.deleteAllData());\n        if (this.legacyCryptoStore) {\n            promises.push(this.legacyCryptoStore.deleteAllData());\n        }\n\n        // delete the stores used by the rust matrix-sdk-crypto, in case they were used\n        const deleteRustSdkStore = async (): Promise<void> => {\n            let indexedDB: IDBFactory;\n            try {\n                indexedDB = globalThis.indexedDB;\n                if (!indexedDB) return; // No indexedDB support\n            } catch {\n                // No indexedDB support\n                return;\n            }\n            for (const dbname of [\n                `${args.cryptoDatabasePrefix ?? RUST_SDK_STORE_PREFIX}::matrix-sdk-crypto`,\n                `${args.cryptoDatabasePrefix ?? RUST_SDK_STORE_PREFIX}::matrix-sdk-crypto-meta`,\n            ]) {\n                const prom = new Promise((resolve, reject) => {\n                    this.logger.info(`Removing IndexedDB instance ${dbname}`);\n                    const req = indexedDB.deleteDatabase(dbname);\n                    req.onsuccess = (_): void => {\n                        this.logger.info(`Removed IndexedDB instance ${dbname}`);\n                        resolve(0);\n                    };\n                    req.onerror = (e): void => {\n                        // In private browsing, Firefox has a globalThis.indexedDB, but attempts to delete an indexeddb\n                        // (even a non-existent one) fail with \"DOMException: A mutation operation was attempted on a\n                        // database that did not allow mutations.\"\n                        //\n                        // it seems like the only thing we can really do is ignore the error.\n                        this.logger.warn(`Failed to remove IndexedDB instance ${dbname}:`, e);\n                        resolve(0);\n                    };\n                    req.onblocked = (e): void => {\n                        this.logger.info(`cannot yet remove IndexedDB instance ${dbname}`);\n                    };\n                });\n                await prom;\n            }\n        };\n        promises.push(deleteRustSdkStore());\n\n        return Promise.all(promises).then(); // .then to fix types\n    }\n\n    /**\n     * Get the user-id of the logged-in user\n     *\n     * @returns MXID for the logged-in user, or null if not logged in\n     */\n    public getUserId(): string | null {\n        return this.credentials?.userId ?? null;\n    }\n\n    /**\n     * Get the user-id of the logged-in user\n     *\n     * @returns MXID for the logged-in user\n     * @throws Error if not logged in\n     */\n    public getSafeUserId(): string {\n        const userId = this.getUserId();\n        if (!userId) {\n            throw new Error(\"Expected logged in user but found none.\");\n        }\n        return userId;\n    }\n\n    /**\n     * Get the domain for this client's MXID\n     * @returns Domain of this MXID\n     */\n    public getDomain(): string | null {\n        if (this.credentials?.userId) {\n            return this.credentials.userId.replace(/^.*?:/, \"\");\n        }\n        return null;\n    }\n\n    /**\n     * Get the local part of the current user ID e.g. \"foo\" in \"\\@foo:bar\".\n     * @returns The user ID localpart or null.\n     */\n    public getUserIdLocalpart(): string | null {\n        return this.credentials?.userId?.split(\":\")[0].substring(1) ?? null;\n    }\n\n    /**\n     * Get the device ID of this client\n     * @returns device ID\n     */\n    public getDeviceId(): string | null {\n        return this.deviceId;\n    }\n\n    /**\n     * Get the session ID of this client\n     * @returns session ID\n     */\n    public getSessionId(): string {\n        return this.sessionId;\n    }\n\n    /**\n     * Check if the runtime environment supports VoIP calling.\n     * @returns True if VoIP is supported.\n     */\n    public supportsVoip(): boolean {\n        return !this.disableVoip && this.canSupportVoip;\n    }\n\n    /**\n     * @returns\n     */\n    public getMediaHandler(): MediaHandler {\n        return this.mediaHandler;\n    }\n\n    /**\n     * Set whether VoIP calls are forced to use only TURN\n     * candidates. This is the same as the forceTURN option\n     * when creating the client.\n     * @param force - True to force use of TURN servers\n     */\n    public setForceTURN(force: boolean): void {\n        this.forceTURN = force;\n    }\n\n    /**\n     * Set whether to advertise transfer support to other parties on Matrix calls.\n     * @param support - True to advertise the 'm.call.transferee' capability\n     */\n    public setSupportsCallTransfer(support: boolean): void {\n        this.supportsCallTransfer = support;\n    }\n\n    /**\n     * Returns true if to-device signalling for group calls will be encrypted with Olm.\n     * If false, it will be sent unencrypted.\n     * @returns boolean Whether group call signalling will be encrypted\n     */\n    public getUseE2eForGroupCall(): boolean {\n        return this.useE2eForGroupCall;\n    }\n\n    /**\n     * Creates a new call.\n     * The place*Call methods on the returned call can be used to actually place a call\n     *\n     * @param roomId - The room the call is to be placed in.\n     * @returns the call or null if the browser doesn't support calling.\n     */\n    public createCall(roomId: string): MatrixCall | null {\n        return createNewMatrixCall(this, roomId);\n    }\n\n    /**\n     * Creates a new group call and sends the associated state event\n     * to alert other members that the room now has a group call.\n     *\n     * @param roomId - The room the call is to be placed in.\n     */\n    public async createGroupCall(\n        roomId: string,\n        type: GroupCallType,\n        isPtt: boolean,\n        intent: GroupCallIntent,\n        dataChannelsEnabled?: boolean,\n        dataChannelOptions?: IGroupCallDataChannelOptions,\n    ): Promise<GroupCall> {\n        if (this.getGroupCallForRoom(roomId)) {\n            throw new Error(`${roomId} already has an existing group call`);\n        }\n\n        const room = this.getRoom(roomId);\n\n        if (!room) {\n            throw new Error(`Cannot find room ${roomId}`);\n        }\n\n        // Because without Media section a WebRTC connection is not possible, so need a RTCDataChannel to set up a\n        // no media WebRTC connection anyway.\n        return new GroupCall(\n            this,\n            room,\n            type,\n            isPtt,\n            intent,\n            undefined,\n            dataChannelsEnabled || this.isVoipWithNoMediaAllowed,\n            dataChannelOptions,\n            this.isVoipWithNoMediaAllowed,\n            this.useLivekitForGroupCalls,\n            this.livekitServiceURL,\n        ).create();\n    }\n\n    public getLivekitServiceURL(): string | undefined {\n        return this.livekitServiceURL;\n    }\n\n    // This shouldn't need to exist, but the widget API has startup ordering problems that\n    // mean it doesn't know the livekit URL fast enough: remove this once this is fixed.\n    public setLivekitServiceURL(newURL: string): void {\n        this.livekitServiceURL = newURL;\n    }\n\n    /**\n     * Wait until an initial state for the given room has been processed by the\n     * client and the client is aware of any ongoing group calls. Awaiting on\n     * the promise returned by this method before calling getGroupCallForRoom()\n     * avoids races where getGroupCallForRoom is called before the state for that\n     * room has been processed. It does not, however, fix other races, eg. two\n     * clients both creating a group call at the same time.\n     * @param roomId - The room ID to wait for\n     * @returns A promise that resolves once existing group calls in the room\n     *          have been processed.\n     */\n    public waitUntilRoomReadyForGroupCalls(roomId: string): Promise<void> {\n        return this.groupCallEventHandler!.waitUntilRoomReadyForGroupCalls(roomId);\n    }\n\n    /**\n     * Get an existing group call for the provided room.\n     * @returns The group call or null if it doesn't already exist.\n     */\n    public getGroupCallForRoom(roomId: string): GroupCall | null {\n        return this.groupCallEventHandler!.groupCalls.get(roomId) || null;\n    }\n\n    /**\n     * Get the current sync state.\n     * @returns the sync state, which may be null.\n     * @see MatrixClient#event:\"sync\"\n     */\n    public getSyncState(): SyncState | null {\n        return this.syncApi?.getSyncState() ?? null;\n    }\n\n    /**\n     * Returns the additional data object associated with\n     * the current sync state, or null if there is no\n     * such data.\n     * Sync errors, if available, are put in the 'error' key of\n     * this object.\n     */\n    public getSyncStateData(): ISyncStateData | null {\n        if (!this.syncApi) {\n            return null;\n        }\n        return this.syncApi.getSyncStateData();\n    }\n\n    /**\n     * Whether the initial sync has completed.\n     * @returns True if at least one sync has happened.\n     */\n    public isInitialSyncComplete(): boolean {\n        const state = this.getSyncState();\n        if (!state) {\n            return false;\n        }\n        return state === SyncState.Prepared || state === SyncState.Syncing;\n    }\n\n    /**\n     * Return whether the client is configured for a guest account.\n     * @returns True if this is a guest access_token (or no token is supplied).\n     */\n    public isGuest(): boolean {\n        return this.isGuestAccount;\n    }\n\n    /**\n     * Set whether this client is a guest account. <b>This method is experimental\n     * and may change without warning.</b>\n     * @param guest - True if this is a guest account.\n     * @experimental if the token is a macaroon, it should be encoded in it that it is a 'guest'\n     * access token, which means that the SDK can determine this entirely without\n     * the dev manually flipping this flag.\n     */\n    public setGuest(guest: boolean): void {\n        this.isGuestAccount = guest;\n    }\n\n    /**\n     * Return the provided scheduler, if any.\n     * @returns The scheduler or undefined\n     */\n    public getScheduler(): MatrixScheduler | undefined {\n        return this.scheduler;\n    }\n\n    /**\n     * Retry a backed off syncing request immediately. This should only be used when\n     * the user <b>explicitly</b> attempts to retry their lost connection.\n     * Will also retry any outbound to-device messages currently in the queue to be sent\n     * (retries of regular outgoing events are handled separately, per-event).\n     * @returns True if this resulted in a request being retried.\n     */\n    public retryImmediately(): boolean {\n        // don't await for this promise: we just want to kick it off\n        this.toDeviceMessageQueue.sendQueue();\n        return this.syncApi?.retryImmediately() ?? false;\n    }\n\n    /**\n     * Return the global notification EventTimelineSet, if any\n     *\n     * @returns the globl notification EventTimelineSet\n     */\n    public getNotifTimelineSet(): EventTimelineSet | null {\n        return this.notifTimelineSet;\n    }\n\n    /**\n     * Set the global notification EventTimelineSet\n     *\n     */\n    public setNotifTimelineSet(set: EventTimelineSet): void {\n        this.notifTimelineSet = set;\n    }\n\n    /**\n     * Gets the cached capabilities of the homeserver, returning cached ones if available.\n     * If there are no cached capabilities and none can be fetched, throw an exception.\n     *\n     * @returns Promise resolving with The capabilities of the homeserver\n     */\n    public async getCapabilities(): Promise<Capabilities> {\n        const caps = this.serverCapabilitiesService.getCachedCapabilities();\n        if (caps) return caps;\n        return this.serverCapabilitiesService.fetchCapabilities();\n    }\n\n    /**\n     * Gets the cached capabilities of the homeserver. If none have been fetched yet,\n     * return undefined.\n     *\n     * @returns The capabilities of the homeserver\n     */\n    public getCachedCapabilities(): Capabilities | undefined {\n        return this.serverCapabilitiesService.getCachedCapabilities();\n    }\n\n    /**\n     * Fetches the latest capabilities from the homeserver, ignoring any cached\n     * versions. The newly returned version is cached.\n     *\n     * @returns A promise which resolves to the capabilities of the homeserver\n     */\n    public fetchCapabilities(): Promise<Capabilities> {\n        return this.serverCapabilitiesService.fetchCapabilities();\n    }\n\n    /**\n     * Initialise support for end-to-end encryption in this client, using the rust matrix-sdk-crypto.\n     *\n     * **WARNING**: the cryptography stack is not thread-safe. Having multiple `MatrixClient` instances connected to\n     * the same Indexed DB will cause data corruption and decryption failures. The application layer is responsible for\n     * ensuring that only one `MatrixClient` issue is instantiated at a time.\n     *\n     * @param args.useIndexedDB - True to use an indexeddb store, false to use an in-memory store. Defaults to 'true'.\n     * @param args.cryptoDatabasePrefix - The database name to use for indexeddb, defaults to 'matrix-js-sdk'.\n     *    Unused if useIndexedDB is 'false'.\n     * @param args.storageKey - A key with which to encrypt the indexeddb store. If provided, it must be exactly\n     *    32 bytes of data, and must be the same each time the client is initialised for a given device.\n     *    If both this and `storagePassword` are unspecified, the store will be unencrypted.\n     * @param args.storagePassword - An alternative to `storageKey`. A password which will be used to derive a key to\n     *    encrypt the store with. Deriving a key from a password is (deliberately) a slow operation, so prefer\n     *    to pass a `storageKey` directly where possible.\n     *\n     * @returns a Promise which will resolve when the crypto layer has been\n     *    successfully initialised.\n     */\n    public async initRustCrypto(\n        args: {\n            useIndexedDB?: boolean;\n            cryptoDatabasePrefix?: string;\n            storageKey?: Uint8Array;\n            storagePassword?: string;\n        } = {},\n    ): Promise<void> {\n        if (this.cryptoBackend) {\n            this.logger.warn(\"Attempt to re-initialise e2e encryption on MatrixClient\");\n            return;\n        }\n\n        const userId = this.getUserId();\n        if (userId === null) {\n            throw new Error(\n                `Cannot enable encryption on MatrixClient with unknown userId: ` +\n                    `ensure userId is passed in createClient().`,\n            );\n        }\n        const deviceId = this.getDeviceId();\n        if (deviceId === null) {\n            throw new Error(\n                `Cannot enable encryption on MatrixClient with unknown deviceId: ` +\n                    `ensure deviceId is passed in createClient().`,\n            );\n        }\n\n        // importing rust-crypto will download the webassembly, so we delay it until we know it will be\n        // needed.\n        this.logger.debug(\"Downloading Rust crypto library\");\n        const RustCrypto = await import(\"./rust-crypto/index.ts\");\n\n        const rustCrypto = await RustCrypto.initRustCrypto({\n            logger: this.logger,\n            http: this.http,\n            userId: userId,\n            deviceId: deviceId,\n            secretStorage: this.secretStorage,\n            cryptoCallbacks: this.cryptoCallbacks,\n            storePrefix: args.useIndexedDB === false ? null : (args.cryptoDatabasePrefix ?? RUST_SDK_STORE_PREFIX),\n            storeKey: args.storageKey,\n            storePassphrase: args.storagePassword,\n\n            legacyCryptoStore: this.legacyCryptoStore,\n            legacyPickleKey: this.legacyPickleKey ?? \"DEFAULT_KEY\",\n            legacyMigrationProgressListener: (progress: number, total: number): void => {\n                this.emit(CryptoEvent.LegacyCryptoStoreMigrationProgress, progress, total);\n            },\n\n            enableEncryptedStateEvents: this.enableEncryptedStateEvents,\n        });\n\n        rustCrypto.setSupportedVerificationMethods(this.verificationMethods);\n\n        this.cryptoBackend = rustCrypto;\n\n        // attach the event listeners needed by RustCrypto\n        this.on(RoomMemberEvent.Membership, rustCrypto.onRoomMembership.bind(rustCrypto));\n        this.on(ClientEvent.Event, (event) => {\n            rustCrypto.onLiveEventFromSync(event);\n        });\n\n        // re-emit the events emitted by the crypto impl\n        this.reEmitter.reEmit(rustCrypto, [\n            CryptoEvent.VerificationRequestReceived,\n            CryptoEvent.UserTrustStatusChanged,\n            CryptoEvent.KeyBackupStatus,\n            CryptoEvent.KeyBackupSessionsRemaining,\n            CryptoEvent.KeyBackupFailed,\n            CryptoEvent.KeyBackupDecryptionKeyCached,\n            CryptoEvent.KeysChanged,\n            CryptoEvent.DevicesUpdated,\n            CryptoEvent.WillUpdateDevices,\n            CryptoEvent.DehydratedDeviceCreated,\n            CryptoEvent.DehydratedDeviceUploaded,\n            CryptoEvent.RehydrationStarted,\n            CryptoEvent.RehydrationProgress,\n            CryptoEvent.RehydrationCompleted,\n            CryptoEvent.RehydrationError,\n            CryptoEvent.DehydrationKeyCached,\n            CryptoEvent.DehydratedDeviceRotationError,\n        ]);\n    }\n\n    /**\n     * Access the server-side secret storage API for this client.\n     */\n    public get secretStorage(): ServerSideSecretStorage {\n        return this._secretStorage;\n    }\n\n    /**\n     * Access the crypto API for this client.\n     *\n     * If end-to-end encryption has been enabled for this client (via {@link initRustCrypto}),\n     * returns an object giving access to the crypto API. Otherwise, returns `undefined`.\n     */\n    public getCrypto(): CryptoApi | undefined {\n        return this.cryptoBackend;\n    }\n\n    /**\n     * Whether encryption is enabled for a room.\n     * @param roomId - the room id to query.\n     * @returns whether encryption is enabled.\n     *\n     * @deprecated Not correctly supported for Rust Cryptography. Use {@link CryptoApi.isEncryptionEnabledInRoom} and/or\n     *    {@link Room.hasEncryptionStateEvent}.\n     */\n    public isRoomEncrypted(roomId: string): boolean {\n        const room = this.getRoom(roomId);\n        if (!room) {\n            // we don't know about this room, so can't determine if it should be\n            // encrypted. Let's assume not.\n            return false;\n        }\n\n        // if there is an 'm.room.encryption' event in this room, it should be\n        // encrypted (independently of whether we actually support encryption)\n        return room.hasEncryptionStateEvent();\n    }\n\n    /**\n     * Check whether the key backup private key is stored in secret storage.\n     * @returns map of key name to key info the secret is\n     *     encrypted with, or null if it is not present or not encrypted with a\n     *     trusted key\n     */\n    public isKeyBackupKeyStored(): Promise<Record<string, SecretStorageKeyDescription> | null> {\n        return Promise.resolve(this.secretStorage.isStored(\"m.megolm_backup.v1\"));\n    }\n\n    private makeKeyBackupPath(roomId?: string, sessionId?: string, version?: string): IKeyBackupPath {\n        let path: string;\n        if (sessionId !== undefined) {\n            path = utils.encodeUri(\"/room_keys/keys/$roomId/$sessionId\", {\n                $roomId: roomId!,\n                $sessionId: sessionId,\n            });\n        } else if (roomId !== undefined) {\n            path = utils.encodeUri(\"/room_keys/keys/$roomId\", {\n                $roomId: roomId,\n            });\n        } else {\n            path = \"/room_keys/keys\";\n        }\n        const queryData = version === undefined ? undefined : { version };\n        return { path, queryData };\n    }\n\n    public deleteKeysFromBackup(roomId: undefined, sessionId: undefined, version?: string): Promise<void>;\n    public deleteKeysFromBackup(roomId: string, sessionId: undefined, version?: string): Promise<void>;\n    public deleteKeysFromBackup(roomId: string, sessionId: string, version?: string): Promise<void>;\n    public async deleteKeysFromBackup(roomId?: string, sessionId?: string, version?: string): Promise<void> {\n        const path = this.makeKeyBackupPath(roomId!, sessionId!, version);\n        await this.http.authedRequest(Method.Delete, path.path, path.queryData, undefined, { prefix: ClientPrefix.V3 });\n    }\n\n    /**\n     * Get the config for the media repository.\n     *\n     * @param useAuthenticatedMedia - If true, the caller supports authenticated\n     * media and wants an authentication-required URL. Note that server support\n     * for authenticated media will *not* be checked - it is the caller's responsibility\n     * to do so before calling this function.\n     *\n     * @returns Promise which resolves with an object containing the config.\n     */\n    public getMediaConfig(useAuthenticatedMedia: boolean = false): Promise<IMediaConfig> {\n        const path = useAuthenticatedMedia ? \"/media/config\" : \"/config\";\n        return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n            prefix: useAuthenticatedMedia ? ClientPrefix.V1 : MediaPrefix.V3,\n        });\n    }\n\n    /**\n     * Get the room for the given room ID.\n     * This function will return a valid room for any room for which a Room event\n     * has been emitted. Note in particular that other events, eg. RoomState.members\n     * will be emitted for a room before this function will return the given room.\n     * @param roomId - The room ID\n     * @returns The Room or null if it doesn't exist or there is no data store.\n     */\n    public getRoom(roomId: string | undefined): Room | null {\n        if (!roomId) {\n            return null;\n        }\n        return this.store.getRoom(roomId);\n    }\n\n    /**\n     * Retrieve all known rooms.\n     * @returns A list of rooms, or an empty list if there is no data store.\n     */\n    public getRooms(): Room[] {\n        return this.store.getRooms();\n    }\n\n    /**\n     * Retrieve all rooms that should be displayed to the user\n     * This is essentially getRooms() with some rooms filtered out, eg. old versions\n     * of rooms that have been replaced or (in future) other rooms that have been\n     * marked at the protocol level as not to be displayed to the user.\n     *\n     * @param msc3946ProcessDynamicPredecessor - if true, look for an\n     *                                           m.room.predecessor state event and\n     *                                           use it if found (MSC3946).\n     * @returns A list of rooms, or an empty list if there is no data store.\n     */\n    public getVisibleRooms(msc3946ProcessDynamicPredecessor = false): Room[] {\n        const allRooms = this.store.getRooms();\n\n        const visibleRooms = new Set(allRooms);\n        for (const room of visibleRooms) {\n            const predecessors = this.findPredecessorRooms(room, true, msc3946ProcessDynamicPredecessor);\n            for (const predecessor of predecessors) {\n                visibleRooms.delete(predecessor);\n            }\n        }\n        return Array.from(visibleRooms);\n    }\n\n    /**\n     * Retrieve a user.\n     * @param userId - The user ID to retrieve.\n     * @returns A user or null if there is no data store or the user does\n     * not exist.\n     */\n    public getUser(userId: string): User | null {\n        return this.store.getUser(userId);\n    }\n\n    /**\n     * Retrieve all known users.\n     * @returns A list of users, or an empty list if there is no data store.\n     */\n    public getUsers(): User[] {\n        return this.store.getUsers();\n    }\n\n    /**\n     * Set account data event for the current user, and wait for the result to be echoed over `/sync`.\n     *\n     * Waiting for the remote echo ensures that a subsequent call to {@link getAccountData} will return the updated\n     * value.\n     *\n     * If called before the client is started with {@link startClient}, logs a warning and falls back to\n     * {@link setAccountDataRaw}.\n     *\n     * Retries the request up to 5 times in the case of an {@link ConnectionError}.\n     *\n     * @param eventType - The event type\n     * @param content - the contents object for the event\n     */\n    public async setAccountData<K extends keyof AccountDataEvents>(\n        eventType: K,\n        content: AccountDataEvents[K] | Record<string, never>,\n    ): Promise<EmptyObject> {\n        // If the sync loop is not running, fall back to setAccountDataRaw.\n        if (!this.clientRunning) {\n            this.logger.warn(\n                \"Calling `setAccountData` before the client is started: `getAccountData` may return inconsistent results.\",\n            );\n            return await retryNetworkOperation(5, () => this.setAccountDataRaw(eventType, content));\n        }\n\n        // If the account data is already correct, then we cannot expect an update over sync, and the operation\n        // is, in any case, a no-op.\n        //\n        // NB that we rely on this operation being synchronous to avoid a race condition: there must be no `await`\n        // between here and `this.addListener` below, in case we miss an update.\n        const existingData = this.store.getAccountData(eventType);\n        if (existingData && deepCompare(existingData.event.content, content)) return {};\n\n        // Create a promise which will resolve when the update is received\n        const updatedResolvers = Promise.withResolvers<void>();\n        function accountDataListener(event: MatrixEvent): void {\n            // Note that we cannot safely check that the content matches what we expected, because there is a race:\n            //   * We set the new content\n            //   * Another client sets alternative content\n            //   * Then /sync returns, but only reflects the latest content.\n            //\n            // Of course there is room for debate over what we should actually do in that case -- a subsequent\n            // `getAccountData` isn't going to return the expected value, but whose fault is that? Databases are hard.\n            //\n            // Anyway, what we *shouldn't* do is get stuck in a loop. I think the best we can do is check that the event\n            // type matches.\n            if (event.getType() === eventType) updatedResolvers.resolve();\n        }\n        this.addListener(ClientEvent.AccountData, accountDataListener);\n\n        try {\n            const result = await retryNetworkOperation(5, () => this.setAccountDataRaw(eventType, content));\n            await updatedResolvers.promise;\n            return result;\n        } finally {\n            this.removeListener(ClientEvent.AccountData, accountDataListener);\n        }\n    }\n\n    /**\n     * Set account data event for the current user, without waiting for the remote echo.\n     *\n     * @param eventType - The event type\n     * @param content - the contents object for the event\n     */\n    public setAccountDataRaw<K extends keyof AccountDataEvents>(\n        eventType: K,\n        content: AccountDataEvents[K] | Record<string, never>,\n    ): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n            $userId: this.credentials.userId!,\n            $type: eventType,\n        });\n\n        return this.http.authedRequest(Method.Put, path, undefined, content);\n    }\n\n    /**\n     * Get account data event of given type for the current user.\n     * @param eventType - The event type\n     * @returns The contents of the given account data event\n     */\n    public getAccountData<K extends keyof AccountDataEvents>(eventType: K): MatrixEvent | undefined {\n        return this.store.getAccountData(eventType);\n    }\n\n    /**\n     * Get account data event of given type for the current user. This variant\n     * gets account data directly from the homeserver if the local store is not\n     * ready, which can be useful very early in startup before the initial sync.\n     * @param eventType - The event type\n     * @returns Promise which resolves: The contents of the given account data event.\n     * @returns Rejects: with an error response.\n     */\n    public async getAccountDataFromServer<K extends keyof AccountDataEvents>(\n        eventType: K,\n    ): Promise<AccountDataEvents[K] | null> {\n        if (this.isInitialSyncComplete()) {\n            const event = this.store.getAccountData(eventType);\n            if (!event) {\n                return null;\n            }\n            // The network version below returns just the content, so this branch\n            // does the same to match.\n            return event.getContent<AccountDataEvents[K]>();\n        }\n        const path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n            $userId: this.credentials.userId!,\n            $type: eventType,\n        });\n        try {\n            return await this.http.authedRequest(Method.Get, path);\n        } catch (e) {\n            if ((<MatrixError>e).data?.errcode === \"M_NOT_FOUND\") {\n                return null;\n            }\n            throw e;\n        }\n    }\n\n    public async deleteAccountData(eventType: keyof AccountDataEvents): Promise<void> {\n        const msc3391DeleteAccountDataServerSupport = this.canSupport.get(Feature.AccountDataDeletion);\n        // if deletion is not supported overwrite with empty content\n        if (msc3391DeleteAccountDataServerSupport === ServerSupport.Unsupported) {\n            await this.setAccountData(eventType, {});\n            return;\n        }\n        const path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n            $userId: this.getSafeUserId(),\n            $type: eventType,\n        });\n        const options =\n            msc3391DeleteAccountDataServerSupport === ServerSupport.Unstable\n                ? { prefix: \"/_matrix/client/unstable/org.matrix.msc3391\" }\n                : undefined;\n        return await this.http.authedRequest(Method.Delete, path, undefined, undefined, options);\n    }\n\n    /**\n     * Gets the users that are ignored by this client\n     * @returns The array of users that are ignored (empty if none)\n     */\n    public getIgnoredUsers(): string[] {\n        const event = this.getAccountData(EventType.IgnoredUserList);\n        if (!event?.getContent()[\"ignored_users\"]) return [];\n        return Object.keys(event.getContent()[\"ignored_users\"]);\n    }\n\n    /**\n     * Sets the users that the current user should ignore.\n     * @param userIds - the user IDs to ignore\n     * @returns Promise which resolves: an empty object\n     * @returns Rejects: with an error response.\n     */\n    public setIgnoredUsers(userIds: string[]): Promise<EmptyObject> {\n        const content = { ignored_users: {} as Record<string, EmptyObject> };\n        userIds.forEach((u) => {\n            content.ignored_users[u] = {};\n        });\n        return this.setAccountData(EventType.IgnoredUserList, content);\n    }\n\n    /**\n     * Gets whether or not a specific user is being ignored by this client.\n     * @param userId - the user ID to check\n     * @returns true if the user is ignored, false otherwise\n     */\n    public isUserIgnored(userId: string): boolean {\n        return this.getIgnoredUsers().includes(userId);\n    }\n\n    /**\n     * Join a room. If you have already joined the room, this will no-op.\n     * @param roomIdOrAlias - The room ID or room alias to join.\n     * @param opts - Options when joining the room.\n     * @returns Promise which resolves: Room object.\n     * @returns Rejects: with an error response.\n     */\n    public async joinRoom(roomIdOrAlias: string, opts: IJoinRoomOpts = {}): Promise<Room> {\n        const room = this.getRoom(roomIdOrAlias);\n        const roomMember = room?.getMember(this.getSafeUserId());\n        const preJoinMembership = roomMember?.membership;\n\n        // If we were invited to the room, the ID of the user that sent the invite. Otherwise, `null`.\n        const inviter =\n            preJoinMembership == KnownMembership.Invite ? (roomMember?.events.member?.getSender() ?? null) : null;\n\n        this.logger.debug(\n            `joinRoom[${roomIdOrAlias}]: preJoinMembership=${preJoinMembership}, inviter=${inviter}, opts=${JSON.stringify(opts)}`,\n        );\n        if (preJoinMembership == KnownMembership.Join) return room!;\n\n        let signPromise: Promise<IThirdPartySigned | void> = Promise.resolve();\n\n        if (opts.inviteSignUrl) {\n            const url = new URL(opts.inviteSignUrl);\n            url.searchParams.set(\"mxid\", this.credentials.userId!);\n            signPromise = this.http.requestOtherUrl<IThirdPartySigned>(Method.Post, url);\n        }\n\n        const queryParams: QueryDict = {};\n        if (opts.viaServers) {\n            // server_name has been deprecated in favour of via with Matrix >1.11 (MSC4156)\n            // We only use the first 3 servers, to avoid URI length issues.\n            queryParams.via = queryParams.server_name = opts.viaServers.slice(0, 3);\n        }\n\n        const data: IJoinRequestBody = {};\n        const signedInviteObj = await signPromise;\n        if (signedInviteObj) {\n            data.third_party_signed = signedInviteObj;\n        }\n\n        const path = utils.encodeUri(\"/join/$roomid\", { $roomid: roomIdOrAlias });\n        const res = await this.http.authedRequest<{ room_id: string }>(Method.Post, path, queryParams, data);\n\n        const roomId = res.room_id;\n        if (opts.acceptSharedHistory && inviter && this.cryptoBackend) {\n            // Try to accept the room key bundle specified in a `m.room_key_bundle` to-device message we (might have) already received.\n            const bundleDownloaded = await this.cryptoBackend.maybeAcceptKeyBundle(roomId, inviter);\n            // If this fails, i.e. we haven't received this message yet, we need to wait until the to-device message arrives.\n            if (!bundleDownloaded) {\n                this.cryptoBackend.markRoomAsPendingKeyBundle(roomId, inviter);\n            }\n        }\n\n        // In case we were originally given an alias, check the room cache again\n        // with the resolved ID - this method is supposed to no-op if we already\n        // were in the room, after all.\n        const resolvedRoom = this.getRoom(roomId);\n        if (resolvedRoom?.hasMembershipState(this.credentials.userId!, KnownMembership.Join)) return resolvedRoom;\n\n        const syncApi = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n        return syncApi.createRoom(roomId);\n    }\n\n    /**\n     * Knock a room. If you have already knocked the room, this will no-op.\n     * @param roomIdOrAlias - The room ID or room alias to knock.\n     * @param opts - Options when knocking the room.\n     * @returns Promise which resolves: `{room_id: {string}}`\n     * @returns Rejects: with an error response.\n     */\n    public knockRoom(roomIdOrAlias: string, opts: KnockRoomOpts = {}): Promise<{ room_id: string }> {\n        const room = this.getRoom(roomIdOrAlias);\n        if (room?.hasMembershipState(this.credentials.userId!, KnownMembership.Knock)) {\n            return Promise.resolve({ room_id: room.roomId });\n        }\n\n        const path = utils.encodeUri(\"/knock/$roomIdOrAlias\", { $roomIdOrAlias: roomIdOrAlias });\n\n        const queryParams: QueryDict = {};\n        if (opts.viaServers) {\n            // We only use the first 3 servers, to avoid URI length issues.\n            const viaServers = Array.isArray(opts.viaServers) ? opts.viaServers.slice(0, 3) : [opts.viaServers];\n            // server_name has been deprecated in favour of via with Matrix >1.11 (MSC4156)\n            queryParams.server_name = viaServers;\n            queryParams.via = viaServers;\n        }\n\n        const body: Record<string, string> = {};\n        if (opts.reason) {\n            body.reason = opts.reason;\n        }\n\n        return this.http.authedRequest(Method.Post, path, queryParams, body);\n    }\n\n    /**\n     * Resend an event. Will also retry any to-device messages waiting to be sent.\n     * @param event - The event to resend.\n     * @param room - Optional. The room the event is in. Will update the\n     * timeline entry if provided.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public resendEvent(event: MatrixEvent, room: Room): Promise<ISendEventResponse> {\n        // also kick the to-device queue to retry\n        this.toDeviceMessageQueue.sendQueue();\n\n        this.updatePendingEventStatus(room, event, EventStatus.SENDING);\n        return this.encryptAndSendEvent(room, event);\n    }\n\n    /**\n     * Cancel a queued or unsent event.\n     *\n     * @param event -   Event to cancel\n     * @throws Error if the event is not in QUEUED, NOT_SENT or ENCRYPTING state\n     */\n    public cancelPendingEvent(event: MatrixEvent): void {\n        if (![EventStatus.QUEUED, EventStatus.NOT_SENT, EventStatus.ENCRYPTING].includes(event.status!)) {\n            throw new Error(\"cannot cancel an event with status \" + event.status);\n        }\n\n        // If the event is currently being encrypted then remove it from the pending list, to indicate that it should\n        // not be sent.\n        if (event.status === EventStatus.ENCRYPTING) {\n            this.eventsBeingEncrypted.delete(event.getId()!);\n        } else if (this.scheduler && event.status === EventStatus.QUEUED) {\n            // tell the scheduler to forget about it, if it's queued\n            this.scheduler.removeEventFromQueue(event);\n        }\n\n        // then tell the room about the change of state, which will remove it\n        // from the room's list of pending events.\n        const room = this.getRoom(event.getRoomId());\n        this.updatePendingEventStatus(room, event, EventStatus.CANCELLED);\n    }\n\n    /**\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public setRoomName(roomId: string, name: string): Promise<ISendEventResponse> {\n        return this.sendStateEvent(roomId, EventType.RoomName, { name: name });\n    }\n\n    /**\n     * @param roomId - The room to update the topic in.\n     * @param topic - The plaintext topic. May be empty to remove the topic.\n     * @param htmlTopic - Optional.\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public setRoomTopic(roomId: string, topic?: string, htmlTopic?: string): Promise<ISendEventResponse> {\n        const content = ContentHelpers.makeTopicContent(topic, htmlTopic);\n        return this.sendStateEvent(roomId, EventType.RoomTopic, content);\n    }\n\n    /**\n     * @returns Promise which resolves: to an object keyed by tagId with objects containing a numeric order field.\n     * @returns Rejects: with an error response.\n     */\n    public getRoomTags(roomId: string): Promise<ITagsResponse> {\n        const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags\", {\n            $userId: this.credentials.userId!,\n            $roomId: roomId,\n        });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * @param tagName - name of room tag to be set\n     * @param metadata - associated with that tag to be stored\n     * @returns Promise which resolves: to an empty object\n     * @returns Rejects: with an error response.\n     */\n    public setRoomTag(roomId: string, tagName: string, metadata: ITagMetadata = {}): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n            $userId: this.credentials.userId!,\n            $roomId: roomId,\n            $tag: tagName,\n        });\n        return this.http.authedRequest(Method.Put, path, undefined, metadata);\n    }\n\n    /**\n     * @param tagName - name of room tag to be removed\n     * @returns Promise which resolves: to an empty object\n     * @returns Rejects: with an error response.\n     */\n    public deleteRoomTag(roomId: string, tagName: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n            $userId: this.credentials.userId!,\n            $roomId: roomId,\n            $tag: tagName,\n        });\n        return this.http.authedRequest(Method.Delete, path);\n    }\n\n    /**\n     * @param eventType - event type to be set\n     * @param content - event content\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public setRoomAccountData(roomId: string, eventType: string, content: Record<string, any>): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/user/$userId/rooms/$roomId/account_data/$type\", {\n            $userId: this.credentials.userId!,\n            $roomId: roomId,\n            $type: eventType,\n        });\n        return this.http.authedRequest(Method.Put, path, undefined, content);\n    }\n\n    /**\n     * Set a power level to one or multiple users.\n     * Will apply changes atop of current power level event from local state if running & synced, falling back\n     * to fetching latest from the `/state/` API.\n     * @param roomId - the room to update power levels in\n     * @param userId - the ID of the user or users to update power levels of\n     * @param powerLevel - the numeric power level to update given users to\n     * @returns Promise which resolves: to an ISendEventResponse object\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public async setPowerLevel(\n        roomId: string,\n        userId: string | string[],\n        powerLevel: number | undefined,\n    ): Promise<ISendEventResponse> {\n        let content: IPowerLevelsContent | undefined;\n        if (this.clientRunning && this.isInitialSyncComplete()) {\n            content = this.getRoom(roomId)?.currentState?.getStateEvents(EventType.RoomPowerLevels, \"\")?.getContent();\n        }\n        if (!content) {\n            try {\n                content = await this.getStateEvent(roomId, EventType.RoomPowerLevels, \"\");\n            } catch (e) {\n                // It is possible for a Matrix room to not have a power levels event\n                if (e instanceof MatrixError && e.errcode === \"M_NOT_FOUND\") {\n                    content = {};\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // take a copy of the content to ensure we don't corrupt\n        // existing client state with a failed power level change\n        content = utils.deepCopy(content);\n\n        if (!content?.users) {\n            content.users = {};\n        }\n        const users = Array.isArray(userId) ? userId : [userId];\n        for (const user of users) {\n            if (powerLevel == null) {\n                delete content.users[user];\n            } else {\n                content.users[user] = powerLevel;\n            }\n        }\n\n        return this.sendStateEvent(roomId, EventType.RoomPowerLevels, content, \"\");\n    }\n\n    /**\n     * Create an m.beacon_info event\n     * @returns\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public async unstable_createLiveBeacon(\n        roomId: Room[\"roomId\"],\n        beaconInfoContent: MBeaconInfoEventContent,\n    ): Promise<ISendEventResponse> {\n        return this.unstable_setLiveBeacon(roomId, beaconInfoContent);\n    }\n\n    /**\n     * Upsert a live beacon event\n     * using a specific m.beacon_info.* event variable type\n     * @param roomId - string\n     * @returns\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public async unstable_setLiveBeacon(\n        roomId: string,\n        beaconInfoContent: MBeaconInfoEventContent,\n    ): Promise<ISendEventResponse> {\n        return this.sendStateEvent(roomId, M_BEACON_INFO.name, beaconInfoContent, this.getUserId()!);\n    }\n\n    /**\n     * Send a Matrix timeline event.\n     * @param roomId The room to send to.\n     * @param eventType The event type.\n     * @param content The event content.\n     * @param txnId An optional ID to deduplicate requests in case of repeated attempts.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendEvent<K extends keyof TimelineEvents>(\n        roomId: string,\n        eventType: K,\n        content: TimelineEvents[K],\n        txnId?: string,\n    ): Promise<ISendEventResponse>;\n    public sendEvent<K extends keyof TimelineEvents>(\n        roomId: string,\n        threadId: string | null,\n        eventType: K,\n        content: TimelineEvents[K],\n        txnId?: string,\n    ): Promise<ISendEventResponse>;\n    public sendEvent(\n        roomId: string,\n        threadIdOrEventType: string | null,\n        eventTypeOrContent: string | IContent,\n        contentOrTxnId?: IContent | string,\n        txnIdOrVoid?: string,\n    ): Promise<ISendEventResponse> {\n        let threadId: string | null;\n        let eventType: string;\n        let content: IContent;\n        let txnId: string | undefined;\n        if (!threadIdOrEventType?.startsWith(EVENT_ID_PREFIX) && threadIdOrEventType !== null) {\n            txnId = contentOrTxnId as string;\n            content = eventTypeOrContent as IContent;\n            eventType = threadIdOrEventType;\n            threadId = null;\n        } else {\n            txnId = txnIdOrVoid;\n            content = contentOrTxnId as IContent;\n            eventType = eventTypeOrContent as string;\n            threadId = threadIdOrEventType;\n        }\n\n        this.addThreadRelationIfNeeded(content, threadId, roomId);\n        return this.sendCompleteEvent({ roomId, threadId, eventObject: { type: eventType, content }, txnId });\n    }\n\n    /**\n     * If we expect that an event is part of a thread but is missing the relation\n     * we need to add it manually, as well as the reply fallback\n     */\n    private addThreadRelationIfNeeded(content: IContent, threadId: string | null, roomId: string): void {\n        if (threadId && !content[\"m.relates_to\"]?.rel_type) {\n            const isReply = !!content[\"m.relates_to\"]?.[\"m.in_reply_to\"];\n            content[\"m.relates_to\"] = {\n                ...content[\"m.relates_to\"],\n                rel_type: THREAD_RELATION_TYPE.name,\n                event_id: threadId,\n                // Set is_falling_back to true unless this is actually intended to be a reply\n                is_falling_back: !isReply,\n            };\n            const thread = this.getRoom(roomId)?.getThread(threadId);\n            if (thread && !isReply) {\n                content[\"m.relates_to\"][\"m.in_reply_to\"] = {\n                    event_id:\n                        thread\n                            .lastReply((ev: MatrixEvent) => {\n                                return ev.isRelation(THREAD_RELATION_TYPE.name) && !ev.status;\n                            })\n                            ?.getId() ?? threadId,\n                };\n            }\n        }\n    }\n\n    /**\n     * @param eventObject - An object with the partial structure of an event, to which event_id, user_id, room_id and origin_server_ts will be added.\n     * @param txnId - Optional.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    private sendCompleteEvent(params: {\n        roomId: string;\n        threadId: string | null;\n        eventObject: Partial<IEvent>;\n        queryDict?: QueryDict;\n        txnId?: string;\n    }): Promise<ISendEventResponse>;\n    /**\n     * Sends a delayed event (MSC4140).\n     * @param eventObject - An object with the partial structure of an event, to which event_id, user_id, room_id and origin_server_ts will be added.\n     * @param delayOpts - Properties of the delay for this event.\n     * @param txnId - Optional.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    private sendCompleteEvent(params: {\n        roomId: string;\n        threadId: string | null;\n        eventObject: Partial<IEvent>;\n        delayOpts: SendDelayedEventRequestOpts;\n        queryDict?: QueryDict;\n        txnId?: string;\n    }): Promise<SendDelayedEventResponse>;\n    private sendCompleteEvent({\n        roomId,\n        threadId,\n        eventObject,\n        delayOpts,\n        queryDict,\n        txnId,\n    }: {\n        roomId: string;\n        threadId: string | null;\n        eventObject: Partial<IEvent>;\n        delayOpts?: SendDelayedEventRequestOpts;\n        queryDict?: QueryDict;\n        txnId?: string;\n    }): Promise<SendDelayedEventResponse | ISendEventResponse> {\n        if (!txnId) {\n            txnId = this.makeTxnId();\n        }\n\n        // We always construct a MatrixEvent when sending because the store and scheduler use them.\n        // We'll extract the params back out if it turns out the client has no scheduler or store.\n        const localEvent = new MatrixEvent(\n            Object.assign(eventObject, {\n                event_id: \"~\" + roomId + \":\" + txnId,\n                user_id: this.credentials.userId,\n                sender: this.credentials.userId,\n                room_id: roomId,\n                origin_server_ts: new Date().getTime(),\n            }),\n        );\n\n        const room = this.getRoom(roomId);\n        const thread = threadId ? room?.getThread(threadId) : undefined;\n        if (thread) {\n            localEvent.setThread(thread);\n        }\n\n        if (!delayOpts) {\n            // set up re-emitter for this new event - this is normally the job of EventMapper but we don't use it here\n            this.reEmitter.reEmit(localEvent, [MatrixEventEvent.Replaced, MatrixEventEvent.VisibilityChange]);\n            room?.reEmitter.reEmit(localEvent, [MatrixEventEvent.BeforeRedaction]);\n        }\n\n        // if this is a relation or redaction of an event\n        // that hasn't been sent yet (e.g. with a local id starting with a ~)\n        // then listen for the remote echo of that event so that by the time\n        // this event does get sent, we have the correct event_id\n        const targetId = localEvent.getAssociatedId();\n        if (targetId?.startsWith(\"~\")) {\n            const target = room?.getPendingEvents().find((e) => e.getId() === targetId);\n            target?.once(MatrixEventEvent.LocalEventIdReplaced, () => {\n                localEvent.updateAssociatedId(target.getId()!);\n            });\n        }\n\n        const type = localEvent.getType();\n        this.logger.debug(\n            `sendEvent of type ${type} in ${roomId} with txnId ${txnId}${delayOpts ? \" (delayed event)\" : \"\"}${queryDict ? \" query params: \" + JSON.stringify(queryDict) : \"\"}`,\n        );\n\n        localEvent.setTxnId(txnId);\n        localEvent.setStatus(EventStatus.SENDING);\n\n        // TODO: separate store for delayed events?\n        if (!delayOpts) {\n            // add this event immediately to the local store as 'sending'.\n            room?.addPendingEvent(localEvent, txnId);\n\n            // addPendingEvent can change the state to NOT_SENT if it believes\n            // that there's other events that have failed. We won't bother to\n            // try sending the event if the state has changed as such.\n            if (localEvent.status === EventStatus.NOT_SENT) {\n                return Promise.reject(new Error(\"Event blocked by other events not yet sent\"));\n            }\n\n            return this.encryptAndSendEvent(room, localEvent, queryDict);\n        } else {\n            return this.encryptAndSendEvent(room, localEvent, delayOpts, queryDict);\n        }\n    }\n\n    /**\n     * encrypts the event if necessary; adds the event to the queue, or sends it; marks the event as sent/unsent\n     * @returns returns a promise which resolves with the result of the send request\n     */\n    protected async encryptAndSendEvent(\n        room: Room | null,\n        event: MatrixEvent,\n        queryDict?: QueryDict,\n    ): Promise<ISendEventResponse>;\n    /**\n     * Simply sends a delayed event without encrypting it.\n     * TODO: Allow encrypted delayed events, and encrypt them properly\n     * @param delayOpts - Properties of the delay for this event.\n     * @returns returns a promise which resolves with the result of the delayed send request\n     */\n    protected async encryptAndSendEvent(\n        room: Room | null,\n        event: MatrixEvent,\n        delayOpts: SendDelayedEventRequestOpts,\n        queryDict?: QueryDict,\n    ): Promise<ISendEventResponse>;\n    protected async encryptAndSendEvent(\n        room: Room | null,\n        event: MatrixEvent,\n        delayOptsOrQuery?: SendDelayedEventRequestOpts | QueryDict,\n        queryDict?: QueryDict,\n    ): Promise<ISendEventResponse | SendDelayedEventResponse> {\n        let queryOpts = queryDict;\n        if (delayOptsOrQuery && isSendDelayedEventRequestOpts(delayOptsOrQuery)) {\n            return this.sendEventHttpRequest(event, delayOptsOrQuery, queryOpts);\n        } else if (!queryOpts) {\n            queryOpts = delayOptsOrQuery;\n        }\n        try {\n            let cancelled: boolean;\n            this.eventsBeingEncrypted.add(event.getId()!);\n            try {\n                await this.encryptEventIfNeeded(event, room ?? undefined);\n            } finally {\n                cancelled = !this.eventsBeingEncrypted.delete(event.getId()!);\n            }\n\n            if (cancelled) {\n                // cancelled via MatrixClient::cancelPendingEvent\n                return {} as ISendEventResponse;\n            }\n\n            // encryptEventIfNeeded may have updated the status from SENDING to ENCRYPTING. If so, we need\n            // to put it back.\n            if (event.status === EventStatus.ENCRYPTING) {\n                this.updatePendingEventStatus(room, event, EventStatus.SENDING);\n            }\n\n            let promise: Promise<ISendEventResponse> | null = null;\n            if (this.scheduler) {\n                // if this returns a promise then the scheduler has control now and will\n                // resolve/reject when it is done. Internally, the scheduler will invoke\n                // processFn which is set to this._sendEventHttpRequest so the same code\n                // path is executed regardless.\n                promise = this.scheduler.queueEvent(event);\n                if (promise && this.scheduler.getQueueForEvent(event)!.length > 1) {\n                    // event is processed FIFO so if the length is 2 or more we know\n                    // this event is stuck behind an earlier event.\n                    this.updatePendingEventStatus(room, event, EventStatus.QUEUED);\n                }\n            }\n\n            if (!promise) {\n                promise = this.sendEventHttpRequest(event, queryOpts);\n                if (room) {\n                    promise = promise.then((res) => {\n                        room.updatePendingEvent(event, EventStatus.SENT, res[\"event_id\"]);\n                        return res;\n                    });\n                }\n            }\n\n            return await promise;\n        } catch (err) {\n            this.logger.error(\"Error sending event\", err);\n            try {\n                // set the error on the event before we update the status:\n                // updating the status emits the event, so the state should be\n                // consistent at that point.\n                event.error = <MatrixError>err;\n                this.updatePendingEventStatus(room, event, EventStatus.NOT_SENT);\n            } catch (e) {\n                this.logger.error(\"Exception in error handler!\", e);\n            }\n            if (err instanceof MatrixError) {\n                err.event = event;\n            }\n            throw err;\n        }\n    }\n\n    private async encryptEventIfNeeded(event: MatrixEvent, room?: Room): Promise<void> {\n        // If the room is unknown, we cannot encrypt for it\n        if (!room) return;\n\n        if (!(await this.shouldEncryptEventForRoom(event, room))) return;\n\n        if (!this.cryptoBackend && this.usingExternalCrypto) {\n            // The client has opted to allow sending messages to encrypted\n            // rooms even if the room is encrypted, and we haven't set up\n            // crypto. This is useful for users of matrix-org/pantalaimon\n            return;\n        }\n\n        if (!this.cryptoBackend) {\n            throw new Error(\"This room is configured to use encryption, but your client does not support encryption.\");\n        }\n\n        this.updatePendingEventStatus(room, event, EventStatus.ENCRYPTING);\n        await this.cryptoBackend.encryptEvent(event, room);\n    }\n\n    /**\n     * Determine whether a given event should be encrypted when we send it to the given room.\n     *\n     * This takes into account event type and room configuration.\n     */\n    private async shouldEncryptEventForRoom(event: MatrixEvent, room: Room): Promise<boolean> {\n        if (event.isEncrypted()) {\n            // this event has already been encrypted; this happens if the\n            // encryption step succeeded, but the send step failed on the first\n            // attempt.\n            return false;\n        }\n\n        if (event.getType() === EventType.Reaction) {\n            // For reactions, there is a very little gained by encrypting the entire\n            // event, as relation data is already kept in the clear. Event\n            // encryption for a reaction effectively only obscures the event type,\n            // but the purpose is still obvious from the relation data, so nothing\n            // is really gained. It also causes quite a few problems, such as:\n            //   * triggers notifications via default push rules\n            //   * prevents server-side bundling for reactions\n            // The reaction key / content / emoji value does warrant encrypting, but\n            // this will be handled separately by encrypting just this value.\n            // See https://github.com/matrix-org/matrix-doc/pull/1849#pullrequestreview-248763642\n            return false;\n        }\n\n        if (event.isRedaction()) {\n            // Redactions do not support encryption in the spec at this time.\n            // Whilst it mostly worked in some clients, it wasn't compliant.\n            return false;\n        }\n\n        // If the room has an m.room.encryption event, we should encrypt.\n        if (room.hasEncryptionStateEvent()) return true;\n\n        // If we have a crypto impl, and *it* thinks we should encrypt, then we should.\n        if (await this.cryptoBackend?.isEncryptionEnabledInRoom(room.roomId)) return true;\n\n        // Otherwise, no need to encrypt.\n        return false;\n    }\n\n    /**\n     * Returns the eventType that should be used taking encryption into account\n     * for a given eventType.\n     * @param roomId - the room for the events `eventType` relates to\n     * @param eventType - the event type\n     * @returns the event type taking encryption into account\n     */\n    private getEncryptedIfNeededEventType(\n        roomId: string,\n        eventType?: EventType | string | null,\n    ): EventType | string | null | undefined {\n        if (eventType === EventType.Reaction) return eventType;\n        return this.getRoom(roomId)?.hasEncryptionStateEvent() ? EventType.RoomMessageEncrypted : eventType;\n    }\n\n    protected updatePendingEventStatus(room: Room | null, event: MatrixEvent, newStatus: EventStatus): void {\n        if (room) {\n            room.updatePendingEvent(event, newStatus);\n        } else {\n            event.setStatus(newStatus);\n        }\n    }\n\n    private sendEventHttpRequest(event: MatrixEvent, queryDict?: QueryDict): Promise<ISendEventResponse>;\n    private sendEventHttpRequest(\n        event: MatrixEvent,\n        delayOpts: SendDelayedEventRequestOpts,\n        queryDict?: QueryDict,\n    ): Promise<SendDelayedEventResponse>;\n    private sendEventHttpRequest(\n        event: MatrixEvent,\n        queryOrDelayOpts?: SendDelayedEventRequestOpts | QueryDict,\n        queryDict?: QueryDict,\n    ): Promise<ISendEventResponse | SendDelayedEventResponse> {\n        let txnId = event.getTxnId();\n        if (!txnId) {\n            txnId = this.makeTxnId();\n            event.setTxnId(txnId);\n        }\n\n        const pathParams = {\n            $roomId: event.getRoomId()!,\n            $eventType: event.getWireType(),\n            $stateKey: event.getStateKey()!,\n            $txnId: txnId,\n        };\n\n        let path: string;\n\n        if (event.isState()) {\n            let pathTemplate = \"/rooms/$roomId/state/$eventType\";\n            if (event.getStateKey() && event.getStateKey()!.length > 0) {\n                pathTemplate = \"/rooms/$roomId/state/$eventType/$stateKey\";\n            }\n            path = utils.encodeUri(pathTemplate, pathParams);\n        } else if (event.isRedaction() && event.event.redacts) {\n            const pathTemplate = `/rooms/$roomId/redact/$redactsEventId/$txnId`;\n            path = utils.encodeUri(pathTemplate, {\n                $redactsEventId: event.event.redacts,\n                ...pathParams,\n            });\n        } else {\n            path = utils.encodeUri(\"/rooms/$roomId/send/$eventType/$txnId\", pathParams);\n        }\n\n        const delayOpts =\n            queryOrDelayOpts && isSendDelayedEventRequestOpts(queryOrDelayOpts) ? queryOrDelayOpts : undefined;\n        const queryOpts = !delayOpts ? queryOrDelayOpts : queryDict;\n        const content = event.getWireContent();\n        if (delayOpts) {\n            return this.http.authedRequest<SendDelayedEventResponse>(\n                Method.Put,\n                path,\n                { ...getUnstableDelayQueryOpts(delayOpts), ...queryOpts },\n                content,\n            );\n        } else {\n            return this.http.authedRequest<ISendEventResponse>(Method.Put, path, queryOpts, content).then((res) => {\n                this.logger.debug(`Event sent to ${event.getRoomId()} with event id ${res.event_id}`);\n                return res;\n            });\n        }\n    }\n\n    /**\n     * @param txnId -  transaction id. One will be made up if not supplied.\n     * @param opts - Redact options\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     * @throws Error if called with `with_rel_types` (MSC3912) but the server does not support it.\n     *         Callers should check whether the server supports MSC3912 via `MatrixClient.canSupport`.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public redactEvent(\n        roomId: string,\n        eventId: string,\n        txnId?: string | undefined,\n        opts?: IRedactOpts,\n    ): Promise<ISendEventResponse>;\n    public redactEvent(\n        roomId: string,\n        threadId: string | null,\n        eventId: string,\n        txnId?: string | undefined,\n        opts?: IRedactOpts,\n    ): Promise<ISendEventResponse>;\n    public redactEvent(\n        roomId: string,\n        threadId: string | null,\n        eventId?: string,\n        txnId?: string | IRedactOpts,\n        opts?: IRedactOpts,\n    ): Promise<ISendEventResponse> {\n        if (!eventId?.startsWith(EVENT_ID_PREFIX)) {\n            opts = txnId as IRedactOpts;\n            txnId = eventId;\n            eventId = threadId!;\n            threadId = null;\n        }\n        const reason = opts?.reason;\n        const content: IContent = { reason };\n\n        if (opts?.with_rel_types !== undefined) {\n            if (this.canSupport.get(Feature.RelationBasedRedactions) === ServerSupport.Unsupported) {\n                throw new Error(\n                    \"Server does not support relation based redactions \" +\n                        `roomId ${roomId} eventId ${eventId} txnId: ${txnId as string} threadId ${threadId}`,\n                );\n            }\n\n            const withRelTypesPropName =\n                this.canSupport.get(Feature.RelationBasedRedactions) === ServerSupport.Stable\n                    ? MSC3912_RELATION_BASED_REDACTIONS_PROP.stable!\n                    : MSC3912_RELATION_BASED_REDACTIONS_PROP.unstable!;\n\n            content[withRelTypesPropName] = opts.with_rel_types;\n        }\n\n        return this.sendCompleteEvent({\n            roomId,\n            threadId,\n            eventObject: {\n                type: EventType.RoomRedaction,\n                content,\n                redacts: eventId,\n            },\n            txnId: txnId as string,\n        });\n    }\n\n    /**\n     * @param txnId - Optional.\n     * @returns Promise which resolves: to an ISendEventResponse object\n     * @returns Rejects: with an error response.\n     */\n    public sendMessage(roomId: string, content: RoomMessageEventContent, txnId?: string): Promise<ISendEventResponse>;\n    public sendMessage(\n        roomId: string,\n        threadId: string | null,\n        content: RoomMessageEventContent,\n        txnId?: string,\n    ): Promise<ISendEventResponse>;\n    public sendMessage(\n        roomId: string,\n        threadId: string | null | RoomMessageEventContent,\n        content?: RoomMessageEventContent | string,\n        txnId?: string,\n    ): Promise<ISendEventResponse> {\n        if (typeof threadId !== \"string\" && threadId !== null) {\n            txnId = content as string;\n            content = threadId as RoomMessageEventContent;\n            threadId = null;\n        }\n\n        const eventType = EventType.RoomMessage;\n        const sendContent = content as RoomMessageEventContent;\n\n        return this.sendEvent(roomId, threadId as string | null, eventType, sendContent, txnId);\n    }\n\n    /**\n     * @param txnId - Optional.\n     * @returns\n     * @returns Rejects: with an error response.\n     */\n    public sendTextMessage(roomId: string, body: string, txnId?: string): Promise<ISendEventResponse>;\n    public sendTextMessage(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        txnId?: string,\n    ): Promise<ISendEventResponse>;\n    public sendTextMessage(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        txnId?: string,\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            txnId = body;\n            body = threadId;\n            threadId = null;\n        }\n        const content = ContentHelpers.makeTextMessage(body);\n        return this.sendMessage(roomId, threadId, content, txnId);\n    }\n\n    /**\n     * @param txnId - Optional.\n     * @returns Promise which resolves: to a ISendEventResponse object\n     * @returns Rejects: with an error response.\n     */\n    public sendNotice(roomId: string, body: string, txnId?: string): Promise<ISendEventResponse>;\n    public sendNotice(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        txnId?: string,\n    ): Promise<ISendEventResponse>;\n    public sendNotice(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        txnId?: string,\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            txnId = body;\n            body = threadId;\n            threadId = null;\n        }\n        const content = ContentHelpers.makeNotice(body);\n        return this.sendMessage(roomId, threadId, content, txnId);\n    }\n\n    /**\n     * @param txnId - Optional.\n     * @returns Promise which resolves: to a ISendEventResponse object\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendEmoteMessage(roomId: string, body: string, txnId?: string): Promise<ISendEventResponse>;\n    public sendEmoteMessage(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        txnId?: string,\n    ): Promise<ISendEventResponse>;\n    public sendEmoteMessage(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        txnId?: string,\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            txnId = body;\n            body = threadId;\n            threadId = null;\n        }\n        const content = ContentHelpers.makeEmoteMessage(body);\n        return this.sendMessage(roomId, threadId, content, txnId);\n    }\n\n    /**\n     * @returns Promise which resolves: to a ISendEventResponse object\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendImageMessage(roomId: string, url: string, info?: ImageInfo, text?: string): Promise<ISendEventResponse>;\n    public sendImageMessage(\n        roomId: string,\n        threadId: string | null,\n        url: string,\n        info?: ImageInfo,\n        text?: string,\n    ): Promise<ISendEventResponse>;\n    public sendImageMessage(\n        roomId: string,\n        threadId: string | null,\n        url?: string | ImageInfo,\n        info?: ImageInfo | string,\n        text = \"Image\",\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            text = (info as string) || \"Image\";\n            info = url as ImageInfo;\n            url = threadId as string;\n            threadId = null;\n        }\n        const content = {\n            msgtype: MsgType.Image,\n            url: url as string,\n            info: info as ImageInfo,\n            body: text,\n        } satisfies RoomMessageEventContent;\n        return this.sendMessage(roomId, threadId, content);\n    }\n\n    /**\n     * @returns Promise which resolves: to a ISendEventResponse object\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendStickerMessage(\n        roomId: string,\n        url: string,\n        info?: ImageInfo,\n        text?: string,\n    ): Promise<ISendEventResponse>;\n    public sendStickerMessage(\n        roomId: string,\n        threadId: string | null,\n        url: string,\n        info?: ImageInfo,\n        text?: string,\n    ): Promise<ISendEventResponse>;\n    public sendStickerMessage(\n        roomId: string,\n        threadId: string | null,\n        url?: string | ImageInfo,\n        info?: ImageInfo | string,\n        text = \"Sticker\",\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            text = (info as string) || \"Sticker\";\n            info = url as ImageInfo;\n            url = threadId as string;\n            threadId = null;\n        }\n        const content = {\n            url: url as string,\n            info: info as ImageInfo,\n            body: text,\n        } satisfies StickerEventContent;\n\n        return this.sendEvent(roomId, threadId, EventType.Sticker, content);\n    }\n\n    /**\n     * @returns Promise which resolves: to a ISendEventResponse object\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendHtmlMessage(roomId: string, body: string, htmlBody: string): Promise<ISendEventResponse>;\n    public sendHtmlMessage(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        htmlBody: string,\n    ): Promise<ISendEventResponse>;\n    public sendHtmlMessage(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        htmlBody?: string,\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            htmlBody = body as string;\n            body = threadId;\n            threadId = null;\n        }\n        const content = ContentHelpers.makeHtmlMessage(body, htmlBody!);\n        return this.sendMessage(roomId, threadId, content);\n    }\n\n    /**\n     * @returns Promise which resolves: to a ISendEventResponse object\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendHtmlNotice(roomId: string, body: string, htmlBody: string): Promise<ISendEventResponse>;\n    public sendHtmlNotice(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        htmlBody: string,\n    ): Promise<ISendEventResponse>;\n    public sendHtmlNotice(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        htmlBody?: string,\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            htmlBody = body as string;\n            body = threadId;\n            threadId = null;\n        }\n        const content = ContentHelpers.makeHtmlNotice(body, htmlBody!);\n        return this.sendMessage(roomId, threadId, content);\n    }\n\n    /**\n     * @returns Promise which resolves: to a ISendEventResponse object\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendHtmlEmote(roomId: string, body: string, htmlBody: string): Promise<ISendEventResponse>;\n    public sendHtmlEmote(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        htmlBody: string,\n    ): Promise<ISendEventResponse>;\n    public sendHtmlEmote(\n        roomId: string,\n        threadId: string | null,\n        body: string,\n        htmlBody?: string,\n    ): Promise<ISendEventResponse> {\n        if (!threadId?.startsWith(EVENT_ID_PREFIX) && threadId !== null) {\n            htmlBody = body as string;\n            body = threadId;\n            threadId = null;\n        }\n        const content = ContentHelpers.makeHtmlEmote(body, htmlBody!);\n        return this.sendMessage(roomId, threadId, content);\n    }\n\n    /**\n     * Send a delayed timeline event.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line\n    public async _unstable_sendDelayedEvent<K extends keyof TimelineEvents>(\n        roomId: string,\n        delayOpts: SendDelayedEventRequestOpts,\n        threadId: string | null,\n        eventType: K,\n        content: TimelineEvents[K],\n        txnId?: string,\n    ): Promise<SendDelayedEventResponse> {\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n            throw new UnsupportedDelayedEventsEndpointError(\n                \"Server does not support the delayed events API\",\n                \"sendDelayedEvent\",\n            );\n        }\n\n        this.addThreadRelationIfNeeded(content, threadId, roomId);\n        return this.sendCompleteEvent({\n            roomId,\n            threadId,\n            eventObject: { type: eventType, content },\n            delayOpts,\n            txnId,\n        });\n    }\n\n    /**\n     * Send a delayed sticky timeline event.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) and\n     *   [MSC4354](https://github.com/matrix-org/matrix-spec-proposals/pull/4354) for more details.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line\n    public async _unstable_sendStickyDelayedEvent<K extends keyof TimelineEvents>(\n        roomId: string,\n        stickDuration: number,\n        delayOpts: SendDelayedEventRequestOpts,\n        threadId: string | null,\n        eventType: K,\n        content: TimelineEvents[K] & { msc4354_sticky_key?: string },\n        txnId?: string,\n    ): Promise<SendDelayedEventResponse> {\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n            throw new UnsupportedDelayedEventsEndpointError(\n                \"Server does not support the delayed events API\",\n                \"getDelayedEvents\",\n            );\n        }\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4354_STICKY_EVENTS))) {\n            throw new UnsupportedStickyEventsEndpointError(\n                \"Server does not support the sticky events\",\n                \"sendStickyEvent\",\n            );\n        }\n\n        this.addThreadRelationIfNeeded(content, threadId, roomId);\n        return this.sendCompleteEvent({\n            roomId,\n            threadId,\n            eventObject: { type: eventType, content },\n            queryDict: { \"org.matrix.msc4354.sticky_duration_ms\": stickDuration },\n            delayOpts,\n            txnId,\n        });\n    }\n\n    /**\n     * Send a delayed state event.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line\n    public async _unstable_sendDelayedStateEvent<K extends keyof StateEvents>(\n        roomId: string,\n        delayOpts: SendDelayedEventRequestOpts,\n        eventType: K,\n        content: StateEvents[K],\n        stateKey = \"\",\n        opts: IRequestOpts = {},\n    ): Promise<SendDelayedEventResponse> {\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n            throw new UnsupportedDelayedEventsEndpointError(\n                \"Server does not support the delayed events API\",\n                \"sendDelayedStateEvent\",\n            );\n        }\n\n        const pathParams = {\n            $roomId: roomId,\n            $eventType: eventType,\n            $stateKey: stateKey,\n        };\n        let path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n        if (stateKey !== undefined) {\n            path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n        }\n        return this.http.authedRequest(Method.Put, path, getUnstableDelayQueryOpts(delayOpts), content as Body, opts);\n    }\n\n    /**\n     * Send a sticky timeline event.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4354](https://github.com/matrix-org/matrix-spec-proposals/pull/4354) for more details.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line\n    public async _unstable_sendStickyEvent<K extends keyof TimelineEvents>(\n        roomId: string,\n        stickDuration: number,\n        threadId: string | null,\n        eventType: K,\n        content: TimelineEvents[K] & { msc4354_sticky_key?: string },\n        txnId?: string,\n    ): Promise<ISendEventResponse> {\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4354_STICKY_EVENTS))) {\n            throw new UnsupportedStickyEventsEndpointError(\n                \"Server does not support the sticky events\",\n                \"sendStickyEvent\",\n            );\n        }\n\n        this.addThreadRelationIfNeeded(content, threadId, roomId);\n        return this.sendCompleteEvent({\n            roomId,\n            threadId,\n            eventObject: { type: eventType, content },\n            queryDict: { \"org.matrix.msc4354.sticky_duration_ms\": stickDuration },\n            txnId,\n        });\n    }\n\n    /**\n     * Get information about delayed events owned by the requesting user.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n     */\n    // eslint-disable-next-line\n    public async _unstable_getDelayedEvents(\n        status?: \"scheduled\" | \"finalised\",\n        delayId?: string | string[],\n        fromToken?: string,\n    ): Promise<DelayedEventInfo> {\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n            throw new UnsupportedDelayedEventsEndpointError(\n                \"Server does not support the delayed events API\",\n                \"getDelayedEvents\",\n            );\n        }\n\n        const queryDict = {\n            from: fromToken,\n            status,\n            delay_id: delayId,\n        };\n        return await this.http.authedRequest(Method.Get, \"/delayed_events\", queryDict, undefined, {\n            prefix: `${ClientPrefix.Unstable}/${UNSTABLE_MSC4140_DELAYED_EVENTS}`,\n        });\n    }\n\n    /**\n     * Manage a delayed event associated with the given delay_id.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n     *\n     * @deprecated Instead use one of:\n     * - {@link _unstable_cancelScheduledDelayedEvent}\n     * - {@link _unstable_restartScheduledDelayedEvent}\n     * - {@link _unstable_sendScheduledDelayedEvent}\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public async _unstable_updateDelayedEvent(\n        delayId: string,\n        action: UpdateDelayedEventAction,\n        requestOptions: IRequestOpts = {},\n    ): Promise<EmptyObject> {\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n            throw new UnsupportedDelayedEventsEndpointError(\n                \"Server does not support the delayed events API\",\n                \"updateDelayedEvent\",\n            );\n        }\n        return await this.updateScheduledDelayedEventWithActionInBody(delayId, action, requestOptions);\n    }\n\n    /**\n     * Cancel the scheduled delivery of the delayed event matching the provided delayId.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n     *\n     * @throws A M_NOT_FOUND error if no matching delayed event could be found.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public async _unstable_cancelScheduledDelayedEvent(\n        delayId: string,\n        requestOptions: IRequestOpts = {},\n    ): Promise<EmptyObject> {\n        return await this.updateScheduledDelayedEvent(delayId, UpdateDelayedEventAction.Cancel, requestOptions);\n    }\n\n    /**\n     * Restart the scheduled delivery of the delayed event matching the given delayId.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n     *\n     * @throws A M_NOT_FOUND error if no matching delayed event could be found.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public async _unstable_restartScheduledDelayedEvent(\n        delayId: string,\n        requestOptions: IRequestOpts = {},\n    ): Promise<EmptyObject> {\n        return await this.updateScheduledDelayedEvent(delayId, UpdateDelayedEventAction.Restart, requestOptions);\n    }\n\n    /**\n     * Immediately send the delayed event matching the given delayId,\n     * instead of waiting for its scheduled delivery.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n     *\n     * @throws A M_NOT_FOUND error if no matching delayed event could be found.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public async _unstable_sendScheduledDelayedEvent(\n        delayId: string,\n        requestOptions: IRequestOpts = {},\n    ): Promise<EmptyObject> {\n        return await this.updateScheduledDelayedEvent(delayId, UpdateDelayedEventAction.Send, requestOptions);\n    }\n\n    private async updateScheduledDelayedEvent(\n        delayId: string,\n        action: UpdateDelayedEventAction,\n        requestOptions: IRequestOpts = {},\n    ): Promise<EmptyObject> {\n        if (!(await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n            throw new UnsupportedDelayedEventsEndpointError(\n                \"Server does not support the delayed events API\",\n                `${action}ScheduledDelayedEvent`,\n            );\n        }\n\n        try {\n            const path = utils.encodeUri(\"/delayed_events/$delayId/$action\", {\n                $delayId: delayId,\n                $action: action,\n            });\n            return await this.http.request(Method.Post, path, undefined, undefined, {\n                ...requestOptions,\n                prefix: `${ClientPrefix.Unstable}/${UNSTABLE_MSC4140_DELAYED_EVENTS}`,\n            });\n        } catch (e) {\n            if (e instanceof MatrixError && e.errcode === \"M_UNRECOGNIZED\") {\n                // For backwards compatibility with an older version of this endpoint\n                // which put the update action in the request body instead of the path\n                return await this.updateScheduledDelayedEventWithActionInBody(delayId, action, requestOptions);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * @deprecated Present for backwards compatibility with an older version of MSC4140\n     * which had a single, authenticated endpoint for updating a delayed event, instead\n     * of one unauthenticated endpoint per update action.\n     */\n    private async updateScheduledDelayedEventWithActionInBody(\n        delayId: string,\n        action: UpdateDelayedEventAction,\n        requestOptions: IRequestOpts = {},\n    ): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/delayed_events/$delayId\", {\n            $delayId: delayId,\n        });\n        const data = {\n            action,\n        };\n        try {\n            return await this.http.request(Method.Post, path, undefined, data, {\n                ...requestOptions,\n                prefix: `${ClientPrefix.Unstable}/${UNSTABLE_MSC4140_DELAYED_EVENTS}`,\n            });\n        } catch (e) {\n            if (e instanceof MatrixError && e.errcode === \"M_MISSING_TOKEN\") {\n                // For backwards compatibility with an older version of this endpoint\n                // which required authentication\n                return await this.http.authedRequest(Method.Post, path, undefined, data, {\n                    ...requestOptions,\n                    prefix: `${ClientPrefix.Unstable}/${UNSTABLE_MSC4140_DELAYED_EVENTS}`,\n                });\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Send a receipt.\n     * @param event - The event being acknowledged\n     * @param receiptType - The kind of receipt e.g. \"m.read\". Other than\n     * ReceiptType.Read are experimental!\n     * @param body - Additional content to send alongside the receipt.\n     * @param unthreaded - An unthreaded receipt will clear room+thread notifications\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public async sendReceipt(\n        event: MatrixEvent,\n        receiptType: ReceiptType,\n        body?: Record<string, any>,\n        unthreaded = false,\n    ): Promise<EmptyObject> {\n        if (this.isGuest()) {\n            return Promise.resolve({}); // guests cannot send receipts so don't bother.\n        }\n\n        const path = utils.encodeUri(\"/rooms/$roomId/receipt/$receiptType/$eventId\", {\n            $roomId: event.getRoomId()!,\n            $receiptType: receiptType,\n            $eventId: event.getId()!,\n        });\n\n        // Unless we're explicitly making an unthreaded receipt or we don't\n        // support threads, include the `thread_id` property in the body.\n        const shouldAddThreadId = !unthreaded && this.supportsThreads();\n        const fullBody = shouldAddThreadId ? { ...body, thread_id: threadIdForReceipt(event) } : body;\n\n        const promise = this.http.authedRequest<EmptyObject>(Method.Post, path, undefined, fullBody || {});\n\n        const room = this.getRoom(event.getRoomId());\n        if (room && this.credentials.userId) {\n            room.addLocalEchoReceipt(this.credentials.userId, event, receiptType, unthreaded);\n        }\n        return promise;\n    }\n\n    /**\n     * Send a read receipt.\n     * @param event - The event that has been read.\n     * @param receiptType - other than ReceiptType.Read are experimental! Optional.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public async sendReadReceipt(\n        event: MatrixEvent | null,\n        receiptType = ReceiptType.Read,\n        unthreaded = false,\n    ): Promise<EmptyObject | undefined> {\n        if (!event) return;\n        const eventId = event.getId()!;\n        const room = this.getRoom(event.getRoomId());\n        if (room?.hasPendingEvent(eventId)) {\n            throw new Error(`Cannot set read receipt to a pending event (${eventId})`);\n        }\n\n        return this.sendReceipt(event, receiptType, {}, unthreaded);\n    }\n\n    /**\n     * Set a marker to indicate the point in a room before which the user has read every\n     * event. This can be retrieved from room account data (the event type is `m.fully_read`)\n     * and displayed as a horizontal line in the timeline that is visually distinct to the\n     * position of the user's own read receipt.\n     * @param roomId - ID of the room that has been read\n     * @param rmEventId - ID of the event that has been read\n     * @param rrEvent - the event tracked by the read receipt. This is here for\n     * convenience because the RR and the RM are commonly updated at the same time as each\n     * other. The local echo of this receipt will be done if set. Optional.\n     * @param rpEvent - the m.read.private read receipt event for when we don't\n     * want other users to see the read receipts. This is experimental. Optional.\n     * @returns Promise which resolves: the empty object, `{}`.\n     */\n    public async setRoomReadMarkers(\n        roomId: string,\n        rmEventId: string,\n        rrEvent?: MatrixEvent,\n        rpEvent?: MatrixEvent,\n    ): Promise<EmptyObject> {\n        const room = this.getRoom(roomId);\n        if (room?.hasPendingEvent(rmEventId)) {\n            throw new Error(`Cannot set read marker to a pending event (${rmEventId})`);\n        }\n\n        // Add the optional RR update, do local echo like `sendReceipt`\n        let rrEventId: string | undefined;\n        if (rrEvent) {\n            rrEventId = rrEvent.getId()!;\n            if (room?.hasPendingEvent(rrEventId)) {\n                throw new Error(`Cannot set read receipt to a pending event (${rrEventId})`);\n            }\n            room?.addLocalEchoReceipt(this.credentials.userId!, rrEvent, ReceiptType.Read);\n        }\n\n        // Add the optional private RR update, do local echo like `sendReceipt`\n        let rpEventId: string | undefined;\n        if (rpEvent) {\n            rpEventId = rpEvent.getId()!;\n            if (room?.hasPendingEvent(rpEventId)) {\n                throw new Error(`Cannot set read receipt to a pending event (${rpEventId})`);\n            }\n            room?.addLocalEchoReceipt(this.credentials.userId!, rpEvent, ReceiptType.ReadPrivate);\n        }\n\n        return await this.setRoomReadMarkersHttpRequest(roomId, rmEventId, rrEventId, rpEventId);\n    }\n\n    /**\n     *\n     * @param roomId\n     * @param notificationEventId\n     * @returns\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public sendRtcDecline(roomId: string, notificationEventId: string): Promise<ISendEventResponse> {\n        return this.sendEvent(roomId, EventType.RTCDecline, {\n            \"m.relates_to\": { event_id: notificationEventId, rel_type: RelationType.Reference },\n        });\n    }\n\n    /**\n     * Get a preview of the given URL as of (roughly) the given point in time,\n     * described as an object with OpenGraph keys and associated values.\n     * Attributes may be synthesized where actual OG metadata is lacking.\n     * Caches results to prevent hammering the server.\n     * @param url - The URL to get preview data for\n     * @param ts - The preferred point in time that the preview should\n     * describe (ms since epoch).  The preview returned will either be the most\n     * recent one preceding this timestamp if available, or failing that the next\n     * most recent available preview.\n     * @returns Promise which resolves: Object of OG metadata.\n     * @returns Rejects: with an error response.\n     * May return synthesized attributes if the URL lacked OG meta.\n     */\n    public getUrlPreview(url: string, ts: number): Promise<IPreviewUrlResponse> {\n        // bucket the timestamp to the nearest minute to prevent excessive spam to the server\n        // Surely 60-second accuracy is enough for anyone.\n        ts = Math.floor(ts / 60000) * 60000;\n\n        const parsed = new URL(url);\n        parsed.hash = \"\"; // strip the hash as it won't affect the preview\n        url = parsed.toString();\n\n        const key = ts + \"_\" + url;\n\n        // If there's already a request in flight (or we've handled it), return that instead.\n        if (key in this.urlPreviewCache) {\n            return this.urlPreviewCache[key];\n        }\n\n        const resp = this.http.authedRequest<IPreviewUrlResponse>(\n            Method.Get,\n            \"/preview_url\",\n            {\n                url,\n                ts: ts.toString(),\n            },\n            undefined,\n            {\n                prefix: MediaPrefix.V3,\n                priority: \"low\",\n            },\n        );\n        // TODO: Expire the URL preview cache sometimes\n        this.urlPreviewCache[key] = resp;\n        return resp;\n    }\n\n    /**\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public sendTyping(roomId: string, isTyping: boolean, timeoutMs: number): Promise<EmptyObject> {\n        if (this.isGuest()) {\n            return Promise.resolve({}); // guests cannot send typing notifications so don't bother.\n        }\n\n        const path = utils.encodeUri(\"/rooms/$roomId/typing/$userId\", {\n            $roomId: roomId,\n            $userId: this.getUserId()!,\n        });\n        const data: QueryDict = {\n            typing: isTyping,\n        };\n        if (isTyping) {\n            data.timeout = timeoutMs ? timeoutMs : 20000;\n        }\n        return this.http.authedRequest(Method.Put, path, undefined, data);\n    }\n\n    /**\n     * Determines the history of room upgrades for a given room, as far as the\n     * client can see. Returns an array of Rooms where the first entry is the\n     * oldest and the last entry is the newest (likely current) room. If the\n     * provided room is not found, this returns an empty list. This works in\n     * both directions, looking for older and newer rooms of the given room.\n     * @param roomId - The room ID to search from\n     * @param verifyLinks - If true, the function will only return rooms\n     * which can be proven to be linked. For example, rooms which have a create\n     * event pointing to an old room which the client is not aware of or doesn't\n     * have a matching tombstone would not be returned.\n     * @param msc3946ProcessDynamicPredecessor - if true, look for\n     * m.room.predecessor state events as well as create events, and prefer\n     * predecessor events where they exist (MSC3946).\n     * @returns An array of rooms representing the upgrade\n     * history.\n     */\n    public getRoomUpgradeHistory(\n        roomId: string,\n        verifyLinks = false,\n        msc3946ProcessDynamicPredecessor = false,\n    ): Room[] {\n        const currentRoom = this.getRoom(roomId);\n        if (!currentRoom) return [];\n\n        const before = this.findPredecessorRooms(currentRoom, verifyLinks, msc3946ProcessDynamicPredecessor);\n        const after = this.findSuccessorRooms(currentRoom, verifyLinks, msc3946ProcessDynamicPredecessor);\n\n        return [...before, currentRoom, ...after];\n    }\n\n    private findPredecessorRooms(room: Room, verifyLinks: boolean, msc3946ProcessDynamicPredecessor: boolean): Room[] {\n        const ret: Room[] = [];\n        const seenRoomIDs = new Set<string>([room.roomId]);\n\n        // Work backwards from newer to older rooms\n        let predecessorRoomId = room.findPredecessor(msc3946ProcessDynamicPredecessor)?.roomId;\n        while (predecessorRoomId !== null) {\n            if (predecessorRoomId) {\n                if (seenRoomIDs.has(predecessorRoomId)) break;\n                seenRoomIDs.add(predecessorRoomId);\n            }\n            const predecessorRoom = this.getRoom(predecessorRoomId);\n            if (predecessorRoom === null) {\n                break;\n            }\n            if (verifyLinks) {\n                const tombstone = predecessorRoom.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n                if (!tombstone || tombstone.getContent()[\"replacement_room\"] !== room.roomId) {\n                    break;\n                }\n            }\n\n            // Insert at the front because we're working backwards from the currentRoom\n            ret.splice(0, 0, predecessorRoom);\n\n            room = predecessorRoom;\n            predecessorRoomId = room.findPredecessor(msc3946ProcessDynamicPredecessor)?.roomId;\n        }\n        return ret;\n    }\n\n    private findSuccessorRooms(room: Room, verifyLinks: boolean, msc3946ProcessDynamicPredecessor: boolean): Room[] {\n        const ret: Room[] = [];\n\n        // Work forwards, looking at tombstone events\n        let tombstoneEvent = room.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n        while (tombstoneEvent) {\n            const successorRoom = this.getRoom(tombstoneEvent.getContent()[\"replacement_room\"]);\n            if (!successorRoom) break; // end of the chain\n            if (successorRoom.roomId === room.roomId) break; // Tombstone is referencing its own room\n\n            if (verifyLinks) {\n                const predecessorRoomId = successorRoom.findPredecessor(msc3946ProcessDynamicPredecessor)?.roomId;\n                if (!predecessorRoomId || predecessorRoomId !== room.roomId) {\n                    break;\n                }\n            }\n\n            // Push to the end because we're looking forwards\n            ret.push(successorRoom);\n            const roomIds = new Set(ret.map((ref) => ref.roomId));\n            if (roomIds.size < ret.length) {\n                // The last room added to the list introduced a previous roomId\n                // To avoid recursion, return the last rooms - 1\n                return ret.slice(0, ret.length - 1);\n            }\n\n            // Set the current room to the reference room so we know where we're at\n            room = successorRoom;\n            tombstoneEvent = room.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n        }\n        return ret;\n    }\n\n    /**\n     * Send an invite to the given user to join the given room.\n     *\n     * @param roomId - The ID of the room to which the user should be invited.\n     * @param userId - The ID of the user that should be invited.\n     * @param opts - Optional reason object. For backwards compatibility, a string is also accepted, and will be interpreted as a reason.\n     *\n     * @returns An empty object.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public async invite(roomId: string, userId: string, opts: InviteOpts | string = {}): Promise<EmptyObject> {\n        if (typeof opts != \"object\") {\n            opts = { reason: opts };\n        }\n\n        if (opts.shareEncryptedHistory) {\n            await this.cryptoBackend?.shareRoomHistoryWithUser(roomId, userId);\n        }\n\n        return await this.membershipChange(roomId, userId, KnownMembership.Invite, opts.reason);\n    }\n\n    /**\n     * Invite a user to a room based on their email address.\n     * @param roomId - The room to invite the user to.\n     * @param email - The email address to invite.\n     * @returns Promise which resolves: `{}` an empty object.\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public inviteByEmail(roomId: string, email: string): Promise<EmptyObject> {\n        return this.inviteByThreePid(roomId, \"email\", email);\n    }\n\n    /**\n     * Invite a user to a room based on a third-party identifier.\n     * @param roomId - The room to invite the user to.\n     * @param medium - The medium to invite the user e.g. \"email\".\n     * @param address - The address for the specified medium.\n     * @returns Promise which resolves: `{}` an empty object.\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public async inviteByThreePid(roomId: string, medium: string, address: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/rooms/$roomId/invite\", { $roomId: roomId });\n\n        const identityServerUrl = this.getIdentityServerUrl(true);\n        if (!identityServerUrl) {\n            return Promise.reject(\n                new MatrixError({\n                    error: \"No supplied identity server URL\",\n                    errcode: \"ORG.MATRIX.JSSDK_MISSING_PARAM\",\n                }),\n            );\n        }\n        const params: Record<string, string> = {\n            id_server: identityServerUrl,\n            medium: medium,\n            address: address,\n        };\n\n        if (this.identityServer?.getAccessToken) {\n            const identityAccessToken = await this.identityServer.getAccessToken();\n            if (identityAccessToken) {\n                params[\"id_access_token\"] = identityAccessToken;\n            }\n        }\n\n        return this.http.authedRequest(Method.Post, path, undefined, params);\n    }\n\n    /**\n     * @returns Promise which resolves: `{}` an empty object.\n     * @returns Rejects: with an error response.\n     */\n    public leave(roomId: string): Promise<EmptyObject> {\n        return this.membershipChange(roomId, undefined, KnownMembership.Leave);\n    }\n\n    /**\n     * Leaves all rooms in the chain of room upgrades based on the given room. By\n     * default, this will leave all the previous and upgraded rooms, including the\n     * given room. To only leave the given room and any previous rooms, keeping the\n     * upgraded (modern) rooms untouched supply `false` to `includeFuture`.\n     * @param roomId - The room ID to start leaving at\n     * @param includeFuture - If true, the whole chain (past and future) of\n     * upgraded rooms will be left.\n     * @returns Promise which resolves when completed with an object keyed\n     * by room ID and value of the error encountered when leaving or null.\n     */\n    public leaveRoomChain(\n        roomId: string,\n        includeFuture = true,\n    ): Promise<{ [roomId: string]: Error | MatrixError | null }> {\n        const upgradeHistory = this.getRoomUpgradeHistory(roomId, true);\n\n        let eligibleToLeave = upgradeHistory;\n        if (!includeFuture) {\n            eligibleToLeave = [];\n            for (const room of upgradeHistory) {\n                eligibleToLeave.push(room);\n                if (room.roomId === roomId) {\n                    break;\n                }\n            }\n        }\n\n        const populationResults: { [roomId: string]: Error } = {};\n        const promises: Promise<unknown>[] = [];\n\n        const doLeave = (roomId: string): Promise<void> => {\n            return this.leave(roomId)\n                .then(() => {\n                    delete populationResults[roomId];\n                })\n                .catch((err) => {\n                    // suppress error\n                    populationResults[roomId] = err;\n                });\n        };\n\n        for (const room of eligibleToLeave) {\n            promises.push(doLeave(room.roomId));\n        }\n\n        return Promise.all(promises).then(() => populationResults);\n    }\n\n    /**\n     * @param reason - Optional.\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     */\n    public ban(roomId: string, userId: string, reason?: string): Promise<EmptyObject> {\n        return this.membershipChange(roomId, userId, KnownMembership.Ban, reason);\n    }\n\n    /**\n     * @param deleteRoom - True to delete the room from the store on success.\n     * Default: true.\n     * @returns Promise which resolves: `{}` an empty object.\n     * @returns Rejects: with an error response.\n     */\n    public async forget(roomId: string, deleteRoom = true): Promise<EmptyObject> {\n        // API returns an empty object\n        const path = utils.encodeUri(\"/rooms/$room_id/forget\", {\n            $room_id: roomId,\n        });\n        const response = await this.http.authedRequest<EmptyObject>(Method.Post, path);\n        if (deleteRoom) {\n            this.store.removeRoom(roomId);\n            this.emit(ClientEvent.DeleteRoom, roomId);\n        }\n        return response;\n    }\n\n    /**\n     * @returns Promise which resolves: Object (currently empty)\n     * @returns Rejects: with an error response.\n     */\n    public unban(roomId: string, userId: string): Promise<EmptyObject> {\n        // unbanning != set their state to leave: this used to be\n        // the case, but was then changed so that leaving was always\n        // a revoking of privilege, otherwise two people racing to\n        // kick / ban someone could end up banning and then un-banning\n        // them.\n        const path = utils.encodeUri(\"/rooms/$roomId/unban\", {\n            $roomId: roomId,\n        });\n        const data = {\n            user_id: userId,\n        };\n        return this.http.authedRequest(Method.Post, path, undefined, data);\n    }\n\n    /**\n     * @param reason - Optional.\n     * @returns Promise which resolves: `{}` an empty object.\n     * @returns Rejects: with an error response.\n     */\n    public kick(roomId: string, userId: string, reason?: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/rooms/$roomId/kick\", {\n            $roomId: roomId,\n        });\n        const data = {\n            user_id: userId,\n            reason: reason,\n        };\n        return this.http.authedRequest(Method.Post, path, undefined, data);\n    }\n\n    private membershipChange(\n        roomId: string,\n        userId: string | undefined,\n        membership: Membership,\n        reason?: string,\n    ): Promise<EmptyObject> {\n        // API returns an empty object\n        const path = utils.encodeUri(\"/rooms/$room_id/$membership\", {\n            $room_id: roomId,\n            $membership: membership,\n        });\n        return this.http.authedRequest(Method.Post, path, undefined, {\n            user_id: userId, // may be undefined e.g. on leave\n            reason: reason,\n        });\n    }\n\n    /**\n     * Obtain a dict of actions which should be performed for this event according\n     * to the push rules for this user.  Caches the dict on the event.\n     * @param event - The event to get push actions for.\n     * @param forceRecalculate - forces to recalculate actions for an event\n     * Useful when an event just got decrypted\n     * @returns A dict of actions to perform.\n     */\n    public getPushActionsForEvent(event: MatrixEvent, forceRecalculate = false): IActionsObject | null {\n        if (!event.getPushActions() || forceRecalculate) {\n            const { actions, rule } = this.pushProcessor.actionsAndRuleForEvent(event);\n            event.setPushDetails(actions, rule);\n        }\n        return event.getPushActions();\n    }\n\n    /**\n     * Obtain a dict of actions which should be performed for this event according\n     * to the push rules for this user.  Caches the dict on the event.\n     * @param event - The event to get push actions for.\n     * @param forceRecalculate - forces to recalculate actions for an event\n     * Useful when an event just got decrypted\n     * @returns A dict of actions to perform.\n     */\n    public getPushDetailsForEvent(event: MatrixEvent, forceRecalculate = false): PushDetails | null {\n        if (!event.getPushDetails() || forceRecalculate) {\n            const { actions, rule } = this.pushProcessor.actionsAndRuleForEvent(event);\n            event.setPushDetails(actions, rule);\n        }\n        return event.getPushDetails();\n    }\n\n    /**\n     * @param info - The kind of info to set (e.g. 'avatar_url')\n     * @param data - The JSON object to set.\n     * @returns\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    // eslint-disable-next-line camelcase\n    public setProfileInfo(info: \"avatar_url\", data: { avatar_url: string }): Promise<EmptyObject>;\n    public setProfileInfo(info: \"displayname\", data: { displayname: string }): Promise<EmptyObject>;\n    public setProfileInfo(info: \"avatar_url\" | \"displayname\", data: object): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/profile/$userId/$info\", {\n            $userId: this.credentials.userId!,\n            $info: info,\n        });\n        return this.http.authedRequest(Method.Put, path, undefined, data);\n    }\n\n    /**\n     * @returns Promise which resolves: `{}` an empty object.\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public async setDisplayName(name: string): Promise<EmptyObject> {\n        const prom = await this.setProfileInfo(\"displayname\", { displayname: name });\n        // XXX: synthesise a profile update for ourselves because Synapse is broken and won't\n        const user = this.getUser(this.getUserId()!);\n        if (user) {\n            user.displayName = name;\n            user.emit(UserEvent.DisplayName, user.events.presence, user);\n        }\n        return prom;\n    }\n\n    /**\n     * @returns Promise which resolves: `{}` an empty object.\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public async setAvatarUrl(url: string): Promise<EmptyObject> {\n        const prom = await this.setProfileInfo(\"avatar_url\", { avatar_url: url });\n        // XXX: synthesise a profile update for ourselves because Synapse is broken and won't\n        const user = this.getUser(this.getUserId()!);\n        if (user) {\n            user.avatarUrl = url;\n            user.emit(UserEvent.AvatarUrl, user.events.presence, user);\n        }\n        return prom;\n    }\n\n    /**\n     * Turn an MXC URL into an HTTP one. <strong>This method is experimental and\n     * may change.</strong>\n     * @param mxcUrl - The MXC URL\n     * @param width - The desired width of the thumbnail.\n     * @param height - The desired height of the thumbnail.\n     * @param resizeMethod - The thumbnail resize method to use, either\n     * \"crop\" or \"scale\".\n     * @param allowDirectLinks - If true, return any non-mxc URLs\n     * directly. Fetching such URLs will leak information about the user to\n     * anyone they share a room with. If false, will return null for such URLs.\n     * @param allowRedirects - If true, the caller supports the URL being 307 or\n     * 308 redirected to another resource upon request. If false, redirects\n     * are not expected. Implied `true` when `useAuthentication` is `true`.\n     * @param useAuthentication - If true, the caller supports authenticated\n     * media and wants an authentication-required URL. Note that server support\n     * for authenticated media will *not* be checked - it is the caller's responsibility\n     * to do so before calling this function. Note also that `useAuthentication`\n     * implies `allowRedirects`. Defaults to false (unauthenticated endpoints).\n     * @returns the avatar URL or null.\n     */\n    public mxcUrlToHttp(\n        mxcUrl: string,\n        width?: number,\n        height?: number,\n        resizeMethod?: string,\n        allowDirectLinks?: boolean,\n        allowRedirects?: boolean,\n        useAuthentication?: boolean,\n    ): string | null {\n        return getHttpUriForMxc(\n            this.baseUrl,\n            mxcUrl,\n            width,\n            height,\n            resizeMethod,\n            allowDirectLinks,\n            allowRedirects,\n            useAuthentication,\n        );\n    }\n\n    /**\n     * Specify the set_presence value to be used for subsequent calls to the Sync API.\n     * This has an advantage over calls to the PUT /presence API in that it\n     * doesn't clobber status_msg set by other devices.\n     * @param presence - the presence to specify to set_presence of sync calls\n     */\n    public async setSyncPresence(presence?: SetPresence): Promise<void> {\n        this.syncApi?.setPresence(presence);\n    }\n\n    /**\n     * @param opts - Options to apply\n     * @returns Promise which resolves\n     * @returns Rejects: with an error response.\n     * @throws If 'presence' isn't a valid presence enum value.\n     */\n    public async setPresence(opts: IPresenceOpts): Promise<void> {\n        const path = utils.encodeUri(\"/presence/$userId/status\", {\n            $userId: this.credentials.userId!,\n        });\n\n        const validStates = [\"offline\", \"online\", \"unavailable\"];\n        if (validStates.indexOf(opts.presence) === -1) {\n            throw new Error(\"Bad presence value: \" + opts.presence);\n        }\n        await this.http.authedRequest(Method.Put, path, undefined, opts);\n    }\n\n    /**\n     * @param userId - The user to get presence for\n     * @returns Promise which resolves: The presence state for this user.\n     * @returns Rejects: with an error response.\n     */\n    public getPresence(userId: string): Promise<IStatusResponse> {\n        const path = utils.encodeUri(\"/presence/$userId/status\", {\n            $userId: userId,\n        });\n\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Retrieve older messages from the given room and put them in the timeline.\n     *\n     * If this is called multiple times whilst a request is ongoing, the <i>same</i>\n     * Promise will be returned. If there was a problem requesting scrollback, there\n     * will be a small delay before another request can be made (to prevent tight-looping\n     * when there is no connection).\n     *\n     * @param room - The room to get older messages in.\n     * @param limit - Optional. The maximum number of previous events to\n     * pull in. Default: 30.\n     * @returns Promise which resolves: Room. If you are at the beginning\n     * of the timeline, `Room.oldState.paginationToken` will be\n     * `null`.\n     * @returns Rejects: with an error response.\n     */\n    public scrollback(room: Room, limit = 30): Promise<Room> {\n        let timeToWaitMs = 0;\n\n        let info = this.ongoingScrollbacks[room.roomId] || {};\n        if (info.promise) {\n            return info.promise;\n        } else if (info.errorTs) {\n            const timeWaitedMs = Date.now() - info.errorTs;\n            timeToWaitMs = Math.max(SCROLLBACK_DELAY_MS - timeWaitedMs, 0);\n        }\n\n        if (room.oldState.paginationToken === null) {\n            return Promise.resolve(room); // already at the start.\n        }\n        // attempt to grab more events from the store first\n        const numAdded = this.store.scrollback(room, limit).length;\n        if (numAdded === limit) {\n            // store contained everything we needed.\n            return Promise.resolve(room);\n        }\n        // reduce the required number of events appropriately\n        limit = limit - numAdded;\n\n        const promise = new Promise<Room>((resolve, reject) => {\n            // wait for a time before doing this request\n            // (which may be 0 in order not to special case the code paths)\n            sleep(timeToWaitMs)\n                .then(() => {\n                    return this.createMessagesRequest(\n                        room.roomId,\n                        room.oldState.paginationToken,\n                        limit,\n                        Direction.Backward,\n                    );\n                })\n                .then((res: IMessagesResponse) => {\n                    const matrixEvents = res.chunk.map(this.getEventMapper());\n                    if (res.state) {\n                        const stateEvents = res.state.map(this.getEventMapper());\n                        room.currentState.setUnknownStateEvents(stateEvents);\n                    }\n\n                    const [timelineEvents, threadedEvents, unknownRelations] =\n                        room.partitionThreadedEvents(matrixEvents);\n\n                    this.processAggregatedTimelineEvents(room, timelineEvents);\n                    room.addEventsToTimeline(timelineEvents, true, true, room.getLiveTimeline());\n                    this.processThreadEvents(room, threadedEvents, true);\n                    unknownRelations.forEach((event) => room.relations.aggregateChildEvent(event));\n\n                    room.oldState.paginationToken = res.end ?? null;\n                    if (res.chunk.length === 0) {\n                        room.oldState.paginationToken = null;\n                    }\n                    this.store.storeEvents(room, matrixEvents, res.end ?? null, true);\n                    delete this.ongoingScrollbacks[room.roomId];\n                    resolve(room);\n                })\n                .catch((err) => {\n                    this.ongoingScrollbacks[room.roomId] = {\n                        errorTs: Date.now(),\n                    };\n                    reject(err);\n                });\n        });\n\n        info = { promise };\n\n        this.ongoingScrollbacks[room.roomId] = info;\n        return promise;\n    }\n\n    public getEventMapper(options?: MapperOpts): EventMapper {\n        return eventMapperFor(this, options || {});\n    }\n\n    /**\n     * Calls the `/context` API for the given room ID & event ID.\n     * Returns the response, with `event` asserted and all optional arrays defaulted to an empty array.\n     * @param roomId - the room ID to request a context for\n     * @param eventId - the event ID to request a context for\n     * @throws if `event` in the response is missing\n     * @private\n     */\n    private async getEventContext(\n        roomId: string,\n        eventId: string,\n    ): Promise<IContextResponse & Omit<Required<IContextResponse>, \"start\" | \"end\">> {\n        const path = utils.encodeUri(\"/rooms/$roomId/context/$eventId\", {\n            $roomId: roomId,\n            $eventId: eventId,\n        });\n\n        const params: Record<string, string | string[]> = {\n            limit: \"0\",\n        };\n        if (this.clientOpts?.lazyLoadMembers) {\n            params.filter = JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER);\n        }\n\n        // TODO: we should implement a backoff (as per scrollback()) to deal more nicely with HTTP errors.\n        const res = await this.http.authedRequest<IContextResponse>(Method.Get, path, params);\n        if (res.event) {\n            return {\n                start: res.start,\n                end: res.end,\n                event: res.event,\n                events_after: res.events_after ?? [],\n                events_before: res.events_before ?? [],\n                state: res.state ?? [],\n            };\n        }\n\n        throw new Error(\"'event' not in '/context' result - homeserver too old?\");\n    }\n\n    /**\n     * Get an EventTimeline for the given event\n     *\n     * <p>If the EventTimelineSet object already has the given event in its store, the\n     * corresponding timeline will be returned. Otherwise, a /context request is\n     * made, and used to construct an EventTimeline.\n     * If the event does not belong to this EventTimelineSet then undefined will be returned.\n     *\n     * @param timelineSet -  The timelineSet to look for the event in, must be bound to a room\n     * @param eventId -  The ID of the event to look for\n     *\n     * @returns Promise which resolves:\n     *    {@link EventTimeline} including the given event\n     */\n    public async getEventTimeline(timelineSet: EventTimelineSet, eventId: string): Promise<EventTimeline | null> {\n        // don't allow any timeline support unless it's been enabled.\n        if (!this.timelineSupport) {\n            throw new Error(\n                \"timeline support is disabled. Set the 'timelineSupport'\" +\n                    \" parameter to true when creating MatrixClient to enable it.\",\n            );\n        }\n\n        if (!timelineSet?.room) {\n            throw new Error(\"getEventTimeline only supports room timelines\");\n        }\n\n        if (timelineSet.getTimelineForEvent(eventId)) {\n            return timelineSet.getTimelineForEvent(eventId);\n        }\n\n        if (timelineSet.thread && this.supportsThreads()) {\n            return (await this.getThreadTimeline(timelineSet, eventId)) ?? null;\n        }\n\n        const res = await this.getEventContext(timelineSet.room.roomId, eventId);\n\n        // by the time the request completes, the event might have ended up in the timeline.\n        if (timelineSet.getTimelineForEvent(eventId)) {\n            return timelineSet.getTimelineForEvent(eventId);\n        }\n\n        const mapper = this.getEventMapper();\n        const event = mapper(res.event);\n        if (event.isRelation(THREAD_RELATION_TYPE.name)) {\n            this.logger.warn(\"Tried loading a regular timeline at the position of a thread event\");\n            return null;\n        }\n        const events = [\n            // Order events from most recent to oldest (reverse-chronological).\n            // We start with the last event, since that's the point at which we have known state.\n            // events_after is already backwards; events_before is forwards.\n            ...res.events_after.reverse().map(mapper),\n            event,\n            ...res.events_before.map(mapper),\n        ];\n\n        // Here we handle non-thread timelines only, but still process any thread events to populate thread summaries.\n        let timeline = timelineSet.getTimelineForEvent(events[0].getId());\n        if (timeline) {\n            timeline.getState(EventTimeline.BACKWARDS)!.setUnknownStateEvents(res.state.map(mapper));\n        } else {\n            timeline = timelineSet.addTimeline();\n            timeline.initialiseState(res.state.map(mapper));\n            timeline.getState(EventTimeline.FORWARDS)!.paginationToken = res.end ?? null;\n        }\n\n        const [timelineEvents, threadedEvents, unknownRelations] = timelineSet.room.partitionThreadedEvents(events);\n        timelineSet.addEventsToTimeline(timelineEvents, true, false, timeline, res.start);\n        // The target event is not in a thread but process the contextual events, so we can show any threads around it.\n        this.processThreadEvents(timelineSet.room, threadedEvents, true);\n        this.processAggregatedTimelineEvents(timelineSet.room, timelineEvents);\n        unknownRelations.forEach((event) => timelineSet.relations.aggregateChildEvent(event));\n\n        // There is no guarantee that the event ended up in \"timeline\" (we might have switched to a neighbouring\n        // timeline) - so check the room's index again. On the other hand, there's no guarantee the event ended up\n        // anywhere, if it was later redacted, so we just return the timeline we first thought of.\n        return (\n            timelineSet.getTimelineForEvent(eventId) ??\n            timelineSet.room.findThreadForEvent(event)?.liveTimeline ?? // for Threads degraded support\n            timeline\n        );\n    }\n\n    public async getThreadTimeline(timelineSet: EventTimelineSet, eventId: string): Promise<EventTimeline | undefined> {\n        if (!this.supportsThreads()) {\n            throw new Error(\"could not get thread timeline: no client support\");\n        }\n\n        if (!timelineSet.room) {\n            throw new Error(\"could not get thread timeline: not a room timeline\");\n        }\n\n        if (!timelineSet.thread) {\n            throw new Error(\"could not get thread timeline: not a thread timeline\");\n        }\n\n        const res = await this.getEventContext(timelineSet.room.roomId, eventId);\n\n        const mapper = this.getEventMapper();\n        const event = mapper(res.event);\n\n        if (!timelineSet.canContain(event)) {\n            return undefined;\n        }\n\n        const recurse = this.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n        if (Thread.hasServerSideSupport) {\n            if (Thread.hasServerSideFwdPaginationSupport) {\n                if (!timelineSet.thread) {\n                    throw new Error(\"could not get thread timeline: not a thread timeline\");\n                }\n\n                const thread = timelineSet.thread;\n                const resOlder: IRelationsResponse = await this.fetchRelations(\n                    timelineSet.room.roomId,\n                    thread.id,\n                    null,\n                    null,\n                    { dir: Direction.Backward, from: res.start, recurse: recurse || undefined },\n                );\n                const resNewer: IRelationsResponse = await this.fetchRelations(\n                    timelineSet.room.roomId,\n                    thread.id,\n                    null,\n                    null,\n                    { dir: Direction.Forward, from: res.end, recurse: recurse || undefined },\n                );\n                const events = [\n                    // Order events from most recent to oldest (reverse-chronological).\n                    // We start with the last event, since that's the point at which we have known state.\n                    // events_after is already backwards; events_before is forwards.\n                    ...resNewer.chunk.reverse().filter(getRelationsThreadFilter(thread.id)).map(mapper),\n                    event,\n                    ...resOlder.chunk.filter(getRelationsThreadFilter(thread.id)).map(mapper),\n                ];\n\n                for (const event of events) {\n                    await timelineSet.thread?.processEvent(event);\n                }\n\n                // Here we handle non-thread timelines only, but still process any thread events to populate thread summaries.\n                let timeline = timelineSet.getTimelineForEvent(event.getId());\n                if (timeline) {\n                    timeline.getState(EventTimeline.BACKWARDS)!.setUnknownStateEvents(res.state.map(mapper));\n                } else {\n                    timeline = timelineSet.addTimeline();\n                    timeline.initialiseState(res.state.map(mapper));\n                }\n\n                timelineSet.addEventsToTimeline(events, true, false, timeline, resNewer.next_batch);\n                if (!resOlder.next_batch) {\n                    const originalEvent = await this.fetchRoomEvent(timelineSet.room.roomId, thread.id);\n                    timelineSet.addEventsToTimeline([mapper(originalEvent)], true, false, timeline, null);\n                }\n                timeline.setPaginationToken(resOlder.next_batch ?? null, Direction.Backward);\n                timeline.setPaginationToken(resNewer.next_batch ?? null, Direction.Forward);\n                this.processAggregatedTimelineEvents(timelineSet.room, events);\n\n                // There is no guarantee that the event ended up in \"timeline\" (we might have switched to a neighbouring\n                // timeline) - so check the room's index again. On the other hand, there's no guarantee the event ended up\n                // anywhere, if it was later redacted, so we just return the timeline we first thought of.\n                return timelineSet.getTimelineForEvent(eventId) ?? timeline;\n            } else {\n                // Where the event is a thread reply (not a root) and running in MSC-enabled mode the Thread timeline only\n                // functions contiguously, so we have to jump through some hoops to get our target event in it.\n                // XXX: workaround for https://github.com/vector-im/element-meta/issues/150\n\n                const thread = timelineSet.thread;\n\n                const resOlder = await this.fetchRelations(\n                    timelineSet.room.roomId,\n                    thread.id,\n                    THREAD_RELATION_TYPE.name,\n                    null,\n                    { dir: Direction.Backward, from: res.start, recurse: recurse || undefined },\n                );\n                const eventsNewer: IEvent[] = [];\n                let nextBatch = res.end;\n                while (nextBatch) {\n                    const resNewer: IRelationsResponse = await this.fetchRelations(\n                        timelineSet.room.roomId,\n                        thread.id,\n                        THREAD_RELATION_TYPE.name,\n                        null,\n                        { dir: Direction.Forward, from: nextBatch, recurse: recurse || undefined },\n                    );\n                    nextBatch = resNewer.next_batch;\n                    eventsNewer.push(...resNewer.chunk);\n                }\n                const events = [\n                    // Order events from most recent to oldest (reverse-chronological).\n                    // We start with the last event, since that's the point at which we have known state.\n                    // events_after is already backwards; events_before is forwards.\n                    ...eventsNewer.reverse().map(mapper),\n                    event,\n                    ...resOlder.chunk.map(mapper),\n                ];\n                for (const event of events) {\n                    await timelineSet.thread?.processEvent(event);\n                }\n\n                // Here we handle non-thread timelines only, but still process any thread events to populate thread\n                // summaries.\n                const timeline = timelineSet.getLiveTimeline();\n                timeline.getState(EventTimeline.BACKWARDS)!.setUnknownStateEvents(res.state.map(mapper));\n\n                timelineSet.addEventsToTimeline(events, true, false, timeline, null);\n                if (!resOlder.next_batch) {\n                    const originalEvent = await this.fetchRoomEvent(timelineSet.room.roomId, thread.id);\n                    timelineSet.addEventsToTimeline([mapper(originalEvent)], true, false, timeline, null);\n                }\n                timeline.setPaginationToken(resOlder.next_batch ?? null, Direction.Backward);\n                timeline.setPaginationToken(null, Direction.Forward);\n                this.processAggregatedTimelineEvents(timelineSet.room, events);\n\n                return timeline;\n            }\n        }\n    }\n\n    /**\n     * Get an EventTimeline for the latest events in the room. This will just\n     * call `/messages` to get the latest message in the room, then use\n     * `client.getEventTimeline(...)` to construct a new timeline from it.\n     *\n     * @param timelineSet -  The timelineSet to find or add the timeline to\n     *\n     * @returns Promise which resolves:\n     *    {@link EventTimeline} timeline with the latest events in the room\n     */\n    public async getLatestTimeline(timelineSet: EventTimelineSet): Promise<EventTimeline | null> {\n        // don't allow any timeline support unless it's been enabled.\n        if (!this.timelineSupport) {\n            throw new Error(\n                \"timeline support is disabled. Set the 'timelineSupport'\" +\n                    \" parameter to true when creating MatrixClient to enable it.\",\n            );\n        }\n\n        if (!timelineSet.room) {\n            throw new Error(\"getLatestTimeline only supports room timelines\");\n        }\n\n        let event: IRoomEvent | undefined;\n        if (timelineSet.threadListType !== null) {\n            const res = await this.createThreadListMessagesRequest(\n                timelineSet.room.roomId,\n                null,\n                1,\n                Direction.Backward,\n                timelineSet.threadListType,\n                timelineSet.getFilter(),\n            );\n            event = res.chunk?.[0];\n        } else if (timelineSet.thread && Thread.hasServerSideSupport) {\n            const recurse = this.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n            const res = await this.fetchRelations(\n                timelineSet.room.roomId,\n                timelineSet.thread.id,\n                THREAD_RELATION_TYPE.name,\n                null,\n                { dir: Direction.Backward, limit: 1, recurse: recurse || undefined },\n            );\n            event = res.chunk?.[0];\n        } else {\n            const messagesPath = utils.encodeUri(\"/rooms/$roomId/messages\", {\n                $roomId: timelineSet.room.roomId,\n            });\n\n            const params: Record<string, string | string[]> = {\n                dir: \"b\",\n            };\n            if (this.clientOpts?.lazyLoadMembers) {\n                params.filter = JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER);\n            }\n\n            const res = await this.http.authedRequest<IMessagesResponse>(Method.Get, messagesPath, params);\n            event = res.chunk?.[0];\n        }\n        if (!event) {\n            throw new Error(\"No message returned when trying to construct getLatestTimeline\");\n        }\n\n        return this.getEventTimeline(timelineSet, event.event_id);\n    }\n\n    /**\n     * Makes a request to /messages with the appropriate lazy loading filter set.\n     * XXX: if we do get rid of scrollback (as it's not used at the moment),\n     * we could inline this method again in paginateEventTimeline as that would\n     * then be the only call-site\n     * @param limit - the maximum amount of events the retrieve\n     * @param dir - 'f' or 'b'\n     * @param timelineFilter - the timeline filter to pass\n     */\n    // XXX: Intended private, used in code.\n    public createMessagesRequest(\n        roomId: string,\n        fromToken: string | null,\n        limit = 30,\n        dir: Direction,\n        timelineFilter?: Filter,\n    ): Promise<IMessagesResponse> {\n        const path = utils.encodeUri(\"/rooms/$roomId/messages\", { $roomId: roomId });\n\n        const params: Record<string, string> = {\n            limit: limit.toString(),\n            dir: dir,\n        };\n\n        if (fromToken) {\n            params.from = fromToken;\n        }\n\n        let filter: IRoomEventFilter | null = null;\n        if (this.clientOpts?.lazyLoadMembers) {\n            // create a shallow copy of LAZY_LOADING_MESSAGES_FILTER,\n            // so the timelineFilter doesn't get written into it below\n            filter = Object.assign({}, Filter.LAZY_LOADING_MESSAGES_FILTER);\n        }\n        if (timelineFilter) {\n            // XXX: it's horrific that /messages' filter parameter doesn't match\n            // /sync's one - see https://matrix.org/jira/browse/SPEC-451\n            filter = filter || {};\n            Object.assign(filter, timelineFilter.getRoomTimelineFilterComponent()?.toJSON());\n        }\n        if (filter) {\n            params.filter = JSON.stringify(filter);\n        }\n        return this.http.authedRequest(Method.Get, path, params);\n    }\n\n    /**\n     * Makes a request to /messages with the appropriate lazy loading filter set.\n     * XXX: if we do get rid of scrollback (as it's not used at the moment),\n     * we could inline this method again in paginateEventTimeline as that would\n     * then be the only call-site\n     * @param limit - the maximum amount of events the retrieve\n     * @param dir - 'f' or 'b'\n     * @param timelineFilter - the timeline filter to pass\n     */\n    // XXX: Intended private, used by room.fetchRoomThreads\n    public createThreadListMessagesRequest(\n        roomId: string,\n        fromToken: string | null,\n        limit = 30,\n        dir = Direction.Backward,\n        threadListType: ThreadFilterType | null = ThreadFilterType.All,\n        timelineFilter?: Filter,\n    ): Promise<IMessagesResponse> {\n        const path = utils.encodeUri(\"/rooms/$roomId/threads\", { $roomId: roomId });\n\n        const params: Record<string, string> = {\n            limit: limit.toString(),\n            dir: dir,\n            include: threadFilterTypeToFilter(threadListType),\n        };\n\n        if (fromToken) {\n            params.from = fromToken;\n        }\n\n        let filter: IRoomEventFilter = {};\n        if (this.clientOpts?.lazyLoadMembers) {\n            // create a shallow copy of LAZY_LOADING_MESSAGES_FILTER,\n            // so the timelineFilter doesn't get written into it below\n            filter = {\n                ...Filter.LAZY_LOADING_MESSAGES_FILTER,\n            };\n        }\n        if (timelineFilter) {\n            // XXX: it's horrific that /messages' filter parameter doesn't match\n            // /sync's one - see https://matrix.org/jira/browse/SPEC-451\n            filter = {\n                ...filter,\n                ...timelineFilter.getRoomTimelineFilterComponent()?.toJSON(),\n            };\n        }\n        if (Object.keys(filter).length) {\n            params.filter = JSON.stringify(filter);\n        }\n\n        const opts = {\n            prefix:\n                Thread.hasServerSideListSupport === FeatureSupport.Stable\n                    ? ClientPrefix.V1\n                    : \"/_matrix/client/unstable/org.matrix.msc3856\",\n        };\n\n        return this.http\n            .authedRequest<IThreadedMessagesResponse>(Method.Get, path, params, undefined, opts)\n            .then((res) => ({\n                ...res,\n                chunk: res.chunk?.reverse(),\n                start: res.prev_batch,\n                end: res.next_batch,\n            }));\n    }\n\n    /**\n     * Take an EventTimeline, and back/forward-fill results.\n     *\n     * @param eventTimeline - timeline object to be updated\n     *\n     * @returns Promise which resolves to a boolean: false if there are no\n     *    events and we reached either end of the timeline; else true.\n     */\n    public paginateEventTimeline(eventTimeline: EventTimeline, opts: IPaginateOpts): Promise<boolean> {\n        const isNotifTimeline = eventTimeline.getTimelineSet() === this.notifTimelineSet;\n        const room = this.getRoom(eventTimeline.getRoomId()!);\n        const threadListType = eventTimeline.getTimelineSet().threadListType;\n        const thread = eventTimeline.getTimelineSet().thread;\n\n        // TODO: we should implement a backoff (as per scrollback()) to deal more\n        // nicely with HTTP errors.\n        opts = opts || {};\n        const backwards = opts.backwards || false;\n\n        if (isNotifTimeline) {\n            if (!backwards) {\n                throw new Error(\"paginateNotifTimeline can only paginate backwards\");\n            }\n        }\n\n        const dir = backwards ? EventTimeline.BACKWARDS : EventTimeline.FORWARDS;\n\n        const token = eventTimeline.getPaginationToken(dir);\n        const pendingRequest = eventTimeline.paginationRequests[dir];\n\n        if (pendingRequest) {\n            // already a request in progress - return the existing promise\n            return pendingRequest;\n        }\n\n        let path: string;\n        let params: Record<string, string>;\n        let promise: Promise<boolean>;\n\n        if (isNotifTimeline) {\n            path = \"/notifications\";\n            params = {\n                limit: (opts.limit ?? 30).toString(),\n                only: \"highlight\",\n            };\n\n            if (token && token !== \"end\") {\n                params.from = token;\n            }\n\n            promise = this.http\n                .authedRequest<INotificationsResponse>(Method.Get, path, params)\n                .then(async (res) => {\n                    const token = res.next_token;\n                    const matrixEvents: MatrixEvent[] = [];\n\n                    res.notifications = res.notifications.filter(noUnsafeEventProps);\n\n                    for (let i = 0; i < res.notifications.length; i++) {\n                        const notification = res.notifications[i];\n                        const event = this.getEventMapper()(notification.event);\n\n                        // @TODO(kerrya) reprocessing every notification is ugly\n                        // remove if we get server MSC3994 support\n                        this.getPushDetailsForEvent(event, true);\n\n                        event.event.room_id = notification.room_id; // XXX: gutwrenching\n                        matrixEvents[i] = event;\n                    }\n\n                    // No need to partition events for threads here, everything lives\n                    // in the notification timeline set\n                    const timelineSet = eventTimeline.getTimelineSet();\n                    timelineSet.addEventsToTimeline(matrixEvents, backwards, false, eventTimeline, token);\n                    this.processAggregatedTimelineEvents(timelineSet.room, matrixEvents);\n\n                    // if we've hit the end of the timeline, we need to stop trying to\n                    // paginate. We need to keep the 'forwards' token though, to make sure\n                    // we can recover from gappy syncs.\n                    if (backwards && !res.next_token) {\n                        eventTimeline.setPaginationToken(null, dir);\n                    }\n                    return Boolean(res.next_token);\n                })\n                .finally(() => {\n                    eventTimeline.paginationRequests[dir] = null;\n                });\n            eventTimeline.paginationRequests[dir] = promise;\n        } else if (threadListType !== null) {\n            if (!room) {\n                throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n            }\n\n            if (!Thread.hasServerSideFwdPaginationSupport && dir === Direction.Forward) {\n                throw new Error(\"Cannot paginate threads forwards without server-side support for MSC 3715\");\n            }\n\n            promise = this.createThreadListMessagesRequest(\n                eventTimeline.getRoomId()!,\n                token,\n                opts.limit,\n                dir,\n                threadListType,\n                eventTimeline.getFilter(),\n            )\n                .then((res) => {\n                    if (res.state) {\n                        const roomState = eventTimeline.getState(dir)!;\n                        const stateEvents = res.state.filter(noUnsafeEventProps).map(this.getEventMapper());\n                        roomState.setUnknownStateEvents(stateEvents);\n                    }\n\n                    const token = res.end;\n                    const matrixEvents = res.chunk.filter(noUnsafeEventProps).map(this.getEventMapper());\n\n                    const timelineSet = eventTimeline.getTimelineSet();\n                    timelineSet.addEventsToTimeline(matrixEvents, backwards, false, eventTimeline, token);\n                    this.processAggregatedTimelineEvents(room, matrixEvents);\n                    this.processThreadRoots(room, matrixEvents, backwards);\n\n                    // if we've hit the end of the timeline, we need to stop trying to\n                    // paginate. We need to keep the 'forwards' token though, to make sure\n                    // we can recover from gappy syncs.\n                    if (backwards && res.end == res.start) {\n                        eventTimeline.setPaginationToken(null, dir);\n                    }\n                    return res.end !== res.start;\n                })\n                .finally(() => {\n                    eventTimeline.paginationRequests[dir] = null;\n                });\n            eventTimeline.paginationRequests[dir] = promise;\n        } else if (thread) {\n            const room = this.getRoom(eventTimeline.getRoomId() ?? undefined);\n            if (!room) {\n                throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n            }\n\n            const recurse = this.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n            promise = this.fetchRelations(eventTimeline.getRoomId() ?? \"\", thread.id, null, null, {\n                dir,\n                limit: opts.limit,\n                from: token ?? undefined,\n                recurse: recurse || undefined,\n            })\n                .then(async (res) => {\n                    const mapper = this.getEventMapper();\n                    const matrixEvents = res.chunk\n                        .filter(noUnsafeEventProps)\n                        .filter(getRelationsThreadFilter(thread.id))\n                        .map(mapper);\n\n                    // Process latest events first\n                    for (const event of matrixEvents.slice().reverse()) {\n                        await thread?.processEvent(event);\n                        const sender = event.getSender()!;\n                        if (!backwards || thread?.getEventReadUpTo(sender) === null) {\n                            room.addLocalEchoReceipt(sender, event, ReceiptType.Read);\n                        }\n                    }\n\n                    const newToken = res.next_batch;\n\n                    const timelineSet = eventTimeline.getTimelineSet();\n                    timelineSet.addEventsToTimeline(matrixEvents, backwards, false, eventTimeline, newToken ?? null);\n                    if (!newToken && backwards) {\n                        const originalEvent =\n                            thread.rootEvent ??\n                            mapper(await this.fetchRoomEvent(eventTimeline.getRoomId() ?? \"\", thread.id));\n                        timelineSet.addEventsToTimeline([originalEvent], true, false, eventTimeline, null);\n                    }\n                    this.processAggregatedTimelineEvents(timelineSet.room, matrixEvents);\n\n                    // if we've hit the end of the timeline, we need to stop trying to\n                    // paginate. We need to keep the 'forwards' token though, to make sure\n                    // we can recover from gappy syncs.\n                    if (backwards && !newToken) {\n                        eventTimeline.setPaginationToken(null, dir);\n                    }\n                    return Boolean(newToken);\n                })\n                .finally(() => {\n                    eventTimeline.paginationRequests[dir] = null;\n                });\n            eventTimeline.paginationRequests[dir] = promise;\n        } else {\n            if (!room) {\n                throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n            }\n\n            promise = this.createMessagesRequest(\n                eventTimeline.getRoomId()!,\n                token,\n                opts.limit,\n                dir,\n                eventTimeline.getFilter(),\n            )\n                .then((res) => {\n                    if (res.state) {\n                        const roomState = eventTimeline.getState(dir)!;\n                        const stateEvents = res.state.filter(noUnsafeEventProps).map(this.getEventMapper());\n                        roomState.setUnknownStateEvents(stateEvents);\n                    }\n                    const token = res.end;\n                    const matrixEvents = res.chunk.filter(noUnsafeEventProps).map(this.getEventMapper());\n\n                    const timelineSet = eventTimeline.getTimelineSet();\n                    const [timelineEvents, , unknownRelations] = room.partitionThreadedEvents(matrixEvents);\n                    timelineSet.addEventsToTimeline(timelineEvents, backwards, false, eventTimeline, token);\n                    this.processAggregatedTimelineEvents(room, timelineEvents);\n                    this.processThreadRoots(\n                        room,\n                        timelineEvents.filter((it) => it.getServerAggregatedRelation(THREAD_RELATION_TYPE.name)),\n                        false,\n                    );\n                    unknownRelations.forEach((event) => room.relations.aggregateChildEvent(event));\n\n                    const atEnd = res.end === undefined || res.end === res.start;\n\n                    // if we've hit the end of the timeline, we need to stop trying to\n                    // paginate. We need to keep the 'forwards' token though, to make sure\n                    // we can recover from gappy syncs.\n                    if (backwards && atEnd) {\n                        eventTimeline.setPaginationToken(null, dir);\n                    }\n                    return !atEnd;\n                })\n                .finally(() => {\n                    eventTimeline.paginationRequests[dir] = null;\n                });\n            eventTimeline.paginationRequests[dir] = promise;\n        }\n\n        return promise;\n    }\n\n    /**\n     * Reset the notifTimelineSet entirely, paginating in some historical notifs as\n     * a starting point for subsequent pagination.\n     */\n    public resetNotifTimelineSet(): void {\n        if (!this.notifTimelineSet) {\n            return;\n        }\n\n        // FIXME: This thing is a total hack, and results in duplicate events being\n        // added to the timeline both from /sync and /notifications, and lots of\n        // slow and wasteful processing and pagination.  The correct solution is to\n        // extend /messages or /search or something to filter on notifications.\n\n        // use the fictitious token 'end'. in practice we would ideally give it\n        // the oldest backwards pagination token from /sync, but /sync doesn't\n        // know about /notifications, so we have no choice but to start paginating\n        // from the current point in time.  This may well overlap with historical\n        // notifs which are then inserted into the timeline by /sync responses.\n        this.notifTimelineSet.resetLiveTimeline(\"end\");\n\n        // we could try to paginate a single event at this point in order to get\n        // a more valid pagination token, but it just ends up with an out of order\n        // timeline. given what a mess this is and given we're going to have duplicate\n        // events anyway, just leave it with the dummy token for now.\n        /*\n        this.paginateNotifTimeline(this._notifTimelineSet.getLiveTimeline(), {\n            backwards: true,\n            limit: 1\n        });\n        */\n    }\n\n    /**\n     * Peek into a room and receive updates about the room. This only works if the\n     * history visibility for the room is world_readable.\n     * @param roomId - The room to attempt to peek into.\n     * @param limit - The number of timeline events to initially retrieve.\n     * @returns Promise which resolves: Room object\n     * @returns Rejects: with an error response.\n     */\n    public peekInRoom(roomId: string, limit: number = 20): Promise<Room> {\n        this.peekSync?.stopPeeking();\n        this.peekSync = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n        return this.peekSync.peek(roomId, limit);\n    }\n\n    /**\n     * Stop any ongoing room peeking.\n     */\n    public stopPeeking(): void {\n        if (this.peekSync) {\n            this.peekSync.stopPeeking();\n            this.peekSync = null;\n        }\n    }\n\n    /**\n     * Set r/w flags for guest access in a room.\n     * @param roomId - The room to configure guest access in.\n     * @param opts - Options\n     * @returns Promise which resolves\n     * @returns Rejects: with an error response.\n     */\n    public setGuestAccess(roomId: string, opts: IGuestAccessOpts): Promise<void> {\n        const writePromise = this.sendStateEvent(\n            roomId,\n            EventType.RoomGuestAccess,\n            {\n                guest_access: opts.allowJoin ? GuestAccess.CanJoin : GuestAccess.Forbidden,\n            },\n            \"\",\n        );\n\n        let readPromise: Promise<unknown> = Promise.resolve();\n        if (opts.allowRead) {\n            readPromise = this.sendStateEvent(\n                roomId,\n                EventType.RoomHistoryVisibility,\n                {\n                    history_visibility: HistoryVisibility.WorldReadable,\n                },\n                \"\",\n            );\n        }\n\n        return Promise.all([readPromise, writePromise]).then(); // .then() to hide results for contract\n    }\n\n    /**\n     * Requests an email verification token for the purposes of registration.\n     * This API requests a token from the homeserver.\n     * The doesServerRequireIdServerParam() method can be used to determine if\n     * the server requires the id_server parameter to be provided.\n     *\n     * Parameters and return value are as for requestEmailToken\n\n     * @param email - As requestEmailToken\n     * @param clientSecret - As requestEmailToken\n     * @param sendAttempt - As requestEmailToken\n     * @param nextLink - As requestEmailToken\n     * @returns Promise which resolves: As requestEmailToken\n     */\n    public requestRegisterEmailToken(\n        email: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink?: string,\n    ): Promise<IRequestTokenResponse> {\n        return this.requestTokenFromEndpoint(\"/register/email/requestToken\", {\n            email: email,\n            client_secret: clientSecret,\n            send_attempt: sendAttempt,\n            next_link: nextLink,\n        });\n    }\n\n    /**\n     * Requests a text message verification token for the purposes of registration.\n     * This API requests a token from the homeserver.\n     * The doesServerRequireIdServerParam() method can be used to determine if\n     * the server requires the id_server parameter to be provided.\n     *\n     * @param phoneCountry - The ISO 3166-1 alpha-2 code for the country in which\n     *    phoneNumber should be parsed relative to.\n     * @param phoneNumber - The phone number, in national or international format\n     * @param clientSecret - As requestEmailToken\n     * @param sendAttempt - As requestEmailToken\n     * @param nextLink - As requestEmailToken\n     * @returns Promise which resolves: As requestEmailToken\n     */\n    public requestRegisterMsisdnToken(\n        phoneCountry: string,\n        phoneNumber: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink?: string,\n    ): Promise<IRequestMsisdnTokenResponse> {\n        return this.requestTokenFromEndpoint(\"/register/msisdn/requestToken\", {\n            country: phoneCountry,\n            phone_number: phoneNumber,\n            client_secret: clientSecret,\n            send_attempt: sendAttempt,\n            next_link: nextLink,\n        });\n    }\n\n    /**\n     * Requests an email verification token for the purposes of adding a\n     * third party identifier to an account.\n     * This API requests a token from the homeserver.\n     * The doesServerRequireIdServerParam() method can be used to determine if\n     * the server requires the id_server parameter to be provided.\n     * If an account with the given email address already exists and is\n     * associated with an account other than the one the user is authed as,\n     * it will either send an email to the address informing them of this\n     * or return M_THREEPID_IN_USE (which one is up to the homeserver).\n     *\n     * @param email - As requestEmailToken\n     * @param clientSecret - As requestEmailToken\n     * @param sendAttempt - As requestEmailToken\n     * @param nextLink - As requestEmailToken\n     * @returns Promise which resolves: As requestEmailToken\n     */\n    public requestAdd3pidEmailToken(\n        email: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink?: string,\n    ): Promise<IRequestTokenResponse> {\n        return this.requestTokenFromEndpoint(\"/account/3pid/email/requestToken\", {\n            email: email,\n            client_secret: clientSecret,\n            send_attempt: sendAttempt,\n            next_link: nextLink,\n        });\n    }\n\n    /**\n     * Requests a text message verification token for the purposes of adding a\n     * third party identifier to an account.\n     * This API proxies the identity server /validate/email/requestToken API,\n     * adding specific behaviour for the addition of phone numbers to an\n     * account, as requestAdd3pidEmailToken.\n     *\n     * @param phoneCountry - As requestRegisterMsisdnToken\n     * @param phoneNumber - As requestRegisterMsisdnToken\n     * @param clientSecret - As requestEmailToken\n     * @param sendAttempt - As requestEmailToken\n     * @param nextLink - As requestEmailToken\n     * @returns Promise which resolves: As requestEmailToken\n     */\n    public requestAdd3pidMsisdnToken(\n        phoneCountry: string,\n        phoneNumber: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink?: string,\n    ): Promise<IRequestMsisdnTokenResponse> {\n        return this.requestTokenFromEndpoint(\"/account/3pid/msisdn/requestToken\", {\n            country: phoneCountry,\n            phone_number: phoneNumber,\n            client_secret: clientSecret,\n            send_attempt: sendAttempt,\n            next_link: nextLink,\n        });\n    }\n\n    /**\n     * Requests an email verification token for the purposes of resetting\n     * the password on an account.\n     * This API proxies the identity server /validate/email/requestToken API,\n     * adding specific behaviour for the password resetting. Specifically,\n     * if no account with the given email address exists, it may either\n     * return M_THREEPID_NOT_FOUND or send an email\n     * to the address informing them of this (which one is up to the homeserver).\n     *\n     * requestEmailToken calls the equivalent API directly on the identity server,\n     * therefore bypassing the password reset specific logic.\n     *\n     * @param email - As requestEmailToken\n     * @param clientSecret - As requestEmailToken\n     * @param sendAttempt - As requestEmailToken\n     * @param nextLink - As requestEmailToken\n     * @returns Promise which resolves: As requestEmailToken\n     */\n    public requestPasswordEmailToken(\n        email: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink?: string,\n    ): Promise<IRequestTokenResponse> {\n        return this.requestTokenFromEndpoint(\"/account/password/email/requestToken\", {\n            email: email,\n            client_secret: clientSecret,\n            send_attempt: sendAttempt,\n            next_link: nextLink,\n        });\n    }\n\n    /**\n     * Requests a text message verification token for the purposes of resetting\n     * the password on an account.\n     * This API proxies the identity server /validate/email/requestToken API,\n     * adding specific behaviour for the password resetting, as requestPasswordEmailToken.\n     *\n     * @param phoneCountry - As requestRegisterMsisdnToken\n     * @param phoneNumber - As requestRegisterMsisdnToken\n     * @param clientSecret - As requestEmailToken\n     * @param sendAttempt - As requestEmailToken\n     * @param nextLink - As requestEmailToken\n     * @returns Promise which resolves: As requestEmailToken\n     */\n    public requestPasswordMsisdnToken(\n        phoneCountry: string,\n        phoneNumber: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink: string,\n    ): Promise<IRequestMsisdnTokenResponse> {\n        return this.requestTokenFromEndpoint(\"/account/password/msisdn/requestToken\", {\n            country: phoneCountry,\n            phone_number: phoneNumber,\n            client_secret: clientSecret,\n            send_attempt: sendAttempt,\n            next_link: nextLink,\n        });\n    }\n\n    /**\n     * Internal utility function for requesting validation tokens from usage-specific\n     * requestToken endpoints.\n     *\n     * @param endpoint - The endpoint to send the request to\n     * @param params - Parameters for the POST request\n     * @returns Promise which resolves: As requestEmailToken\n     */\n    private async requestTokenFromEndpoint<T extends IRequestTokenResponse>(\n        endpoint: string,\n        params: QueryDict,\n    ): Promise<T> {\n        const postParams = Object.assign({}, params);\n\n        return this.http.request(Method.Post, endpoint, undefined, postParams);\n    }\n\n    /**\n     * Get the room-kind push rule associated with a room.\n     * @param scope - \"global\" or device-specific.\n     * @param roomId - the id of the room.\n     * @returns the rule or undefined.\n     */\n    public getRoomPushRule(scope: \"global\" | \"device\", roomId: string): IPushRule | undefined {\n        // There can be only room-kind push rule per room\n        // and its id is the room id.\n        if (this.pushRules) {\n            return this.pushRules[scope]?.room?.find((rule) => rule.rule_id === roomId);\n        } else {\n            throw new Error(\"SyncApi.sync() must be done before accessing to push rules.\");\n        }\n    }\n\n    /**\n     * Set a room-kind muting push rule in a room.\n     * The operation also updates MatrixClient.pushRules at the end.\n     * @param scope - \"global\" or device-specific.\n     * @param roomId - the id of the room.\n     * @param mute - the mute state.\n     * @returns Promise which resolves: result object\n     * @returns Rejects: with an error response.\n     */\n    public setRoomMutePushRule(scope: \"global\" | \"device\", roomId: string, mute: boolean): Promise<void> | undefined {\n        let promise: Promise<unknown> | undefined;\n        let hasDontNotifyRule = false;\n\n        // Get the existing room-kind push rule if any\n        const roomPushRule = this.getRoomPushRule(scope, roomId);\n        if (roomPushRule?.actions.includes(PushRuleActionName.DontNotify)) {\n            hasDontNotifyRule = true;\n        }\n\n        if (!mute) {\n            // Remove the rule only if it is a muting rule\n            if (hasDontNotifyRule) {\n                promise = this.deletePushRule(scope, PushRuleKind.RoomSpecific, roomPushRule!.rule_id);\n            }\n        } else {\n            if (!roomPushRule) {\n                promise = this.addPushRule(scope, PushRuleKind.RoomSpecific, roomId, {\n                    actions: [PushRuleActionName.DontNotify],\n                });\n            } else if (!hasDontNotifyRule) {\n                // Remove the existing one before setting the mute push rule\n                // This is a workaround to SYN-590 (Push rule update fails)\n                const doneResolvers = Promise.withResolvers<void>();\n                this.deletePushRule(scope, PushRuleKind.RoomSpecific, roomPushRule.rule_id)\n                    .then(() => {\n                        this.addPushRule(scope, PushRuleKind.RoomSpecific, roomId, {\n                            actions: [PushRuleActionName.DontNotify],\n                        })\n                            .then(() => {\n                                doneResolvers.resolve();\n                            })\n                            .catch((err) => {\n                                doneResolvers.reject(err);\n                            });\n                    })\n                    .catch((err) => {\n                        doneResolvers.reject(err);\n                    });\n\n                promise = doneResolvers.promise;\n            }\n        }\n\n        if (promise) {\n            return new Promise<void>((resolve, reject) => {\n                // Update this.pushRules when the operation completes\n                promise!\n                    .then(() => {\n                        this.getPushRules()\n                            .then((result) => {\n                                this.pushRules = result;\n                                resolve();\n                            })\n                            .catch((err) => {\n                                reject(err);\n                            });\n                    })\n                    .catch((err: Error) => {\n                        // Update it even if the previous operation fails. This can help the\n                        // app to recover when push settings has been modified from another client\n                        this.getPushRules()\n                            .then((result) => {\n                                this.pushRules = result;\n                                reject(err);\n                            })\n                            .catch((err2) => {\n                                reject(err);\n                            });\n                    });\n            });\n        }\n    }\n\n    public searchMessageText(opts: ISearchOpts): Promise<ISearchResponse> {\n        const roomEvents: ISearchRequestBody[\"search_categories\"][\"room_events\"] = {\n            search_term: opts.query,\n        };\n\n        if (\"keys\" in opts) {\n            roomEvents.keys = opts.keys;\n        }\n\n        return this.search({\n            body: {\n                search_categories: {\n                    room_events: roomEvents,\n                },\n            },\n        });\n    }\n\n    /**\n     * Perform a server-side search for room events.\n     *\n     * The returned promise resolves to an object containing the fields:\n     *\n     *  * count:       estimate of the number of results\n     *  * next_batch:  token for back-pagination; if undefined, there are no more results\n     *  * highlights:  a list of words to highlight from the stemming algorithm\n     *  * results:     a list of results\n     *\n     * Each entry in the results list is a SearchResult.\n     *\n     * @returns Promise which resolves: result object\n     * @returns Rejects: with an error response.\n     */\n    public searchRoomEvents(opts: IEventSearchOpts): Promise<ISearchResults> {\n        // TODO: support search groups\n\n        const body = {\n            search_categories: {\n                room_events: {\n                    search_term: opts.term,\n                    filter: opts.filter,\n                    order_by: SearchOrderBy.Recent,\n                    event_context: {\n                        before_limit: 1,\n                        after_limit: 1,\n                        include_profile: true,\n                    },\n                },\n            },\n        };\n\n        const searchResults: ISearchResults = {\n            _query: body,\n            results: [],\n            highlights: [],\n        };\n\n        return this.search({ body: body }).then((res) => this.processRoomEventsSearch(searchResults, res));\n    }\n\n    /**\n     * Take a result from an earlier searchRoomEvents call, and backfill results.\n     *\n     * @param searchResults -  the results object to be updated\n     * @returns Promise which resolves: updated result object\n     * @returns Rejects: with an error response.\n     */\n    public backPaginateRoomEventsSearch<T extends ISearchResults>(searchResults: T): Promise<T> {\n        // TODO: we should implement a backoff (as per scrollback()) to deal more\n        // nicely with HTTP errors.\n\n        if (!searchResults.next_batch) {\n            return Promise.reject(new Error(\"Cannot backpaginate event search any further\"));\n        }\n\n        if (searchResults.pendingRequest) {\n            // already a request in progress - return the existing promise\n            return searchResults.pendingRequest as Promise<T>;\n        }\n\n        const searchOpts = {\n            body: searchResults._query!,\n            next_batch: searchResults.next_batch,\n        };\n\n        const promise = this.search(searchOpts, searchResults.abortSignal)\n            .then((res) => this.processRoomEventsSearch(searchResults, res))\n            .finally(() => {\n                searchResults.pendingRequest = undefined;\n            });\n        searchResults.pendingRequest = promise;\n\n        return promise;\n    }\n\n    /**\n     * helper for searchRoomEvents and backPaginateRoomEventsSearch. Processes the\n     * response from the API call and updates the searchResults\n     *\n     * @returns searchResults\n     * @internal\n     */\n    // XXX: Intended private, used in code\n    public processRoomEventsSearch<T extends ISearchResults>(searchResults: T, response: ISearchResponse): T {\n        const roomEvents = response.search_categories.room_events;\n\n        searchResults.count = roomEvents.count;\n        searchResults.next_batch = roomEvents.next_batch;\n\n        // combine the highlight list with our existing list;\n        const highlights = new Set<string>(roomEvents.highlights);\n        searchResults.highlights.forEach((hl) => {\n            highlights.add(hl);\n        });\n\n        // turn it back into a list.\n        searchResults.highlights = Array.from(highlights);\n\n        const mapper = this.getEventMapper();\n\n        // append the new results to our existing results\n        const resultsLength = roomEvents.results?.length ?? 0;\n        for (let i = 0; i < resultsLength; i++) {\n            const sr = SearchResult.fromJson(roomEvents.results![i], mapper);\n            const room = this.getRoom(sr.context.getEvent().getRoomId());\n            if (room) {\n                for (const ev of sr.context.getTimeline()) {\n                    ev.setMetadata(room.currentState, false);\n                }\n            }\n            searchResults.results.push(sr);\n        }\n        return searchResults;\n    }\n\n    /**\n     * Populate the store with rooms the user has left.\n     * @returns Promise which resolves: TODO - Resolved when the rooms have\n     * been added to the data store.\n     * @returns Rejects: with an error response.\n     */\n    public syncLeftRooms(): Promise<Room[]> {\n        // Guard against multiple calls whilst ongoing and multiple calls post success\n        if (this.syncedLeftRooms) {\n            return Promise.resolve([]); // don't call syncRooms again if it succeeded.\n        }\n        if (this.syncLeftRoomsPromise) {\n            return this.syncLeftRoomsPromise; // return the ongoing request\n        }\n        const syncApi = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n        this.syncLeftRoomsPromise = syncApi.syncLeftRooms();\n\n        // cleanup locks\n        this.syncLeftRoomsPromise\n            .then(() => {\n                this.logger.debug(\"Marking success of sync left room request\");\n                this.syncedLeftRooms = true; // flip the bit on success\n            })\n            .finally(() => {\n                this.syncLeftRoomsPromise = undefined; // cleanup ongoing request state\n            });\n\n        return this.syncLeftRoomsPromise;\n    }\n\n    /**\n     * Create a new filter.\n     * @param content - The HTTP body for the request\n     * @returns Promise which resolves to a Filter object.\n     * @returns Rejects: with an error response.\n     */\n    public createFilter(content: IFilterDefinition): Promise<Filter> {\n        const path = utils.encodeUri(\"/user/$userId/filter\", {\n            $userId: this.credentials.userId!,\n        });\n        return this.http.authedRequest<IFilterResponse>(Method.Post, path, undefined, content).then((response) => {\n            // persist the filter\n            const filter = Filter.fromJson(this.credentials.userId, response.filter_id, content);\n            this.store.storeFilter(filter);\n            return filter;\n        });\n    }\n\n    /**\n     * Retrieve a filter.\n     * @param userId - The user ID of the filter owner\n     * @param filterId - The filter ID to retrieve\n     * @param allowCached - True to allow cached filters to be returned.\n     * Default: True.\n     * @returns Promise which resolves: a Filter object\n     * @returns Rejects: with an error response.\n     */\n    public getFilter(userId: string, filterId: string, allowCached: boolean): Promise<Filter> {\n        if (allowCached) {\n            const filter = this.store.getFilter(userId, filterId);\n            if (filter) {\n                return Promise.resolve(filter);\n            }\n        }\n\n        const path = utils.encodeUri(\"/user/$userId/filter/$filterId\", {\n            $userId: userId,\n            $filterId: filterId,\n        });\n\n        return this.http.authedRequest<IFilterDefinition>(Method.Get, path).then((response) => {\n            // persist the filter\n            const filter = Filter.fromJson(userId, filterId, response);\n            this.store.storeFilter(filter);\n            return filter;\n        });\n    }\n\n    /**\n     * @returns Filter ID\n     */\n    public async getOrCreateFilter(filterName: string, filter: Filter): Promise<string> {\n        const filterId = this.store.getFilterIdByName(filterName);\n        let existingId: string | undefined;\n\n        if (filterId) {\n            // check that the existing filter matches our expectations\n            try {\n                const existingFilter = await this.getFilter(this.credentials.userId!, filterId, true);\n                if (existingFilter) {\n                    const oldDef = existingFilter.getDefinition();\n                    const newDef = filter.getDefinition();\n\n                    if (utils.deepCompare(oldDef, newDef)) {\n                        // super, just use that.\n                        // debuglog(\"Using existing filter ID %s: %s\", filterId,\n                        //          JSON.stringify(oldDef));\n                        existingId = filterId;\n                    }\n                }\n            } catch (error) {\n                // Synapse currently returns the following when the filter cannot be found:\n                // {\n                //     errcode: \"M_UNKNOWN\",\n                //     name: \"M_UNKNOWN\",\n                //     message: \"No row found\",\n                // }\n                if ((<MatrixError>error).errcode !== \"M_UNKNOWN\" && (<MatrixError>error).errcode !== \"M_NOT_FOUND\") {\n                    throw error;\n                }\n            }\n            // if the filter doesn't exist anymore on the server, remove from store\n            if (!existingId) {\n                this.store.setFilterIdByName(filterName, undefined);\n            }\n        }\n\n        if (existingId) {\n            return existingId;\n        }\n\n        // create a new filter\n        const createdFilter = await this.createFilter(filter.getDefinition());\n\n        this.store.setFilterIdByName(filterName, createdFilter.filterId);\n        return createdFilter.filterId!;\n    }\n\n    /**\n     * Gets a bearer token from the homeserver that the user can\n     * present to a third party in order to prove their ownership\n     * of the Matrix account they are logged into.\n     * @returns Promise which resolves: Token object\n     * @returns Rejects: with an error response.\n     */\n    public getOpenIdToken(): Promise<IOpenIDToken> {\n        const path = utils.encodeUri(\"/user/$userId/openid/request_token\", {\n            $userId: this.credentials.userId!,\n        });\n\n        return this.http.authedRequest(Method.Post, path, undefined, {});\n    }\n\n    private startCallEventHandler = (): void => {\n        if (this.isInitialSyncComplete()) {\n            if (supportsMatrixCall()) {\n                this.callEventHandler!.start();\n                this.groupCallEventHandler!.start();\n            }\n\n            this.off(ClientEvent.Sync, this.startCallEventHandler);\n        }\n    };\n\n    private startMatrixRTC = (): void => {\n        if (this.isInitialSyncComplete()) {\n            this.matrixRTC.start();\n\n            this.off(ClientEvent.Sync, this.startMatrixRTC);\n        }\n    };\n\n    /**\n     * Once the client has been initialised, we want to clear notifications we\n     * know for a fact should be here.\n     * This issue should also be addressed on synapse's side and is tracked as part\n     * of https://github.com/matrix-org/synapse/issues/14837\n     *\n     * We consider a room or a thread as fully read if the current user has sent\n     * the last event in the live timeline of that context and if the read receipt\n     * we have on record matches.\n     */\n    private fixupRoomNotifications = (): void => {\n        if (this.isInitialSyncComplete()) {\n            const unreadRooms = (this.getRooms() ?? []).filter((room) => {\n                return room.getUnreadNotificationCount(NotificationCountType.Total) > 0;\n            });\n\n            for (const room of unreadRooms) {\n                const currentUserId = this.getSafeUserId();\n                room.fixupNotifications(currentUserId);\n            }\n\n            this.off(ClientEvent.Sync, this.fixupRoomNotifications);\n        }\n    };\n\n    /**\n     * @returns Promise which resolves: ITurnServerResponse object\n     * @returns Rejects: with an error response.\n     */\n    public turnServer(): Promise<ITurnServerResponse> {\n        return this.http.authedRequest(Method.Get, \"/voip/turnServer\");\n    }\n\n    /**\n     * Get the TURN servers for this homeserver.\n     * @returns The servers or an empty list.\n     */\n    public getTurnServers(): ITurnServer[] {\n        return this.turnServers || [];\n    }\n\n    /**\n     * Get the unix timestamp (in milliseconds) at which the current\n     * TURN credentials (from getTurnServers) expire\n     * @returns The expiry timestamp in milliseconds\n     */\n    public getTurnServersExpiry(): number {\n        return this.turnServersExpiry;\n    }\n\n    public get pollingTurnServers(): boolean {\n        return this.checkTurnServersIntervalID !== undefined;\n    }\n\n    // XXX: Intended private, used in code.\n    public async checkTurnServers(): Promise<boolean | undefined> {\n        if (!this.supportsVoip()) {\n            return;\n        }\n\n        let credentialsGood = false;\n        const remainingTime = this.turnServersExpiry - Date.now();\n        if (remainingTime > TURN_CHECK_INTERVAL) {\n            this.logger.debug(\"TURN creds are valid for another \" + remainingTime + \" ms: not fetching new ones.\");\n            credentialsGood = true;\n        } else {\n            this.logger.debug(\"Fetching new TURN credentials\");\n            try {\n                const res = await this.turnServer();\n                if (res.uris) {\n                    this.logger.debug(\"Got TURN URIs: \" + res.uris + \" refresh in \" + res.ttl + \" secs\");\n                    // map the response to a format that can be fed to RTCPeerConnection\n                    const servers: ITurnServer = {\n                        urls: res.uris,\n                        username: res.username,\n                        credential: res.password,\n                    };\n                    this.turnServers = [servers];\n                    // The TTL is in seconds but we work in ms\n                    this.turnServersExpiry = Date.now() + res.ttl * 1000;\n                    credentialsGood = true;\n                    this.emit(ClientEvent.TurnServers, this.turnServers);\n                }\n            } catch (err) {\n                this.logger.error(\"Failed to get TURN URIs\", err);\n                if ((<HTTPError>err).httpStatus === 403) {\n                    // We got a 403, so there's no point in looping forever.\n                    this.logger.info(\"TURN access unavailable for this account: stopping credentials checks\");\n                    if (this.checkTurnServersIntervalID !== null) {\n                        globalThis.clearInterval(this.checkTurnServersIntervalID);\n                    }\n                    this.checkTurnServersIntervalID = undefined;\n                    this.emit(ClientEvent.TurnServersError, <HTTPError>err, true); // fatal\n                } else {\n                    // otherwise, if we failed for whatever reason, try again the next time we're called.\n                    this.emit(ClientEvent.TurnServersError, <Error>err, false); // non-fatal\n                }\n            }\n        }\n\n        return credentialsGood;\n    }\n\n    /**\n     * Set whether to allow a fallback ICE server should be used for negotiating a\n     * WebRTC connection if the homeserver doesn't provide any servers. Defaults to\n     * false.\n     *\n     */\n    public setFallbackICEServerAllowed(allow: boolean): void {\n        this.fallbackICEServerAllowed = allow;\n    }\n\n    /**\n     * Get whether to allow a fallback ICE server should be used for negotiating a\n     * WebRTC connection if the homeserver doesn't provide any servers. Defaults to\n     * false.\n     *\n     * @returns\n     */\n    public isFallbackICEServerAllowed(): boolean {\n        return this.fallbackICEServerAllowed;\n    }\n\n    /**\n     * Determines if the current user is an administrator of the Synapse homeserver.\n     * Returns false if untrue or the homeserver does not appear to be a Synapse\n     * homeserver. <strong>This function is implementation specific and may change\n     * as a result.</strong>\n     * @returns true if the user appears to be a Synapse administrator.\n     */\n    public isSynapseAdministrator(): Promise<boolean> {\n        const path = utils.encodeUri(\"/_synapse/admin/v1/users/$userId/admin\", { $userId: this.getUserId()! });\n        return this.http\n            .authedRequest<{ admin: boolean }>(Method.Get, path, undefined, undefined, { prefix: \"\" })\n            .then((r) => r.admin); // pull out the specific boolean we want\n    }\n\n    /**\n     * Performs a whois lookup on a user using Synapse's administrator API.\n     * <strong>This function is implementation specific and may change as a\n     * result.</strong>\n     * @param userId - the User ID to look up.\n     * @returns the whois response - see Synapse docs for information.\n     */\n    public whoisSynapseUser(userId: string): Promise<ISynapseAdminWhoisResponse> {\n        const path = utils.encodeUri(\"/_synapse/admin/v1/whois/$userId\", { $userId: userId });\n        return this.http.authedRequest(Method.Get, path, undefined, undefined, { prefix: \"\" });\n    }\n\n    /**\n     * Deactivates a user using Synapse's administrator API. <strong>This\n     * function is implementation specific and may change as a result.</strong>\n     * @param userId - the User ID to deactivate.\n     * @returns the deactivate response - see Synapse docs for information.\n     */\n    public deactivateSynapseUser(userId: string): Promise<ISynapseAdminDeactivateResponse> {\n        const path = utils.encodeUri(\"/_synapse/admin/v1/deactivate/$userId\", { $userId: userId });\n        return this.http.authedRequest(Method.Post, path, undefined, undefined, { prefix: \"\" });\n    }\n\n    protected async fetchClientWellKnown(): Promise<void> {\n        // `getRawClientConfig` does not throw or reject on network errors, instead\n        // it absorbs errors and returns `{}`.\n        this.clientWellKnownPromise = AutoDiscovery.getRawClientConfig(this.getDomain() ?? undefined);\n        this.clientWellKnown = await this.clientWellKnownPromise;\n        this.emit(ClientEvent.ClientWellKnown, this.clientWellKnown);\n    }\n\n    public getClientWellKnown(): IClientWellKnown | undefined {\n        return this.clientWellKnown;\n    }\n\n    public waitForClientWellKnown(): Promise<IClientWellKnown> {\n        if (!this.clientRunning) {\n            throw new Error(\"Client is not running\");\n        }\n        return this.clientWellKnownPromise!;\n    }\n\n    /**\n     * store client options with boolean/string/numeric values\n     * to know in the next session what flags the sync data was\n     * created with (e.g. lazy loading)\n     * @returns for store operation\n     */\n    public storeClientOptions(): Promise<void> {\n        // XXX: Intended private, used in code\n        const primTypes = [\"boolean\", \"string\", \"number\"];\n        const serializableOpts = Object.entries(this.clientOpts!)\n            .filter(([key, value]) => {\n                return primTypes.includes(typeof value);\n            })\n            .reduce<Record<string, any>>((obj, [key, value]) => {\n                obj[key] = value;\n                return obj;\n            }, {});\n        return this.store.storeClientOptions(serializableOpts);\n    }\n\n    /**\n     * Gets a set of room IDs in common with another user.\n     *\n     * Note: This endpoint is unstable, and can throw an `Error`.\n     *   Check progress on [MSC2666](https://github.com/matrix-org/matrix-spec-proposals/pull/2666) for more details.\n     *\n     * @param userId - The userId to check.\n     * @returns Promise which resolves to an array of rooms\n     * @returns Rejects: with an error response.\n     */\n    // TODO: on spec release, rename this to getMutualRooms\n    // eslint-disable-next-line\n    public async _unstable_getSharedRooms(userId: string): Promise<string[]> {\n        // Initial variant of the MSC\n        const sharedRoomsSupport = await this.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_SHARED_ROOMS);\n\n        // Newer variant that renamed shared rooms to mutual rooms\n        const mutualRoomsSupport = await this.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_MUTUAL_ROOMS);\n\n        // Latest variant that changed from path elements to query elements\n        const queryMutualRoomsSupport = await this.doesServerSupportUnstableFeature(\n            UNSTABLE_MSC2666_QUERY_MUTUAL_ROOMS,\n        );\n\n        if (!sharedRoomsSupport && !mutualRoomsSupport && !queryMutualRoomsSupport) {\n            throw Error(\"Server does not support the Mutual Rooms API\");\n        }\n\n        let path;\n        let query;\n\n        // Cascading unstable support switching.\n        if (queryMutualRoomsSupport) {\n            path = \"/uk.half-shot.msc2666/user/mutual_rooms\";\n            query = { user_id: userId };\n        } else {\n            path = utils.encodeUri(\n                `/uk.half-shot.msc2666/user/${mutualRoomsSupport ? \"mutual_rooms\" : \"shared_rooms\"}/$userId`,\n                { $userId: userId },\n            );\n            query = {};\n        }\n\n        // Accumulated rooms\n        const rooms: string[] = [];\n        let token = null;\n\n        do {\n            const tokenQuery: Record<string, string> = {};\n            if (token != null && queryMutualRoomsSupport) {\n                tokenQuery[\"batch_token\"] = token;\n            }\n\n            const res = await this.http.authedRequest<{\n                joined: string[];\n                next_batch_token?: string;\n            }>(Method.Get, path, { ...query, ...tokenQuery }, undefined, {\n                prefix: ClientPrefix.Unstable,\n            });\n\n            rooms.push(...res.joined);\n\n            if (res.next_batch_token !== undefined) {\n                token = res.next_batch_token;\n            } else {\n                token = null;\n            }\n        } while (token != null);\n\n        return rooms;\n    }\n\n    /**\n     * Returns a set of configured RTC transports supported by the homeserver.\n     * Requires homeserver support for MSC4143.\n     * @throws A M_NOT_FOUND error if not supported by the homeserver.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public async _unstable_getRTCTransports(): Promise<Transport[]> {\n        // There is no /versions endpoint to check for support, so we just have to attempt a request.\n        return (\n            await this.http.authedRequest<{\n                rtc_transports: Transport[];\n            }>(Method.Get, \"/rtc/transports\", undefined, undefined, {\n                prefix: `${ClientPrefix.Unstable}/org.matrix.msc4143`,\n            })\n        ).rtc_transports;\n    }\n\n    /**\n     * Get the API versions supported by the server, along with any\n     * unstable APIs it supports\n     * @returns The server /versions response\n     */\n    public async getVersions(): Promise<IServerVersions> {\n        if (this.serverVersionsPromise) {\n            return this.serverVersionsPromise;\n        }\n\n        // We send an authenticated request as of MSC4026\n        this.serverVersionsPromise = this.http\n            .authedRequest<IServerVersions>(Method.Get, \"/_matrix/client/versions\", undefined, undefined, {\n                prefix: \"\",\n            })\n            .catch((e) => {\n                // Need to unset this if it fails, otherwise we'll never retry\n                this.serverVersionsPromise = undefined;\n                // but rethrow the exception to anything that was waiting\n                throw e;\n            });\n\n        const serverVersions = await this.serverVersionsPromise;\n        this.canSupport = await buildFeatureSupportMap(serverVersions);\n\n        return this.serverVersionsPromise;\n    }\n\n    /**\n     * Check if a particular spec version is supported by the server.\n     * @param version - The spec version (such as \"r0.5.0\") to check for.\n     * @returns Whether it is supported\n     */\n    public async isVersionSupported(version: string): Promise<boolean> {\n        const { versions } = await this.getVersions();\n        return versions && versions.includes(version);\n    }\n\n    /**\n     * Query the server to see if it lists support for an unstable feature\n     * in the /versions response\n     * @param feature - the feature name\n     * @returns true if the feature is supported\n     */\n    public async doesServerSupportUnstableFeature(feature: string): Promise<boolean> {\n        const response = await this.getVersions();\n        if (!response) return false;\n        const unstableFeatures = response[\"unstable_features\"];\n        return unstableFeatures && !!unstableFeatures[feature];\n    }\n\n    /**\n     * Query the server to see if it is forcing encryption to be enabled for\n     * a given room preset, based on the /versions response.\n     * @param presetName - The name of the preset to check.\n     * @returns true if the server is forcing encryption\n     * for the preset.\n     */\n    public async doesServerForceEncryptionForPreset(presetName: Preset): Promise<boolean> {\n        const response = await this.getVersions();\n        if (!response) return false;\n        const unstableFeatures = response[\"unstable_features\"];\n\n        // The preset name in the versions response will be without the _chat suffix.\n        const versionsPresetName = presetName.includes(\"_chat\")\n            ? presetName.substring(0, presetName.indexOf(\"_chat\"))\n            : presetName;\n\n        return unstableFeatures && !!unstableFeatures[`io.element.e2ee_forced.${versionsPresetName}`];\n    }\n\n    public async doesServerSupportThread(): Promise<{\n        threads: FeatureSupport;\n        list: FeatureSupport;\n        fwdPagination: FeatureSupport;\n    }> {\n        if (await this.isVersionSupported(\"v1.4\")) {\n            return {\n                threads: FeatureSupport.Stable,\n                list: FeatureSupport.Stable,\n                fwdPagination: FeatureSupport.Stable,\n            };\n        }\n\n        try {\n            const [threadUnstable, threadStable, listUnstable, listStable, fwdPaginationUnstable, fwdPaginationStable] =\n                await Promise.all([\n                    this.doesServerSupportUnstableFeature(\"org.matrix.msc3440\"),\n                    this.doesServerSupportUnstableFeature(\"org.matrix.msc3440.stable\"),\n                    this.doesServerSupportUnstableFeature(\"org.matrix.msc3856\"),\n                    this.doesServerSupportUnstableFeature(\"org.matrix.msc3856.stable\"),\n                    this.doesServerSupportUnstableFeature(\"org.matrix.msc3715\"),\n                    this.doesServerSupportUnstableFeature(\"org.matrix.msc3715.stable\"),\n                ]);\n\n            return {\n                threads: determineFeatureSupport(threadStable, threadUnstable),\n                list: determineFeatureSupport(listStable, listUnstable),\n                fwdPagination: determineFeatureSupport(fwdPaginationStable, fwdPaginationUnstable),\n            };\n        } catch {\n            return {\n                threads: FeatureSupport.None,\n                list: FeatureSupport.None,\n                fwdPagination: FeatureSupport.None,\n            };\n        }\n    }\n\n    /**\n     * Get if lazy loading members is being used.\n     * @returns Whether or not members are lazy loaded by this client\n     */\n    public hasLazyLoadMembersEnabled(): boolean {\n        return !!this.clientOpts?.lazyLoadMembers;\n    }\n\n    /**\n     * Set a function which is called when /sync returns a 'limited' response.\n     * It is called with a room ID and returns a boolean. It should return 'true' if the SDK\n     * can SAFELY remove events from this room. It may not be safe to remove events if there\n     * are other references to the timelines for this room, e.g because the client is\n     * actively viewing events in this room.\n     * Default: returns false.\n     * @param cb - The callback which will be invoked.\n     */\n    public setCanResetTimelineCallback(cb: ResetTimelineCallback): void {\n        this.canResetTimelineCallback = cb;\n    }\n\n    /**\n     * Get the callback set via `setCanResetTimelineCallback`.\n     * @returns The callback or null\n     */\n    public getCanResetTimelineCallback(): ResetTimelineCallback | undefined {\n        return this.canResetTimelineCallback;\n    }\n\n    /**\n     * Returns relations for a given event. Handles encryption transparently,\n     * with the caveat that the amount of events returned might be 0, even though you get a nextBatch.\n     * When the returned promise resolves, all messages should have finished trying to decrypt.\n     * @param roomId - the room of the event\n     * @param eventId - the id of the event\n     * @param relationType - the rel_type of the relations requested\n     * @param eventType - the event type of the relations requested\n     * @param opts - options with optional values for the request.\n     * @returns an object with `events` as `MatrixEvent[]` and optionally `nextBatch` if more relations are available.\n     */\n    public async relations(\n        roomId: string,\n        eventId: string,\n        relationType: RelationType | string | null,\n        eventType?: EventType | string | null,\n        opts: IRelationsRequestOpts = { dir: Direction.Backward },\n    ): Promise<{\n        originalEvent?: MatrixEvent | null;\n        events: MatrixEvent[];\n        nextBatch?: string | null;\n        prevBatch?: string | null;\n    }> {\n        const fetchedEventType = eventType ? this.getEncryptedIfNeededEventType(roomId, eventType) : null;\n        const [eventResult, result] = await Promise.all([\n            this.fetchRoomEvent(roomId, eventId),\n            this.fetchRelations(roomId, eventId, relationType, fetchedEventType, opts),\n        ]);\n        const mapper = this.getEventMapper();\n\n        const originalEvent = eventResult ? mapper(eventResult) : undefined;\n        let events = result.chunk.map(mapper);\n\n        if (fetchedEventType === EventType.RoomMessageEncrypted) {\n            const allEvents = originalEvent ? events.concat(originalEvent) : events;\n            await Promise.all(allEvents.map((e) => this.decryptEventIfNeeded(e)));\n            if (eventType !== null) {\n                events = events.filter((e) => e.getType() === eventType);\n            }\n        }\n\n        if (originalEvent && relationType === RelationType.Replace) {\n            events = events.filter((e) => e.getSender() === originalEvent.getSender());\n        }\n        return {\n            originalEvent: originalEvent ?? null,\n            events,\n            nextBatch: result.next_batch ?? null,\n            prevBatch: result.prev_batch ?? null,\n        };\n    }\n\n    /**\n     * Generates a random string suitable for use as a client secret. <strong>This\n     * method is experimental and may change.</strong>\n     * @returns A new client secret\n     */\n    public generateClientSecret(): string {\n        return secureRandomString(32);\n    }\n\n    /**\n     * Attempts to decrypt an event\n     * @param event - The event to decrypt\n     * @returns A decryption promise\n     */\n    public decryptEventIfNeeded(event: MatrixEvent, options?: IDecryptOptions): Promise<void> {\n        if (event.isState() && !this.enableEncryptedStateEvents) {\n            return Promise.resolve();\n        }\n\n        if (event.shouldAttemptDecryption() && this.getCrypto()) {\n            event.attemptDecryption(this.cryptoBackend!, options);\n        }\n\n        if (event.isBeingDecrypted()) {\n            return event.getDecryptionPromise()!;\n        } else {\n            return Promise.resolve();\n        }\n    }\n\n    private termsUrlForService(serviceType: SERVICE_TYPES, baseUrl: string): URL {\n        switch (serviceType) {\n            case SERVICE_TYPES.IS:\n                return this.http.getUrl(\"/terms\", undefined, IdentityPrefix.V2, baseUrl);\n            case SERVICE_TYPES.IM:\n                return this.http.getUrl(\"/terms\", undefined, \"/_matrix/integrations/v1\", baseUrl);\n            default:\n                throw new Error(\"Unsupported service type\");\n        }\n    }\n\n    /**\n     * Get the Homeserver URL of this client\n     * @returns Homeserver URL of this client\n     */\n    public getHomeserverUrl(): string {\n        return this.baseUrl;\n    }\n\n    /**\n     * Get the identity server URL of this client\n     * @param stripProto - whether or not to strip the protocol from the URL\n     * @returns Identity server URL of this client\n     */\n    public getIdentityServerUrl(stripProto = false): string | undefined {\n        if (stripProto && (this.idBaseUrl?.startsWith(\"http://\") || this.idBaseUrl?.startsWith(\"https://\"))) {\n            return this.idBaseUrl.split(\"://\")[1];\n        }\n        return this.idBaseUrl;\n    }\n\n    /**\n     * Set the identity server URL of this client\n     * @param url - New identity server URL\n     */\n    public setIdentityServerUrl(url?: string): void {\n        this.idBaseUrl = utils.ensureNoTrailingSlash(url);\n        this.http.setIdBaseUrl(this.idBaseUrl);\n    }\n\n    /**\n     * Get the access token associated with this account.\n     * @returns The access_token or null\n     */\n    public getAccessToken(): string | null {\n        return this.http.opts.accessToken || null;\n    }\n\n    /**\n     * Get the refresh token associated with this account.\n     * @returns The refresh_token or null\n     */\n    public getRefreshToken(): string | null {\n        return this.http.opts.refreshToken ?? null;\n    }\n\n    /**\n     * Set the access token associated with this account.\n     * @param token - The new access token.\n     */\n    public setAccessToken(token: string): void {\n        this.http.opts.accessToken = token;\n        // The /versions response can vary for different users so clear the cache\n        this.serverVersionsPromise = undefined;\n    }\n\n    /**\n     * @returns true if there is a valid access_token for this client.\n     */\n    public isLoggedIn(): boolean {\n        return this.http.opts.accessToken !== undefined;\n    }\n\n    /**\n     * Make up a new transaction id\n     *\n     * @returns a new, unique, transaction id\n     */\n    public makeTxnId(): string {\n        return \"m\" + new Date().getTime() + \".\" + this.txnCtr++;\n    }\n\n    /**\n     * Check whether a username is available prior to registration. An error response\n     * indicates an invalid/unavailable username.\n     * @param username - The username to check the availability of.\n     * @returns Promise which resolves: to boolean of whether the username is available.\n     */\n    public isUsernameAvailable(username: string): Promise<boolean> {\n        return this.http\n            .authedRequest<{ available: true }>(Method.Get, \"/register/available\", { username })\n            .then((response) => {\n                return response.available;\n            })\n            .catch((response) => {\n                if (response.errcode === \"M_USER_IN_USE\") {\n                    return false;\n                }\n                return Promise.reject(response);\n            });\n    }\n\n    /**\n     * @param bindThreepids - Set key 'email' to true to bind any email\n     *     threepid uses during registration in the identity server. Set 'msisdn' to\n     *     true to bind msisdn.\n     * @returns Promise which resolves to a RegisterResponse object\n     * @returns Rejects: with an error response.\n     */\n    public register(\n        username: string,\n        password: string,\n        sessionId: string | null,\n        auth: { session?: string; type: string },\n        bindThreepids?: { email?: boolean; msisdn?: boolean },\n        guestAccessToken?: string,\n        inhibitLogin?: boolean,\n    ): Promise<RegisterResponse> {\n        if (sessionId) {\n            auth.session = sessionId;\n        }\n\n        const params: RegisterRequest = {\n            auth: auth,\n            refresh_token: true, // always ask for a refresh token - does nothing if unsupported\n        };\n        if (username !== undefined && username !== null) {\n            params.username = username;\n        }\n        if (password !== undefined && password !== null) {\n            params.password = password;\n        }\n        if (guestAccessToken !== undefined && guestAccessToken !== null) {\n            params.guest_access_token = guestAccessToken;\n        }\n        if (inhibitLogin !== undefined && inhibitLogin !== null) {\n            params.inhibit_login = inhibitLogin;\n        }\n\n        return this.registerRequest(params);\n    }\n\n    /**\n     * Register a guest account.\n     * This method returns the auth info needed to create a new authenticated client,\n     * Remember to call `setGuest(true)` on the (guest-)authenticated client, e.g:\n     * ```javascript\n     * const tmpClient = await sdk.createClient(MATRIX_INSTANCE);\n     * const { user_id, device_id, access_token } = tmpClient.registerGuest();\n     * const client = createClient({\n     *   baseUrl: MATRIX_INSTANCE,\n     *   accessToken: access_token,\n     *   userId: user_id,\n     *   deviceId: device_id,\n     * })\n     * client.setGuest(true);\n     * ```\n     *\n     * @param body - JSON HTTP body to provide.\n     * @returns Promise which resolves: JSON object that contains:\n     *                   `{ user_id, device_id, access_token, home_server }`\n     * @returns Rejects: with an error response.\n     */\n    public registerGuest({ body }: { body?: RegisterRequest } = {}): Promise<RegisterResponse> {\n        return this.registerRequest(body || {}, \"guest\");\n    }\n\n    /**\n     * @param data - parameters for registration request\n     * @param kind - type of user to register. may be \"guest\"\n     * @returns Promise which resolves: to the /register response\n     * @returns Rejects: with an error response.\n     */\n    public registerRequest(data: RegisterRequest, kind?: string): Promise<RegisterResponse> {\n        const params: { kind?: string } = {};\n        if (kind) {\n            params.kind = kind;\n        }\n\n        return this.http.request(Method.Post, \"/register\", params, data);\n    }\n\n    /**\n     * Refreshes an access token using a provided refresh token. The refresh token\n     * must be valid for the current access token known to the client instance.\n     *\n     * Note that this function will not cause a logout if the token is deemed\n     * unknown by the server - the caller is responsible for managing logout\n     * actions on error.\n     * @param refreshToken - The refresh token.\n     * @returns Promise which resolves to the new token.\n     * @returns Rejects with an error response.\n     */\n    public refreshToken(refreshToken: string): Promise<IRefreshTokenResponse> {\n        const performRefreshRequestWithPrefix = (prefix: ClientPrefix): Promise<IRefreshTokenResponse> =>\n            this.http.authedRequest(\n                Method.Post,\n                \"/refresh\",\n                undefined,\n                { refresh_token: refreshToken },\n                {\n                    prefix,\n                    inhibitLogoutEmit: true, // we don't want to cause logout loops\n                },\n            );\n\n        // First try with the (specced) /v3/ prefix.\n        // However, before Synapse 1.72.0, Synapse incorrectly required a /v1/ prefix, so we fall\n        // back to that if the request fails, for backwards compatibility.\n        return performRefreshRequestWithPrefix(ClientPrefix.V3).catch((e) => {\n            if (e.errcode === \"M_UNRECOGNIZED\") {\n                return performRefreshRequestWithPrefix(ClientPrefix.V1);\n            }\n            throw e;\n        });\n    }\n\n    /**\n     * @returns Promise which resolves to the available login flows\n     * @returns Rejects: with an error response.\n     */\n    public loginFlows(): Promise<ILoginFlowsResponse> {\n        return this.http.request(Method.Get, \"/login\");\n    }\n\n    /**\n     * @returns Promise which resolves to a LoginResponse object\n     * @returns Rejects: with an error response.\n     *\n     * @deprecated This method has unintuitive behaviour: it updates the `MatrixClient` instance with *some* of the\n     *    returned credentials. Instead, call {@link loginRequest} and create a new `MatrixClient` instance using the\n     *    results. See https://github.com/matrix-org/matrix-js-sdk/issues/4502.\n     */\n    public login(loginType: LoginRequest[\"type\"], data: Omit<LoginRequest, \"type\">): Promise<LoginResponse> {\n        return this.loginRequest({\n            ...data,\n            type: loginType,\n        }).then((response) => {\n            if (response.access_token && response.user_id) {\n                this.http.opts.accessToken = response.access_token;\n                this.credentials = {\n                    userId: response.user_id,\n                };\n            }\n            return response;\n        });\n    }\n\n    /**\n     * @returns Promise which resolves to a LoginResponse object\n     * @returns Rejects: with an error response.\n     *\n     * @deprecated This method has unintuitive behaviour: it updates the `MatrixClient` instance with *some* of the\n     *   returned credentials. Instead, call {@link loginRequest} with `data.type: \"m.login.password\"`, and create a new\n     *   `MatrixClient` instance using the results. See https://github.com/matrix-org/matrix-js-sdk/issues/4502.\n     */\n    public loginWithPassword(user: string, password: string): Promise<LoginResponse> {\n        return this.login(\"m.login.password\", {\n            user: user,\n            password: password,\n        });\n    }\n\n    /**\n     * @param redirectUrl - The URL to redirect to after the HS\n     * authenticates with CAS.\n     * @returns The HS URL to hit to begin the CAS login process.\n     */\n    public getCasLoginUrl(redirectUrl: string): string {\n        return this.getSsoLoginUrl(redirectUrl, \"cas\");\n    }\n\n    /**\n     * @param redirectUrl - The URL to redirect to after the HS\n     *     authenticates with the SSO.\n     * @param loginType - The type of SSO login we are doing (sso or cas).\n     *     Defaults to 'sso'.\n     * @param idpId - The ID of the Identity Provider being targeted, optional.\n     * @param action - the SSO flow to indicate to the IdP, optional.\n     * @returns The HS URL to hit to begin the SSO login process.\n     */\n    public getSsoLoginUrl(redirectUrl: string, loginType = \"sso\", idpId?: string, action?: SSOAction): string {\n        let url = \"/login/\" + loginType + \"/redirect\";\n        if (idpId) {\n            url += \"/\" + idpId;\n        }\n\n        const params = {\n            redirectUrl,\n            [SSO_ACTION_PARAM.stable!]: action,\n            [SSO_ACTION_PARAM.unstable!]: action,\n        };\n\n        return this.http.getUrl(url, params).href;\n    }\n\n    /**\n     * @param token - Login token previously received from homeserver\n     * @returns Promise which resolves to a LoginResponse object\n     * @returns Rejects: with an error response.\n     *\n     * @deprecated This method has unintuitive behaviour: it updates the `MatrixClient` instance with *some* of the\n     *   returned credentials. Instead, call {@link loginRequest} with `data.type: \"m.login.token\"`, and create a new\n     *   `MatrixClient` instance using the results. See https://github.com/matrix-org/matrix-js-sdk/issues/4502.\n     */\n    public loginWithToken(token: string): Promise<LoginResponse> {\n        return this.login(\"m.login.token\", {\n            token: token,\n        });\n    }\n\n    /**\n     * Sends a `POST /login` request to the server.\n     *\n     * If successful, this will create a new device and access token for the user.\n     *\n     * @see {@link MatrixClient.loginFlows} which makes a `GET /login` request.\n     * @see https://spec.matrix.org/v1.13/client-server-api/#post_matrixclientv3login\n     *\n     * @param data - Credentials and other details for the login request.\n     */\n    public async loginRequest(data: LoginRequest): Promise<LoginResponse> {\n        return await this.http.authedRequest<LoginResponse>(Method.Post, \"/login\", undefined, data);\n    }\n\n    /**\n     * Logs out the current session.\n     * Obviously, further calls that require authorisation should fail after this\n     * method is called. The state of the MatrixClient object is not affected:\n     * it is up to the caller to either reset or destroy the MatrixClient after\n     * this method succeeds.\n     * @param stopClient - whether to stop the client before calling /logout to prevent invalid token errors.\n     * @returns Promise which resolves: On success, the empty object `{}`\n     */\n    public async logout(stopClient = false): Promise<EmptyObject> {\n        if (stopClient) {\n            this.stopClient();\n            this.http.abort();\n        }\n\n        return this.http.authedRequest(Method.Post, \"/logout\");\n    }\n\n    /**\n     * Deactivates the logged-in account.\n     * Obviously, further calls that require authorisation should fail after this\n     * method is called. The state of the MatrixClient object is not affected:\n     * it is up to the caller to either reset or destroy the MatrixClient after\n     * this method succeeds.\n     * @param auth - Optional. Auth data to supply for User-Interactive auth.\n     * @param erase - Optional. If set, send as `erase` attribute in the\n     * JSON request body, indicating whether the account should be erased. Defaults\n     * to false.\n     * @returns Promise which resolves: On success, the empty object\n     */\n    public deactivateAccount(\n        auth?: AuthDict,\n        erase?: boolean,\n    ): Promise<{ id_server_unbind_result: IdServerUnbindResult }> {\n        const body: Body = {};\n        if (auth) {\n            body.auth = auth;\n        }\n        if (erase !== undefined) {\n            body.erase = erase;\n        }\n\n        return this.http.authedRequest(Method.Post, \"/account/deactivate\", undefined, body);\n    }\n\n    /**\n     * Make a request for an `m.login.token` to be issued as per\n     * https://spec.matrix.org/v1.7/client-server-api/#post_matrixclientv1loginget_token\n     *\n     * The server may require User-Interactive auth.\n     *\n     * @param auth - Optional. Auth data to supply for User-Interactive auth.\n     * @returns Promise which resolves: On success, the token response\n     * or UIA auth data.\n     */\n    public async requestLoginToken(auth?: AuthDict): Promise<LoginTokenPostResponse> {\n        const body: UIARequest<unknown> = { auth };\n        return this.http.authedRequest<LoginTokenPostResponse>(\n            Method.Post,\n            \"/login/get_token\",\n            undefined, // no query params\n            body,\n            { prefix: ClientPrefix.V1 },\n        );\n    }\n\n    /**\n     * Get the fallback URL to use for unknown interactive-auth stages.\n     *\n     * @param loginType -     the type of stage being attempted\n     * @param authSessionId - the auth session ID provided by the homeserver\n     *\n     * @returns HS URL to hit to for the fallback interface\n     */\n    public getFallbackAuthUrl(loginType: string, authSessionId: string): string {\n        const path = utils.encodeUri(\"/auth/$loginType/fallback/web\", {\n            $loginType: loginType,\n        });\n\n        return this.http.getUrl(path, {\n            session: authSessionId,\n        }).href;\n    }\n\n    /**\n     * Create a new room.\n     * @param options - a list of options to pass to the /createRoom API.\n     * @returns Promise which resolves: `{room_id: {string}}`\n     * @returns Rejects: with an error response.\n     */\n    public async createRoom(options: ICreateRoomOpts): Promise<{ room_id: string }> {\n        // eslint-disable-line camelcase\n        // some valid options include: room_alias_name, visibility, invite\n\n        // inject the id_access_token if inviting 3rd party addresses\n        const invitesNeedingToken = (options.invite_3pid || []).filter((i) => !i.id_access_token);\n        if (invitesNeedingToken.length > 0 && this.identityServer?.getAccessToken) {\n            const identityAccessToken = await this.identityServer.getAccessToken();\n            if (identityAccessToken) {\n                for (const invite of invitesNeedingToken) {\n                    invite.id_access_token = identityAccessToken;\n                }\n            }\n        }\n\n        return this.http.authedRequest(Method.Post, \"/createRoom\", undefined, options);\n    }\n\n    /**\n     * Fetches relations for a given event\n     * @param roomId - the room of the event\n     * @param eventId - the id of the event\n     * @param relationType - the rel_type of the relations requested\n     * @param eventType - the event type of the relations requested\n     * @param opts - options with optional values for the request.\n     * @returns the response, with chunk, prev_batch and, next_batch.\n     */\n    public fetchRelations(\n        roomId: string,\n        eventId: string,\n        relationType: RelationType | string | null,\n        eventType?: EventType | string | null,\n        opts: IRelationsRequestOpts = { dir: Direction.Backward },\n    ): Promise<IRelationsResponse> {\n        let params = opts as QueryDict;\n        if (Thread.hasServerSideFwdPaginationSupport === FeatureSupport.Experimental) {\n            params = replaceParam(\"dir\", \"org.matrix.msc3715.dir\", params);\n        }\n        if (this.canSupport.get(Feature.RelationsRecursion) === ServerSupport.Unstable) {\n            params = replaceParam(\"recurse\", \"org.matrix.msc3981.recurse\", params);\n        }\n        const queryString = utils.encodeParams(params);\n\n        let templatedUrl = \"/rooms/$roomId/relations/$eventId\";\n        if (relationType !== null) {\n            templatedUrl += \"/$relationType\";\n            if (eventType !== null) {\n                templatedUrl += \"/$eventType\";\n            }\n        } else if (eventType !== null) {\n            this.logger.warn(`eventType: ${eventType} ignored when fetching\n            relations as relationType is null`);\n            eventType = null;\n        }\n\n        const path = utils.encodeUri(templatedUrl + \"?\" + queryString, {\n            $roomId: roomId,\n            $eventId: eventId,\n            $relationType: relationType!,\n            $eventType: eventType!,\n        });\n        return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n            prefix: ClientPrefix.V1,\n        });\n    }\n\n    /**\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     */\n    public roomState(roomId: string): Promise<IStateEventWithRoomId[]> {\n        const path = utils.encodeUri(\"/rooms/$roomId/state\", { $roomId: roomId });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Get an event in a room by its event id.\n     *\n     * @returns Promise which resolves to an object containing the event.\n     * @returns Rejects: with an error response.\n     */\n    public fetchRoomEvent(roomId: string, eventId: string): Promise<Partial<IEvent>> {\n        const path = utils.encodeUri(\"/rooms/$roomId/event/$eventId\", {\n            $roomId: roomId,\n            $eventId: eventId,\n        });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * @param includeMembership - the membership type to include in the response\n     * @param excludeMembership - the membership type to exclude from the response\n     * @param atEventId - the id of the event for which moment in the timeline the members should be returned for\n     * @returns Promise which resolves: dictionary of userid to profile information\n     * @returns Rejects: with an error response.\n     */\n    public members(\n        roomId: string,\n        includeMembership?: string,\n        excludeMembership?: string,\n        atEventId?: string,\n    ): Promise<{ [userId: string]: IStateEventWithRoomId[] }> {\n        const queryParams: Record<string, string> = {};\n        if (includeMembership) {\n            queryParams.membership = includeMembership;\n        }\n        if (excludeMembership) {\n            queryParams.not_membership = excludeMembership;\n        }\n        if (atEventId) {\n            queryParams.at = atEventId;\n        }\n\n        const queryString = utils.encodeParams(queryParams);\n\n        const path = utils.encodeUri(\"/rooms/$roomId/members?\" + queryString, { $roomId: roomId });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Upgrades a room to a new protocol version\n     * @param newVersion - The target version to upgrade to\n     * @param additionalCreators - an optional list of user IDs of users who\n     *        should have the same permissions as the user performing the\n     *        upgrade\n     * @returns Promise which resolves: Object with key 'replacement_room'\n     * @returns Rejects: with an error response.\n     */\n    public upgradeRoom(\n        roomId: string,\n        newVersion: string,\n        additionalCreators?: string[],\n    ): Promise<{ replacement_room: string }> {\n        // eslint-disable-line camelcase\n        const path = utils.encodeUri(\"/rooms/$roomId/upgrade\", { $roomId: roomId });\n        return this.http.authedRequest(Method.Post, path, undefined, {\n            new_version: newVersion,\n            additional_creators: additionalCreators,\n        });\n    }\n\n    /**\n     * Retrieve a state event.\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     */\n    public getStateEvent(roomId: string, eventType: string, stateKey: string): Promise<Record<string, any>> {\n        const pathParams = {\n            $roomId: roomId,\n            $eventType: eventType,\n            $stateKey: stateKey,\n        };\n        let path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n        if (stateKey !== undefined) {\n            path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n        }\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Send a state event into a room\n     * @param roomId - ID of the room to send the event into\n     * @param eventType - type of the state event to send\n     * @param content - content of the event to send\n     * @param stateKey - the stateKey to send into the room\n     * @param opts - Options for the request function.\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     */\n    public async sendStateEvent<K extends keyof StateEvents>(\n        roomId: string,\n        eventType: K,\n        content: StateEvents[K],\n        stateKey = \"\",\n        opts: IRequestOpts = {},\n    ): Promise<ISendEventResponse> {\n        const room = this.getRoom(roomId);\n        const event = new MatrixEvent({\n            room_id: roomId,\n            type: eventType,\n            state_key: stateKey,\n            // Cast safety: StateEvents[K] is a stronger bound than IContent, which has [key: string]: any\n            content: content as IContent,\n        });\n\n        await this.encryptStateEventIfNeeded(event, room ?? undefined);\n\n        const pathParams = {\n            $roomId: roomId,\n            $eventType: event.getWireType(),\n            $stateKey: event.getWireStateKey(),\n        };\n        let path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n        if (stateKey !== undefined) {\n            path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n        }\n        return this.http.authedRequest(Method.Put, path, undefined, event.getWireContent(), opts);\n    }\n\n    private async encryptStateEventIfNeeded(event: MatrixEvent, room?: Room): Promise<void> {\n        if (!this.enableEncryptedStateEvents) {\n            return;\n        }\n\n        // If the room is unknown, we cannot encrypt for it\n        if (!room) return;\n\n        if (!this.cryptoBackend && this.usingExternalCrypto) {\n            // The client has opted to allow sending messages to encrypted\n            // rooms even if the room is encrypted, and we haven't set up\n            // crypto. This is useful for users of matrix-org/pantalaimon\n            return;\n        }\n\n        if (!this.cryptoBackend) {\n            throw new Error(\"This room is configured to use encryption, but your client does not support encryption.\");\n        }\n\n        // Check regular encryption conditions.\n        if (!(await this.shouldEncryptEventForRoom(event, room))) {\n            return;\n        }\n\n        // If the crypto impl thinks we shouldn't encrypt, then we shouldn't.\n        // Safety: we checked the crypto impl exists above.\n        if (!(await this.cryptoBackend!.isStateEncryptionEnabledInRoom(room.roomId))) {\n            return;\n        }\n\n        // Check if the event is excluded under MSC4362\n        if (\n            [\n                \"m.room.create\",\n                \"m.room.member\",\n                \"m.room.join_rules\",\n                \"m.room.power_levels\",\n                \"m.room.third_party_invite\",\n                \"m.room.history_visibility\",\n                \"m.room.guest_access\",\n                \"m.room.encryption\",\n            ].includes(event.getType())\n        ) {\n            return;\n        }\n\n        await this.cryptoBackend.encryptEvent(event, room);\n    }\n\n    /**\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     */\n    public roomInitialSync(roomId: string, limit: number): Promise<IRoomInitialSyncResponse> {\n        const path = utils.encodeUri(\"/rooms/$roomId/initialSync\", { $roomId: roomId });\n\n        return this.http.authedRequest(Method.Get, path, { limit: limit?.toString() ?? \"30\" });\n    }\n\n    /**\n     * Set a marker to indicate the point in a room before which the user has read every\n     * event. This can be retrieved from room account data (the event type is `m.fully_read`)\n     * and displayed as a horizontal line in the timeline that is visually distinct to the\n     * position of the user's own read receipt.\n     * @param roomId - ID of the room that has been read\n     * @param rmEventId - ID of the event that has been read\n     * @param rrEventId - ID of the event tracked by the read receipt. This is here\n     * for convenience because the RR and the RM are commonly updated at the same time as\n     * each other. Optional.\n     * @param rpEventId - rpEvent the m.read.private read receipt event for when we\n     * don't want other users to see the read receipts. This is experimental. Optional.\n     * @returns Promise which resolves: the empty object, `{}`.\n     */\n    public async setRoomReadMarkersHttpRequest(\n        roomId: string,\n        rmEventId: string,\n        rrEventId?: string,\n        rpEventId?: string,\n    ): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/rooms/$roomId/read_markers\", {\n            $roomId: roomId,\n        });\n\n        const content: IContent = {\n            [ReceiptType.FullyRead]: rmEventId,\n            [ReceiptType.Read]: rrEventId,\n        };\n\n        if (\n            (await this.doesServerSupportUnstableFeature(\"org.matrix.msc2285.stable\")) ||\n            (await this.isVersionSupported(\"v1.4\"))\n        ) {\n            content[ReceiptType.ReadPrivate] = rpEventId;\n        }\n\n        return this.http.authedRequest(Method.Post, path, undefined, content);\n    }\n\n    /**\n     * @returns Promise which resolves: A list of the user's current rooms\n     * @returns Rejects: with an error response.\n     */\n    public getJoinedRooms(): Promise<IJoinedRoomsResponse> {\n        const path = utils.encodeUri(\"/joined_rooms\", {});\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Retrieve membership info. for a room.\n     * @param roomId - ID of the room to get membership for\n     * @returns Promise which resolves: A list of currently joined users\n     *                                 and their profile data.\n     * @returns Rejects: with an error response.\n     */\n    public getJoinedRoomMembers(roomId: string): Promise<IJoinedMembersResponse> {\n        const path = utils.encodeUri(\"/rooms/$roomId/joined_members\", {\n            $roomId: roomId,\n        });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Get the public rooms list from the server. Supports pagination\n     * @param params - Options for this request\n     * @returns Promise which resolves: IPublicRoomsResponse\n     * @returns Rejects: with an error response.\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public publicRooms({\n        server,\n        limit,\n        since,\n        ...options\n    }: IRoomDirectoryOptions = {}): Promise<IPublicRoomsResponse> {\n        if (Object.keys(options).length === 0) {\n            const queryParams: QueryDict = { server, limit, since };\n            return this.http.authedRequest(Method.Get, \"/publicRooms\", queryParams);\n        } else {\n            const queryParams: QueryDict = { server };\n            const body = {\n                limit,\n                since,\n                ...options,\n            };\n            return this.http.authedRequest(Method.Post, \"/publicRooms\", queryParams, body);\n        }\n    }\n\n    /**\n     * Create an alias to room ID mapping.\n     * @param alias - The room alias to create.\n     * @param roomId - The room ID to link the alias to.\n     * @returns Promise which resolves: an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public createAlias(alias: string, roomId: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/directory/room/$alias\", {\n            $alias: alias,\n        });\n        const data = {\n            room_id: roomId,\n        };\n        return this.http.authedRequest(Method.Put, path, undefined, data);\n    }\n\n    /**\n     * Delete an alias to room ID mapping. This alias must be on your local server,\n     * and you must have sufficient access to do this operation.\n     * @param alias - The room alias to delete.\n     * @returns Promise which resolves: an empty object `{}`.\n     * @returns Rejects: with an error response.\n     */\n    public deleteAlias(alias: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/directory/room/$alias\", {\n            $alias: alias,\n        });\n        return this.http.authedRequest(Method.Delete, path);\n    }\n\n    /**\n     * Gets the local aliases for the room. Note: this includes all local aliases, unlike the\n     * curated list from the m.room.canonical_alias state event.\n     * @param roomId - The room ID to get local aliases for.\n     * @returns Promise which resolves: an object with an `aliases` property, containing an array of local aliases\n     * @returns Rejects: with an error response.\n     */\n    public getLocalAliases(roomId: string): Promise<{ aliases: string[] }> {\n        const path = utils.encodeUri(\"/rooms/$roomId/aliases\", { $roomId: roomId });\n        const prefix = ClientPrefix.V3;\n        return this.http.authedRequest(Method.Get, path, undefined, undefined, { prefix });\n    }\n\n    /**\n     * Get room info for the given alias.\n     * @param alias - The room alias to resolve.\n     * @returns Promise which resolves: Object with room_id and servers.\n     * @returns Rejects: with an error response.\n     */\n    public getRoomIdForAlias(alias: string): Promise<{ room_id: string; servers: string[] }> {\n        // eslint-disable-line camelcase\n        const path = utils.encodeUri(\"/directory/room/$alias\", {\n            $alias: alias,\n        });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Get the visibility of a room in the current HS's room directory\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     */\n    public getRoomDirectoryVisibility(roomId: string): Promise<{ visibility: Visibility }> {\n        const path = utils.encodeUri(\"/directory/list/room/$roomId\", {\n            $roomId: roomId,\n        });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Set the visibility of a room in the current HS's room directory\n     * @param visibility - \"public\" to make the room visible\n     *                 in the public directory, or \"private\" to make\n     *                 it invisible.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public setRoomDirectoryVisibility(roomId: string, visibility: Visibility): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/directory/list/room/$roomId\", {\n            $roomId: roomId,\n        });\n        return this.http.authedRequest(Method.Put, path, undefined, { visibility });\n    }\n\n    /**\n     * Query the user directory with a term matching user IDs, display names and domains.\n     * @param options\n     * @param options.term - the term with which to search.\n     * @param options.limit - the maximum number of results to return. The server will apply a limit if unspecified.\n     * @returns Promise which resolves: an array of results.\n     */\n    public searchUserDirectory({ term, limit }: { term: string; limit?: number }): Promise<IUserDirectoryResponse> {\n        const body: Body = {\n            search_term: term,\n        };\n\n        if (limit !== undefined) {\n            body.limit = limit;\n        }\n\n        return this.http.authedRequest(Method.Post, \"/user_directory/search\", undefined, body);\n    }\n\n    /**\n     * Upload a file to the media repository on the homeserver.\n     *\n     * @param file - The object to upload. On a browser, something that\n     *   can be sent to XMLHttpRequest.send (typically a File).  Under node.js,\n     *   a a Buffer, String or ReadStream.\n     *\n     * @param opts -  options object\n     *\n     * @returns Promise which resolves to response object, or rejects with an error (usually a MatrixError).\n     */\n    public uploadContent(file: FileType, opts?: UploadOpts): Promise<UploadResponse> {\n        return this.http.uploadContent(file, opts);\n    }\n\n    /**\n     * Cancel a file upload in progress\n     * @param upload - The object returned from uploadContent\n     * @returns true if canceled, otherwise false\n     */\n    public cancelUpload(upload: Promise<UploadResponse>): boolean {\n        return this.http.cancelUpload(upload);\n    }\n\n    /**\n     * Get a list of all file uploads in progress\n     * @returns Array of objects representing current uploads.\n     * Currently in progress is element 0. Keys:\n     *  - promise: The promise associated with the upload\n     *  - loaded: Number of bytes uploaded\n     *  - total: Total number of bytes to upload\n     */\n    public getCurrentUploads(): Upload[] {\n        return this.http.getCurrentUploads();\n    }\n\n    /**\n     * @param info - The kind of info to retrieve (e.g. 'displayname',\n     * 'avatar_url').\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     */\n    public getProfileInfo(\n        userId: string,\n        info?: string,\n        // eslint-disable-next-line camelcase\n    ): Promise<{ avatar_url?: string; displayname?: string }> {\n        const path = info\n            ? utils.encodeUri(\"/profile/$userId/$info\", { $userId: userId, $info: info })\n            : utils.encodeUri(\"/profile/$userId\", { $userId: userId });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Determine if the server supports extended profiles, as described by MSC4133.\n     *\n     * @returns `true` if supported, otherwise `false`\n     */\n    public async doesServerSupportExtendedProfiles(): Promise<boolean> {\n        return (\n            (await this.isVersionSupported(\"v1.16\")) ||\n            (await this.doesServerSupportUnstableFeature(UNSTABLE_MSC4133_EXTENDED_PROFILES)) ||\n            (await this.doesServerSupportUnstableFeature(STABLE_MSC4133_EXTENDED_PROFILES))\n        );\n    }\n\n    /**\n     * Get the prefix used for extended profile requests.\n     *\n     * @returns The prefix for use with `authedRequest`\n     */\n    private async getExtendedProfileRequestPrefix(): Promise<string> {\n        if (\n            (await this.isVersionSupported(\"v1.16\")) ||\n            (await this.doesServerSupportUnstableFeature(\"uk.tcpip.msc4133.stable\"))\n        ) {\n            return ClientPrefix.V3;\n        }\n        return \"/_matrix/client/unstable/uk.tcpip.msc4133\";\n    }\n\n    /**\n     * Fetch a user's *extended* profile, which may include additional keys.\n     *\n     * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n     * @param userId The user ID to fetch the profile of.\n     * @returns A set of keys to property values.\n     *\n     * @throws An error if the server does not support MSC4133.\n     * @throws A M_NOT_FOUND error if the profile could not be found.\n     */\n    public async getExtendedProfile(userId: string): Promise<Record<string, unknown>> {\n        if (!(await this.doesServerSupportExtendedProfiles())) {\n            throw new Error(\"Server does not support extended profiles\");\n        }\n        return this.http.authedRequest(\n            Method.Get,\n            utils.encodeUri(\"/profile/$userId\", { $userId: userId }),\n            undefined,\n            undefined,\n            {\n                prefix: await this.getExtendedProfileRequestPrefix(),\n            },\n        );\n    }\n\n    /**\n     * Fetch a specific key from the user's *extended* profile.\n     *\n     * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n     * @param userId The user ID to fetch the profile of.\n     * @param key The key of the property to fetch.\n     * @returns The property value.\n     *\n     * @throws An error if the server does not support MSC4133.\n     * @throws A M_NOT_FOUND error if the key was not set OR the profile could not be found.\n     */\n    public async getExtendedProfileProperty(userId: string, key: string): Promise<unknown> {\n        if (!(await this.doesServerSupportExtendedProfiles())) {\n            throw new Error(\"Server does not support extended profiles\");\n        }\n        const profile = (await this.http.authedRequest(\n            Method.Get,\n            utils.encodeUri(\"/profile/$userId/$key\", { $userId: userId, $key: key }),\n            undefined,\n            undefined,\n            {\n                prefix: await this.getExtendedProfileRequestPrefix(),\n            },\n        )) as Record<string, unknown>;\n        return profile[key];\n    }\n\n    /**\n     * Set a property on your *extended* profile.\n     *\n     * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n     * @param key The key of the property to set.\n     * @param value The value to set on the property.\n     *\n     * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n     */\n    public async setExtendedProfileProperty(key: string, value: unknown): Promise<void> {\n        if (!(await this.doesServerSupportExtendedProfiles())) {\n            throw new Error(\"Server does not support extended profiles\");\n        }\n        const userId = this.getUserId();\n\n        await this.http.authedRequest(\n            Method.Put,\n            utils.encodeUri(\"/profile/$userId/$key\", { $userId: userId, $key: key }),\n            undefined,\n            { [key]: value },\n            {\n                prefix: await this.getExtendedProfileRequestPrefix(),\n            },\n        );\n    }\n\n    /**\n     * Delete a property on your *extended* profile.\n     *\n     * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n     * @param key The key of the property to delete.\n     *\n     * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n     */\n    public async deleteExtendedProfileProperty(key: string): Promise<void> {\n        if (!(await this.doesServerSupportExtendedProfiles())) {\n            throw new Error(\"Server does not support extended profiles\");\n        }\n        const userId = this.getUserId();\n\n        await this.http.authedRequest(\n            Method.Delete,\n            utils.encodeUri(\"/profile/$userId/$key\", { $userId: userId, $key: key }),\n            undefined,\n            undefined,\n            {\n                prefix: await this.getExtendedProfileRequestPrefix(),\n            },\n        );\n    }\n\n    /**\n     * Update multiple properties on your *extended* profile. This will\n     * merge with any existing keys.\n     *\n     * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n     * @param profile The profile object to merge with the existing profile.\n     * @returns The newly merged profile.\n     *\n     * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n     */\n    public async patchExtendedProfile(profile: Record<string, unknown>): Promise<Record<string, unknown>> {\n        if (!(await this.doesServerSupportExtendedProfiles())) {\n            throw new Error(\"Server does not support extended profiles\");\n        }\n        const userId = this.getUserId();\n\n        return this.http.authedRequest(\n            Method.Patch,\n            utils.encodeUri(\"/profile/$userId\", { $userId: userId }),\n            {},\n            profile,\n            {\n                prefix: await this.getExtendedProfileRequestPrefix(),\n            },\n        );\n    }\n\n    /**\n     * Set multiple properties on your *extended* profile. This will completely\n     * replace the existing profile, removing any unspecified keys.\n     *\n     * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n     * @param profile The profile object to set.\n     *\n     * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n     */\n    public async setExtendedProfile(profile: Record<string, unknown>): Promise<void> {\n        if (!(await this.doesServerSupportExtendedProfiles())) {\n            throw new Error(\"Server does not support extended profiles\");\n        }\n        const userId = this.getUserId();\n\n        await this.http.authedRequest(\n            Method.Put,\n            utils.encodeUri(\"/profile/$userId\", { $userId: userId }),\n            {},\n            profile,\n            {\n                prefix: await this.getExtendedProfileRequestPrefix(),\n            },\n        );\n    }\n\n    /**\n     * @returns Promise which resolves to a list of the user's threepids.\n     * @returns Rejects: with an error response.\n     */\n    public getThreePids(): Promise<{ threepids: IThreepid[] }> {\n        return this.http.authedRequest(Method.Get, \"/account/3pid\");\n    }\n\n    /**\n     * Add a 3PID to your homeserver account. This API does not use an identity\n     * server, as the homeserver is expected to handle 3PID ownership validation.\n     *\n     * @param data - A object with 3PID validation data from having called\n     * `account/3pid/<medium>/requestToken` on the homeserver.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public async addThreePidOnly(data: IAddThreePidOnlyBody): Promise<EmptyObject> {\n        const path = \"/account/3pid/add\";\n        return this.http.authedRequest(Method.Post, path, undefined, data);\n    }\n\n    /**\n     * Bind a 3PID for discovery onto an identity server via the homeserver. The\n     * identity server handles 3PID ownership validation and the homeserver records\n     * the new binding to track where all 3PIDs for the account are bound.\n     *\n     * @param data - A object with 3PID validation data from having called\n     * `validate/<medium>/requestToken` on the identity server. It should also\n     * contain `id_server` and `id_access_token` fields as well.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public async bindThreePid(data: IBindThreePidBody): Promise<EmptyObject> {\n        const path = \"/account/3pid/bind\";\n        return this.http.authedRequest(Method.Post, path, undefined, data);\n    }\n\n    /**\n     * Unbind a 3PID for discovery on an identity server via the homeserver. The\n     * homeserver removes its record of the binding to keep an updated record of\n     * where all 3PIDs for the account are bound.\n     *\n     * @param medium - The threepid medium (eg. 'email')\n     * @param address - The threepid address (eg. 'bob\\@example.com')\n     *        this must be as returned by getThreePids.\n     * @returns Promise which resolves: on success\n     * @returns Rejects: with an error response.\n     */\n    public async unbindThreePid(\n        medium: string,\n        address: string,\n        // eslint-disable-next-line camelcase\n    ): Promise<{ id_server_unbind_result: IdServerUnbindResult }> {\n        const path = \"/account/3pid/unbind\";\n        const data = {\n            medium,\n            address,\n            id_server: this.getIdentityServerUrl(true),\n        };\n        return this.http.authedRequest(Method.Post, path, undefined, data);\n    }\n\n    /**\n     * @param medium - The threepid medium (eg. 'email')\n     * @param address - The threepid address (eg. 'bob\\@example.com')\n     *        this must be as returned by getThreePids.\n     * @returns Promise which resolves: The server response on success\n     *     (generally the empty JSON object)\n     * @returns Rejects: with an error response.\n     */\n    public deleteThreePid(\n        medium: string,\n        address: string,\n        // eslint-disable-next-line camelcase\n    ): Promise<{ id_server_unbind_result: IdServerUnbindResult }> {\n        const path = \"/account/3pid/delete\";\n        return this.http.authedRequest(Method.Post, path, undefined, { medium, address });\n    }\n\n    /**\n     * Make a request to change your password.\n     * @param newPassword - The new desired password.\n     * @param logoutDevices - Should all sessions be logged out after the password change. Defaults to true.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public setPassword(authDict: AuthDict, newPassword: string, logoutDevices?: boolean): Promise<EmptyObject> {\n        const path = \"/account/password\";\n        const data = {\n            auth: authDict,\n            new_password: newPassword,\n            logout_devices: logoutDevices,\n        };\n\n        return this.http.authedRequest<EmptyObject>(Method.Post, path, undefined, data);\n    }\n\n    /**\n     * Gets all devices recorded for the logged-in user\n     * @returns Promise which resolves: result object\n     * @returns Rejects: with an error response.\n     */\n    public getDevices(): Promise<{ devices: IMyDevice[] }> {\n        return this.http.authedRequest(Method.Get, \"/devices\");\n    }\n\n    /**\n     * Gets specific device details for the logged-in user\n     * @param deviceId -  device to query\n     * @returns Promise which resolves: result object\n     * @returns Rejects: with an error response.\n     */\n    public getDevice(deviceId: string): Promise<IMyDevice> {\n        const path = utils.encodeUri(\"/devices/$device_id\", {\n            $device_id: deviceId,\n        });\n        return this.http.authedRequest(Method.Get, path);\n    }\n\n    /**\n     * Update the given device\n     *\n     * @param deviceId -  device to update\n     * @param body -       body of request\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    // eslint-disable-next-line camelcase\n    public setDeviceDetails(deviceId: string, body: { display_name: string }): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/devices/$device_id\", {\n            $device_id: deviceId,\n        });\n\n        return this.http.authedRequest(Method.Put, path, undefined, body);\n    }\n\n    /**\n     * Delete the given device\n     *\n     * @param deviceId -  device to delete\n     * @param auth - Optional. Auth data to supply for User-Interactive auth.\n     * @returns Promise which resolves: result object\n     * @returns Rejects: with an error response.\n     */\n    public deleteDevice(deviceId: string, auth?: AuthDict): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/devices/$device_id\", {\n            $device_id: deviceId,\n        });\n\n        const body: Body = {};\n\n        if (auth) {\n            body.auth = auth;\n        }\n\n        return this.http.authedRequest(Method.Delete, path, undefined, body);\n    }\n\n    /**\n     * Delete multiple device\n     *\n     * @param devices - IDs of the devices to delete\n     * @param auth - Optional. Auth data to supply for User-Interactive auth.\n     * @returns Promise which resolves: result object\n     * @returns Rejects: with an error response.\n     */\n    public deleteMultipleDevices(devices: string[], auth?: AuthDict): Promise<EmptyObject> {\n        const body: Body = { devices };\n\n        if (auth) {\n            body.auth = auth;\n        }\n\n        const path = \"/delete_devices\";\n        return this.http.authedRequest(Method.Post, path, undefined, body);\n    }\n\n    /**\n     * Gets all pushers registered for the logged-in user\n     *\n     * @returns Promise which resolves: Array of objects representing pushers\n     * @returns Rejects: with an error response.\n     */\n    public async getPushers(): Promise<{ pushers: IPusher[] }> {\n        const response = await this.http.authedRequest<{ pushers: IPusher[] }>(Method.Get, \"/pushers\");\n\n        // Migration path for clients that connect to a homeserver that does not support\n        // MSC3881 yet, see https://github.com/matrix-org/matrix-spec-proposals/blob/kerry/remote-push-toggle/proposals/3881-remote-push-notification-toggling.md#migration\n        if (!(await this.doesServerSupportUnstableFeature(\"org.matrix.msc3881\"))) {\n            response.pushers = response.pushers.map((pusher) => {\n                if (!pusher.hasOwnProperty(PUSHER_ENABLED.name)) {\n                    pusher[PUSHER_ENABLED.name] = true;\n                }\n                return pusher;\n            });\n        }\n\n        return response;\n    }\n\n    /**\n     * Adds a new pusher or updates an existing pusher\n     *\n     * @param pusher - Object representing a pusher\n     * @returns Promise which resolves: Empty json object on success\n     * @returns Rejects: with an error response.\n     */\n    public setPusher(pusher: IPusherRequest): Promise<EmptyObject> {\n        const path = \"/pushers/set\";\n        return this.http.authedRequest(Method.Post, path, undefined, pusher);\n    }\n\n    /**\n     * Removes an existing pusher\n     * @param pushKey - pushkey of pusher to remove\n     * @param appId - app_id of pusher to remove\n     * @returns Promise which resolves: Empty json object on success\n     * @returns Rejects: with an error response.\n     */\n    public removePusher(pushKey: string, appId: string): Promise<EmptyObject> {\n        const path = \"/pushers/set\";\n        const body = {\n            pushkey: pushKey,\n            app_id: appId,\n            kind: null, // marks pusher for removal\n        };\n        return this.http.authedRequest(Method.Post, path, undefined, body);\n    }\n\n    /**\n     * Persists local notification settings\n     * @returns Promise which resolves: an empty object\n     * @returns Rejects: with an error response.\n     */\n    public setLocalNotificationSettings(\n        deviceId: string,\n        notificationSettings: LocalNotificationSettings,\n    ): Promise<EmptyObject> {\n        const key = `${LOCAL_NOTIFICATION_SETTINGS_PREFIX.name}.${deviceId}` as const;\n        return this.setAccountData(key, notificationSettings);\n    }\n\n    /**\n     * Get the push rules for the account from the server.\n     * @returns Promise which resolves to the push rules.\n     * @returns Rejects: with an error response.\n     */\n    public getPushRules(): Promise<IPushRules> {\n        return this.http.authedRequest<IPushRules>(Method.Get, \"/pushrules/\").then((rules: IPushRules) => {\n            this.setPushRules(rules);\n            return this.pushRules!;\n        });\n    }\n\n    /**\n     * Update the push rules for the account. This should be called whenever\n     * updated push rules are available.\n     */\n    public setPushRules(rules: IPushRules): void {\n        // Fix-up defaults, if applicable.\n        this.pushRules = PushProcessor.rewriteDefaultRules(this.logger, rules, this.getUserId()!);\n        // Pre-calculate any necessary caches.\n        this.pushProcessor.updateCachedPushRuleKeys(this.pushRules);\n    }\n\n    /**\n     * @returns Promise which resolves: an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public addPushRule(\n        scope: string,\n        kind: PushRuleKind,\n        ruleId: Exclude<string, RuleId>,\n        body: Pick<IPushRule, \"actions\" | \"conditions\" | \"pattern\">,\n    ): Promise<EmptyObject> {\n        // NB. Scope not uri encoded because devices need the '/'\n        const path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId\", {\n            $kind: kind,\n            $ruleId: ruleId,\n        });\n        return this.http.authedRequest(Method.Put, path, undefined, body);\n    }\n\n    /**\n     * @returns Promise which resolves: an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public deletePushRule(scope: string, kind: PushRuleKind, ruleId: Exclude<string, RuleId>): Promise<EmptyObject> {\n        // NB. Scope not uri encoded because devices need the '/'\n        const path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId\", {\n            $kind: kind,\n            $ruleId: ruleId,\n        });\n        return this.http.authedRequest(Method.Delete, path);\n    }\n\n    /**\n     * Enable or disable a push notification rule.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public setPushRuleEnabled(\n        scope: string,\n        kind: PushRuleKind,\n        ruleId: RuleId | string,\n        enabled: boolean,\n    ): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId/enabled\", {\n            $kind: kind,\n            $ruleId: ruleId,\n        });\n        return this.http.authedRequest(Method.Put, path, undefined, { enabled: enabled });\n    }\n\n    /**\n     * Set the actions for a push notification rule.\n     * @returns Promise which resolves: to an empty object `{}`\n     * @returns Rejects: with an error response.\n     */\n    public setPushRuleActions(\n        scope: string,\n        kind: PushRuleKind,\n        ruleId: RuleId | string,\n        actions: PushRuleAction[],\n    ): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId/actions\", {\n            $kind: kind,\n            $ruleId: ruleId,\n        });\n        return this.http.authedRequest(Method.Put, path, undefined, { actions: actions });\n    }\n\n    /**\n     * Perform a server-side search.\n     * @param params\n     * @param params.next_batch - the batch token to pass in the query string\n     * @param params.body - the JSON object to pass to the request body.\n     * @param abortSignal - optional signal used to cancel the http request.\n     * @returns Promise which resolves to the search response object.\n     * @returns Rejects: with an error response.\n     */\n    public search(\n        { body, next_batch: nextBatch }: { body: ISearchRequestBody; next_batch?: string },\n        abortSignal?: AbortSignal,\n    ): Promise<ISearchResponse> {\n        const queryParams: QueryDict = {};\n        if (nextBatch) {\n            queryParams.next_batch = nextBatch;\n        }\n        return this.http.authedRequest(Method.Post, \"/search\", queryParams, body, { abortSignal });\n    }\n\n    /**\n     * Upload keys\n     *\n     * @param content -  body of upload request\n     *\n     * @param opts - this method no longer takes any opts,\n     *  used to take opts.device_id but this was not removed from the spec as a redundant parameter\n     *\n     * @returns Promise which resolves: result object. Rejects: with\n     *     an error response ({@link MatrixError}).\n     */\n    public uploadKeysRequest(content: IUploadKeysRequest, opts?: void): Promise<IKeysUploadResponse> {\n        return this.http.authedRequest(Method.Post, \"/keys/upload\", undefined, content);\n    }\n\n    public uploadKeySignatures(content: KeySignatures): Promise<IUploadKeySignaturesResponse> {\n        return this.http.authedRequest(Method.Post, \"/keys/signatures/upload\", undefined, content);\n    }\n\n    /**\n     * Download device keys\n     *\n     * @param userIds -  list of users to get keys for\n     *\n     * @param token - sync token to pass in the query request, to help\n     *   the HS give the most recent results\n     *\n     * @returns Promise which resolves: result object. Rejects: with\n     *     an error response ({@link MatrixError}).\n     */\n    public downloadKeysForUsers(userIds: string[], { token }: { token?: string } = {}): Promise<IDownloadKeyResult> {\n        const content: IQueryKeysRequest = {\n            device_keys: {},\n        };\n        if (token !== undefined) {\n            content.token = token;\n        }\n        userIds.forEach((u) => {\n            content.device_keys[u] = [];\n        });\n\n        return this.http.authedRequest(Method.Post, \"/keys/query\", undefined, content);\n    }\n\n    /**\n     * Claim one-time keys\n     *\n     * @param devices -  a list of [userId, deviceId] pairs\n     *\n     * @param keyAlgorithm -  desired key type\n     *\n     * @param timeout - the time (in milliseconds) to wait for keys from remote\n     *     servers\n     *\n     * @returns Promise which resolves: result object. Rejects: with\n     *     an error response ({@link MatrixError}).\n     */\n    public claimOneTimeKeys(\n        devices: [string, string][],\n        keyAlgorithm = \"signed_curve25519\",\n        timeout?: number,\n    ): Promise<IClaimOTKsResult> {\n        const queries: Record<string, Record<string, string>> = {};\n\n        if (keyAlgorithm === undefined) {\n            keyAlgorithm = \"signed_curve25519\";\n        }\n\n        for (const [userId, deviceId] of devices) {\n            const query = queries[userId] || {};\n            safeSet(queries, userId, query);\n            safeSet(query, deviceId, keyAlgorithm);\n        }\n        const content: IClaimKeysRequest = { one_time_keys: queries };\n        if (timeout) {\n            content.timeout = timeout;\n        }\n        const path = \"/keys/claim\";\n        return this.http.authedRequest(Method.Post, path, undefined, content);\n    }\n\n    /**\n     * Ask the server for a list of users who have changed their device lists\n     * between a pair of sync tokens\n     *\n     *\n     * @returns Promise which resolves: result object. Rejects: with\n     *     an error response ({@link MatrixError}).\n     */\n    public getKeyChanges(oldToken: string, newToken: string): Promise<{ changed: string[]; left: string[] }> {\n        const qps = {\n            from: oldToken,\n            to: newToken,\n        };\n\n        return this.http.authedRequest(Method.Get, \"/keys/changes\", qps);\n    }\n\n    public uploadDeviceSigningKeys(auth?: AuthDict, keys?: CrossSigningKeys): Promise<EmptyObject> {\n        // API returns empty object\n        const data = Object.assign({}, keys);\n        if (auth) Object.assign(data, { auth });\n        return this.http.authedRequest(Method.Post, \"/keys/device_signing/upload\", undefined, data, {\n            prefix: ClientPrefix.Unstable,\n        });\n    }\n\n    /**\n     * Register with an identity server using the OpenID token from the user's\n     * Homeserver, which can be retrieved via\n     * {@link MatrixClient#getOpenIdToken}.\n     *\n     * Note that the `/account/register` endpoint (as well as IS authentication in\n     * general) was added as part of the v2 API version.\n     *\n     * @returns Promise which resolves: with object containing an Identity\n     * Server access token.\n     * @returns Rejects: with an error response.\n     */\n    public registerWithIdentityServer(hsOpenIdToken: IOpenIDToken): Promise<{\n        access_token: string;\n        token: string;\n    }> {\n        if (!this.idBaseUrl) {\n            throw new Error(\"No identity server base URL set\");\n        }\n\n        const uri = this.http.getUrl(\"/account/register\", undefined, IdentityPrefix.V2, this.idBaseUrl);\n        return this.http.requestOtherUrl(Method.Post, uri, hsOpenIdToken);\n    }\n\n    /**\n     * Requests an email verification token directly from an identity server.\n     *\n     * This API is used as part of binding an email for discovery on an identity\n     * server. The validation data that results should be passed to the\n     * `bindThreePid` method to complete the binding process.\n     *\n     * @param email - The email address to request a token for\n     * @param clientSecret - A secret binary string generated by the client.\n     *                 It is recommended this be around 16 ASCII characters.\n     * @param sendAttempt - If an identity server sees a duplicate request\n     *                 with the same sendAttempt, it will not send another email.\n     *                 To request another email to be sent, use a larger value for\n     *                 the sendAttempt param as was used in the previous request.\n     * @param nextLink - Optional If specified, the client will be redirected\n     *                 to this link after validation.\n     * @param identityAccessToken - The `access_token` field of the identity\n     * server `/account/register` response (see {@link registerWithIdentityServer}).\n     *\n     * @returns Promise which resolves: TODO\n     * @returns Rejects: with an error response.\n     * @throws Error if no identity server is set\n     */\n    public requestEmailToken(\n        email: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink?: string,\n        identityAccessToken?: string,\n    ): Promise<IRequestTokenResponse> {\n        const params: Record<string, string> = {\n            client_secret: clientSecret,\n            email: email,\n            send_attempt: sendAttempt?.toString(),\n        };\n        if (nextLink) {\n            params.next_link = nextLink;\n        }\n\n        return this.http.idServerRequest<IRequestTokenResponse>(\n            Method.Post,\n            \"/validate/email/requestToken\",\n            params,\n            IdentityPrefix.V2,\n            identityAccessToken,\n        );\n    }\n\n    /**\n     * Requests a MSISDN verification token directly from an identity server.\n     *\n     * This API is used as part of binding a MSISDN for discovery on an identity\n     * server. The validation data that results should be passed to the\n     * `bindThreePid` method to complete the binding process.\n     *\n     * @param phoneCountry - The ISO 3166-1 alpha-2 code for the country in\n     *                 which phoneNumber should be parsed relative to.\n     * @param phoneNumber - The phone number, in national or international\n     *                 format\n     * @param clientSecret - A secret binary string generated by the client.\n     *                 It is recommended this be around 16 ASCII characters.\n     * @param sendAttempt - If an identity server sees a duplicate request\n     *                 with the same sendAttempt, it will not send another SMS.\n     *                 To request another SMS to be sent, use a larger value for\n     *                 the sendAttempt param as was used in the previous request.\n     * @param nextLink - Optional If specified, the client will be redirected\n     *                 to this link after validation.\n     * @param identityAccessToken - The `access_token` field of the Identity\n     * Server `/account/register` response (see {@link registerWithIdentityServer}).\n     *\n     * @returns Promise which resolves to an object with a sid string\n     * @returns Rejects: with an error response.\n     * @throws Error if no identity server is set\n     */\n    public requestMsisdnToken(\n        phoneCountry: string,\n        phoneNumber: string,\n        clientSecret: string,\n        sendAttempt: number,\n        nextLink?: string,\n        identityAccessToken?: string,\n    ): Promise<IRequestMsisdnTokenResponse> {\n        const params: Record<string, string> = {\n            client_secret: clientSecret,\n            country: phoneCountry,\n            phone_number: phoneNumber,\n            send_attempt: sendAttempt?.toString(),\n        };\n        if (nextLink) {\n            params.next_link = nextLink;\n        }\n\n        return this.http.idServerRequest<IRequestMsisdnTokenResponse>(\n            Method.Post,\n            \"/validate/msisdn/requestToken\",\n            params,\n            IdentityPrefix.V2,\n            identityAccessToken,\n        );\n    }\n\n    /**\n     * Submits a MSISDN token to the identity server\n     *\n     * This is used when submitting the code sent by SMS to a phone number.\n     * The identity server has an equivalent API for email but the js-sdk does\n     * not expose this, since email is normally validated by the user clicking\n     * a link rather than entering a code.\n     *\n     * @param sid - The sid given in the response to requestToken\n     * @param clientSecret - A secret binary string generated by the client.\n     *                 This must be the same value submitted in the requestToken call.\n     * @param msisdnToken - The MSISDN token, as entered by the user.\n     * @param identityAccessToken - The `access_token` field of the Identity\n     * Server `/account/register` response (see {@link registerWithIdentityServer}).\n     * Some legacy identity servers had no authentication here.\n     *\n     * @returns Promise which resolves: Object, containing success boolean.\n     * @returns Rejects: with an error response.\n     * @throws Error if No identity server is set\n     */\n    public submitMsisdnToken(\n        sid: string,\n        clientSecret: string,\n        msisdnToken: string,\n        identityAccessToken: string | null,\n    ): Promise<{ success: boolean }> {\n        const params = {\n            sid: sid,\n            client_secret: clientSecret,\n            token: msisdnToken,\n        };\n\n        return this.http.idServerRequest(\n            Method.Post,\n            \"/validate/msisdn/submitToken\",\n            params,\n            IdentityPrefix.V2,\n            identityAccessToken ?? undefined,\n        );\n    }\n\n    /**\n     * Submits a MSISDN token to an arbitrary URL.\n     *\n     * This is used when submitting the code sent by SMS to a phone number in the\n     * newer 3PID flow where the homeserver validates 3PID ownership (as part of\n     * `requestAdd3pidMsisdnToken`). The homeserver response may include a\n     * `submit_url` to specify where the token should be sent, and this helper can\n     * be used to pass the token to this URL.\n     *\n     * @param url - The URL to submit the token to\n     * @param sid - The sid given in the response to requestToken\n     * @param clientSecret - A secret binary string generated by the client.\n     *                 This must be the same value submitted in the requestToken call.\n     * @param msisdnToken - The MSISDN token, as entered by the user.\n     *\n     * @returns Promise which resolves: Object, containing success boolean.\n     * @returns Rejects: with an error response.\n     */\n    public submitMsisdnTokenOtherUrl(\n        url: string,\n        sid: string,\n        clientSecret: string,\n        msisdnToken: string,\n    ): Promise<{ success: boolean }> {\n        const params = {\n            sid: sid,\n            client_secret: clientSecret,\n            token: msisdnToken,\n        };\n        return this.http.requestOtherUrl(Method.Post, url, params);\n    }\n\n    /**\n     * Gets the V2 hashing information from the identity server. Primarily useful for\n     * lookups.\n     * @param identityAccessToken - The access token for the identity server.\n     * @returns The hashing information for the identity server.\n     */\n    public getIdentityHashDetails(identityAccessToken: string): Promise<{\n        /**\n         * The algorithms the server supports. Must contain at least sha256.\n         */\n        algorithms: string[];\n        /**\n         * The pepper the client MUST use in hashing identifiers,\n         * and MUST supply to the /lookup endpoint when performing lookups.\n         */\n        lookup_pepper: string;\n    }> {\n        return this.http.idServerRequest(\n            Method.Get,\n            \"/hash_details\",\n            undefined,\n            IdentityPrefix.V2,\n            identityAccessToken,\n        );\n    }\n\n    /**\n     * Performs a hashed lookup of addresses against the identity server. This is\n     * only supported on identity servers which have at least the version 2 API.\n     * @param addressPairs - An array of 2 element arrays.\n     * The first element of each pair is the address, the second is the 3PID medium.\n     * Eg: `[\"email@example.org\", \"email\"]`\n     * @param identityAccessToken - The access token for the identity server.\n     * @returns A collection of address mappings to\n     * found MXIDs. Results where no user could be found will not be listed.\n     */\n    public async identityHashedLookup(\n        addressPairs: [string, string][],\n        identityAccessToken: string,\n    ): Promise<{ address: string; mxid: string }[]> {\n        const params: Record<string, string | string[]> = {\n            // addresses: [\"email@example.org\", \"10005550000\"],\n            // algorithm: \"sha256\",\n            // pepper: \"abc123\"\n        };\n\n        // Get hash information first before trying to do a lookup\n        const hashes = await this.getIdentityHashDetails(identityAccessToken);\n        if (!hashes || !hashes[\"lookup_pepper\"] || !hashes[\"algorithms\"]) {\n            throw new Error(\"Unsupported identity server: bad response\");\n        }\n\n        params[\"pepper\"] = hashes[\"lookup_pepper\"];\n\n        const localMapping: Record<string, string> = {\n            // hashed identifier => plain text address\n            // For use in this function's return format\n        };\n\n        // When picking an algorithm, we pick the hashed over no hashes\n        if (hashes[\"algorithms\"].includes(\"sha256\")) {\n            params[\"addresses\"] = await Promise.all(\n                addressPairs.map(async (p) => {\n                    const addr = p[0].toLowerCase(); // lowercase to get consistent hashes\n                    const med = p[1].toLowerCase();\n                    const hashBuffer = await sha256(`${addr} ${med} ${params[\"pepper\"]}`);\n                    const hashed = encodeUnpaddedBase64Url(hashBuffer);\n\n                    // Map the hash to a known (case-sensitive) address. We use the case\n                    // sensitive version because the caller might be expecting that.\n                    localMapping[hashed] = p[0];\n                    return hashed;\n                }),\n            );\n            params[\"algorithm\"] = \"sha256\";\n        } else if (hashes[\"algorithms\"].includes(\"none\")) {\n            params[\"addresses\"] = addressPairs.map((p) => {\n                const addr = p[0].toLowerCase(); // lowercase to get consistent hashes\n                const med = p[1].toLowerCase();\n                const unhashed = `${addr} ${med}`;\n                // Map the unhashed values to a known (case-sensitive) address. We use\n                // the case-sensitive version because the caller might be expecting that.\n                localMapping[unhashed] = p[0];\n                return unhashed;\n            });\n            params[\"algorithm\"] = \"none\";\n        } else {\n            throw new Error(\"Unsupported identity server: unknown hash algorithm\");\n        }\n\n        const response = await this.http.idServerRequest<{\n            mappings: { [address: string]: string };\n        }>(Method.Post, \"/lookup\", params, IdentityPrefix.V2, identityAccessToken);\n\n        if (!response?.[\"mappings\"]) return []; // no results\n\n        const foundAddresses: { address: string; mxid: string }[] = [];\n        for (const hashed of Object.keys(response[\"mappings\"])) {\n            const mxid = response[\"mappings\"][hashed];\n            const plainAddress = localMapping[hashed];\n            if (!plainAddress) {\n                throw new Error(\"Identity server returned more results than expected\");\n            }\n\n            foundAddresses.push({ address: plainAddress, mxid });\n        }\n        return foundAddresses;\n    }\n\n    /**\n     * Looks up the public Matrix ID mapping for a given 3rd party\n     * identifier from the identity server\n     *\n     * @param medium - The medium of the threepid, eg. 'email'\n     * @param address - The textual address of the threepid\n     * @param identityAccessToken - The `access_token` field of the Identity\n     * Server `/account/register` response (see {@link registerWithIdentityServer}).\n     *\n     * @returns Promise which resolves: A threepid mapping\n     *                                 object or the empty object if no mapping\n     *                                 exists\n     * @returns Rejects: with an error response.\n     */\n    public async lookupThreePid(\n        medium: string,\n        address: string,\n        identityAccessToken: string,\n    ): Promise<\n        | {\n              address: string;\n              medium: string;\n              mxid: string;\n          }\n        | EmptyObject\n    > {\n        // Note: we're using the V2 API by calling this function, but our\n        // function contract requires a V1 response. We therefore have to\n        // convert it manually.\n        const response = await this.identityHashedLookup([[address, medium]], identityAccessToken);\n        const result = response.find((p) => p.address === address);\n        if (!result) {\n            return {};\n        }\n\n        const mapping = {\n            address,\n            medium,\n            mxid: result.mxid,\n\n            // We can't reasonably fill these parameters:\n            // not_before\n            // not_after\n            // ts\n            // signatures\n        };\n\n        return mapping;\n    }\n\n    /**\n     * Looks up the public Matrix ID mappings for multiple 3PIDs.\n     *\n     * @param query - Array of arrays containing\n     * [medium, address]\n     * @param identityAccessToken - The `access_token` field of the Identity\n     * Server `/account/register` response (see {@link registerWithIdentityServer}).\n     *\n     * @returns Promise which resolves: Lookup results from IS.\n     * @returns Rejects: with an error response.\n     */\n    public async bulkLookupThreePids(\n        query: [string, string][],\n        identityAccessToken: string,\n    ): Promise<{\n        threepids: [medium: string, address: string, mxid: string][];\n    }> {\n        // Note: we're using the V2 API by calling this function, but our\n        // function contract requires a V1 response. We therefore have to\n        // convert it manually.\n        const response = await this.identityHashedLookup(\n            // We have to reverse the query order to get [address, medium] pairs\n            query.map((p) => [p[1], p[0]]),\n            identityAccessToken,\n        );\n\n        const v1results: [medium: string, address: string, mxid: string][] = [];\n        for (const mapping of response) {\n            const originalQuery = query.find((p) => p[1] === mapping.address);\n            if (!originalQuery) {\n                throw new Error(\"Identity sever returned unexpected results\");\n            }\n\n            v1results.push([\n                originalQuery[0], // medium\n                mapping.address,\n                mapping.mxid,\n            ]);\n        }\n\n        return { threepids: v1results };\n    }\n\n    /**\n     * Get account info from the identity server. This is useful as a neutral check\n     * to verify that other APIs are likely to approve access by testing that the\n     * token is valid, terms have been agreed, etc.\n     *\n     * @param identityAccessToken - The `access_token` field of the Identity\n     * Server `/account/register` response (see {@link registerWithIdentityServer}).\n     *\n     * @returns Promise which resolves: an object with account info.\n     * @returns Rejects: with an error response.\n     */\n    public getIdentityAccount(identityAccessToken: string): Promise<{ user_id: string }> {\n        return this.http.idServerRequest(Method.Get, \"/account\", undefined, IdentityPrefix.V2, identityAccessToken);\n    }\n\n    /**\n     * Send an event to a specific list of devices.\n     * This is a low-level API that simply wraps the HTTP API\n     * call to send to-device messages. We recommend using\n     * queueToDevice() which is a higher level API.\n     *\n     * @param eventType -  type of event to send\n     *    content to send. Map from user_id to device_id to content object.\n     * @param txnId -     transaction id. One will be made up if not\n     *    supplied.\n     * @returns Promise which resolves: to an empty object `{}`\n     */\n    public sendToDevice(eventType: string, contentMap: SendToDeviceContentMap, txnId?: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/sendToDevice/$eventType/$txnId\", {\n            $eventType: eventType,\n            $txnId: txnId ? txnId : this.makeTxnId(),\n        });\n\n        const body = {\n            messages: utils.recursiveMapToObject(contentMap),\n        };\n\n        const targets = new Map<string, string[]>();\n\n        for (const [userId, deviceMessages] of contentMap) {\n            targets.set(userId, Array.from(deviceMessages.keys()));\n        }\n\n        this.logger.debug(`PUT ${path}`, targets);\n\n        return this.http.authedRequest(Method.Put, path, undefined, body);\n    }\n\n    /**\n     * This will encrypt the payload for all devices in the list and will queue it.\n     * The type of the sent to-device message will be `m.room.encrypted`.\n     * @param eventType - The type of event to send\n     * @param devices - The list of devices to send the event to.\n     * @param payload - The payload to send. This will be encrypted.\n     * @returns Promise which resolves once queued there is no error feedback when sending fails.\n     */\n    public async encryptAndSendToDevice(\n        eventType: string,\n        devices: { userId: string; deviceId: string }[],\n        payload: ToDevicePayload,\n    ): Promise<void> {\n        if (!this.cryptoBackend) {\n            throw new Error(\"Cannot encrypt to device event, your client does not support encryption.\");\n        }\n        const batch = await this.cryptoBackend.encryptToDeviceMessages(eventType, devices, payload);\n\n        // TODO The batch mechanism removes all possibility to get error feedbacks..\n        // We might want instead to do the API call directly and pass the errors back.\n        await this.queueToDevice(batch);\n    }\n\n    /**\n     * Sends events directly to specific devices using Matrix's to-device\n     * messaging system. The batch will be split up into appropriately sized\n     * batches for sending and stored in the store so they can be retried\n     * later if they fail to send. Retries will happen automatically.\n     * @param batch - The to-device messages to send\n     */\n    public queueToDevice(batch: ToDeviceBatch): Promise<void> {\n        return this.toDeviceMessageQueue.queueBatch(batch);\n    }\n\n    /**\n     * Get the third party protocols that can be reached using\n     * this HS\n     * @returns Promise which resolves to the result object\n     */\n    public getThirdpartyProtocols(): Promise<{ [protocol: string]: IProtocol }> {\n        return this.http\n            .authedRequest<Record<string, IProtocol>>(Method.Get, \"/thirdparty/protocols\")\n            .then((response) => {\n                // sanity check\n                if (!response || typeof response !== \"object\") {\n                    throw new Error(`/thirdparty/protocols did not return an object: ${response}`);\n                }\n                return response;\n            });\n    }\n\n    /**\n     * Get information on how a specific place on a third party protocol\n     * may be reached.\n     * @param protocol - The protocol given in getThirdpartyProtocols()\n     * @param params - Protocol-specific parameters, as given in the\n     *                        response to getThirdpartyProtocols()\n     * @returns Promise which resolves to the result object\n     */\n    public getThirdpartyLocation(\n        protocol: string,\n        params: { searchFields?: string[] },\n    ): Promise<IThirdPartyLocation[]> {\n        const path = utils.encodeUri(\"/thirdparty/location/$protocol\", {\n            $protocol: protocol,\n        });\n\n        return this.http.authedRequest(Method.Get, path, params);\n    }\n\n    /**\n     * Get information on how a specific user on a third party protocol\n     * may be reached.\n     * @param protocol - The protocol given in getThirdpartyProtocols()\n     * @param params - Protocol-specific parameters, as given in the\n     *                        response to getThirdpartyProtocols()\n     * @returns Promise which resolves to the result object\n     */\n    public getThirdpartyUser(protocol: string, params?: QueryDict): Promise<IThirdPartyUser[]> {\n        const path = utils.encodeUri(\"/thirdparty/user/$protocol\", {\n            $protocol: protocol,\n        });\n\n        return this.http.authedRequest(Method.Get, path, params);\n    }\n\n    public getTerms(serviceType: SERVICE_TYPES, baseUrl: string): Promise<Terms> {\n        const url = this.termsUrlForService(serviceType, baseUrl);\n        return this.http.requestOtherUrl(Method.Get, url);\n    }\n\n    public agreeToTerms(\n        serviceType: SERVICE_TYPES,\n        baseUrl: string,\n        accessToken: string,\n        termsUrls: string[],\n    ): Promise<EmptyObject> {\n        const url = this.termsUrlForService(serviceType, baseUrl);\n        const headers = {\n            Authorization: \"Bearer \" + accessToken,\n        };\n        return this.http.requestOtherUrl(\n            Method.Post,\n            url,\n            {\n                user_accepts: termsUrls,\n            },\n            { headers },\n        );\n    }\n\n    /**\n     * Reports an event as inappropriate to the server, which may then notify the appropriate people.\n     * @param roomId - The room in which the event being reported is located.\n     * @param eventId - The event to report.\n     * @param score - The score to rate this content as where -100 is most offensive and 0 is inoffensive.\n     * @param reason - The reason the content is being reported. May be blank.\n     * @returns Promise which resolves to an empty object if successful\n     */\n    public reportEvent(roomId: string, eventId: string, score: number, reason: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/rooms/$roomId/report/$eventId\", {\n            $roomId: roomId,\n            $eventId: eventId,\n        });\n\n        return this.http.authedRequest(Method.Post, path, undefined, { score, reason });\n    }\n\n    /**\n     * Reports a room as inappropriate to the server, which may then notify the appropriate people.\n     *\n     * This API was introduced in Matrix v1.13.\n     *\n     * @param roomId - The room being reported.\n     * @param reason - The reason the room is being reported. May be blank.\n     * @returns Promise which resolves to an empty object if successful\n     */\n    public reportRoom(roomId: string, reason: string): Promise<EmptyObject> {\n        const path = utils.encodeUri(\"/rooms/$roomId/report\", {\n            $roomId: roomId,\n        });\n\n        return this.http.authedRequest(Method.Post, path, undefined, { reason });\n    }\n\n    /**\n     * Fetches or paginates a room hierarchy asmatrix-js-sdk/spec/unit/matrix-client.spec.ts defined by MSC2946.\n     * Falls back gracefully to sourcing its data from `getSpaceSummary` if this API is not yet supported by the server.\n     * @param roomId - The ID of the space-room to use as the root of the summary.\n     * @param limit - The maximum number of rooms to return per page.\n     * @param maxDepth - The maximum depth in the tree from the root room to return.\n     * @param suggestedOnly - Whether to only return rooms with suggested=true.\n     * @param fromToken - The opaque token to paginate a previous request.\n     * @returns the response, with next_batch & rooms fields.\n     */\n    public getRoomHierarchy(\n        roomId: string,\n        limit?: number,\n        maxDepth?: number,\n        suggestedOnly = false,\n        fromToken?: string,\n    ): Promise<IRoomHierarchy> {\n        const path = utils.encodeUri(\"/rooms/$roomId/hierarchy\", {\n            $roomId: roomId,\n        });\n\n        const queryParams: QueryDict = {\n            suggested_only: String(suggestedOnly),\n            max_depth: maxDepth?.toString(),\n            from: fromToken,\n            limit: limit?.toString(),\n        };\n\n        return this.http\n            .authedRequest<IRoomHierarchy>(Method.Get, path, queryParams, undefined, {\n                prefix: ClientPrefix.V1,\n            })\n            .catch((e) => {\n                if (e.errcode === \"M_UNRECOGNIZED\") {\n                    // fall back to the prefixed hierarchy API.\n                    return this.http.authedRequest<IRoomHierarchy>(Method.Get, path, queryParams, undefined, {\n                        prefix: \"/_matrix/client/unstable/org.matrix.msc2946\",\n                    });\n                }\n\n                throw e;\n            });\n    }\n\n    /**\n     * Creates a new file tree space with the given name. The client will pick\n     * defaults for how it expects to be able to support the remaining API offered\n     * by the returned class.\n     *\n     * Note that this is UNSTABLE and may have breaking changes without notice.\n     * @param name - The name of the tree space.\n     * @returns Promise which resolves to the created space.\n     */\n    public async unstableCreateFileTree(name: string): Promise<MSC3089TreeSpace> {\n        const { room_id: roomId } = await this.createRoom({\n            name: name,\n            preset: Preset.PrivateChat,\n            power_level_content_override: {\n                ...DEFAULT_TREE_POWER_LEVELS_TEMPLATE,\n                users: {\n                    [this.getUserId()!]: 100,\n                },\n            },\n            creation_content: {\n                [RoomCreateTypeField]: RoomType.Space,\n            },\n            initial_state: [\n                {\n                    type: UNSTABLE_MSC3088_PURPOSE.name,\n                    state_key: UNSTABLE_MSC3089_TREE_SUBTYPE.name,\n                    content: {\n                        [UNSTABLE_MSC3088_ENABLED.name]: true,\n                    },\n                },\n                {\n                    type: EventType.RoomEncryption,\n                    state_key: \"\",\n                    content: {\n                        algorithm: \"m.megolm.v1.aes-sha2\",\n                    },\n                },\n            ],\n        });\n        return new MSC3089TreeSpace(this, roomId);\n    }\n\n    /**\n     * Gets a reference to a tree space, if the room ID given is a tree space. If the room\n     * does not appear to be a tree space then null is returned.\n     *\n     * Note that this is UNSTABLE and may have breaking changes without notice.\n     * @param roomId - The room ID to get a tree space reference for.\n     * @returns The tree space, or null if not a tree space.\n     */\n    public unstableGetFileTreeSpace(roomId: string): MSC3089TreeSpace | null {\n        const room = this.getRoom(roomId);\n        if (room?.getMyMembership() !== KnownMembership.Join) return null;\n\n        const createEvent = room.currentState.getStateEvents(EventType.RoomCreate, \"\");\n        const purposeEvent = room.currentState.getStateEvents(\n            UNSTABLE_MSC3088_PURPOSE.name,\n            UNSTABLE_MSC3089_TREE_SUBTYPE.name,\n        );\n\n        if (!createEvent) throw new Error(\"Expected single room create event\");\n\n        if (!purposeEvent?.getContent()?.[UNSTABLE_MSC3088_ENABLED.name]) return null;\n        if (createEvent.getContent()?.[RoomCreateTypeField] !== RoomType.Space) return null;\n\n        return new MSC3089TreeSpace(this, roomId);\n    }\n\n    /**\n     * Perform a single MSC3575 sliding sync request.\n     * @param req - The request to make.\n     * @param proxyBaseUrl - The base URL for the sliding sync proxy.\n     * @param abortSignal - Optional signal to abort request mid-flight.\n     * @returns The sliding sync response, or a standard error.\n     * @throws on non 2xx status codes with an object with a field \"httpStatus\":number.\n     */\n    public slidingSync(\n        req: MSC3575SlidingSyncRequest,\n        proxyBaseUrl?: string,\n        abortSignal?: AbortSignal,\n    ): Promise<MSC3575SlidingSyncResponse> {\n        const qps: QueryDict = {};\n        if (req.pos) {\n            qps.pos = req.pos;\n            delete req.pos;\n        }\n        if (req.timeout) {\n            qps.timeout = req.timeout;\n            delete req.timeout;\n        }\n        const clientTimeout = req.clientTimeout;\n        delete req.clientTimeout;\n        return this.http.authedRequest<MSC3575SlidingSyncResponse>(Method.Post, \"/sync\", qps, req, {\n            prefix: \"/_matrix/client/unstable/org.matrix.simplified_msc3575\",\n            baseUrl: proxyBaseUrl,\n            localTimeoutMs: clientTimeout,\n            abortSignal,\n        });\n    }\n\n    /**\n     * A helper to determine thread support\n     * @returns a boolean to determine if threads are enabled\n     */\n    public supportsThreads(): boolean {\n        return this.clientOpts?.threadSupport || false;\n    }\n\n    /**\n     * A helper to determine intentional mentions support\n     * @returns a boolean to determine if intentional mentions are enabled on the server\n     * @experimental\n     */\n    public supportsIntentionalMentions(): boolean {\n        return this.canSupport.get(Feature.IntentionalMentions) !== ServerSupport.Unsupported;\n    }\n\n    /**\n     * Fetches the summary of a room as defined by an initial version of MSC3266 and implemented in Synapse\n     * Proposed at https://github.com/matrix-org/matrix-doc/pull/3266\n     * @param roomIdOrAlias - The ID or alias of the room to get the summary of.\n     * @param via - The list of servers which know about the room if only an ID was provided.\n     */\n    public async getRoomSummary(roomIdOrAlias: string, via?: string[]): Promise<RoomSummary> {\n        const paramOpts = {\n            prefix: \"/_matrix/client/unstable/im.nheko.summary\",\n        };\n        try {\n            const path = utils.encodeUri(\"/summary/$roomid\", { $roomid: roomIdOrAlias });\n            return await this.http.authedRequest(Method.Get, path, { via }, undefined, paramOpts);\n        } catch (e) {\n            if (e instanceof MatrixError && e.errcode === \"M_UNRECOGNIZED\") {\n                const path = utils.encodeUri(\"/rooms/$roomid/summary\", { $roomid: roomIdOrAlias });\n                return await this.http.authedRequest(Method.Get, path, { via }, undefined, paramOpts);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Processes a list of threaded events and adds them to their respective timelines\n     * @param room - the room the adds the threaded events\n     * @param threadedEvents - an array of the threaded events\n     * @param toStartOfTimeline - the direction in which we want to add the events\n     */\n    public processThreadEvents(room: Room, threadedEvents: MatrixEvent[], toStartOfTimeline: boolean): void {\n        room.processThreadedEvents(threadedEvents, toStartOfTimeline);\n    }\n\n    /**\n     * Processes a list of thread roots and creates a thread model\n     * @param room - the room to create the threads in\n     * @param threadedEvents - an array of thread roots\n     * @param toStartOfTimeline - the direction\n     */\n    public processThreadRoots(room: Room, threadedEvents: MatrixEvent[], toStartOfTimeline: boolean): void {\n        if (!this.supportsThreads()) return;\n        room.processThreadRoots(threadedEvents, toStartOfTimeline);\n    }\n\n    public processBeaconEvents(room?: Room, events?: MatrixEvent[]): void {\n        this.processAggregatedTimelineEvents(room, events);\n    }\n\n    /**\n     * Calls aggregation functions for event types that are aggregated\n     * Polls and location beacons\n     * @param room - room the events belong to\n     * @param events - timeline events to be processed\n     * @returns\n     */\n    public processAggregatedTimelineEvents(room?: Room, events?: MatrixEvent[]): void {\n        if (!events?.length) return;\n        if (!room) return;\n\n        room.currentState.processBeaconEvents(events, this);\n        room.processPollEvents(events);\n    }\n\n    /**\n     * Fetches information about the user for the configured access token.\n     */\n    public async whoami(): Promise<IWhoamiResponse> {\n        return this.http.authedRequest(Method.Get, \"/account/whoami\");\n    }\n\n    /**\n     * Find the event_id closest to the given timestamp in the given direction.\n     * @returns Resolves: A promise of an object containing the event_id and\n     *    origin_server_ts of the closest event to the timestamp in the given direction\n     * @returns Rejects: when the request fails (module:http-api.MatrixError)\n     */\n    public async timestampToEvent(\n        roomId: string,\n        timestamp: number,\n        dir: Direction,\n    ): Promise<TimestampToEventResponse> {\n        const path = utils.encodeUri(\"/rooms/$roomId/timestamp_to_event\", {\n            $roomId: roomId,\n        });\n        const queryParams = {\n            ts: timestamp.toString(),\n            dir: dir,\n        };\n\n        try {\n            return await this.http.authedRequest(Method.Get, path, queryParams, undefined, {\n                prefix: ClientPrefix.V1,\n            });\n        } catch (err) {\n            // Fallback to the prefixed unstable endpoint. Since the stable endpoint is\n            // new, we should also try the unstable endpoint before giving up. We can\n            // remove this fallback request in a year (remove after 2023-11-28).\n            if (\n                (<MatrixError>err).errcode === \"M_UNRECOGNIZED\" &&\n                // XXX: The 400 status code check should be removed in the future\n                // when Synapse is compliant with MSC3743.\n                ((<MatrixError>err).httpStatus === 400 ||\n                    // This the correct standard status code for an unsupported\n                    // endpoint according to MSC3743. Not Found and Method Not Allowed\n                    // both indicate that this endpoint+verb combination is\n                    // not supported.\n                    (<MatrixError>err).httpStatus === 404 ||\n                    (<MatrixError>err).httpStatus === 405)\n            ) {\n                return await this.http.authedRequest(Method.Get, path, queryParams, undefined, {\n                    prefix: \"/_matrix/client/unstable/org.matrix.msc3030\",\n                });\n            }\n\n            throw err;\n        }\n    }\n\n    /**\n     * Discover and validate the auth metadata for the OAuth 2.0 API.\n     *\n     * Fetches /auth_metadata falling back to legacy implementation using /auth_issuer followed by\n     * https://oidc-issuer.example.com/.well-known/openid-configuration and other files linked therein.\n     * When successful, validated metadata is returned.\n     *\n     * @returns validated authentication metadata and optionally signing keys\n     * @throws when delegated auth config is invalid or unreachable\n     */\n    public async getAuthMetadata(): Promise<OidcClientConfig> {\n        let authMetadata: unknown | undefined;\n        try {\n            const useStable = await this.isVersionSupported(\"v1.15\");\n            authMetadata = await this.http.request<unknown>(Method.Get, \"/auth_metadata\", undefined, undefined, {\n                prefix: useStable ? ClientPrefix.V1 : ClientPrefix.Unstable + \"/org.matrix.msc2965\",\n            });\n        } catch (e) {\n            if (e instanceof MatrixError && e.errcode === \"M_UNRECOGNIZED\") {\n                // Fall back to older variant of MSC2965\n                const { issuer } = await this.http.request<{\n                    issuer: string;\n                }>(Method.Get, \"/auth_issuer\", undefined, undefined, {\n                    prefix: ClientPrefix.Unstable + \"/org.matrix.msc2965\",\n                });\n                return discoverAndValidateOIDCIssuerWellKnown(issuer);\n            }\n            throw e;\n        }\n\n        return validateAuthMetadataAndKeys(authMetadata);\n    }\n}\n\nfunction getUnstableDelayQueryOpts(delayOpts: SendDelayedEventRequestOpts): QueryDict {\n    return Object.fromEntries(\n        Object.entries(delayOpts).map(([k, v]) => [`${UNSTABLE_MSC4140_DELAYED_EVENTS}.${k}`, v]),\n    );\n}\n\n/**\n * recalculates an accurate notifications count on event decryption.\n * Servers do not have enough knowledge about encrypted events to calculate an\n * accurate notification_count\n */\nexport function fixNotificationCountOnDecryption(cli: MatrixClient, event: MatrixEvent): void {\n    const ourUserId = cli.getUserId();\n    const eventId = event.getId();\n\n    const room = cli.getRoom(event.getRoomId());\n    if (!room || !ourUserId || !eventId) return;\n\n    // Due to threads, we can get relation events (eg. edits & reactions) that never get\n    // added to a timeline and so cannot be found in their own room (their edit / reaction\n    // still applies to the event it needs to, so it doesn't matter too much). However, if\n    // we try to process notification about this event, we'll get very confused because we\n    // won't be able to find the event in the room, so will assume it must be unread, even\n    // if it's actually read. We therefore skip anything that isn't in the room. This isn't\n    // *great*, so if we can fix the homeless events (eg. with MSC4023) then we should probably\n    // remove this workaround.\n    if (!room.findEventById(eventId)) {\n        logger.info(`Decrypted event ${event.getId()} is not in room ${room.roomId}: ignoring`);\n        return;\n    }\n\n    const isThreadEvent = !!event.threadRootId && !event.isThreadRoot;\n\n    let hasReadEvent;\n    if (isThreadEvent) {\n        const thread = room.getThread(event.threadRootId);\n        hasReadEvent = thread\n            ? thread.hasUserReadEvent(ourUserId, eventId)\n            : // If the thread object does not exist in the room yet, we don't\n              // want to calculate notification for this event yet. We have not\n              // restored the read receipts yet and can't accurately calculate\n              // notifications at this stage.\n              //\n              // This issue can likely go away when MSC3874 is implemented\n              true;\n    } else {\n        hasReadEvent = room.hasUserReadEvent(ourUserId, eventId);\n    }\n\n    if (hasReadEvent) {\n        // If the event has been read, ignore it.\n        return;\n    }\n\n    const actions = cli.getPushActionsForEvent(event, true);\n\n    // Ensure the unread counts are kept up to date if the event is encrypted\n    // We also want to make sure that the notification count goes up if we already\n    // have encrypted events to avoid other code from resetting 'highlight' to zero.\n    const newHighlight = !!actions?.tweaks?.highlight;\n\n    if (newHighlight) {\n        // TODO: Handle mentions received while the client is offline\n        // See also https://github.com/vector-im/element-web/issues/9069\n        const newCount = room.getUnreadCountForEventContext(NotificationCountType.Highlight, event) + 1;\n        if (isThreadEvent) {\n            room.setThreadUnreadNotificationCount(event.threadRootId, NotificationCountType.Highlight, newCount);\n        } else {\n            room.setUnreadNotificationCount(NotificationCountType.Highlight, newCount);\n        }\n    }\n\n    // `notify` is used in practice for incrementing the total count\n    const newNotify = !!actions?.notify;\n\n    // The room total count is NEVER incremented by the server for encrypted rooms. We basically ignore\n    // the server here as it's always going to tell us to increment for encrypted events.\n    if (newNotify) {\n        // Total count is used to typically increment a room notification counter, but not loudly highlight it.\n        const newCount = room.getUnreadCountForEventContext(NotificationCountType.Total, event) + 1;\n        if (isThreadEvent) {\n            room.setThreadUnreadNotificationCount(event.threadRootId, NotificationCountType.Total, newCount);\n        } else {\n            room.setUnreadNotificationCount(NotificationCountType.Total, newCount);\n        }\n    }\n}\n\n/**\n * Given an event, figure out the thread ID we should use for it in a receipt.\n *\n * This will either be \"main\", or event.threadRootId. For the thread root, or\n * e.g. reactions to the thread root, this will be main. For events inside the\n * thread, or e.g. reactions to them, this will be event.threadRootId.\n *\n * (Exported for test.)\n */\nexport function threadIdForReceipt(event: MatrixEvent): string {\n    return inMainTimelineForReceipt(event) ? MAIN_ROOM_TIMELINE : event.threadRootId!;\n}\n\n/**\n * a) True for non-threaded messages, thread roots and non-thread relations to thread roots.\n * b) False for messages with thread relations to the thread root.\n * c) False for messages with any kind of relation to a message from case b.\n *\n * Note: true for redactions of messages that are in threads. Redacted messages\n * are not really in threads (because their relations are gone), so if they look\n * like they are in threads, that is a sign of a bug elsewhere. (At time of\n * writing, this bug definitely exists - messages are not moved to another\n * thread when they are redacted.)\n *\n * @returns true if this event is considered to be in the main timeline as far\n *               as receipts are concerned.\n */\nexport function inMainTimelineForReceipt(event: MatrixEvent): boolean {\n    if (!event.threadRootId) {\n        // Not in a thread: then it is in the main timeline\n        return true;\n    }\n\n    if (event.isThreadRoot) {\n        // Thread roots are in the main timeline. Note: the spec is ambiguous (or\n        // wrong) on this - see\n        // https://github.com/matrix-org/matrix-spec-proposals/pull/4037\n        return true;\n    }\n\n    if (!event.isRelation()) {\n        // If it's not related to anything, it can't be related via a chain of\n        // relations to a thread root.\n        //\n        // Note: this is a bug, because how does it have a threadRootId if it is\n        // neither a thread root, nor related to one?\n        logger.warn(`Event is not a relation or a thread root, but still has a threadRootId! id=${event.getId()}`);\n        return true;\n    }\n\n    if (event.isRelation(THREAD_RELATION_TYPE.name)) {\n        // It's a message in a thread - definitely not in the main timeline.\n        return false;\n    }\n\n    const isRelatedToRoot = event.relationEventId === event.threadRootId;\n\n    // If it's related to the thread root (and we already know it's not a thread\n    // relation) then it's in the main timeline. If it's related to something\n    // else, then it's in the thread (because it has a thread ID).\n    return isRelatedToRoot;\n}\n","/*\nCopyright 2018 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MBeaconEventContent, type MBeaconInfoContent, type MBeaconInfoEventContent } from \"./@types/beacon.ts\";\nimport { MsgType } from \"./@types/event.ts\";\nimport { M_TEXT, REFERENCE_RELATION } from \"./@types/extensible_events.ts\";\nimport { isProvided } from \"./extensible_events_v1/utilities.ts\";\nimport {\n    M_ASSET,\n    LocationAssetType,\n    M_LOCATION,\n    M_TIMESTAMP,\n    type LocationEventWireContent,\n    type MLocationEventContent,\n    type MLocationContent,\n    type MAssetContent,\n    type LegacyLocationEventContent,\n} from \"./@types/location.ts\";\nimport { type MRoomTopicEventContent, type MTopicContent, M_TOPIC } from \"./@types/topic.ts\";\nimport { type RoomMessageEventContent } from \"./@types/events.ts\";\n\n/**\n * Generates the content for a HTML Message event\n * @param body - the plaintext body of the message\n * @param htmlBody - the HTML representation of the message\n * @returns\n */\nexport function makeHtmlMessage(body: string, htmlBody: string): RoomMessageEventContent {\n    return {\n        msgtype: MsgType.Text,\n        format: \"org.matrix.custom.html\",\n        body: body,\n        formatted_body: htmlBody,\n    };\n}\n\n/**\n * Generates the content for a HTML Notice event\n * @param body - the plaintext body of the notice\n * @param htmlBody - the HTML representation of the notice\n * @returns\n */\nexport function makeHtmlNotice(body: string, htmlBody: string): RoomMessageEventContent {\n    return {\n        msgtype: MsgType.Notice,\n        format: \"org.matrix.custom.html\",\n        body: body,\n        formatted_body: htmlBody,\n    };\n}\n\n/**\n * Generates the content for a HTML Emote event\n * @param body - the plaintext body of the emote\n * @param htmlBody - the HTML representation of the emote\n * @returns\n */\nexport function makeHtmlEmote(body: string, htmlBody: string): RoomMessageEventContent {\n    return {\n        msgtype: MsgType.Emote,\n        format: \"org.matrix.custom.html\",\n        body: body,\n        formatted_body: htmlBody,\n    };\n}\n\n/**\n * Generates the content for a Plaintext Message event\n * @param body - the plaintext body of the emote\n * @returns\n */\nexport function makeTextMessage(body: string): RoomMessageEventContent {\n    return {\n        msgtype: MsgType.Text,\n        body: body,\n    };\n}\n\n/**\n * Generates the content for a Plaintext Notice event\n * @param body - the plaintext body of the notice\n * @returns\n */\nexport function makeNotice(body: string): RoomMessageEventContent {\n    return {\n        msgtype: MsgType.Notice,\n        body: body,\n    };\n}\n\n/**\n * Generates the content for a Plaintext Emote event\n * @param body - the plaintext body of the emote\n * @returns\n */\nexport function makeEmoteMessage(body: string): RoomMessageEventContent {\n    return {\n        msgtype: MsgType.Emote,\n        body: body,\n    };\n}\n\n/** Location content helpers */\n\nexport const getTextForLocationEvent = (\n    uri: string | undefined,\n    assetType: LocationAssetType,\n    timestamp?: number,\n    description?: string | null,\n): string => {\n    const date = `at ${new Date(timestamp!).toISOString()}`;\n    const assetName = assetType === LocationAssetType.Self ? \"User\" : undefined;\n    const quotedDescription = description ? `\"${description}\"` : undefined;\n\n    return [assetName, \"Location\", quotedDescription, uri, date].filter(Boolean).join(\" \");\n};\n\n/**\n * Generates the content for a Location event\n * @param uri - a geo:// uri for the location\n * @param timestamp - the timestamp when the location was correct (milliseconds since the UNIX epoch)\n * @param description - the (optional) label for this location on the map\n * @param assetType - the (optional) asset type of this location e.g. \"m.self\"\n * @param text - optional. A text for the location\n */\nexport const makeLocationContent = (\n    // this is first but optional\n    // to avoid a breaking change\n    text?: string,\n    uri?: string,\n    timestamp?: number,\n    description?: string | null,\n    assetType?: LocationAssetType,\n): LegacyLocationEventContent & MLocationEventContent => {\n    const defaultedText =\n        text ?? getTextForLocationEvent(uri, assetType || LocationAssetType.Self, timestamp, description);\n    const timestampEvent = timestamp ? { [M_TIMESTAMP.name]: timestamp } : {};\n    return {\n        msgtype: MsgType.Location,\n        body: defaultedText,\n        geo_uri: uri,\n        [M_LOCATION.name]: {\n            description,\n            uri,\n        },\n        [M_ASSET.name]: {\n            type: assetType || LocationAssetType.Self,\n        },\n        [M_TEXT.name]: defaultedText,\n        ...timestampEvent,\n    } as LegacyLocationEventContent & MLocationEventContent;\n};\n\n/**\n * Parse location event content and transform to\n * a backwards compatible modern m.location event format\n */\nexport const parseLocationEvent = (wireEventContent: LocationEventWireContent): MLocationEventContent => {\n    const location = M_LOCATION.findIn<MLocationContent>(wireEventContent);\n    const asset = M_ASSET.findIn<MAssetContent>(wireEventContent);\n    const timestamp = M_TIMESTAMP.findIn<number>(wireEventContent);\n    const text = M_TEXT.findIn<string>(wireEventContent);\n\n    const geoUri = location?.uri ?? wireEventContent?.geo_uri;\n    const description = location?.description;\n    const assetType = asset?.type ?? LocationAssetType.Self;\n    const fallbackText = text ?? wireEventContent.body;\n\n    return makeLocationContent(fallbackText, geoUri, timestamp ?? undefined, description, assetType);\n};\n\n/**\n * Topic event helpers\n */\nexport type MakeTopicContent = (topic: string | null | undefined, htmlTopic?: string) => MRoomTopicEventContent;\n\nexport const makeTopicContent: MakeTopicContent = (topic, htmlTopic) => {\n    const renderings = [];\n    // Put HTML first because clients will render the first type in\n    // the array that they understand\n    if (isProvided(htmlTopic)) {\n        renderings.push({ body: htmlTopic, mimetype: \"text/html\" });\n    }\n    if (isProvided(topic)) {\n        renderings.push({ body: topic, mimetype: \"text/plain\" });\n    }\n    return { topic, [M_TOPIC.name]: { \"m.text\": renderings } };\n};\n\nexport type TopicState = {\n    text?: string;\n    html?: string;\n};\n\nexport const parseTopicContent = (content: MRoomTopicEventContent): TopicState => {\n    const mtopicParent = M_TOPIC.findIn<MTopicContent>(content);\n    const mtopic = Array.isArray(mtopicParent) ? mtopicParent : mtopicParent?.[\"m.text\"];\n    // TODO remove support for the old malformed m.topic arrays after a few releases (only allow array in m.text)\n    //      https://github.com/matrix-org/matrix-js-sdk/pull/4984#pullrequestreview-3174251065\n    //const mtopic = M_TOPIC.findIn<MTopicContent>(content)?.[\"m.text\"];\n    if (!Array.isArray(mtopic)) {\n        return { text: content.topic ?? undefined };\n    }\n    const text =\n        mtopic?.find((r) => !isProvided(r.mimetype) || r.mimetype === \"text/plain\")?.body ?? content.topic ?? undefined;\n    const html = mtopic?.find((r) => r.mimetype === \"text/html\")?.body;\n    return { text, html };\n};\n\n/**\n * Beacon event helpers\n */\nexport type MakeBeaconInfoContent = (\n    timeout: number,\n    isLive?: boolean,\n    description?: string,\n    assetType?: LocationAssetType,\n    timestamp?: number,\n) => MBeaconInfoEventContent;\n\nexport const makeBeaconInfoContent: MakeBeaconInfoContent = (timeout, isLive, description, assetType, timestamp) => ({\n    description,\n    timeout,\n    live: isLive,\n    [M_TIMESTAMP.name]: timestamp || Date.now(),\n    [M_ASSET.name]: {\n        type: assetType ?? LocationAssetType.Self,\n    },\n});\n\nexport type BeaconInfoState = MBeaconInfoContent & {\n    assetType?: LocationAssetType;\n    timestamp?: number;\n};\n/**\n * Flatten beacon info event content\n */\nexport const parseBeaconInfoContent = (content: MBeaconInfoEventContent): BeaconInfoState => {\n    const { description, timeout, live } = content;\n    const timestamp = M_TIMESTAMP.findIn<number>(content) ?? undefined;\n    const asset = M_ASSET.findIn<MAssetContent>(content);\n\n    return {\n        description,\n        timeout,\n        live,\n        assetType: asset?.type,\n        timestamp,\n    };\n};\n\nexport type MakeBeaconContent = (\n    uri: string,\n    timestamp: number,\n    beaconInfoEventId: string,\n    description?: string,\n) => MBeaconEventContent;\n\nexport const makeBeaconContent: MakeBeaconContent = (uri, timestamp, beaconInfoEventId, description) => ({\n    [M_LOCATION.name]: {\n        description,\n        uri,\n    },\n    [M_TIMESTAMP.name]: timestamp,\n    \"m.relates_to\": {\n        rel_type: REFERENCE_RELATION.name,\n        event_id: beaconInfoEventId,\n    },\n});\n\nexport type BeaconLocationState = Omit<MLocationContent, \"uri\"> & {\n    uri?: string; // override from MLocationContent to allow optionals\n    timestamp?: number;\n};\n\nexport const parseBeaconContent = (content: MBeaconEventContent): BeaconLocationState => {\n    const location = M_LOCATION.findIn<MLocationContent>(content);\n    const timestamp = M_TIMESTAMP.findIn<number>(content) ?? undefined;\n\n    return {\n        description: location?.description,\n        uri: location?.uri,\n        timestamp,\n    };\n};\n","import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport bs58 from \"bs58\";\n\n// picked arbitrarily but to try & avoid clashing with any bitcoin ones\n// (which are also base58 encoded, but bitcoin's involve a lot more hashing)\nconst OLM_RECOVERY_KEY_PREFIX = [0x8b, 0x01];\nconst KEY_SIZE = 32;\n\n/**\n * Encode a recovery key using the Matrix {@link https://spec.matrix.org/v1.11/appendices/#cryptographic-key-representation | Cryptographic key representation}\n * @param key\n */\nexport function encodeRecoveryKey(key: ArrayLike<number>): string | undefined {\n    const buf = new Uint8Array(OLM_RECOVERY_KEY_PREFIX.length + key.length + 1);\n    buf.set(OLM_RECOVERY_KEY_PREFIX, 0);\n    buf.set(key, OLM_RECOVERY_KEY_PREFIX.length);\n\n    let parity = 0;\n    for (let i = 0; i < buf.length - 1; ++i) {\n        parity ^= buf[i];\n    }\n    buf[buf.length - 1] = parity;\n    const base58key = bs58.encode(buf);\n\n    return base58key.match(/.{1,4}/g)?.join(\" \");\n}\n\n/**\n * Decode a recovery key encoded with the Matrix {@link https://spec.matrix.org/v1.11/appendices/#cryptographic-key-representation | Cryptographic key representation} encoding.\n * @param recoveryKey\n */\nexport function decodeRecoveryKey(recoveryKey: string): Uint8Array<ArrayBuffer> {\n    const result = bs58.decode(recoveryKey.replace(/ /g, \"\"));\n\n    let parity = 0;\n    for (const b of result) {\n        parity ^= b;\n    }\n    if (parity !== 0) {\n        throw new Error(\"Incorrect parity\");\n    }\n\n    for (let i = 0; i < OLM_RECOVERY_KEY_PREFIX.length; ++i) {\n        if (result[i] !== OLM_RECOVERY_KEY_PREFIX[i]) {\n            throw new Error(\"Incorrect prefix\");\n        }\n    }\n\n    if (result.length !== OLM_RECOVERY_KEY_PREFIX.length + KEY_SIZE + 1) {\n        throw new Error(\"Incorrect length\");\n    }\n\n    return Uint8Array.from(result.slice(OLM_RECOVERY_KEY_PREFIX.length, OLM_RECOVERY_KEY_PREFIX.length + KEY_SIZE));\n}\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Cryptography-related events emitted by the {@link matrix.MatrixClient}.\n */\nexport enum CryptoEvent {\n    /**\n     * Fires when the trust status of a user changes.\n     * The payload is a pair (userId, userTrustLevel). The trust level is one of the values from UserVerificationStatus.\n     */\n    UserTrustStatusChanged = \"userTrustStatusChanged\",\n\n    /**\n     * Fires when the key backup status changes.\n     * The payload is a boolean indicating whether the key backup is enabled.\n     */\n    KeyBackupStatus = \"crypto.keyBackupStatus\",\n\n    /**\n     * Fires when we failed to back up the keys\n     * The payload is the error code of the error that occurred.\n     */\n    KeyBackupFailed = \"crypto.keyBackupFailed\",\n\n    /**\n     * Fires when the number of sessions that can be backed up changes.\n     * The payload is the remaining number of sessions that can be backed up.\n     */\n    KeyBackupSessionsRemaining = \"crypto.keyBackupSessionsRemaining\",\n\n    /**\n     * Fires when a new valid backup decryption key is in cache.\n     * This will happen when a secret is received from another session, from secret storage,\n     * or when a new backup is created from this session.\n     *\n     * The payload is the version of the backup for which we have the key for.\n     *\n     * This event is only fired by the rust crypto backend.\n     */\n    KeyBackupDecryptionKeyCached = \"crypto.keyBackupDecryptionKeyCached\",\n\n    /**\n     * Fires when a key verification request is received.\n     * The payload is a VerificationRequest object representing the request.\n     */\n    VerificationRequestReceived = \"crypto.verificationRequestReceived\",\n\n    /** @deprecated Use {@link DevicesUpdated} instead when using rust crypto */\n    WillUpdateDevices = \"crypto.willUpdateDevices\",\n\n    /**\n     * Fires whenever the stored devices for a user have been updated\n     * The payload is a pair (userIds, initialFetch).\n     */\n    DevicesUpdated = \"crypto.devicesUpdated\",\n\n    /**\n     * Fires when the user's cross-signing keys have changed or cross-signing\n     * has been enabled/disabled. The client can use getStoredCrossSigningForUser\n     * with the user ID of the logged in user to check if cross-signing is\n     * enabled on the account. If enabled, it can test whether the current key\n     * is trusted using with checkUserTrust with the user ID of the logged\n     * in user. The checkOwnCrossSigningTrust function may be used to reconcile\n     * the trust in the account key.\n     *\n     * The cross-signing API is currently UNSTABLE and may change without notice.\n     * @experimental\n     */\n    KeysChanged = \"crossSigning.keysChanged\",\n\n    /**\n     * Fires when data is being migrated from legacy crypto to rust crypto.\n     *\n     * The payload is a pair `(progress, total)`, where `progress` is the number of steps completed so far, and\n     * `total` is the total number of steps. When migration is complete, a final instance of the event is emitted, with\n     * `progress === total === -1`.\n     */\n    LegacyCryptoStoreMigrationProgress = \"crypto.legacyCryptoStoreMigrationProgress\",\n\n    /**\n     * Fires when a new dehydrated device is created locally.\n     *\n     * After the client calls {@link CryptoApi.startDehydration}, this event\n     * will be fired every time a new dehydrated device is created.  It may fire\n     * before `startDehydration` returns.\n     */\n    DehydratedDeviceCreated = \"dehydration.DehydratedDeviceCreated\",\n\n    /**\n     * Fires when a new dehydrated device is successfully uploaded to the server.\n     *\n     * This should fire shortly after {@link DehydratedDeviceCreated} fires. If\n     * upload is unsuccessful, this will be reported either by an error thrown\n     * by {@link CryptoApi.startDehydration} (for errors that happen before\n     * `startDehydration` returns), or by firing {@link DehydratedDeviceRotationError}\n     * (for errors that happen during regular rotation of the dehydrated device)\n     */\n    DehydratedDeviceUploaded = \"dehydration.DehydratedDeviceUploaded\",\n\n    /**\n     * Fires when rehydration has started.\n     *\n     * After the client calls {@link CryptoApi.startDehydration}, this event will\n     * fire if a dehydrated device is found and we attempt to rehydrate it.\n     */\n    RehydrationStarted = \"dehydration.RehydrationStarted\",\n\n    /**\n     * Fires during rehydration, to inform the application of rehydration progress.\n     *\n     * The payload is a pair `[roomKeyCount: number, toDeviceCount: number]`,\n     * where `roomKeyCount` is the number of room keys that have been received\n     * so far, and `toDeviceCount` is the number of to-device messages received\n     * so far (including the messages containing room keys).\n     */\n    RehydrationProgress = \"dehydration.RehydrationProgress\",\n\n    /** Fires when rehydration has completed successfully. */\n    RehydrationCompleted = \"dehydration.RehydrationCompleted\",\n\n    /** Fires when there was an error in rehydration.\n     *\n     * The payload is an error message as a string.\n     */\n    RehydrationError = \"dehydration.RehydrationError\",\n\n    /**\n     * Fires when a dehydrated device key has been cached in the local database.\n     */\n    DehydrationKeyCached = \"dehydration.DehydrationKeyCached\",\n\n    /**\n     * Fires when an error occurs during periodic rotation of the dehydrated device.\n     *\n     * The payload is an error message as a string.\n     */\n    DehydratedDeviceRotationError = \"dehydration.DehydratedDeviceRotationError\",\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type { SecretsBundle } from \"@matrix-org/matrix-sdk-crypto-wasm\";\nimport type { IMegolmSessionData } from \"../@types/crypto.ts\";\nimport type { ToDeviceBatch, ToDevicePayload } from \"../models/ToDeviceMessage.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { type DeviceMap } from \"../models/device.ts\";\nimport { type UIAuthCallback } from \"../interactive-auth.ts\";\nimport { type PassphraseInfo, type SecretStorageKey, type SecretStorageKeyDescription } from \"../secret-storage.ts\";\nimport { type VerificationRequest } from \"./verification.ts\";\nimport {\n    type BackupTrustInfo,\n    type KeyBackupCheck,\n    type KeyBackupInfo,\n    type KeyBackupRestoreOpts,\n    type KeyBackupRestoreResult,\n} from \"./keybackup.ts\";\nimport { type ISignatures } from \"../@types/signed.ts\";\nimport { type MatrixEvent } from \"../models/event.ts\";\n\n/**\n * `matrix-js-sdk/lib/crypto-api`: End-to-end encryption support.\n *\n * The most important type is {@link CryptoApi}, an instance of which can be retrieved via\n * {@link MatrixClient.getCrypto}.\n *\n * @packageDocumentation\n */\n\n/**\n * The options to start device dehydration.\n */\nexport interface StartDehydrationOpts {\n    /**\n     * Force creation of a new dehydration key, even if there is already an\n     * existing dehydration key. If `false`, and `onlyIfKeyCached` is `false`, a\n     * new key will be created if there is no existing dehydration key, whether\n     * already cached in our local storage or stored in Secret Storage.\n     *\n     * Checking for the presence of the key in Secret Storage may result in the\n     * `getSecretStorageKey` callback being called.\n     *\n     * Defaults to `false`.\n     */\n    createNewKey?: boolean;\n    /**\n     * Only start dehydration if we have a dehydration key cached in our local\n     * storage. If `true`, Secret Storage will not be checked. Defaults to\n     * `false`.\n     */\n    onlyIfKeyCached?: boolean;\n    /**\n     * Try to rehydrate a device before creating a new dehydrated device.\n     * Setting this to `false` may be useful for situations where the client is\n     * known to pre-date the dehydrated device, and so rehydration is\n     * unnecessary. Defaults to `true`.\n     */\n    rehydrate?: boolean;\n}\n\n/**\n * Public interface to the cryptography parts of the js-sdk\n *\n * @remarks Currently, this is a work-in-progress. In time, more methods will be added here.\n */\nexport interface CryptoApi {\n    /**\n     * Global override for whether the client should ever send encrypted\n     * messages to unverified devices. This provides the default for rooms which\n     * do not specify a value.\n     *\n     * If true, all unverified devices will be blacklisted by default\n     */\n    globalBlacklistUnverifiedDevices: boolean;\n\n    /**\n     * The {@link DeviceIsolationMode} mode to use.\n     */\n    setDeviceIsolationMode(isolationMode: DeviceIsolationMode): void;\n\n    /**\n     * Return the current version of the crypto module.\n     * For example: `Rust SDK ${versions.matrix_sdk_crypto} (${versions.git_sha}), Vodozemac ${versions.vodozemac}`.\n     * @returns the formatted version\n     */\n    getVersion(): string;\n\n    /**\n     * Get the public part of the device keys for the current device.\n     *\n     * @returns The public device keys.\n     */\n    getOwnDeviceKeys(): Promise<OwnDeviceKeys>;\n\n    /**\n     * Check if we believe the given room to be encrypted.\n     *\n     * This method returns true if the room has been configured with encryption. The setting is persistent, so that\n     * even if the encryption event is removed from the room state, it still returns true. This helps to guard against\n     * a downgrade attack wherein a server admin attempts to remove encryption.\n     *\n     * @returns `true` if the room with the supplied ID is encrypted. `false` if the room is not encrypted, or is unknown to\n     * us.\n     */\n    isEncryptionEnabledInRoom(roomId: string): Promise<boolean>;\n\n    /**\n     * Check if we believe the given room supports encrypted state events.\n     */\n    isStateEncryptionEnabledInRoom(roomId: string): Promise<boolean>;\n\n    /**\n     * Perform any background tasks that can be done before a message is ready to\n     * send, in order to speed up sending of the message.\n     *\n     * @param room - the room the event is in\n     */\n    prepareToEncrypt(room: Room): void;\n\n    /**\n     * Discard any existing megolm session for the given room.\n     *\n     * This will ensure that a new session is created on the next call to {@link prepareToEncrypt},\n     * or the next time a message is sent.\n     *\n     * This should not normally be necessary: it should only be used as a debugging tool if there has been a\n     * problem with encryption.\n     *\n     * @param roomId - the room to discard sessions for\n     */\n    forceDiscardSession(roomId: string): Promise<void>;\n\n    /**\n     * Get a list containing all of the room keys\n     *\n     * This should be encrypted before returning it to the user.\n     *\n     * @returns a promise which resolves to a list of\n     *    session export objects\n     */\n    exportRoomKeys(): Promise<IMegolmSessionData[]>;\n\n    /**\n     * Get a JSON list containing all of the room keys\n     *\n     * This should be encrypted before returning it to the user.\n     *\n     * @returns a promise which resolves to a JSON string\n     *    encoding a list of session export objects,\n     *    each of which is an IMegolmSessionData\n     */\n    exportRoomKeysAsJson(): Promise<string>;\n\n    /**\n     * Import a list of room keys previously exported by exportRoomKeys\n     *\n     * @param keys - a list of session export objects\n     * @param opts - options object\n     * @returns a promise which resolves once the keys have been imported\n     */\n    importRoomKeys(keys: IMegolmSessionData[], opts?: ImportRoomKeysOpts): Promise<void>;\n\n    /**\n     * Import a JSON string encoding a list of room keys previously\n     * exported by exportRoomKeysAsJson\n     *\n     * @param keys - a JSON string encoding a list of session export\n     *    objects, each of which is an IMegolmSessionData\n     * @param opts - options object\n     * @returns a promise which resolves once the keys have been imported\n     */\n    importRoomKeysAsJson(keys: string, opts?: ImportRoomKeysOpts): Promise<void>;\n\n    /**\n     * Check if the given user has published cross-signing keys.\n     *\n     * - If the user is tracked, a `/keys/query` request is made to update locally the cross signing keys.\n     * - If the user is not tracked locally and downloadUncached is set to true,\n     *   a `/keys/query` request is made to the server to retrieve the cross signing keys.\n     * - Otherwise, return false\n     *\n     * @param userId - the user ID to check. Defaults to the local user.\n     * @param downloadUncached - If true, download the device list for users whose device list we are not\n     *    currently tracking. Defaults to false, in which case `false` will be returned for such users.\n     *\n     * @returns true if the cross signing keys are available.\n     */\n    userHasCrossSigningKeys(userId?: string, downloadUncached?: boolean): Promise<boolean>;\n\n    /**\n     * Get the device information for the given list of users.\n     *\n     * For any users whose device lists are cached (due to sharing an encrypted room with the user), the\n     * cached device data is returned.\n     *\n     * If there are uncached users, and the `downloadUncached` parameter is set to `true`,\n     * a `/keys/query` request is made to the server to retrieve these devices.\n     *\n     * @param userIds - The users to fetch.\n     * @param downloadUncached - If true, download the device list for users whose device list we are not\n     *    currently tracking. Defaults to false, in which case such users will not appear at all in the result map.\n     *\n     * @returns A map `{@link DeviceMap}`.\n     */\n    getUserDeviceInfo(userIds: string[], downloadUncached?: boolean): Promise<DeviceMap>;\n\n    /**\n     * Set whether to trust other user's signatures of their devices.\n     *\n     * If false, devices will only be considered 'verified' if we have\n     * verified that device individually (effectively disabling cross-signing).\n     *\n     * `true` by default.\n     *\n     * @param val - the new value\n     */\n    setTrustCrossSignedDevices(val: boolean): void;\n\n    /**\n     * Return whether we trust other user's signatures of their devices.\n     *\n     * @see {@link CryptoApi.setTrustCrossSignedDevices}\n     *\n     * @returns `true` if we trust cross-signed devices, otherwise `false`.\n     */\n    getTrustCrossSignedDevices(): boolean;\n\n    /**\n     * Get the verification status of a given user.\n     *\n     * @param userId - The ID of the user to check.\n     *\n     */\n    getUserVerificationStatus(userId: string): Promise<UserVerificationStatus>;\n\n    /**\n     * \"Pin\" the current identity of the given user, accepting it as genuine.\n     *\n     * This is useful if the user has changed identity since we first saw them (leading to\n     * {@link UserVerificationStatus.needsUserApproval}), and we are now accepting their new identity.\n     *\n     * Throws an error if called on our own user ID, or on a user ID that we don't have an identity for.\n     */\n    pinCurrentUserIdentity(userId: string): Promise<void>;\n\n    /**\n     * Remove the requirement for this identity to be verified, and pin it.\n     *\n     * This is useful if the user was previously verified but is not anymore\n     * ({@link UserVerificationStatus.wasCrossSigningVerified}) and it is not possible to verify him again now.\n     *\n     */\n    withdrawVerificationRequirement(userId: string): Promise<void>;\n\n    /**\n     * Get the verification status of a given device.\n     *\n     * @param userId - The ID of the user whose device is to be checked.\n     * @param deviceId - The ID of the device to check\n     *\n     * @returns `null` if the device is unknown, or has not published any encryption keys (implying it does not support\n     *     encryption); otherwise the verification status of the device.\n     */\n    getDeviceVerificationStatus(userId: string, deviceId: string): Promise<DeviceVerificationStatus | null>;\n\n    /**\n     * Mark the given device as locally verified.\n     *\n     * Marking a device as locally verified has much the same effect as completing the verification dance, or receiving\n     * a cross-signing signature for it.\n     *\n     * @param userId - owner of the device\n     * @param deviceId - unique identifier for the device.\n     * @param verified - whether to mark the device as verified. Defaults to 'true'.\n     *\n     * @throws an error if the device is unknown, or has not published any encryption keys.\n     */\n    setDeviceVerified(userId: string, deviceId: string, verified?: boolean): Promise<void>;\n\n    /**\n     * Cross-sign one of our own devices.\n     *\n     * This will create a signature for the device using our self-signing key, and publish that signature.\n     * Cross-signing a device indicates, to our other devices and to other users, that we have verified that it really\n     * belongs to us.\n     *\n     * Requires that cross-signing has been set up on this device (normally by calling {@link bootstrapCrossSigning}).\n     *\n     * *Note*: Do not call this unless you have verified, somehow, that the device is genuine!\n     *\n     * @param deviceId - ID of the device to be signed.\n     */\n    crossSignDevice(deviceId: string): Promise<void>;\n\n    /**\n     * Checks whether cross signing:\n     * - is enabled on this account and trusted by this device\n     * - has private keys either cached locally or stored in secret storage\n     *\n     * If this function returns false, {@link bootstrapCrossSigning()} can be used\n     * to fix things such that it returns true. That is to say, after\n     * `bootstrapCrossSigning()` completes successfully, this function should\n     * return true.\n     *\n     * @returns True if cross-signing is ready to be used on this device\n     *\n     * @throws May throw {@link matrix.ClientStoppedError} if the `MatrixClient` is stopped before or during the call.\n     */\n    isCrossSigningReady(): Promise<boolean>;\n\n    /**\n     * Get the ID of one of the user's cross-signing keys, if both private and matching\n     * public parts of that key are available (ie. cached in the local crypto store).\n     *\n     * The public part may not be available if a `/keys/query` request has not yet been\n     * performed, or if the device that created the keys failed to publish them.\n     *\n     * If either part of the keypair is not available, this will return `null`.\n     *\n     * @param type - The type of key to get the ID of.  One of `CrossSigningKey.Master`, `CrossSigningKey.SelfSigning`,\n     *     or `CrossSigningKey.UserSigning`.  Defaults to `CrossSigningKey.Master`.\n     *\n     * @returns If cross-signing has been initialised on this device, the ID of the given key. Otherwise, null\n     */\n    getCrossSigningKeyId(type?: CrossSigningKey): Promise<string | null>;\n\n    /**\n     * Bootstrap cross-signing by creating keys if needed.\n     *\n     * If everything is already set up, then no changes are made, so this is safe to run to ensure\n     * cross-signing is ready for use.\n     *\n     * This function:\n     * - creates new cross-signing keys if they are not found locally cached nor in\n     *   secret storage (if it has been set up)\n     * - publishes the public keys to the server if they are not already published\n     * - stores the private keys in secret storage if secret storage is set up.\n     *\n     * @param opts - options object\n     */\n    bootstrapCrossSigning(opts: BootstrapCrossSigningOpts): Promise<void>;\n\n    /**\n     * Checks whether secret storage:\n     * - is enabled on this account\n     * - is storing cross-signing private keys\n     * - is storing session backup key (if enabled)\n     *\n     * If this function returns false, {@link bootstrapSecretStorage()} can be used\n     * to fix things such that it returns true. That is to say, after\n     * `bootstrapSecretStorage()` completes successfully, this function should\n     * return true.\n     *\n     * @returns True if secret storage is ready to be used on this device\n     */\n    isSecretStorageReady(): Promise<boolean>;\n\n    /**\n     * Inspect the status of secret storage, in more detail than {@link isSecretStorageReady}.\n     */\n    getSecretStorageStatus(): Promise<SecretStorageStatus>;\n\n    /**\n     * Bootstrap [secret storage](https://spec.matrix.org/v1.12/client-server-api/#storage).\n     *\n     * - If secret storage is not already set up, or {@link CreateSecretStorageOpts.setupNewSecretStorage} is set:\n     *   * Calls {@link CreateSecretStorageOpts.createSecretStorageKey} to generate a new key.\n     *   * Stores the metadata of the new key in account data and sets it as the default secret storage key.\n     *   * Calls {@link CryptoCallbacks.cacheSecretStorageKey} if provided.\n     * - Stores the private cross signing keys in the secret storage if they are known, and they are not\n     *   already stored in secret storage.\n     * - If {@link CreateSecretStorageOpts.setupNewKeyBackup} is set, calls {@link CryptoApi.resetKeyBackup}; otherwise,\n     *   stores the key backup decryption key in secret storage if it is known, and it is not\n     *   already stored in secret storage.\n     *\n     * Note that there may be multiple accesses to secret storage during the course of this call, each of which will\n     * result in a call to {@link CryptoCallbacks.getSecretStorageKey}.\n     *\n     * @param opts - Options object.\n     */\n    bootstrapSecretStorage(opts: CreateSecretStorageOpts): Promise<void>;\n\n    /**\n     * Get the status of our cross-signing keys.\n     *\n     * @returns The current status of cross-signing keys: whether we have public and private keys cached locally, and\n     * whether the private keys are in secret storage.\n     *\n     * @throws May throw {@link matrix.ClientStoppedError} if the `MatrixClient` is stopped before or during the call.\n     */\n    getCrossSigningStatus(): Promise<CrossSigningStatus>;\n\n    /**\n     * Create a recovery key (ie, a key suitable for use with server-side secret storage).\n     *\n     * The key can either be based on a user-supplied passphrase, or just created randomly.\n     *\n     * @param password - Optional passphrase string to use to derive the key,\n     *      which can later be entered by the user as an alternative to entering the\n     *      recovery key itself. If omitted, a key is generated randomly.\n     *\n     * @returns Object including recovery key and server upload parameters.\n     *      The private key should be disposed of after displaying to the use.\n     */\n    createRecoveryKeyFromPassphrase(password?: string): Promise<GeneratedSecretStorageKey>;\n\n    /**\n     * Get information about the encryption of the given event.\n     *\n     * @param event - the event to get information for\n     *\n     * @returns `null` if the event is not encrypted, or has not (yet) been successfully decrypted. Otherwise, an\n     *      object with information about the encryption of the event.\n     */\n    getEncryptionInfoForEvent(event: MatrixEvent): Promise<EventEncryptionInfo | null>;\n\n    /**\n     * Encrypts a given payload object via Olm to-device messages to a given\n     * set of devices.\n     *\n     * @param eventType - the type of the event to send.\n     * @param devices - an array of devices to encrypt the payload for.\n     * @param payload - the payload to encrypt.\n     *\n     * @returns the batch of encrypted payloads which can then be sent via {@link matrix.MatrixClient#queueToDevice}.\n     */\n    encryptToDeviceMessages(\n        eventType: string,\n        devices: { userId: string; deviceId: string }[],\n        payload: ToDevicePayload,\n    ): Promise<ToDeviceBatch>;\n\n    /**\n     * Reset the encryption of the user by going through the following steps:\n     * - Remove the dehydrated device and stop the periodic creation of dehydrated devices.\n     * - Disable backing up room keys and delete any existing backups.\n     * - Remove the default secret storage key from the account data (ie: the recovery key).\n     * - Reset the cross-signing keys.\n     * - Create a new key backup.\n     *\n     * Note that the dehydrated device will be removed, but will not be replaced\n     * and it will not schedule creating new dehydrated devices.  To do this,\n     * {@link startDehydration} should be called after a new secret storage key\n     * is created.\n     *\n     * @param authUploadDeviceSigningKeys - Callback to authenticate the upload of device signing keys.\n     *      Used when resetting the cross signing keys.\n     *      See {@link BootstrapCrossSigningOpts#authUploadDeviceSigningKeys}.\n     */\n    resetEncryption(authUploadDeviceSigningKeys: UIAuthCallback<void>): Promise<void>;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Device/User verification\n    //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Returns to-device verification requests that are already in progress for the given user id.\n     *\n     * @param userId - the ID of the user to query\n     *\n     * @returns the VerificationRequests that are in progress\n     */\n    getVerificationRequestsToDeviceInProgress(userId: string): VerificationRequest[];\n\n    /**\n     * Finds a DM verification request that is already in progress for the given room and user.\n     *\n     * @param roomId - the room to use for verification.\n     * @param userId - search for a verification request for the given user.\n     *\n     * @returns the VerificationRequest that is in progress, if any.\n     */\n    findVerificationRequestDMInProgress(roomId: string, userId?: string): VerificationRequest | undefined;\n\n    /**\n     * Request a key verification from another user, using a DM.\n     *\n     * @param userId - the user to request verification with.\n     * @param roomId - the room to use for verification.\n     *\n     * @returns resolves to a VerificationRequest when the request has been sent to the other party.\n     */\n    requestVerificationDM(userId: string, roomId: string): Promise<VerificationRequest>;\n\n    /**\n     * Send a verification request to our other devices.\n     *\n     * This is normally used when the current device is new, and we want to ask another of our devices to cross-sign.\n     *\n     * If an all-devices verification is already in flight, returns it. Otherwise, initiates a new one.\n     *\n     * To control the methods offered, set {@link matrix.ICreateClientOpts.verificationMethods} when creating the\n     * `MatrixClient`.\n     *\n     * @returns a VerificationRequest when the request has been sent to the other party.\n     */\n    requestOwnUserVerification(): Promise<VerificationRequest>;\n\n    /**\n     * Request an interactive verification with the given device.\n     *\n     * This is normally used on one of our own devices, when the current device is already cross-signed, and we want to\n     * validate another device.\n     *\n     * If a verification for this user/device is already in flight, returns it. Otherwise, initiates a new one.\n     *\n     * To control the methods offered, set {@link  matrix.ICreateClientOpts.verificationMethods} when creating the\n     * `MatrixClient`.\n     *\n     * @param userId - ID of the owner of the device to verify\n     * @param deviceId - ID of the device to verify\n     *\n     * @returns a VerificationRequest when the request has been sent to the other party.\n     */\n    requestDeviceVerification(userId: string, deviceId: string): Promise<VerificationRequest>;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Secure key backup\n    //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Fetch the backup decryption key we have saved in our store.\n     *\n     * This can be used for gossiping the key to other devices.\n     *\n     * @returns the key, if any, or null\n     */\n    getSessionBackupPrivateKey(): Promise<Uint8Array | null>;\n\n    /**\n     * Store the backup decryption key.\n     *\n     * This should be called if the client has received the key from another device via secret sharing (gossiping).\n     * It is the responsability of the caller to check that the decryption key is valid for the given backup version.\n     *\n     * @param key - the backup decryption key\n     * @param version - the backup version corresponding to this decryption key\n     */\n    storeSessionBackupPrivateKey(key: Uint8Array, version: string): Promise<void>;\n\n    /**\n     * Attempt to fetch the backup decryption key from secret storage.\n     *\n     * If the key is found in secret storage, checks it against the latest backup on the server;\n     * if they match, stores the key in the crypto store by calling {@link storeSessionBackupPrivateKey},\n     * which enables automatic restore of individual keys when an Unable-to-decrypt error is encountered.\n     *\n     * If we are unable to fetch the key from secret storage, there is no backup on the server, or the key\n     * does not match, throws an exception.\n     */\n    loadSessionBackupPrivateKeyFromSecretStorage(): Promise<void>;\n\n    /**\n     * Get the current status of key backup.\n     *\n     * @returns If automatic key backups are enabled, the `version` of the active backup. Otherwise, `null`.\n     */\n    getActiveSessionBackupVersion(): Promise<string | null>;\n\n    /**\n     * Determine if a key backup can be trusted.\n     *\n     * @param info - key backup info dict from {@link CryptoApi.getKeyBackupInfo}.\n     */\n    isKeyBackupTrusted(info: KeyBackupInfo): Promise<BackupTrustInfo>;\n\n    /**\n     * Return the details of the latest backup on the server, when we last checked.\n     *\n     * This normally returns a cached value, but if we haven't yet made a request to the server, it will fire one off.\n     * It will always return the details of the active backup if key backup is enabled.\n     *\n     * Return null if there is no backup.\n     *\n     * @returns the key backup information\n     */\n    getKeyBackupInfo(): Promise<KeyBackupInfo | null>;\n\n    /**\n     * Force a re-check of the key backup and enable/disable it as appropriate.\n     *\n     * Fetches the current backup information from the server. If there is a backup, and it is trusted, starts\n     * backing up to it; otherwise, disables backups.\n     *\n     * @returns `null` if there is no backup on the server. Otherwise, data on the backup as returned by the server,\n     *   and trust information (as returned by {@link isKeyBackupTrusted}).\n     */\n    checkKeyBackupAndEnable(): Promise<KeyBackupCheck | null>;\n\n    /**\n     * Creates a new key backup version.\n     *\n     * If there are existing backups they will be replaced.\n     *\n     * If secret storage is set up, the new decryption key will be saved (the {@link CryptoCallbacks.getSecretStorageKey}\n     * callback will be called to obtain the secret storage key).\n     *\n     * The backup engine will be started using the new backup version (i.e., {@link checkKeyBackupAndEnable} is called).\n     */\n    resetKeyBackup(): Promise<void>;\n\n    /**\n     * Disables server-side key storage and deletes server-side backups.\n     *  * Deletes the current key backup version, if any (but not any previous versions).\n     *  * Disables 4S, deleting the info for the default key, the default key pointer itself and any\n     *    known 4S data (cross-signing keys and the megolm key backup key).\n     *  * Deletes any dehydrated devices.\n     *  * Sets the \"m.org.matrix.custom.backup_disabled\" account data flag to indicate that the user has disabled backups.\n     */\n    disableKeyStorage(): Promise<void>;\n\n    /**\n     * Deletes the given key backup.\n     *\n     * @param version - The backup version to delete.\n     */\n    deleteKeyBackupVersion(version: string): Promise<void>;\n\n    /**\n     * Download and restore the full key backup from the homeserver.\n     *\n     * Before calling this method, a decryption key, and the backup version to restore,\n     * must have been saved in the crypto store. This happens in one of the following ways:\n     *\n     * - When a new backup version is created with {@link CryptoApi.resetKeyBackup}, a new key is created and cached.\n     * - The key can be loaded from secret storage with {@link CryptoApi.loadSessionBackupPrivateKeyFromSecretStorage}.\n     * - The key can be received from another device via secret sharing, typically as part of the interactive verification flow.\n     * - The key and backup version can also be set explicitly via {@link CryptoApi.storeSessionBackupPrivateKey},\n     *   though this is not expected to be a common operation.\n     *\n     * Warning: the full key backup may be quite large, so this operation may take several hours to complete.\n     * Use of {@link KeyBackupRestoreOpts.progressCallback} is recommended.\n     *\n     * @param opts\n     */\n    restoreKeyBackup(opts?: KeyBackupRestoreOpts): Promise<KeyBackupRestoreResult>;\n\n    /**\n     * Restores a key backup using a passphrase.\n     * The decoded key (derived from the passphrase) is stored locally by calling {@link CryptoApi#storeSessionBackupPrivateKey}.\n     *\n     * @param passphrase - The passphrase to use to restore the key backup.\n     * @param opts\n     *\n     * @deprecated Deriving a backup key from a passphrase is not part of the matrix spec. Instead, a random key is generated and stored/shared via 4S.\n     */\n    restoreKeyBackupWithPassphrase(passphrase: string, opts?: KeyBackupRestoreOpts): Promise<KeyBackupRestoreResult>;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Dehydrated devices\n    //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Returns whether MSC3814 dehydrated devices are supported by the crypto\n     * backend and by the server.\n     *\n     * This should be called before calling `startDehydration`, and if this\n     * returns `false`, `startDehydration` should not be called.\n     */\n    isDehydrationSupported(): Promise<boolean>;\n\n    /**\n     * Start using device dehydration.\n     *\n     * - Rehydrates a dehydrated device, if one is available and `opts.rehydrate`\n     *   is `true`.\n     * - Creates a new dehydration key, if necessary, and stores it in Secret\n     *   Storage.\n     *   - If `opts.createNewKey` is set to true, always creates a new key.\n     *   - If a dehydration key is not available, creates a new one.\n     * - Creates a new dehydrated device, and schedules periodically creating\n     *   new dehydrated devices.\n     *\n     * This function must not be called unless `isDehydrationSupported` returns\n     * `true`, and must not be called until after cross-signing and secret\n     * storage have been set up.\n     *\n     * @param opts - options for device dehydration. For backwards compatibility\n     *     with old code, a boolean can be given here, which will be treated as\n     *     the `createNewKey` option. However, this is deprecated.\n     */\n    startDehydration(opts?: StartDehydrationOpts | boolean): Promise<void>;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Import/export of secret keys\n    //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Export secrets bundle for transmitting to another device as part of OIDC QR login\n     */\n    exportSecretsBundle?(): Promise<Awaited<ReturnType<SecretsBundle[\"to_json\"]>>>;\n\n    /**\n     * Import secrets bundle transmitted from another device.\n     * @param secrets - The secrets bundle received from the other device\n     */\n    importSecretsBundle?(secrets: Awaited<ReturnType<SecretsBundle[\"to_json\"]>>): Promise<void>;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // Room key history sharing (MSC4268)\n    //\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Share any shareable E2EE history in the given room with the given recipient,\n     * as per [MSC4268](https://github.com/matrix-org/matrix-spec-proposals/pull/4268)\n     *\n     * @experimental\n     */\n    shareRoomHistoryWithUser(roomId: string, userId: string): Promise<void>;\n}\n\n/** A reason code for a failure to decrypt an event. */\nexport enum DecryptionFailureCode {\n    /** Message was encrypted with a Megolm session whose keys have not been shared with us. */\n    MEGOLM_UNKNOWN_INBOUND_SESSION_ID = \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",\n\n    /** A special case of {@link MEGOLM_UNKNOWN_INBOUND_SESSION_ID}: the sender has told us it is withholding the key. */\n    MEGOLM_KEY_WITHHELD = \"MEGOLM_KEY_WITHHELD\",\n\n    /** A special case of {@link MEGOLM_KEY_WITHHELD}: the sender has told us it is withholding the key, because the current device is unverified. */\n    MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE = \"MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE\",\n\n    /** Message was encrypted with a Megolm session which has been shared with us, but in a later ratchet state. */\n    OLM_UNKNOWN_MESSAGE_INDEX = \"OLM_UNKNOWN_MESSAGE_INDEX\",\n\n    /**\n     * Message was sent before the current device was created; there is no key backup on the server, so this\n     * decryption failure is expected.\n     */\n    HISTORICAL_MESSAGE_NO_KEY_BACKUP = \"HISTORICAL_MESSAGE_NO_KEY_BACKUP\",\n\n    /**\n     * Message was sent before the current device was created; there was a key backup on the server, but we don't\n     * seem to have access to the backup. (Probably we don't have the right key.)\n     */\n    HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED = \"HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED\",\n\n    /**\n     * Message was sent before the current device was created; there was a (usable) key backup on the server, but we\n     * still can't decrypt. (Either the session isn't in the backup, or we just haven't gotten around to checking yet.)\n     */\n    HISTORICAL_MESSAGE_WORKING_BACKUP = \"HISTORICAL_MESSAGE_WORKING_BACKUP\",\n\n    /**\n     * Message was sent when the user was not a member of the room.\n     */\n    HISTORICAL_MESSAGE_USER_NOT_JOINED = \"HISTORICAL_MESSAGE_USER_NOT_JOINED\",\n\n    /**\n     * The sender's identity is not verified, but was previously verified.\n     */\n    SENDER_IDENTITY_PREVIOUSLY_VERIFIED = \"SENDER_IDENTITY_PREVIOUSLY_VERIFIED\",\n\n    /**\n     * The sender device is not cross-signed.  This will only be used if the\n     * device isolation mode is set to `OnlySignedDevicesIsolationMode`.\n     */\n    UNSIGNED_SENDER_DEVICE = \"UNSIGNED_SENDER_DEVICE\",\n\n    /**\n     * We weren't able to link the message back to any known device.  This will\n     * only be used if the device isolation mode is set to `OnlySignedDevicesIsolationMode`.\n     */\n    UNKNOWN_SENDER_DEVICE = \"UNKNOWN_SENDER_DEVICE\",\n\n    /** Unknown or unclassified error. */\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n}\n\n/** Base {@link DeviceIsolationMode} kind. */\nexport enum DeviceIsolationModeKind {\n    AllDevicesIsolationMode,\n    OnlySignedDevicesIsolationMode,\n}\n\n/**\n * A type of {@link DeviceIsolationMode}.\n *\n * Message encryption keys are shared with all devices in the room, except in case of\n * verified user problems (see {@link errorOnVerifiedUserProblems}).\n *\n * Events from all senders are always decrypted (and should be decorated with message shields in case\n * of authenticity warnings, see {@link EventEncryptionInfo}).\n */\nexport class AllDevicesIsolationMode {\n    public readonly kind = DeviceIsolationModeKind.AllDevicesIsolationMode;\n\n    /**\n     *\n     * @param errorOnVerifiedUserProblems - Behavior when sharing keys to remote devices.\n     *\n     * If set to `true`, sharing keys will fail (i.e. message sending will fail) with an error if:\n     *   - The user was previously verified but is not anymore, or:\n     *   - A verified user has some unverified devices (not cross-signed).\n     *\n     * If `false`, the keys will be distributed as usual. In this case, the client UX should display\n     * warnings to inform the user about problematic devices/users, and stop them hitting this case.\n     */\n    public constructor(public readonly errorOnVerifiedUserProblems: boolean) {}\n}\n\n/**\n * A type of {@link DeviceIsolationMode}.\n *\n * Message encryption keys are only shared with devices that have been cross-signed by their owner.\n * Encryption will throw an error if a verified user replaces their identity.\n *\n * Events are decrypted only if they come from a cross-signed device. Other events will result in a decryption\n * failure. (To access the failure reason, see {@link MatrixEvent.decryptionFailureReason}.)\n */\nexport class OnlySignedDevicesIsolationMode {\n    public readonly kind = DeviceIsolationModeKind.OnlySignedDevicesIsolationMode;\n}\n\n/**\n * DeviceIsolationMode represents the mode of device isolation used when encrypting or decrypting messages.\n * It can be one of two types: {@link AllDevicesIsolationMode} or {@link OnlySignedDevicesIsolationMode}.\n *\n * Only supported by rust Crypto.\n */\nexport type DeviceIsolationMode = AllDevicesIsolationMode | OnlySignedDevicesIsolationMode;\n\n/**\n * Options object for `CryptoApi.bootstrapCrossSigning`.\n */\nexport interface BootstrapCrossSigningOpts {\n    /** Optional. Reset the cross-signing keys even if keys already exist. */\n    setupNewCrossSigning?: boolean;\n\n    /**\n     * An application callback to collect the authentication data for uploading the keys. If not given, the keys\n     * will not be uploaded to the server (which seems like a bad thing?).\n     */\n    authUploadDeviceSigningKeys?: UIAuthCallback<void>;\n}\n\n/**\n * Represents the ways in which we trust a user\n */\nexport class UserVerificationStatus {\n    /**\n     * Indicates if the identity has changed in a way that needs user approval.\n     *\n     * This happens if the identity has changed since we first saw it, *unless* the new identity has also been verified\n     * by our user (eg via an interactive verification).\n     *\n     * To rectify this, either:\n     *\n     *  * Conduct a verification of the new identity via {@link CryptoApi.requestVerificationDM}.\n     *  * Pin the new identity, via {@link CryptoApi.pinCurrentUserIdentity}.\n     *\n     * @returns true if the identity has changed in a way that needs user approval.\n     */\n    public readonly needsUserApproval: boolean;\n\n    public constructor(\n        private readonly crossSigningVerified: boolean,\n        private readonly crossSigningVerifiedBefore: boolean,\n        private readonly tofu: boolean,\n        needsUserApproval: boolean = false,\n    ) {\n        this.needsUserApproval = needsUserApproval;\n    }\n\n    /**\n     * @returns true if this user is verified via any means\n     */\n    public isVerified(): boolean {\n        return this.isCrossSigningVerified();\n    }\n\n    /**\n     * @returns true if this user is verified via cross signing\n     */\n    public isCrossSigningVerified(): boolean {\n        return this.crossSigningVerified;\n    }\n\n    /**\n     * @returns true if we ever verified this user before (at least for\n     * the history of verifications observed by this device).\n     */\n    public wasCrossSigningVerified(): boolean {\n        return this.crossSigningVerifiedBefore;\n    }\n\n    /**\n     * @returns true if this user's key is trusted on first use\n     *\n     * @deprecated No longer supported, with the Rust crypto stack.\n     */\n    public isTofu(): boolean {\n        return this.tofu;\n    }\n}\n\nexport class DeviceVerificationStatus {\n    /**\n     * True if this device has been signed by its owner (and that signature verified).\n     *\n     * This doesn't necessarily mean that we have verified the device, since we may not have verified the\n     * owner's cross-signing key.\n     */\n    public readonly signedByOwner: boolean;\n\n    /**\n     * True if this device has been verified via cross signing.\n     *\n     * This does *not* take into account `trustCrossSignedDevices`.\n     */\n    public readonly crossSigningVerified: boolean;\n\n    /**\n     * TODO: tofu magic wtf does this do?\n     */\n    public readonly tofu: boolean;\n\n    /**\n     * True if the device has been marked as locally verified.\n     */\n    public readonly localVerified: boolean;\n\n    /**\n     * True if the client has been configured to trust cross-signed devices via {@link CryptoApi#setTrustCrossSignedDevices}.\n     */\n    private readonly trustCrossSignedDevices: boolean;\n\n    public constructor(\n        opts: Partial<DeviceVerificationStatus> & {\n            /**\n             * True if cross-signed devices should be considered verified for {@link DeviceVerificationStatus#isVerified}.\n             */\n            trustCrossSignedDevices?: boolean;\n        },\n    ) {\n        this.signedByOwner = opts.signedByOwner ?? false;\n        this.crossSigningVerified = opts.crossSigningVerified ?? false;\n        this.tofu = opts.tofu ?? false;\n        this.localVerified = opts.localVerified ?? false;\n        this.trustCrossSignedDevices = opts.trustCrossSignedDevices ?? false;\n    }\n\n    /**\n     * Check if we should consider this device \"verified\".\n     *\n     * A device is \"verified\" if either:\n     *  * it has been manually marked as such via {@link CryptoApi.setDeviceVerified}.\n     *  * it has been cross-signed with a verified signing key, **and** the client has been configured to trust\n     *    cross-signed devices via {@link CryptoApi.setTrustCrossSignedDevices}.\n     *\n     * @returns true if this device is verified via any means.\n     */\n    public isVerified(): boolean {\n        return this.localVerified || (this.trustCrossSignedDevices && this.crossSigningVerified);\n    }\n}\n\n/**\n * Enum representing the different stages of importing room keys.\n *\n * This is the type of the `stage` property of {@link ImportRoomKeyProgressData}.\n */\nexport enum ImportRoomKeyStage {\n    /**\n     * The stage where room keys are being fetched.\n     *\n     * @see {@link ImportRoomKeyFetchProgress}.\n     */\n    Fetch = \"fetch\",\n    /**\n     * The stage where room keys are being loaded.\n     *\n     * @see {@link ImportRoomKeyLoadProgress}.\n     */\n    LoadKeys = \"load_keys\",\n}\n\n/**\n * Type representing the progress during the 'fetch' stage of the room key import process.\n *\n * @see {@link ImportRoomKeyProgressData}.\n */\nexport type ImportRoomKeyFetchProgress = {\n    /**\n     * The current stage of the import process.\n     */\n    stage: ImportRoomKeyStage.Fetch;\n};\n\n/**\n * Type representing the progress during the 'load_keys' stage of the room key import process.\n *\n * @see {@link ImportRoomKeyProgressData}.\n */\nexport type ImportRoomKeyLoadProgress = {\n    /**\n     * The current stage of the import process.\n     */\n    stage: ImportRoomKeyStage.LoadKeys;\n\n    /**\n     * The number of successfully loaded room keys so far.\n     */\n    successes: number;\n\n    /**\n     * The number of room keys that failed to load so far.\n     */\n    failures: number;\n\n    /**\n     * The total number of room keys being loaded.\n     */\n    total: number;\n};\n\n/**\n * Room key import progress report.\n * Used when calling {@link CryptoApi#importRoomKeys},\n * {@link CryptoApi#importRoomKeysAsJson} or {@link CryptoApi#restoreKeyBackup} as the parameter of\n * the progressCallback. Used to display feedback.\n */\nexport type ImportRoomKeyProgressData = ImportRoomKeyFetchProgress | ImportRoomKeyLoadProgress;\n\n/**\n * Options object for {@link CryptoApi#importRoomKeys} and\n * {@link CryptoApi#importRoomKeysAsJson}.\n */\nexport interface ImportRoomKeysOpts {\n    /** Reports ongoing progress of the import process. Can be used for feedback. */\n    progressCallback?: (stage: ImportRoomKeyProgressData) => void;\n    /** @deprecated not useful externally */\n    source?: string;\n}\n\n/**\n * The result of a call to {@link CryptoApi.getCrossSigningStatus}.\n */\nexport interface CrossSigningStatus {\n    /**\n     * True if the public master, self signing and user signing keys are available on this device.\n     */\n    publicKeysOnDevice: boolean;\n    /**\n     * True if the private keys are stored in the secret storage.\n     */\n    privateKeysInSecretStorage: boolean;\n    /**\n     * True if the private keys are stored locally.\n     */\n    privateKeysCachedLocally: {\n        masterKey: boolean;\n        selfSigningKey: boolean;\n        userSigningKey: boolean;\n    };\n}\n\n/**\n * Crypto callbacks provided by the application\n */\nexport interface CryptoCallbacks {\n    /**\n     * Called to retrieve a secret storage encryption key.\n     *\n     * [Server-side secret storage](https://spec.matrix.org/v1.12/client-server-api/#key-storage)\n     * is, as the name implies, a mechanism for storing secrets which should be shared between\n     * clients on the server. For example, it is typically used for storing the\n     * [key backup decryption key](https://spec.matrix.org/v1.12/client-server-api/#decryption-key)\n     * and the private [cross-signing keys](https://spec.matrix.org/v1.12/client-server-api/#cross-signing).\n     *\n     * The secret storage mechanism encrypts the secrets before uploading them to the server using a\n     * secret storage key. The schema supports multiple keys, but in practice only one tends to be used\n     * at once; this is the \"default secret storage key\" and may be known as the \"recovery key\" (or, sometimes,\n     * the \"security key\").\n     *\n     * Secret storage can be set up by calling {@link CryptoApi.bootstrapSecretStorage}. Having done so, when\n     * the crypto stack needs to access secret storage (for example, when setting up a new device, or to\n     * store newly-generated secrets), it will use this callback (`getSecretStorageKey`).\n     *\n     * Note that the secret storage key may be needed several times in quick succession: it is recommended\n     * that applications use a temporary cache to avoid prompting the user multiple times for the key. See\n     * also {@link cacheSecretStorageKey} which is called when a new key is created.\n     *\n     * The helper method {@link deriveRecoveryKeyFromPassphrase} may be useful if the secret storage key\n     * was derived from a passphrase.\n     *\n     * @param opts - An options object.\n     *\n     * @param name - the name of the *secret* (NB: not the encryption key) being stored or retrieved.\n     *    When the item is stored in account data, it will have this `type`.\n     *\n     * @returns a pair [`keyId`, `privateKey`], where `keyId` is one of the keys from the `keys` parameter,\n     *    and `privateKey` is the raw private encryption key, as appropriate for the encryption algorithm.\n     *    (For `m.secret_storage.v1.aes-hmac-sha2`, it is the input to an HKDF as defined in the\n     *    [specification](https://spec.matrix.org/v1.6/client-server-api/#msecret_storagev1aes-hmac-sha2).)\n     *\n     *    Alternatively, if none of the keys are known, may return `null`  in which case the original\n     *     operation that requires access to a secret in secret storage may fail with an exception.\n     */\n    getSecretStorageKey?: (\n        opts: {\n            /**\n             * Details of the secret storage keys required: a map from the key ID\n             * (excluding the `m.secret_storage.key.` prefix) to details of the key.\n             *\n             * When storing a secret, `keys` will contain exactly one entry.\n             *\n             * For secret retrieval, `keys` may contain several entries, and the application can return\n             * any one of the requested keys. Unless your application specifically wants to offer the\n             * user the ability to have more than one secret storage key active at a time, it is recommended\n             * to call {@link matrix.SecretStorage.ServerSideSecretStorage.getDefaultKeyId | ServerSideSecretStorage.getDefaultKeyId}\n             * to figure out which is the current default key, and to return `null` if the default key is not listed in `keys`.\n             */\n            keys: Record<string, SecretStorageKeyDescription>;\n        },\n        name: string,\n    ) => Promise<[string, Uint8Array<ArrayBuffer>] | null>;\n\n    /**\n     * Called by {@link CryptoApi.bootstrapSecretStorage} when a new default secret storage key is created.\n     *\n     * Applications can use this to (temporarily) cache the secret storage key, for later return by\n     * {@link getSecretStorageKey}.\n     *\n     * @param keyId - secret storage key id\n     * @param keyInfo - secret storage key info\n     * @param key - private key to store\n     */\n    cacheSecretStorageKey?: (keyId: string, keyInfo: SecretStorageKeyDescription, key: Uint8Array<ArrayBuffer>) => void;\n}\n\n/**\n * The result of a call to {@link CryptoApi.getSecretStorageStatus}.\n */\nexport interface SecretStorageStatus {\n    /** Whether secret storage is fully populated. The same as {@link CryptoApi.isSecretStorageReady}. */\n    ready: boolean;\n\n    /** The ID of the current default secret storage key. */\n    defaultKeyId: string | null;\n\n    /**\n     * For each secret that we checked whether it is correctly stored in secret storage with the default secret storage key.\n     *\n     * Note that we will only check that the key backup key is stored if key backup is currently enabled (i.e. that\n     * {@link CryptoApi.getActiveSessionBackupVersion} returns non-null). `m.megolm_backup.v1` will only be present in that case.\n     *\n     * (This is an object rather than a `Map` so that it JSON.stringify()s nicely, since its main purpose is to end up\n     * in logs.)\n     */\n    secretStorageKeyValidityMap: {\n        [P in SecretStorageKey]?: boolean;\n    };\n}\n\n/**\n * Parameter of {@link CryptoApi#bootstrapSecretStorage}\n */\nexport interface CreateSecretStorageOpts {\n    /**\n     * Function called to await a secret storage key creation flow.\n     * @returns Promise resolving to an object with public key metadata, encoded private\n     *     recovery key which should be disposed of after displaying to the user,\n     *     and raw private key to avoid round tripping if needed.\n     */\n    createSecretStorageKey?: () => Promise<GeneratedSecretStorageKey>;\n\n    /**\n     * If true, a new key backup version will be\n     * created and the private key stored in the new SSSS store. Ignored if keyBackupInfo\n     * is supplied.\n     */\n    setupNewKeyBackup?: boolean;\n\n    /**\n     * Reset even if keys already exist.\n     */\n    setupNewSecretStorage?: boolean;\n}\n\n/** Types of cross-signing key */\nexport enum CrossSigningKey {\n    Master = \"master\",\n    SelfSigning = \"self_signing\",\n    UserSigning = \"user_signing\",\n}\n\n/**\n * Information on one of the cross-signing keys.\n * @see https://spec.matrix.org/v1.7/client-server-api/#post_matrixclientv3keysdevice_signingupload\n */\nexport interface CrossSigningKeyInfo {\n    keys: { [algorithm: string]: string };\n    signatures?: ISignatures;\n    usage: string[];\n    user_id: string;\n}\n\n/**\n * Recovery key created by {@link CryptoApi#createRecoveryKeyFromPassphrase} or {@link CreateSecretStorageOpts#createSecretStorageKey}.\n */\nexport interface GeneratedSecretStorageKey {\n    keyInfo?: {\n        /** If the key was derived from a passphrase, information (algorithm, salt, etc) on that derivation. */\n        passphrase?: PassphraseInfo;\n        /** Optional human-readable name for the key, to be stored in account_data. */\n        name?: string;\n    };\n    /** The raw generated private key. */\n    privateKey: Uint8Array<ArrayBuffer>;\n    /** The generated key, encoded for display to the user per https://spec.matrix.org/v1.7/client-server-api/#key-representation. */\n    encodedPrivateKey?: string;\n}\n\n/**\n *  Result type of {@link CryptoApi#getEncryptionInfoForEvent}.\n */\nexport interface EventEncryptionInfo {\n    /** \"Shield\" to be shown next to this event representing its verification status */\n    shieldColour: EventShieldColour;\n\n    /**\n     * `null` if `shieldColour` is `EventShieldColour.NONE`; otherwise a reason code for the shield in `shieldColour`.\n     */\n    shieldReason: EventShieldReason | null;\n}\n\n/**\n * Types of shield to be shown for {@link EventEncryptionInfo#shieldColour}.\n */\nexport enum EventShieldColour {\n    NONE,\n    GREY,\n    RED,\n}\n\n/**\n * Reason codes for {@link EventEncryptionInfo#shieldReason}.\n */\nexport enum EventShieldReason {\n    /** An unknown reason from the crypto library (if you see this, it is a bug in matrix-js-sdk). */\n    UNKNOWN,\n\n    /** \"Encrypted by an unverified user.\" */\n    UNVERIFIED_IDENTITY,\n\n    /** \"Encrypted by a device not verified by its owner.\" */\n    UNSIGNED_DEVICE,\n\n    /** \"Encrypted by an unknown or deleted device.\" */\n    UNKNOWN_DEVICE,\n\n    /**\n     * \"The authenticity of this encrypted message can't be guaranteed on this device.\"\n     *\n     * ie: the key has been forwarded, or retrieved from an insecure backup.\n     */\n    AUTHENTICITY_NOT_GUARANTEED,\n\n    /**\n     * The (deprecated) sender_key field in the event does not match the Ed25519 key of the device that sent us the\n     * decryption keys.\n     *\n     * @deprecated The sender_key field is not checked by matrix-sdk-crypto, and this value is therefore unused since\n     * the migration to matrix-sdk-crypto in v37.0.0.\n     */\n    MISMATCHED_SENDER_KEY,\n\n    /**\n     * The event was sent unencrypted in an encrypted room.\n     *\n     * @deprecated This has never been used. The fact it is here was due to a misunderstanding of the behaviour of\n     * `matrix-sdk-crypto`.\n     */\n    SENT_IN_CLEAR,\n\n    /**\n     * The sender was previously verified but changed their identity.\n     */\n    VERIFICATION_VIOLATION,\n\n    /**\n     * The `sender` field on the event does not match the owner of the device\n     * that established the Megolm session.\n     */\n    MISMATCHED_SENDER,\n}\n\n/** The result of a call to {@link CryptoApi.getOwnDeviceKeys} */\nexport interface OwnDeviceKeys {\n    /** Public part of the Ed25519 fingerprint key for the current device, base64 encoded. */\n    ed25519: string;\n    /** Public part of the Curve25519 identity key for the current device, base64 encoded. */\n    curve25519: string;\n}\n\n/**\n * Information about the encryption of a successfully decrypted to-device message.\n */\nexport interface OlmEncryptionInfo {\n    /** The user ID of the event sender, note this is untrusted data unless `isVerified` is true **/\n    sender: string;\n    /**\n     * The device ID of the device that sent us the event.\n     * Note this is untrusted data unless {@link senderVerified} is true.\n     * If the device ID is not known, this will be `null`.\n     **/\n    senderDevice?: string;\n    /** The sender device's public Curve25519 key, base64 encoded **/\n    senderCurve25519KeyBase64: string;\n    /**\n     *  If true, this message is guaranteed to be authentic as it is coming from a device belonging to a user that we have verified.\n     *  This is the state at the time of decryption (the user could be verified later).\n     */\n    senderVerified: boolean;\n}\n\nexport * from \"./verification.ts\";\nexport type * from \"./keybackup.ts\";\nexport * from \"./recovery-key.ts\";\nexport * from \"./key-passphrase.ts\";\nexport * from \"./CryptoEvent.ts\";\nexport type * from \"./CryptoEventHandlerMap.ts\";\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { type TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\n\n/**\n * An incoming, or outgoing, request to verify a user or a device via cross-signing.\n */\nexport interface VerificationRequest extends TypedEventEmitter<\n    VerificationRequestEvent,\n    VerificationRequestEventHandlerMap\n> {\n    /**\n     * Unique ID for this verification request.\n     *\n     * An ID isn't assigned until the first message is sent, so this may be `undefined` in the early phases.\n     */\n    get transactionId(): string | undefined;\n\n    /**\n     * For an in-room verification, the ID of the room.\n     *\n     * For to-device verifictions, `undefined`.\n     */\n    get roomId(): string | undefined;\n\n    /**\n     * True if this request was initiated by the local client.\n     *\n     * For in-room verifications, the initiator is who sent the `m.key.verification.request` event.\n     * For to-device verifications, the initiator is who sent the `m.key.verification.start` event.\n     */\n    get initiatedByMe(): boolean;\n\n    /** The user id of the other party in this request */\n    get otherUserId(): string;\n\n    /** For verifications via to-device messages: the ID of the other device. Otherwise, undefined. */\n    get otherDeviceId(): string | undefined;\n\n    /** True if the other party in this request is one of this user's own devices. */\n    get isSelfVerification(): boolean;\n\n    /** current phase of the request. */\n    get phase(): VerificationPhase;\n\n    /** True if the request has sent its initial event and needs more events to complete\n     * (ie it is in phase `Requested`, `Ready` or `Started`).\n     */\n    get pending(): boolean;\n\n    /**\n     * True if we have started the process of sending an `m.key.verification.ready` (but have not necessarily received\n     * the remote echo which causes a transition to {@link VerificationPhase.Ready}.\n     */\n    get accepting(): boolean;\n\n    /**\n     * True if we have started the process of sending an `m.key.verification.cancel` (but have not necessarily received\n     * the remote echo which causes a transition to {@link VerificationPhase.Cancelled}).\n     */\n    get declining(): boolean;\n\n    /**\n     * The remaining number of ms before the request will be automatically cancelled.\n     *\n     * `null` indicates that there is no timeout\n     */\n    get timeout(): number | null;\n\n    /** once the phase is Started (and !initiatedByMe) or Ready: common methods supported by both sides */\n    get methods(): string[];\n\n    /** the method picked in the .start event */\n    get chosenMethod(): string | null;\n\n    /**\n     * Checks whether the other party supports a given verification method.\n     * This is useful when setting up the QR code UI, as it is somewhat asymmetrical:\n     * if the other party supports SCAN_QR, we should show a QR code in the UI, and vice versa.\n     * For methods that need to be supported by both ends, use the `methods` property.\n     *\n     * @param method - the method to check\n     * @returns true if the other party said they supported the method\n     */\n    otherPartySupportsMethod(method: string): boolean;\n\n    /**\n     * Accepts the request, sending a .ready event to the other party\n     *\n     * @returns Promise which resolves when the event has been sent.\n     */\n    accept(): Promise<void>;\n\n    /**\n     * Cancels the request, sending a cancellation to the other party\n     *\n     * @param params - Details for the cancellation, including `reason` (defaults to \"User declined\"), and `code`\n     *    (defaults to `m.user`). **Deprecated**: this parameter is ignored by the Rust cryptography implementation.\n     *\n     * @returns Promise which resolves when the event has been sent.\n     */\n    cancel(params?: { reason?: string; code?: string }): Promise<void>;\n\n    /**\n     * Send an `m.key.verification.start` event to start verification via a particular method.\n     *\n     * This is normally used when starting a verification via emojis (ie, `method` is set to `m.sas.v1`).\n     *\n     * @param method - the name of the verification method to use.\n     *\n     * @returns The verifier which will do the actual verification.\n     */\n    startVerification(method: string): Promise<Verifier>;\n\n    /**\n     * Start a QR code verification by providing a scanned QR code for this verification flow.\n     *\n     * Validates the QR code, and if it is ok, sends an `m.key.verification.start` event with `method` set to\n     * `m.reciprocate.v1`, to tell the other side the scan was successful.\n     *\n     * See also {@link VerificationRequest#startVerification} which can be used to start other verification methods.\n     *\n     * @param qrCodeData - the decoded QR code.\n     * @returns A verifier; call `.verify()` on it to wait for the other side to complete the verification flow.\n     */\n    scanQRCode(qrCodeData: Uint8ClampedArray): Promise<Verifier>;\n\n    /**\n     * The verifier which is doing the actual verification, once the method has been established.\n     * Only defined when the `phase` is Started.\n     */\n    get verifier(): Verifier | undefined;\n\n    /**\n     * Generate the data for a QR code allowing the other device to verify this one, if it supports it.\n     *\n     * Only returns data once `phase` is {@link VerificationPhase.Ready} and the other party can scan a QR code;\n     * otherwise returns `undefined`.\n     */\n    generateQRCode(): Promise<Uint8ClampedArray | undefined>;\n\n    /**\n     * If this request has been cancelled, the cancellation code (e.g `m.user`) which is responsible for cancelling\n     * this verification.\n     */\n    get cancellationCode(): string | null;\n\n    /**\n     * The id of the user that cancelled the request.\n     *\n     * Only defined when phase is Cancelled\n     */\n    get cancellingUserId(): string | undefined;\n}\n\n/** Events emitted by {@link VerificationRequest}. */\nexport enum VerificationRequestEvent {\n    /**\n     * Fires whenever the state of the request object has changed.\n     *\n     * There is no payload to the event.\n     */\n    Change = \"change\",\n}\n\n/**\n * Listener type map for {@link VerificationRequestEvent}s.\n *\n * @internal\n */\nexport type VerificationRequestEventHandlerMap = {\n    [VerificationRequestEvent.Change]: () => void;\n};\n\n/** The current phase of a verification request. */\nexport enum VerificationPhase {\n    /** Initial state: no event yet exchanged */\n    Unsent = 1,\n\n    /** An `m.key.verification.request` event has been sent or received */\n    Requested,\n\n    /** An `m.key.verification.ready` event has been sent or received, indicating the verification request is accepted. */\n    Ready,\n\n    /**\n     * The verification is in flight.\n     *\n     * This means that an `m.key.verification.start` event has been sent or received, choosing a verification method;\n     * however the verification has not yet completed or been cancelled.\n     */\n    Started,\n\n    /**\n     * An `m.key.verification.cancel` event has been sent or received at any time before the `done` event, cancelling\n     * the verification request\n     */\n    Cancelled,\n\n    /**\n     * The verification request is complete.\n     *\n     * Normally this means that `m.key.verification.done` events have been sent and received.\n     */\n    Done,\n}\n\n/**\n * A `Verifier` is responsible for performing the verification using a particular method, such as via QR code or SAS\n * (emojis).\n *\n * A verifier object can be created by calling `VerificationRequest.beginVerification`; one is also created\n * automatically when a `m.key.verification.start` event is received for an existing VerificationRequest.\n *\n * Once a verifier object is created, the verification can be started by calling the {@link Verifier#verify} method.\n */\nexport interface Verifier extends TypedEventEmitter<VerifierEvent, VerifierEventHandlerMap> {\n    /**\n     * Returns true if the verification has been cancelled, either by us or the other side.\n     */\n    get hasBeenCancelled(): boolean;\n\n    /**\n     * The ID of the other user in the verification process.\n     */\n    get userId(): string;\n\n    /**\n     * Start the key verification, if it has not already been started.\n     *\n     * This means sending a `m.key.verification.start` if we are the first responder, or a `m.key.verification.accept`\n     * if the other side has already sent a start event.\n     *\n     * @returns Promise which resolves when the verification has completed, or rejects if the verification is cancelled\n     *    or times out.\n     */\n    verify(): Promise<void>;\n\n    /**\n     * Cancel a verification.\n     *\n     * We will send an `m.key.verification.cancel` if the verification is still in flight. The verification promise\n     * will reject, and a {@link crypto-api.VerifierEvent.Cancel | VerifierEvent.Cancel} will be emitted.\n     *\n     * @param e - the reason for the cancellation.\n     */\n    cancel(e: Error): void;\n\n    /**\n     * Get the details for an SAS verification, if one is in progress\n     *\n     * Returns `null`, unless this verifier is for a SAS-based verification and we are waiting for the user to confirm\n     * the SAS matches.\n     */\n    getShowSasCallbacks(): ShowSasCallbacks | null;\n\n    /**\n     * Get the details for reciprocating QR code verification, if one is in progress\n     *\n     * Returns `null`, unless this verifier is for reciprocating a QR-code-based verification (ie, the other user has\n     * already scanned our QR code), and we are waiting for the user to confirm.\n     */\n    getReciprocateQrCodeCallbacks(): ShowQrCodeCallbacks | null;\n}\n\n/** Events emitted by {@link Verifier} */\nexport enum VerifierEvent {\n    /**\n     * The verification has been cancelled, by us or the other side.\n     *\n     * The payload is either an {@link Error}, or an (incoming or outgoing) {@link MatrixEvent}, depending on\n     * unspecified reasons.\n     */\n    Cancel = \"cancel\",\n\n    /**\n     * SAS data has been exchanged and should be displayed to the user.\n     *\n     * The payload is the {@link ShowSasCallbacks} object.\n     */\n    ShowSas = \"show_sas\",\n\n    /**\n     * The user should confirm if the other side has scanned our QR code.\n     *\n     * The payload is the {@link ShowQrCodeCallbacks} object.\n     */\n    ShowReciprocateQr = \"show_reciprocate_qr\",\n}\n\n/** Listener type map for {@link VerifierEvent}s. */\nexport type VerifierEventHandlerMap = {\n    [VerifierEvent.Cancel]: (e: Error | MatrixEvent) => void;\n    [VerifierEvent.ShowSas]: (sas: ShowSasCallbacks) => void;\n    [VerifierEvent.ShowReciprocateQr]: (qr: ShowQrCodeCallbacks) => void;\n};\n\n/**\n * Callbacks for user actions to confirm that the other side has scanned our QR code.\n *\n * This is exposed as the payload of a `VerifierEvent.ShowReciprocateQr` event, or can be retrieved directly from the\n * verifier as `reciprocateQREvent`.\n */\nexport interface ShowQrCodeCallbacks {\n    /** The user confirms that the verification data matches */\n    confirm(): void;\n\n    /** Cancel the verification flow */\n    cancel(): void;\n}\n\n/**\n * Callbacks for user actions while a SAS is displayed.\n *\n * This is exposed as the payload of a `VerifierEvent.ShowSas` event, or directly from the verifier as `sasEvent`.\n */\nexport interface ShowSasCallbacks {\n    /** The generated SAS to be shown to the user */\n    sas: GeneratedSas;\n\n    /** Function to call if the user confirms that the SAS matches.\n     *\n     * @returns A Promise that completes once the m.key.verification.mac is queued.\n     */\n    confirm(): Promise<void>;\n\n    /**\n     * Function to call if the user finds the SAS does not match.\n     *\n     * Sends an `m.key.verification.cancel` event with a `m.mismatched_sas` error code.\n     */\n    mismatch(): void;\n\n    /** Cancel the verification flow */\n    cancel(): void;\n}\n\n/** A generated SAS to be shown to the user, in alternative formats */\nexport interface GeneratedSas {\n    /**\n     * The SAS as three numbers between 0 and 8191.\n     *\n     * Only populated if the `decimal` SAS method was negotiated.\n     */\n    decimal?: [number, number, number];\n\n    /**\n     * The SAS as seven emojis.\n     *\n     * Only populated if the `emoji` SAS method was negotiated.\n     */\n    emoji?: EmojiMapping[];\n}\n\n/**\n * An emoji for the generated SAS. A tuple `[emoji, name]` where `emoji` is the emoji itself and `name` is the\n * English name.\n */\nexport type EmojiMapping = [emoji: string, name: string];\n\n/**\n * True if the request is in a state where it can be accepted (ie, that we're in phases {@link VerificationPhase.Unsent}\n * or {@link VerificationPhase.Requested}, and that we're not in the process of sending a `ready` or `cancel`).\n */\nexport function canAcceptVerificationRequest(req: VerificationRequest): boolean {\n    return req.phase < VerificationPhase.Ready && !req.accepting && !req.declining;\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum InvalidCryptoStoreState {\n    TooNew = \"TOO_NEW\",\n}\n\nexport class InvalidCryptoStoreError extends Error {\n    public static TOO_NEW = InvalidCryptoStoreState.TooNew;\n\n    public constructor(public readonly reason: InvalidCryptoStoreState) {\n        const message =\n            `Crypto store is invalid because ${reason}, ` +\n            `please stop the client, delete all data and start the client again`;\n        super(message);\n        this.name = \"InvalidCryptoStoreError\";\n    }\n}\n\nexport class KeySignatureUploadError extends Error {\n    public constructor(\n        message: string,\n        public readonly value: any,\n    ) {\n        super(message);\n    }\n}\n\n/**\n * It is invalid to call most methods once {@link MatrixClient#stopClient} has been called.\n *\n * This error will be thrown if you attempt to do so.\n *\n * {@link MatrixClient#stopClient} itself is an exception to this: it may safely be called multiple times on the same\n * instance.\n */\nexport class ClientStoppedError extends Error {\n    public constructor() {\n        super(\"MatrixClient has been stopped\");\n    }\n}\n\n/**\n * This error is thrown when the Homeserver does not support the delayed events endpoints.\n */\nexport class UnsupportedDelayedEventsEndpointError extends Error {\n    public constructor(\n        message: string,\n        public clientEndpoint:\n            | \"sendDelayedEvent\"\n            | \"updateDelayedEvent\"\n            | \"cancelScheduledDelayedEvent\"\n            | \"restartScheduledDelayedEvent\"\n            | \"sendScheduledDelayedEvent\"\n            | \"sendDelayedStateEvent\"\n            | \"getDelayedEvents\",\n    ) {\n        super(message);\n        this.name = \"UnsupportedDelayedEventsEndpointError\";\n    }\n}\n\n/**\n * This error is thrown when the Homeserver does not support the sticky events endpoints.\n */\nexport class UnsupportedStickyEventsEndpointError extends Error {\n    public constructor(\n        message: string,\n        public clientEndpoint: \"sendStickyEvent\" | \"sendStickyStateEvent\",\n    ) {\n        super(message);\n        this.name = \"UnsupportedStickyEventsEndpointError\";\n    }\n}\n","/*\nCopyright 2021 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Optional } from \"matrix-events-sdk\";\n\n/**\n * Determines if the given optional was provided a value.\n * @param s - The optional to test.\n * @returns True if the value is defined.\n */\nexport function isProvided<T>(s: Optional<T>): s is T {\n    return s !== null && s !== undefined;\n}\n\n/**\n * Determines if the given optional string is a defined string.\n * @param s - The input string.\n * @returns True if the input is a defined string.\n */\nexport function isOptionalAString(s: Optional<string>): s is string {\n    return isProvided(s) && typeof s === \"string\";\n}\n","/*\nCopyright 2015 - 2021 Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type EventType, type RelationType } from \"./@types/event.ts\";\nimport { UNREAD_THREAD_NOTIFICATIONS } from \"./@types/sync.ts\";\nimport { FilterComponent, type IFilterComponent } from \"./filter-component.ts\";\nimport { type MatrixEvent } from \"./models/event.ts\";\n\n/**\n */\nfunction setProp(obj: Record<string, any>, keyNesting: string, val: any): void {\n    const nestedKeys = keyNesting.split(\".\") as [keyof typeof obj];\n    let currentObj = obj;\n    for (let i = 0; i < nestedKeys.length - 1; i++) {\n        if (!currentObj[nestedKeys[i]]) {\n            currentObj[nestedKeys[i]] = {};\n        }\n        currentObj = currentObj[nestedKeys[i]];\n    }\n    currentObj[nestedKeys[nestedKeys.length - 1]] = val;\n}\n\n/* eslint-disable camelcase */\nexport interface IFilterDefinition {\n    event_fields?: string[];\n    event_format?: \"client\" | \"federation\";\n    presence?: IFilterComponent;\n    account_data?: IFilterComponent;\n    room?: IRoomFilter;\n}\n\nexport interface IRoomEventFilter extends IFilterComponent {\n    \"lazy_load_members\"?: boolean;\n    \"include_redundant_members\"?: boolean;\n    \"types\"?: Array<EventType | string>;\n    \"related_by_senders\"?: Array<RelationType | string>;\n    \"related_by_rel_types\"?: string[];\n    \"unread_thread_notifications\"?: boolean;\n    \"org.matrix.msc3773.unread_thread_notifications\"?: boolean;\n\n    // Unstable values\n    \"io.element.relation_senders\"?: Array<RelationType | string>;\n    \"io.element.relation_types\"?: string[];\n}\n\ninterface IStateFilter extends IRoomEventFilter {}\n\ninterface IRoomFilter {\n    not_rooms?: string[];\n    rooms?: string[];\n    ephemeral?: IRoomEventFilter;\n    include_leave?: boolean;\n    state?: IStateFilter;\n    timeline?: IRoomEventFilter;\n    account_data?: IRoomEventFilter;\n}\n/* eslint-enable camelcase */\n\nexport class Filter {\n    public static LAZY_LOADING_MESSAGES_FILTER = {\n        lazy_load_members: true,\n    };\n\n    /**\n     * Create a filter from existing data.\n     */\n    public static fromJson(userId: string | undefined | null, filterId: string, jsonObj: IFilterDefinition): Filter {\n        const filter = new Filter(userId, filterId);\n        filter.setDefinition(jsonObj);\n        return filter;\n    }\n\n    private definition: IFilterDefinition = {};\n    private roomFilter?: FilterComponent;\n    private roomTimelineFilter?: FilterComponent;\n\n    /**\n     * Construct a new Filter.\n     * @param userId - The user ID for this filter.\n     * @param filterId - The filter ID if known.\n     */\n    public constructor(\n        public readonly userId: string | undefined | null,\n        public filterId?: string,\n    ) {}\n\n    /**\n     * Get the ID of this filter on your homeserver (if known)\n     * @returns The filter ID\n     */\n    public getFilterId(): string | undefined {\n        return this.filterId;\n    }\n\n    /**\n     * Get the JSON body of the filter.\n     * @returns The filter definition\n     */\n    public getDefinition(): IFilterDefinition {\n        return this.definition;\n    }\n\n    /**\n     * Set the JSON body of the filter\n     * @param definition - The filter definition\n     */\n    public setDefinition(definition: IFilterDefinition): void {\n        this.definition = definition;\n\n        // This is all ported from synapse's FilterCollection()\n\n        // definitions look something like:\n        // {\n        //   \"room\": {\n        //     \"rooms\": [\"!abcde:example.com\"],\n        //     \"not_rooms\": [\"!123456:example.com\"],\n        //     \"state\": {\n        //       \"types\": [\"m.room.*\"],\n        //       \"not_rooms\": [\"!726s6s6q:example.com\"],\n        //       \"lazy_load_members\": true,\n        //     },\n        //     \"timeline\": {\n        //       \"limit\": 10,\n        //       \"types\": [\"m.room.message\"],\n        //       \"not_rooms\": [\"!726s6s6q:example.com\"],\n        //       \"not_senders\": [\"@spam:example.com\"]\n        //       \"contains_url\": true\n        //     },\n        //     \"ephemeral\": {\n        //       \"types\": [\"m.receipt\", \"m.typing\"],\n        //       \"not_rooms\": [\"!726s6s6q:example.com\"],\n        //       \"not_senders\": [\"@spam:example.com\"]\n        //     }\n        //   },\n        //   \"presence\": {\n        //     \"types\": [\"m.presence\"],\n        //     \"not_senders\": [\"@alice:example.com\"]\n        //   },\n        //   \"event_format\": \"client\",\n        //   \"event_fields\": [\"type\", \"content\", \"sender\"]\n        // }\n\n        const roomFilterJson = definition.room;\n\n        // consider the top level rooms/not_rooms filter\n        const roomFilterFields: IRoomFilter = {};\n        if (roomFilterJson) {\n            if (roomFilterJson.rooms) {\n                roomFilterFields.rooms = roomFilterJson.rooms;\n            }\n            if (roomFilterJson.rooms) {\n                roomFilterFields.not_rooms = roomFilterJson.not_rooms;\n            }\n        }\n\n        this.roomFilter = new FilterComponent(roomFilterFields, this.userId);\n        this.roomTimelineFilter = new FilterComponent(roomFilterJson?.timeline || {}, this.userId);\n\n        // don't bother porting this from synapse yet:\n        // this._room_state_filter =\n        //     new FilterComponent(roomFilterJson.state || {});\n        // this._room_ephemeral_filter =\n        //     new FilterComponent(roomFilterJson.ephemeral || {});\n        // this._room_account_data_filter =\n        //     new FilterComponent(roomFilterJson.account_data || {});\n        // this._presence_filter =\n        //     new FilterComponent(definition.presence || {});\n        // this._account_data_filter =\n        //     new FilterComponent(definition.account_data || {});\n    }\n\n    /**\n     * Get the room.timeline filter component of the filter\n     * @returns room timeline filter component\n     */\n    public getRoomTimelineFilterComponent(): FilterComponent | undefined {\n        return this.roomTimelineFilter;\n    }\n\n    /**\n     * Filter the list of events based on whether they are allowed in a timeline\n     * based on this filter\n     * @param events -  the list of events being filtered\n     * @returns the list of events which match the filter\n     */\n    public filterRoomTimeline(events: MatrixEvent[]): MatrixEvent[] {\n        if (this.roomFilter) {\n            events = this.roomFilter.filter(events);\n        }\n        if (this.roomTimelineFilter) {\n            events = this.roomTimelineFilter.filter(events);\n        }\n        return events;\n    }\n\n    /**\n     * Set the max number of events to return for each room's timeline.\n     * @param limit - The max number of events to return for each room.\n     */\n    public setTimelineLimit(limit: number): void {\n        setProp(this.definition, \"room.timeline.limit\", limit);\n    }\n\n    /**\n     * Enable threads unread notification\n     */\n    public setUnreadThreadNotifications(enabled: boolean): void {\n        this.definition = {\n            ...this.definition,\n            room: {\n                ...this.definition?.room,\n                timeline: {\n                    ...this.definition?.room?.timeline,\n                    [UNREAD_THREAD_NOTIFICATIONS.name]: enabled,\n                },\n            },\n        };\n    }\n\n    public setLazyLoadMembers(enabled: boolean): void {\n        setProp(this.definition, \"room.state.lazy_load_members\", enabled);\n    }\n\n    /**\n     * Control whether left rooms should be included in responses.\n     * @param includeLeave - True to make rooms the user has left appear\n     * in responses.\n     */\n    public setIncludeLeaveRooms(includeLeave: boolean): void {\n        setProp(this.definition, \"room.include_leave\", includeLeave);\n    }\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { FetchHttpApi } from \"./fetch.ts\";\nimport {\n    type FileType,\n    type IContentUri,\n    type IHttpOpts,\n    type Upload,\n    type UploadOpts,\n    type UploadResponse,\n} from \"./interface.ts\";\nimport { MediaPrefix } from \"./prefix.ts\";\nimport { type QueryDict, removeElement } from \"../utils.ts\";\nimport * as callbacks from \"../realtime-callbacks.ts\";\nimport { Method } from \"./method.ts\";\nimport { ConnectionError } from \"./errors.ts\";\nimport { parseErrorResponse } from \"./utils.ts\";\n\nexport * from \"./interface.ts\";\nexport * from \"./prefix.ts\";\nexport * from \"./errors.ts\";\nexport * from \"./method.ts\";\nexport * from \"./utils.ts\";\n\nexport class MatrixHttpApi<O extends IHttpOpts> extends FetchHttpApi<O> {\n    private uploads: Upload[] = [];\n\n    /**\n     * Upload content to the homeserver\n     *\n     * @param file - The object to upload. On a browser, something that\n     *   can be sent to XMLHttpRequest.send (typically a File).  Under node.js,\n     *   a Buffer, String or ReadStream.\n     *\n     * @param opts - options object\n     *\n     * @returns Promise which resolves to response object, or rejects with an error (usually a MatrixError).\n     * @throws May throw a `MatrixSafetyError` if content is deemed unsafe.\n     * @see MatrixSafetyError\n     */\n    public uploadContent(file: FileType, opts: UploadOpts = {}): Promise<UploadResponse> {\n        const includeFilename = opts.includeFilename ?? true;\n        const abortController = opts.abortController ?? new AbortController();\n\n        // If the file doesn't have a mime type, use a default since the HS errors if we don't supply one.\n        const contentType = (opts.type ?? (file as File).type) || \"application/octet-stream\";\n        const fileName = opts.name ?? (file as File).name;\n\n        const upload = {\n            loaded: 0,\n            total: 0,\n            abortController,\n        } as Upload;\n        const uploadResolvers = Promise.withResolvers<UploadResponse>();\n\n        if (globalThis.XMLHttpRequest) {\n            const xhr = new globalThis.XMLHttpRequest();\n\n            const timeoutFn = function (): void {\n                xhr.abort();\n                uploadResolvers.reject(new Error(\"Timeout\"));\n            };\n\n            // set an initial timeout of 30s; we'll advance it each time we get a progress notification\n            let timeoutTimer = callbacks.setTimeout(timeoutFn, 30000);\n\n            xhr.onreadystatechange = function (): void {\n                switch (xhr.readyState) {\n                    case globalThis.XMLHttpRequest.DONE:\n                        callbacks.clearTimeout(timeoutTimer);\n                        try {\n                            if (xhr.status === 0) {\n                                throw new DOMException(xhr.statusText, \"AbortError\"); // mimic fetch API\n                            }\n                            if (!xhr.responseText) {\n                                throw new Error(\"No response body.\");\n                            }\n\n                            if (xhr.status >= 400) {\n                                uploadResolvers.reject(parseErrorResponse(xhr, xhr.responseText));\n                            } else {\n                                uploadResolvers.resolve(JSON.parse(xhr.responseText));\n                            }\n                        } catch (err) {\n                            if ((<Error>err).name === \"AbortError\") {\n                                uploadResolvers.reject(err);\n                                return;\n                            }\n                            uploadResolvers.reject(new ConnectionError(\"request failed\", <Error>err));\n                        }\n                        break;\n                }\n            };\n\n            xhr.upload.onprogress = (ev: ProgressEvent): void => {\n                callbacks.clearTimeout(timeoutTimer);\n                upload.loaded = ev.loaded;\n                upload.total = ev.total;\n                timeoutTimer = callbacks.setTimeout(timeoutFn, 30000);\n                opts.progressHandler?.({\n                    loaded: ev.loaded,\n                    total: ev.total,\n                });\n            };\n\n            const url = this.getUrl(\"/upload\", undefined, MediaPrefix.V3);\n\n            if (includeFilename && fileName) {\n                url.searchParams.set(\"filename\", encodeURIComponent(fileName));\n            }\n\n            if (!this.opts.useAuthorizationHeader && this.opts.accessToken) {\n                url.searchParams.set(\"access_token\", encodeURIComponent(this.opts.accessToken));\n            }\n\n            xhr.open(Method.Post, url.href);\n            if (this.opts.useAuthorizationHeader && this.opts.accessToken) {\n                xhr.setRequestHeader(\"Authorization\", \"Bearer \" + this.opts.accessToken);\n            }\n            xhr.setRequestHeader(\"Content-Type\", contentType);\n            xhr.send(file);\n\n            abortController.signal.addEventListener(\"abort\", () => {\n                xhr.abort();\n            });\n        } else {\n            const queryParams: QueryDict = {};\n            if (includeFilename && fileName) {\n                queryParams.filename = fileName;\n            }\n\n            const headers: Record<string, string> = { \"Content-Type\": contentType };\n\n            this.authedRequest<UploadResponse>(Method.Post, \"/upload\", queryParams, file, {\n                prefix: MediaPrefix.V3,\n                headers,\n                abortSignal: abortController.signal,\n            }).then(uploadResolvers.resolve, uploadResolvers.reject);\n        }\n\n        // remove the upload from the list on completion\n        upload.promise = uploadResolvers.promise.finally(() => {\n            removeElement(this.uploads, (elem) => elem === upload);\n        });\n        abortController.signal.addEventListener(\"abort\", () => {\n            removeElement(this.uploads, (elem) => elem === upload);\n            uploadResolvers.reject(new DOMException(\"Aborted\", \"AbortError\"));\n        });\n        this.uploads.push(upload);\n        return upload.promise;\n    }\n\n    public cancelUpload(promise: Promise<UploadResponse>): boolean {\n        const upload = this.uploads.find((u) => u.promise === promise);\n        if (upload) {\n            upload.abortController.abort();\n            return true;\n        }\n        return false;\n    }\n\n    public getCurrentUploads(): Upload[] {\n        return this.uploads;\n    }\n\n    /**\n     * Get the content repository url with query parameters.\n     * @returns An object with a 'base', 'path' and 'params' for base URL,\n     *          path and query parameters respectively.\n     */\n    public getContentUri(): IContentUri {\n        return {\n            base: this.opts.baseUrl,\n            path: MediaPrefix.V3 + \"/upload\",\n            params: {\n                access_token: this.opts.accessToken!,\n            },\n        };\n    }\n}\n","/*\nCopyright 2017 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { LocalIndexedDBStoreBackend } from \"./indexeddb-local-backend.ts\";\nimport { logger } from \"../logger.ts\";\n\ninterface ICmd {\n    command: string;\n    seq: number;\n    args: any[];\n}\n\n/**\n * This class lives in the webworker and drives a LocalIndexedDBStoreBackend\n * controlled by messages from the main process.\n *\n * @example\n * It should be instantiated by a web worker script provided by the application\n * in a script, for example:\n * ```\n * import {IndexedDBStoreWorker} from 'matrix-js-sdk/lib/indexeddb-worker.js';\n * const remoteWorker = new IndexedDBStoreWorker(postMessage);\n * onmessage = remoteWorker.onMessage;\n * ```\n *\n * Note that it is advisable to import this class by referencing the file directly to\n * avoid a dependency on the whole js-sdk.\n *\n */\nexport class IndexedDBStoreWorker {\n    private backend?: LocalIndexedDBStoreBackend;\n\n    /**\n     * @param postMessage - The web worker postMessage function that\n     * should be used to communicate back to the main script.\n     */\n    public constructor(private readonly postMessage: InstanceType<typeof Worker>[\"postMessage\"]) {}\n\n    private onClose = (): void => {\n        this.postMessage.call(null, {\n            command: \"closed\",\n        });\n    };\n\n    /**\n     * Passes a message event from the main script into the class. This method\n     * can be directly assigned to the web worker `onmessage` variable.\n     *\n     * @param ev - The message event\n     */\n    public onMessage = (ev: MessageEvent): void => {\n        const msg: ICmd = ev.data;\n        let prom: Promise<any> | undefined;\n\n        switch (msg.command) {\n            case \"setupWorker\":\n                // this is the 'indexedDB' global (where global != window\n                // because it's a web worker and there is no window).\n                this.backend = new LocalIndexedDBStoreBackend(indexedDB, msg.args[0]);\n                prom = Promise.resolve();\n                break;\n            case \"connect\":\n                prom = this.backend?.connect(this.onClose);\n                break;\n            case \"isNewlyCreated\":\n                prom = this.backend?.isNewlyCreated();\n                break;\n            case \"clearDatabase\":\n                prom = this.backend?.clearDatabase();\n                break;\n            case \"getSavedSync\":\n                prom = this.backend?.getSavedSync(false);\n                break;\n            case \"setSyncData\":\n                prom = this.backend?.setSyncData(msg.args[0]);\n                break;\n            case \"syncToDatabase\":\n                prom = this.backend?.syncToDatabase(msg.args[0]);\n                break;\n            case \"getUserPresenceEvents\":\n                prom = this.backend?.getUserPresenceEvents();\n                break;\n            case \"getNextBatchToken\":\n                prom = this.backend?.getNextBatchToken();\n                break;\n            case \"getOutOfBandMembers\":\n                prom = this.backend?.getOutOfBandMembers(msg.args[0]);\n                break;\n            case \"clearOutOfBandMembers\":\n                prom = this.backend?.clearOutOfBandMembers(msg.args[0]);\n                break;\n            case \"setOutOfBandMembers\":\n                prom = this.backend?.setOutOfBandMembers(msg.args[0], msg.args[1]);\n                break;\n            case \"getClientOptions\":\n                prom = this.backend?.getClientOptions();\n                break;\n            case \"storeClientOptions\":\n                prom = this.backend?.storeClientOptions(msg.args[0]);\n                break;\n            case \"saveToDeviceBatches\":\n                prom = this.backend?.saveToDeviceBatches(msg.args[0]);\n                break;\n            case \"getOldestToDeviceBatch\":\n                prom = this.backend?.getOldestToDeviceBatch();\n                break;\n            case \"removeToDeviceBatch\":\n                prom = this.backend?.removeToDeviceBatch(msg.args[0]);\n                break;\n        }\n\n        if (prom === undefined) {\n            this.postMessage({\n                command: \"cmd_fail\",\n                seq: msg.seq,\n                // Can't be an Error because they're not structured cloneable\n                error: \"Unrecognised command\",\n            });\n            return;\n        }\n\n        prom.then(\n            (ret) => {\n                this.postMessage.call(null, {\n                    command: \"cmd_success\",\n                    seq: msg.seq,\n                    result: ret,\n                });\n            },\n            (err) => {\n                logger.error(\"Error running command: \" + msg.command, err);\n                this.postMessage.call(null, {\n                    command: \"cmd_fail\",\n                    seq: msg.seq,\n                    // Just send a string because Error objects aren't cloneable\n                    error: {\n                        message: err.message,\n                        name: err.name,\n                    },\n                });\n            },\n        );\n    };\n}\n","/*\nCopyright 2018 Andr Jaenisch\nCopyright 2019-2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport loglevel from \"loglevel\";\n\n/** Backwards-compatibility hack to expose `log` to applications that might still be relying on it. */\ninterface LoggerWithLogMethod extends Logger {\n    /**\n     * Output debug message to the logger.\n     *\n     * @param msg - Data to log.\n     *\n     * @deprecated prefer {@link Logger.debug}.\n     */\n    log(...msg: any[]): void;\n}\n\n/** Logger interface used within the js-sdk codebase */\nexport interface Logger extends BaseLogger {\n    /**\n     * Create a child logger.\n     *\n     * This child will use the `methodFactory` of the parent, so any log extensions applied to the parent\n     * at the time of calling `getChild` will be applied to the child as well.\n     * It will NOT apply changes to the parent's `methodFactory` after the child was created.\n     * Those changes need to be applied to the child manually.\n     *\n     * @param namespace - name to add to the current logger to generate the child. Some implementations of `Logger`\n     *    use this as a prefix; others use a different mechanism.\n     */\n    getChild(namespace: string): Logger;\n}\n\n/** The basic interface for a logger which doesn't support children */\nexport interface BaseLogger {\n    /**\n     * Output trace message to the logger, with stack trace.\n     *\n     * @param msg - Data to log.\n     */\n    trace(...msg: any[]): void;\n\n    /**\n     * Output debug message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    debug(...msg: any[]): void;\n\n    /**\n     * Output info message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    info(...msg: any[]): void;\n\n    /**\n     * Output warn message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    warn(...msg: any[]): void;\n\n    /**\n     * Output error message to the logger.\n     *\n     * @param msg - Data to log.\n     */\n    error(...msg: any[]): void;\n}\n\n// This is to demonstrate, that you can use any namespace you want.\n// Namespaces allow you to turn on/off the logging for specific parts of the\n// application.\n// An idea would be to control this via an environment variable (on Node.js).\n// See https://www.npmjs.com/package/debug to see how this could be implemented\n// Part of #332 is introducing a logging library in the first place.\nconst DEFAULT_NAMESPACE = \"matrix\";\n\n// because rageshakes in react-sdk hijack the console log, also at module load time,\n// initializing the logger here races with the initialization of rageshakes.\n// to avoid the issue, we override the methodFactory of loglevel that binds to the\n// console methods at initialization time by a factory that looks up the console methods\n// when logging so we always get the current value of console methods.\nloglevel.methodFactory = function (methodName, logLevel, loggerName) {\n    return function (this: PrefixedLogger, ...args): void {\n        /* eslint-disable @typescript-eslint/no-invalid-this */\n        if (this.prefix) {\n            args.unshift(this.prefix);\n        }\n        /* eslint-enable @typescript-eslint/no-invalid-this */\n        const supportedByConsole =\n            methodName === \"error\" ||\n            methodName === \"warn\" ||\n            methodName === \"trace\" ||\n            methodName === \"info\" ||\n            methodName === \"debug\";\n        /* eslint-disable no-console */\n        if (supportedByConsole) {\n            return console[methodName](...args);\n        } else {\n            return console.log(...args);\n        }\n        /* eslint-enable no-console */\n    };\n};\n\n/**\n * Implementation of {@link Logger} based on `loglevel`.\n */\ninterface PrefixedLogger extends loglevel.Logger, LoggerWithLogMethod {\n    prefix?: string;\n}\n\n/**\n * Internal utility function: gets a {@link Logger} based on `loglevel`.\n *\n * Child loggers produced by {@link Logger.getChild} add the name of the child logger as a prefix on each log line.\n *\n * @param prefix Prefix to add to each logged line. If undefined, no prefix will be added.\n */\nfunction getPrefixedLogger(prefix?: string): PrefixedLogger {\n    const loggerName = DEFAULT_NAMESPACE + (prefix === undefined ? \"\" : `-${prefix}`);\n    const prefixLogger = loglevel.getLogger(loggerName) as PrefixedLogger;\n\n    if (prefixLogger.getChild === undefined) {\n        // This is a new loglevel Logger which has not been turned into a PrefixedLogger yet.\n        prefixLogger.prefix = prefix;\n        prefixLogger.getChild = (childPrefix): Logger => {\n            // create the new child logger\n            const childLogger = getPrefixedLogger((prefix ?? \"\") + childPrefix);\n            // Assign the methodFactory from the parent logger.\n            // This is useful if we add extensions to the parent logger that modifies\n            // its methodFactory. (An example extension is: storing each log to a rageshake db)\n            childLogger.methodFactory = prefixLogger.methodFactory;\n            // Rebuild the child logger with the new methodFactory.\n            childLogger.rebuild();\n            return childLogger;\n        };\n        prefixLogger.setLevel(loglevel.levels.DEBUG, false);\n    }\n\n    return prefixLogger;\n}\n\n/**\n * Drop-in replacement for `console` using {@link https://www.npmjs.com/package/loglevel|loglevel}.\n * Can be tailored down to specific use cases if needed.\n *\n * @deprecated avoid the use of this unless you are the constructor of `MatrixClient`: you should be using the logger\n *    associated with `MatrixClient`.\n */\nexport const logger = getPrefixedLogger() as LoggerWithLogMethod;\n\n/**\n * A \"span\" for grouping related log lines together.\n *\n * The current implementation just adds the name at the start of each log line.\n *\n * This offers a lighter-weight alternative to 'child' loggers returned by {@link Logger#getChild}. In particular,\n * it's not possible to apply individual filters to the LogSpan such as setting the verbosity level. On the other hand,\n * no reference to the LogSpan is retained in the logging framework, so it is safe to make lots of them over the course\n * of an application's life and just drop references to them when the job is done.\n */\nexport class LogSpan implements BaseLogger {\n    private readonly name;\n\n    public constructor(\n        private readonly parent: BaseLogger,\n        name: string,\n    ) {\n        this.name = name + \":\";\n    }\n\n    public trace(...msg: any[]): void {\n        this.parent.trace(this.name, ...msg);\n    }\n\n    public debug(...msg: any[]): void {\n        this.parent.debug(this.name, ...msg);\n    }\n\n    public info(...msg: any[]): void {\n        this.parent.info(this.name, ...msg);\n    }\n\n    public warn(...msg: any[]): void {\n        this.parent.warn(this.name, ...msg);\n    }\n\n    public error(...msg: any[]): void {\n        this.parent.error(this.name, ...msg);\n    }\n}\n\n/**\n * A simplification of the `Debugger` type exposed by the `debug` library. We reimplement the bits we need here\n * to avoid a dependency on `debug`.\n */\ninterface Debugger {\n    (formatter: any, ...args: any[]): void;\n    extend: (namespace: string, delimiter?: string) => Debugger;\n}\n\n/**\n * A `Logger` instance, suitable for use in {@link ICreateClientOpts.logger}, which will write to the `debug` library.\n *\n * @example\n * ```js\n *     import debug from \"debug\";\n *\n *     const client = createClient({\n *         baseUrl: homeserverUrl,\n *         userId: userId,\n *         accessToken: \"akjgkrgjs\",\n *         deviceId: \"xzcvb\",\n *         logger: new DebugLogger(debug(`matrix-js-sdk:${userId}`)),\n *     });\n * ```\n */\nexport class DebugLogger implements Logger {\n    public constructor(private debugInstance: Debugger) {}\n\n    public trace(...msg: any[]): void {\n        this.debugWithPrefix(\"[TRACE]\", ...msg);\n    }\n\n    public debug(...msg: any[]): void {\n        this.debugWithPrefix(\"[DEBUG]\", ...msg);\n    }\n\n    public info(...msg: any[]): void {\n        this.debugWithPrefix(\"[INFO]\", ...msg);\n    }\n\n    public warn(...msg: any[]): void {\n        this.debugWithPrefix(\"[WARN]\", ...msg);\n    }\n\n    public error(...msg: any[]): void {\n        this.debugWithPrefix(\"[ERROR]\", ...msg);\n    }\n\n    public getChild(namespace: string): DebugLogger {\n        return new DebugLogger(this.debugInstance.extend(namespace));\n    }\n\n    private debugWithPrefix(prefix: string, ...msg: any[]): void {\n        let formatter: string;\n\n        // Convert the first argument to a string, so that we can safely add a prefix. This is much the same logic that\n        // `debug()` uses.\n        if (msg.length === 0) {\n            formatter = \"\";\n        } else if (msg[0] instanceof Error) {\n            const err = msg.shift();\n            formatter = err.stack || err.message;\n        } else if (typeof msg[0] == \"string\") {\n            formatter = msg.shift();\n        } else {\n            formatter = \"%O\";\n        }\n        this.debugInstance(prefix + \" \" + formatter, ...msg);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MXID_PATTERN } from \"../models/room-member.ts\";\nimport { deepCompare } from \"../utils.ts\";\nimport { type LivekitFocusSelection } from \"./LivekitTransport.ts\";\nimport { slotDescriptionToId, slotIdToDescription, type SlotDescription } from \"./MatrixRTCSession.ts\";\nimport type { RTCCallIntent, Transport } from \"./types.ts\";\nimport { type MatrixEvent, type IContent } from \"../models/event.ts\";\nimport { type RelationType } from \"../@types/event.ts\";\nimport { sha256 } from \"../digest.ts\";\nimport { encodeUnpaddedBase64 } from \"../base64.ts\";\nimport { type Logger } from \"../logger.ts\";\n\n/**\n * The default duration in milliseconds that a membership is considered valid for.\n * Ordinarily the client responsible for the session will update the membership before it expires.\n * We use this duration as the fallback case where stale sessions are present for some reason.\n */\nexport const DEFAULT_EXPIRE_DURATION = 1000 * 60 * 60 * 4;\n\ntype CallScope = \"m.room\" | \"m.user\";\ntype Member = {\n    user_id: string;\n    device_id: string;\n    /**\n     * The id used on the media backend.\n     * (With livekit this is the participant identity on the LK SFU)\n     * This can be a UUID but right now it is `${this.matrixEventData.sender}:${data.device_id}`.\n     */\n    id: string;\n};\n\nexport interface RtcMembershipData {\n    \"slot_id\": string;\n    \"member\": Member;\n    \"m.relates_to\"?: {\n        event_id: string;\n        rel_type: RelationType.Reference;\n    };\n    \"application\": {\n        type: string;\n        // other application specific keys\n        [key: string]: unknown;\n    };\n    \"rtc_transports\": Transport[];\n    \"versions\": string[];\n    \"msc4354_sticky_key\"?: string;\n    \"sticky_key\"?: string;\n}\n\nconst checkRtcMembershipData = (\n    data: IContent,\n    errors: string[],\n    referenceUserId: string,\n): data is RtcMembershipData => {\n    const prefix = \" - \";\n\n    // required fields\n    if (typeof data.slot_id !== \"string\") {\n        errors.push(prefix + \"slot_id must be string\");\n    } else {\n        if (data.slot_id.split(\"#\").length !== 2) errors.push(prefix + 'slot_id must include exactly one \"#\"');\n    }\n    if (typeof data.member !== \"object\" || data.member === null) {\n        errors.push(prefix + \"member must be an object\");\n    } else {\n        if (typeof data.member.user_id !== \"string\") errors.push(prefix + \"member.user_id must be string\");\n        else if (!MXID_PATTERN.test(data.member.user_id)) errors.push(prefix + \"member.user_id must be a valid mxid\");\n        // This is not what the spec enforces but there currently are no rules what power levels are required to\n        // send a m.rtc.member event for a other user. So we add this check for simplicity and to avoid possible attacks until there\n        // is a proper definition when this is allowed.\n        else if (data.member.user_id !== referenceUserId) errors.push(prefix + \"member.user_id must match the sender\");\n        if (typeof data.member.device_id !== \"string\") errors.push(prefix + \"member.device_id must be string\");\n        if (typeof data.member.id !== \"string\") errors.push(prefix + \"member.id must be string\");\n    }\n    if (typeof data.application !== \"object\" || data.application === null) {\n        errors.push(prefix + \"application must be an object\");\n    } else {\n        if (typeof data.application.type !== \"string\") {\n            errors.push(prefix + \"application.type must be a string\");\n        } else {\n            if (data.application.type.includes(\"#\")) errors.push(prefix + 'application.type must not include \"#\"');\n        }\n    }\n    if (data.rtc_transports === undefined || !Array.isArray(data.rtc_transports)) {\n        errors.push(prefix + \"rtc_transports must be an array\");\n    } else {\n        // validate that each transport has at least a string 'type'\n        for (const t of data.rtc_transports) {\n            if (typeof t !== \"object\" || t === null || typeof (t as any).type !== \"string\") {\n                errors.push(prefix + \"rtc_transports entries must be objects with a string type\");\n                break;\n            }\n        }\n    }\n    if (data.versions === undefined || !Array.isArray(data.versions)) {\n        errors.push(prefix + \"versions must be an array\");\n    } else if (!data.versions.every((v) => typeof v === \"string\")) {\n        errors.push(prefix + \"versions must be an array of strings\");\n    }\n\n    // optional fields\n    if ((data.sticky_key ?? data.msc4354_sticky_key) === undefined) {\n        errors.push(prefix + \"sticky_key or msc4354_sticky_key must be a defined\");\n    }\n    if (data.sticky_key !== undefined && typeof data.sticky_key !== \"string\") {\n        errors.push(prefix + \"sticky_key must be a string\");\n    }\n    if (data.msc4354_sticky_key !== undefined && typeof data.msc4354_sticky_key !== \"string\") {\n        errors.push(prefix + \"msc4354_sticky_key must be a string\");\n    }\n    if (\n        data.sticky_key !== undefined &&\n        data.msc4354_sticky_key !== undefined &&\n        data.sticky_key !== data.msc4354_sticky_key\n    ) {\n        errors.push(prefix + \"sticky_key and msc4354_sticky_key must be equal if both are defined\");\n    }\n    if (data[\"m.relates_to\"] !== undefined) {\n        const rel = data[\"m.relates_to\"] as RtcMembershipData[\"m.relates_to\"];\n        if (typeof rel !== \"object\" || rel === null) {\n            errors.push(prefix + \"m.relates_to must be an object if provided\");\n        } else {\n            if (typeof rel.event_id !== \"string\") errors.push(prefix + \"m.relates_to.event_id must be a string\");\n            if (rel.rel_type !== \"m.reference\") errors.push(prefix + \"m.relates_to.rel_type must be m.reference\");\n        }\n    }\n\n    return errors.length === 0;\n};\n\n/**\n * MSC4143 (MatrixRTC) session membership data.\n * Represents the `session` in the memberships section of an m.call.member event as it is on the wire.\n **/\nexport type SessionMembershipData = {\n    /**\n     * The RTC application defines the type of the RTC session.\n     */\n    \"application\": string;\n\n    /**\n     * The id of this session.\n     * A session can never span over multiple rooms so this id is to distinguish between\n     * multiple session in one room. A room wide session that is not associated with a user,\n     * and therefore immune to creation race conflicts, uses the `call_id: \"\"`.\n     */\n    \"call_id\": string;\n\n    /**\n     * The Matrix device ID of this session. A single user can have multiple sessions on different devices.\n     */\n    \"device_id\": string;\n\n    /**\n     * The focus selection system this user/membership is using.\n     */\n    \"focus_active\": LivekitFocusSelection;\n\n    /**\n     * A list of possible foci this user knows about. One of them might be used based on the focus_active\n     * selection system.\n     */\n    \"foci_preferred\": Transport[];\n\n    /**\n     * Optional field that contains the creation of the session. If it is undefined the creation\n     * is the `origin_server_ts` of the event itself. For updates to the event this property tracks\n     * the `origin_server_ts` of the initial join event.\n     *  - If it is undefined it can be interpreted as a \"Join\".\n     *  - If it is defined it can be interpreted as an \"Update\"\n     */\n    \"created_ts\"?: number;\n\n    // Application specific data\n\n    /**\n     * If the `application` = `\"m.call\"` this defines if it is a room or user owned call.\n     * There can always be one room scoped call but multiple user owned calls (breakout sessions)\n     */\n    \"scope\"?: CallScope;\n\n    /**\n     * Optionally we allow to define a delta to the `created_ts` that defines when the event is expired/invalid.\n     * This should be set to multiple hours. The only reason it exist is to deal with failed delayed events.\n     * (for example caused by a homeserver crashes)\n     **/\n    \"expires\"?: number;\n\n    /**\n     * The intent of the call from the perspective of this user. This may be an audio call, video call or\n     * something else.\n     */\n    \"m.call.intent\"?: RTCCallIntent;\n    /**\n     * The sticky key in case of a sticky event. This string encodes the application + device_id indicating the used slot + device.\n     */\n    \"msc4354_sticky_key\"?: string;\n\n    /**\n     * The id used on the media backend.\n     * (With livekit this is the participant identity on the LK SFU)\n     * This can be a UUID but right now it is `${this.matrixEventData.sender}:${data.device_id}`.\n     *\n     * It is compleatly valid to not set this field. Other clients will treat `undefined` as `${this.matrixEventData.sender}:${data.device_id}`\n     */\n    \"membershipID\"?: string;\n};\n\nconst checkSessionsMembershipData = (data: IContent, errors: string[]): data is SessionMembershipData => {\n    const prefix = \" - \";\n    if (typeof data.device_id !== \"string\") errors.push(prefix + \"device_id must be string\");\n    if (typeof data.call_id !== \"string\") errors.push(prefix + \"call_id must be string\");\n    if (typeof data.application !== \"string\") errors.push(prefix + \"application must be a string\");\n    if (typeof data.focus_active?.type !== \"string\") errors.push(prefix + \"focus_active.type must be a string\");\n    if (data.focus_active === undefined) {\n        errors.push(prefix + \"focus_active has an invalid type\");\n    }\n    if (\n        data.foci_preferred !== undefined &&\n        !(\n            Array.isArray(data.foci_preferred) &&\n            data.foci_preferred.every(\n                (f: Transport) => typeof f === \"object\" && f !== null && typeof f.type === \"string\",\n            )\n        )\n    ) {\n        errors.push(prefix + \"foci_preferred must be an array of transport objects\");\n    }\n    // optional parameters\n    if (data.created_ts !== undefined && typeof data.created_ts !== \"number\") {\n        errors.push(prefix + \"created_ts must be number\");\n    }\n\n    // application specific data (we first need to check if they exist)\n    if (data.scope !== undefined && typeof data.scope !== \"string\") errors.push(prefix + \"scope must be string\");\n\n    if (data[\"m.call.intent\"] !== undefined && typeof data[\"m.call.intent\"] !== \"string\") {\n        errors.push(prefix + \"m.call.intent must be a string\");\n    }\n\n    return errors.length === 0;\n};\n\ntype MembershipData = { kind: \"rtc\"; data: RtcMembershipData } | { kind: \"session\"; data: SessionMembershipData };\n// TODO: Rename to RtcMembership once we removed the legacy SessionMembership from this file.\nexport class CallMembership {\n    public static equal(a?: CallMembership, b?: CallMembership): boolean {\n        return deepCompare(a?.membershipData, b?.membershipData);\n    }\n\n    private logger?: Logger;\n    /** The parsed data from the Matrix event.\n     * To access checked eventId and sender from the matrixEvent.\n     * Class construction will fail if these values cannot get obtained. */\n    private readonly matrixEventData: { eventId: string; sender: string; ts: number };\n\n    public constructor(\n        /** The required parts of the Matrix event that this membership is based on */\n        matrixEvent: Pick<MatrixEvent, \"getId\" | \"getSender\" | \"getTs\">,\n\n        /**\n         * The type checked membership data {data: (content of the matrix event), kind: (type hint)}\n         *\n         */\n        private readonly membershipData: MembershipData,\n\n        /**\n         *\n         * Anonymized identity to use with the RTC backend.\n         *\n         * The rtcBackendIdentity is a hashed version of all the identity parts:\n         * `sha256(${this.userId}|${this.deviceId}|${this.memberId})`\n         *\n         * It is used to anonymize the identity of the user in the RTC backend.\n         */\n        public readonly rtcBackendIdentity: string,\n        /**\n         * The constructor will automatically create a properly tagged child logger instance.\n         */\n        logger?: Logger,\n    ) {\n        const [eventId, sender, ts] = [matrixEvent.getId(), matrixEvent.getSender(), matrixEvent.getTs()];\n        if (eventId === undefined) throw new Error(\"parentEvent is missing eventId field\");\n        if (sender === undefined) throw new Error(\"parentEvent is missing sender field\");\n\n        this.matrixEventData = { eventId, sender, ts };\n\n        this.logger = logger?.getChild(`[CallMembership ${sender}:${this.deviceId}]`);\n    }\n\n    /**\n     * sha256(`${this.userId}|${this.deviceId}|${this.memberId}`) for sticky events (kind = rtc)\n     * `${this.userId}:${this.deviceId}` for state events (kind = session)\n     */\n    public static async computeRtcBackendIdentity(\n        matrixEvent: Pick<MatrixEvent, \"getSender\">,\n        membershipData: MembershipData,\n    ): Promise<string> {\n        const { kind, data } = membershipData;\n        switch (kind) {\n            case \"rtc\": {\n                return CallMembership.computeRtcIdentityRaw(data.member.user_id, data.member.device_id, data.member.id);\n            }\n            case \"session\":\n                return `${matrixEvent.getSender()}:${data.device_id}`;\n        }\n    }\n\n    public static async computeRtcIdentityRaw(userId: string, deviceId: string, memberId: string): Promise<string> {\n        return encodeUnpaddedBase64(await sha256(`${userId}|${deviceId}|${memberId}`));\n    }\n\n    public static membershipDataFromMatrixEvent(matrixEvent: MatrixEvent): MembershipData {\n        const [eventId, sender, content] = [matrixEvent.getId(), matrixEvent.getSender(), matrixEvent.getContent()];\n\n        if (eventId === undefined) throw new Error(\"parentEvent is missing eventId field\");\n        if (sender === undefined) throw new Error(\"parentEvent is missing sender field\");\n\n        const sessionErrors: string[] = [];\n        const rtcErrors: string[] = [];\n        if (checkSessionsMembershipData(content, sessionErrors)) {\n            return { kind: \"session\", data: content };\n        } else if (checkRtcMembershipData(content, rtcErrors, sender)) {\n            return { kind: \"rtc\", data: content };\n        } else {\n            const details =\n                sessionErrors.length < rtcErrors.length\n                    ? `Does not match MSC4143 m.call.member:\\n${sessionErrors.join(\"\\n\")}\\n\\n`\n                    : `Does not match MSC4143 m.rtc.member:\\n${rtcErrors.join(\"\\n\")}\\n\\n`;\n            const json = \"\\nevent:\\n\" + JSON.stringify(content).replaceAll('\"', \"'\");\n            throw Error(`unknown CallMembership data.\\n` + details + json);\n        }\n    }\n\n    /** @deprecated use userId instead */\n    public get sender(): string {\n        return this.userId;\n    }\n    public get userId(): string {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.member.user_id;\n            case \"session\":\n            default:\n                return this.matrixEventData.sender;\n        }\n    }\n\n    public get eventId(): string {\n        return this.matrixEventData.eventId;\n    }\n\n    /**\n     * The ID of the MatrixRTC slot that this membership belongs to (format `{application}#{id}`).\n     * This is computed in case SessionMembershipData is used.\n     */\n    public get slotId(): string {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.slot_id;\n            case \"session\":\n            default:\n                // INFO_SLOT_ID_LEGACY_CASE  (search for all occurances of this INFO to get the full picture)\n                // The spec got changed to use `\"ROOM\"` instead of `\"\"` empyt string for the implicit default call.\n                // State events still are sent with `\"\"` however. To find other events that should end up in the same call,\n                // we use the slotId.\n                // Since the CallMembership is the public representation of a rtc.member event, we just pretend it is a\n                // \"ROOM\" slotId/call_id.\n                // This makes all the remote members work with just this simple trick.\n                //\n                // We of course now need to be careful when sending legacy events (state events)\n                // They get a slotDescription containing \"ROOM\" since this is what we use starting at the time this comment\n                // is commited.\n                //\n                // See the Other INFO_SLOT_ID_LEGACY_CASE comments to see where we revert back to \"\" just before sending the event.\n                return slotDescriptionToId({\n                    application: this.application,\n                    id: data.call_id === \"\" ? \"ROOM\" : data.call_id,\n                });\n        }\n    }\n\n    public get deviceId(): string {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.member.device_id;\n            case \"session\":\n            default:\n                return data.device_id;\n        }\n    }\n\n    public get callIntent(): RTCCallIntent | undefined {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\": {\n                const intent = data.application[\"m.call.intent\"];\n                if (typeof intent === \"string\") {\n                    return intent;\n                }\n                this.logger?.warn(\"RTC membership has invalid m.call.intent\");\n                return undefined;\n            }\n            case \"session\":\n            default:\n                return data[\"m.call.intent\"];\n        }\n    }\n\n    /**\n     * Parsed `slot_id` (format `{application}#{id}`) into its components (application and id).\n     */\n    public get slotDescription(): SlotDescription {\n        return slotIdToDescription(this.slotId);\n    }\n\n    public get application(): string {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.application.type;\n            case \"session\":\n            default:\n                return data.application;\n        }\n    }\n    public get applicationData(): { type: string; [key: string]: unknown } {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.application;\n            case \"session\":\n            default:\n                return { \"type\": data.application, \"m.call.intent\": data[\"m.call.intent\"] };\n        }\n    }\n\n    /** @deprecated scope is not used and will be removed in future versions. replaced by application specific types.*/\n    public get scope(): CallScope | undefined {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return undefined;\n            case \"session\":\n            default:\n                return data.scope;\n        }\n    }\n    /**\n     * @deprecated renamed to `memberId`\n     */\n    public get membershipID(): string {\n        return this.memberId;\n    }\n\n    /**\n     * This computes the membership ID for the membership.\n     * For the sticky event based rtcSessionData this is trivial it is `member.id`.\n     * This is not supposed to be used to identity on an rtc backend. This is just a nouance for\n     * a generated (sha256) anonymised identity. Only send `rtcBackendIdentity` to any rtc backend service.\n     *\n     * For the legacy sessionMemberEvents it is a bit more complex. Here we sometimes do not have this data\n     * in the event content and we expected the SFU and the client to use `${this.matrixEventData.sender}:${data.device_id}`.\n     *\n     * So if there is no membershipID we use the hard coded jwt id default (`${this.matrixEventData.sender}:${data.device_id}`)\n     * value (used until version 0.16.0)\n     *\n     * It is also possible for a session event to set a custom membershipID. in that case this will be used.\n     */\n    public get memberId(): string {\n        // the createdTs behaves equivalent to the membershipID.\n        // we only need the field for the legacy member events where we needed to update them\n        // synapse ignores sending state events if they have the same content.\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.member.id;\n            case \"session\":\n            default:\n                return (\n                    // best case we have a client already publishing the right custom membershipId\n                    data.membershipID ??\n                    // alternativly we use the hard coded jwt id defuatl value (used until version 0.16.0)\n                    `${this.matrixEventData.sender}:${data.device_id}`\n                );\n        }\n    }\n\n    public createdTs(): number {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                // TODO we need to read the referenced (relation) event if available to get the real created_ts\n                return this.matrixEventData.ts;\n            case \"session\":\n            default:\n                return data.created_ts ?? this.matrixEventData.ts;\n        }\n    }\n\n    /**\n     * Gets the absolute expiry timestamp of the membership.\n     * @returns The absolute expiry time of the membership as a unix timestamp in milliseconds or undefined if not applicable\n     */\n    public getAbsoluteExpiry(): number | undefined {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return undefined;\n            case \"session\":\n            default:\n                // TODO: calculate this from the MatrixRTCSession join configuration directly\n                return this.createdTs() + (data.expires ?? DEFAULT_EXPIRE_DURATION);\n        }\n    }\n\n    /**\n     * @returns The number of milliseconds until the membership expires or undefined if applicable\n     */\n    public getMsUntilExpiry(): number | undefined {\n        const { kind } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return undefined;\n            case \"session\":\n            default:\n                // Assume that local clock is sufficiently in sync with other clocks in the distributed system.\n                // We used to try and adjust for the local clock being skewed, but there are cases where this is not accurate.\n                // The current implementation allows for the local clock to be -infinity to +MatrixRTCSession.MEMBERSHIP_EXPIRY_TIME/2\n                return this.getAbsoluteExpiry()! - Date.now();\n        }\n    }\n\n    /**\n     * @returns true if the membership has expired, otherwise false\n     */\n    public isExpired(): boolean {\n        const { kind } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return false;\n            case \"session\":\n            default:\n                return this.getMsUntilExpiry()! <= 0;\n        }\n    }\n\n    /**\n     * ## RTC Membership\n     * Gets the primary transport to use for this RTC membership (m.rtc.member).\n     * This will return the primary transport that is used by this call membership to publish their media.\n     * Directly relates to the `rtc_transports` field.\n     *\n     * ## Legacy session membership\n     * In case of a legacy session membership (m.call.member) this will return the selected transport where\n     * media is published. How this selection happens depends on the `focus_active` field of the session membership.\n     * If the `focus_selection` is `oldest_membership` this will return the transport of the oldest membership\n     * in the room (based on the `created_ts` field of the session membership).\n     * If the `focus_selection` is `multi_sfu` it will return the first transport of the `foci_preferred` list.\n     * (`multi_sfu` is equivalent to how `m.rtc.member` `rtc_transports` work).\n     * @param oldestMembership For backwards compatibility with session membership (legacy). Unused in case of RTC membership.\n     * Always required to make the consumer not care if it deals with RTC or session memberships.\n     * @returns The transport this membership uses to publish media or undefined if no transport is available.\n     */\n    public getTransport(oldestMembership: CallMembership): Transport | undefined {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.rtc_transports[0];\n            case \"session\":\n                switch (data.focus_active.focus_selection) {\n                    case \"multi_sfu\":\n                        return data.foci_preferred[0];\n                    case \"oldest_membership\":\n                        if (CallMembership.equal(this, oldestMembership)) return data.foci_preferred[0];\n                        if (oldestMembership !== undefined) return oldestMembership.getTransport(oldestMembership);\n                        break;\n                }\n        }\n        return undefined;\n    }\n\n    /**\n     * The focus_active filed of the session membership (m.call.member).\n     * @deprecated focus_active is not used and will be removed in future versions.\n     */\n    public getFocusActive(): LivekitFocusSelection | undefined {\n        const { kind, data } = this.membershipData;\n        if (kind === \"session\") return data.focus_active;\n        return undefined;\n    }\n    /**\n     * The value of the `rtc_transports` field for RTC memberships (m.rtc.member).\n     * Or the value of the `foci_preferred` field for legacy session memberships (m.call.member).\n     */\n    public get transports(): Transport[] {\n        const { kind, data } = this.membershipData;\n        switch (kind) {\n            case \"rtc\":\n                return data.rtc_transports;\n            case \"session\":\n            default:\n                return data.foci_preferred;\n        }\n    }\n    public get kind(): MembershipData[\"kind\"] {\n        return this.membershipData.kind;\n    }\n}\n","/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport type { CallMembership } from \"./CallMembership.ts\";\nimport type { RTCCallIntent, Status, Transport } from \"./types.ts\";\nimport { type TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\n\nexport enum MembershipManagerEvent {\n    StatusChanged = \"StatusChanged\",\n    /**\n     * Emitted when the membership manager has not heard back from the server for the duration\n     * of the delayed event and hence failed to restart the delayed event.\n     * This means that the user is probably not joined anymore and the leave event was distributed to other session members.\n     */\n    ProbablyLeft = \"ProbablyLeft\",\n    /**\n     * Once the membershipManger has aquired the a delay id (after sending the state event)\n     * It will emit and share the delay id.\n     */\n    DelayIdChanged = \"DelayIdChanged\",\n}\n\nexport type MembershipManagerEventHandlerMap = {\n    [MembershipManagerEvent.StatusChanged]: (prefStatus: Status, newStatus: Status) => void;\n    [MembershipManagerEvent.ProbablyLeft]: (probablyLeft: boolean) => void;\n    [MembershipManagerEvent.DelayIdChanged]: (delayId: string | undefined) => void;\n};\n\n/**\n * This interface defines what a MembershipManager uses and exposes.\n * This interface is what we use to write tests and allows changing the actual implementation\n * without breaking tests because of some internal method renaming.\n *\n * @internal\n */\nexport interface IMembershipManager extends TypedEventEmitter<\n    MembershipManagerEvent,\n    MembershipManagerEventHandlerMap\n> {\n    /**\n     * If we are trying to join, or have successfully joined the session.\n     * It does not reflect if the room state is already configured to represent us being joined.\n     * It only means that the Manager should be trying to connect or to disconnect running.\n     * The Manager is still running right after isJoined becomes false to send the disconnect events.\n     * @returns true if we intend to be participating in the MatrixRTC session\n     * @deprecated This name is confusing and replaced by `isActivated()`. (Returns the same as `isActivated()`)\n     */\n    isJoined(): boolean;\n    /**\n     * If the manager is activated. This means it tries to do its job to join the call, resend state events...\n     * It does not imply that the room state is already configured to represent being joined.\n     * It means that the Manager tries to connect or is connected. (\"the manager is still active\")\n     * Once `leave()` is called the manager is not activated anymore but still running until `leave()` resolves.\n     * @returns `true` if we intend to be participating in the MatrixRTC session\n     */\n    isActivated(): boolean;\n    /**\n     * Get the actual connection status of the manager.\n     */\n    get status(): Status;\n\n    /**\n     * The Current own state event if the manger is connected.\n     * `undefined` if not connected.\n     */\n    get ownMembership(): CallMembership | undefined;\n\n    /**\n     * If the membership manager has reason to believe that the hs sent a leave event\n     * and as a consequence the current user is perceived as left for other session participants.\n     */\n    get probablyLeft(): boolean;\n\n    /**\n     * If the membership manager has reason to believe that the hs sent a leave event\n     * and as a consequence the current user is perceived as left for other session participants.\n     */\n    get delayId(): string | undefined;\n\n    /**\n     * Start sending all necessary events to make this user participate in the RTC session.\n     * @param fociPreferred the list of preferred foci to use in the joined RTC membership event.\n     * If multiSfuFocus is set, this is only needed if this client wants to publish to multiple transports simultaneously.\n     * @param multiSfuFocus the active focus to use in the joined RTC membership event. Setting this implies the\n     * membership manager will operate in a multi-SFU connection mode. If `undefined`, an `oldest_membership`\n     * transport selection will be used instead.\n     * @throws can throw if it exceeds a configured maximum retry.\n     */\n    join(fociPreferred: Transport[], multiSfuFocus?: Transport, onError?: (error: unknown) => void): void;\n    /**\n     * Send all necessary events to make this user leave the RTC session.\n     * @param timeout the maximum duration in ms until the promise is forced to resolve.\n     * @returns It resolves with true in case the leave was sent successfully.\n     * It resolves with false in case we hit the timeout before sending successfully.\n     */\n    leave(timeout?: number): Promise<boolean>;\n    /**\n     * Call this if the MatrixRTC session members have changed.\n     */\n    onRTCSessionMemberUpdate(memberships: CallMembership[]): Promise<void>;\n\n    /**\n     * Update the intent of a membership on the call (e.g. user is now providing a video feed)\n     * @param callIntent The new intent to set.\n     */\n    updateCallIntent(callIntent: RTCCallIntent): Promise<void>;\n}\n","/*\nCopyright 2023 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Logger, logger as rootLogger } from \"../logger.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { EventTimeline } from \"../models/event-timeline.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { EventType, RelationType } from \"../@types/event.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\nimport { type ISendEventResponse } from \"../@types/requests.ts\";\nimport { CallMembership } from \"./CallMembership.ts\";\nimport { RoomStateEvent } from \"../models/room-state.ts\";\nimport { MembershipManager, StickyEventMembershipManager } from \"./MembershipManager.ts\";\nimport { type CallMembershipIdentityParts, EncryptionManager, type IEncryptionManager } from \"./EncryptionManager.ts\";\nimport { logDurationSync } from \"../utils.ts\";\nimport type {\n    Statistics,\n    RTCNotificationType,\n    Status,\n    IRTCNotificationContent,\n    RTCCallIntent,\n    Transport,\n} from \"./types.ts\";\nimport {\n    MembershipManagerEvent,\n    type MembershipManagerEventHandlerMap,\n    type IMembershipManager,\n} from \"./IMembershipManager.ts\";\nimport { RTCEncryptionManager } from \"./RTCEncryptionManager.ts\";\nimport { ToDeviceKeyTransport } from \"./ToDeviceKeyTransport.ts\";\nimport { TypedReEmitter } from \"../ReEmitter.ts\";\nimport { type IContent, type MatrixEvent } from \"../models/event.ts\";\nimport { RoomStickyEventsEvent, type RoomStickyEventsMap } from \"../models/room-sticky-events.ts\";\nimport { RoomKeyTransport } from \"./RoomKeyTransport.ts\";\n\n/**\n * Events emitted by MatrixRTCSession\n */\nexport enum MatrixRTCSessionEvent {\n    // A member joined, left, or updated a property of their membership.\n    MembershipsChanged = \"memberships_changed\",\n    // We joined or left the session: our own local idea of whether we are joined,\n    // separate from MembershipsChanged, ie. independent of whether our member event\n    // has successfully gone through.\n    JoinStateChanged = \"join_state_changed\",\n    // The key used to encrypt media has changed\n    EncryptionKeyChanged = \"encryption_key_changed\",\n    /** The membership manager had to shut down caused by an unrecoverable error */\n    MembershipManagerError = \"membership_manager_error\",\n    /** The RTCSession did send a call notification caused by joining the call as the first member */\n    DidSendCallNotification = \"did_send_call_notification\",\n}\n\nexport type MatrixRTCSessionEventHandlerMap = {\n    [MatrixRTCSessionEvent.MembershipsChanged]: (\n        oldMemberships: CallMembership[],\n        newMemberships: CallMembership[],\n    ) => void;\n    [MatrixRTCSessionEvent.JoinStateChanged]: (isJoined: boolean) => void;\n    [MatrixRTCSessionEvent.EncryptionKeyChanged]: (\n        key: Uint8Array<ArrayBuffer>,\n        encryptionKeyIndex: number,\n        membership: CallMembershipIdentityParts,\n        rtcBackendIdentity: string,\n    ) => void;\n    [MatrixRTCSessionEvent.MembershipManagerError]: (error: unknown) => void;\n    [MatrixRTCSessionEvent.DidSendCallNotification]: (\n        notificationContentNew: { event_id: string } & IRTCNotificationContent,\n    ) => void;\n};\n\nexport interface SessionConfig {\n    /**\n     * What kind of notification to send when starting the session.\n     * @default `undefined` (no notification)\n     */\n    notificationType?: RTCNotificationType;\n\n    /**\n     * Determines the kind of call this will be.\n     */\n    callIntent?: RTCCallIntent;\n}\n\n/**\n * The session description is used to identify a session. Used in the state event.\n */\nexport interface SlotDescription {\n    id: string;\n    application: string;\n}\nexport function slotIdToDescription(slotId: string): SlotDescription {\n    const [application, id] = slotId.split(\"#\");\n    return { application, id };\n}\nexport function slotDescriptionToId(slotDescription: SlotDescription): string {\n    return `${slotDescription.application}#${slotDescription.id}`;\n}\n\n// The names follow these principles:\n// - we use the technical term delay if the option is related to delayed events.\n// - we use delayedLeaveEvent if the option is related to the delayed leave event.\n// - we use membershipEvent if the option is related to the rtc member state event.\n// - we use the technical term expiry if the option is related to the expiry field of the membership state event.\n// - we use a `Ms` postfix if the option is a duration to avoid using words like:\n//   `time`, `duration`, `delay`, `timeout`... that might be mistaken/confused with technical terms.\nexport interface MembershipConfig {\n    /**\n     * The timeout (in milliseconds) after we joined the call, that our membership should expire\n     * unless we have explicitly updated it.\n     *\n     * This is what goes into the m.rtc.member event expiry field and is typically set to a number of hours.\n     */\n    membershipEventExpiryMs?: number;\n\n    /**\n     * The time in (in milliseconds) which the manager will prematurely send the updated state event before the membership `expires` time to make sure it\n     * sends the updated state event early enough.\n     *\n     * A headroom of 1000ms and a `membershipExpiryTimeout` of 10000ms would result in the first membership event update after 9s and\n     * a membership event that would be considered expired after 10s.\n     *\n     * This value does not have an effect on the value of `SessionMembershipData.expires`.\n     */\n    membershipEventExpiryHeadroomMs?: number;\n\n    /**\n     * The timeout (in milliseconds) with which the deleayed leave event on the server is configured.\n     * After this time the server will set the event to the disconnected stat if it has not received a keep-alive from the client.\n     */\n    delayedLeaveEventDelayMs?: number;\n\n    /**\n     * The interval (in milliseconds) in which the client will send membership keep-alives to the server.\n     */\n    delayedLeaveEventRestartMs?: number;\n\n    /**\n     * The maximum number of retries that the manager will do for delayed event sending/updating and state event sending when a server rate limit has been hit.\n     */\n    maximumRateLimitRetryCount?: number;\n\n    /**\n     * The maximum number of retries that the manager will do for delayed event sending/updating and state event sending when a network error occurs.\n     */\n    maximumNetworkErrorRetryCount?: number;\n\n    /**\n     * The time (in milliseconds) after which we will retry a http request if it\n     * failed to send due to a network error. (send membership event, send delayed event, restart delayed event...)\n     */\n    networkErrorRetryMs?: number;\n\n    /**\n     * If true, use the new to-device transport for sending encryption keys.\n     */\n    useExperimentalToDeviceTransport?: boolean;\n\n    /**\n     * The time (in milliseconds) after which a we consider a delayed event restart http request to have failed.\n     * Setting this to a lower value will result in more frequent retries but also a higher chance of failiour.\n     *\n     * In the presence of network packet loss (hurting TCP connections), the custom delayedEventRestartLocalTimeoutMs\n     * helps by keeping more delayed event reset candidates in flight,\n     * improving the chances of a successful reset. (its is equivalent to the js-sdk `localTimeout` configuration,\n     * but only applies to calls to the `_unstable_restartScheduledDelayedEvent` endpoint\n     * or the `_unstable_updateDelayedEvent` endpoint with a body of `{action:\"restart\"}`.)\n     */\n    delayedLeaveEventRestartLocalTimeoutMs?: number;\n\n    /**\n     * Send membership using sticky events rather than state events.\n     * This also make the client use the new m.rtc.member MSC4354 event format. (instead of m.call.member)\n     *\n     * **WARNING**: This is an unstable feature and not all clients will support it.\n     */\n    unstableSendStickyEvents?: boolean;\n}\n\nexport interface EncryptionConfig {\n    /**\n     *  If true, generate and share a media key for this participant,\n     *  and emit MatrixRTCSessionEvent.EncryptionKeyChanged when\n     *  media keys for other participants become available.\n     */\n    manageMediaKeys?: boolean;\n    /**\n     * The minimum time (in milliseconds) between each attempt to send encryption key(s).\n     * e.g. if this is set to 1000, then we will send at most one key event every second.\n     * @deprecated - Not used by the new encryption manager.\n     */\n    updateEncryptionKeyThrottle?: number;\n\n    /**\n     * Sometimes it is necessary to rotate the encryption key after a membership update.\n     * For performance reasons we might not want to rotate the key immediately but allow future memberships to use the same key.\n     * If 5 people join in a row in less than 5 seconds, we don't want to rotate the key for each of them.\n     * If 5 people leave in a row in less than 5 seconds, we don't want to rotate the key for each of them.\n     * So we do share the key which was already used live for <5s to new joiners.\n     * This does result in a potential leak up to the configured time of call media.\n     * This has to be considered when choosing a value for this property.\n     */\n    keyRotationGracePeriodMs?: number;\n\n    /**\n     * The delay (in milliseconds) after a member leaves before we create and publish a new key, because people\n     * tend to leave calls at the same time.\n     * @deprecated - Not used by the new encryption manager.\n     */\n    makeKeyDelay?: number;\n    /**\n     * The delay (in milliseconds) between sending a new key and starting to encrypt with it. This\n     * gives others a chance to receive the new key to minimize the chance they get media they can't decrypt.\n     *\n     * The higher this value is, the better it is for existing members as they will have a smoother experience.\n     * But it impacts new joiners: They will always have to wait `useKeyDelay` before being able to decrypt the media\n     * (as it will be encrypted with the new key after the delay only), even if the key has already arrived before the delay.\n     */\n    useKeyDelay?: number;\n}\nexport type JoinSessionConfig = SessionConfig & MembershipConfig & EncryptionConfig;\n\ninterface SessionMembershipsForSlotOpts {\n    /**\n     * Listen for incoming sticky member events. If disabled, this session will\n     * ignore any incoming sticky events.\n     */\n    listenForStickyEvents: boolean;\n    /**\n     * Listen for incoming  member state events (legacy). If disabled, this session will\n     * ignore any incoming state events.\n     */\n    listenForMemberStateEvents: boolean;\n}\n\nconst DEFAULT_SESSION_MEMBERSHIPS_FOR_SLOT_OPTS: SessionMembershipsForSlotOpts = {\n    listenForStickyEvents: true,\n    listenForMemberStateEvents: true,\n};\n\n/**\n * A MatrixRTCSession manages the membership & properties of a MatrixRTC session.\n * This class doesn't deal with media at all, just membership & properties of a session.\n */\nexport class MatrixRTCSession extends TypedEventEmitter<\n    MatrixRTCSessionEvent | MembershipManagerEvent,\n    MatrixRTCSessionEventHandlerMap & MembershipManagerEventHandlerMap\n> {\n    private membershipManager?: IMembershipManager;\n    private encryptionManager?: IEncryptionManager;\n    private joinConfig?: SessionConfig;\n    private logger: Logger;\n\n    private pendingNotificationToSend: undefined | RTCNotificationType;\n    /**\n     * This timeout is responsible to track any expiration. We need to know when we have to start\n     * to ignore other call members. There is no callback for this. This timeout will always be configured to\n     * emit when the next membership expires.\n     */\n    private expiryTimeout?: ReturnType<typeof setTimeout>;\n\n    public memberships: CallMembership[] = [];\n\n    /**\n     * The statistics for this session.\n     */\n    public statistics: Statistics = {\n        counters: {\n            roomEventEncryptionKeysSent: 0,\n            roomEventEncryptionKeysReceived: 0,\n        },\n        totals: {\n            roomEventEncryptionKeysReceivedTotalAge: 0,\n        },\n    };\n\n    public get membershipStatus(): Status | undefined {\n        return this.membershipManager?.status;\n    }\n    public get probablyLeft(): boolean | undefined {\n        return this.membershipManager?.probablyLeft;\n    }\n    public get delayId(): string | undefined {\n        return this.membershipManager?.delayId;\n    }\n\n    /**\n     * The callId (sessionId) of the call.\n     *\n     * It can be undefined since the callId is only known once the first membership joins.\n     * The callId is the property that, per definition, groups memberships into one call.\n     * @deprecated use `slotId` instead.\n     */\n    public get callId(): string | undefined {\n        return this.slotDescription?.id;\n    }\n    /**\n     * The slotId of the call.\n     * `{application}#{appSpecificId}`\n     * It can be undefined since the slotId is only known once the first membership joins.\n     * The slotId is the property that, per definition, groups memberships into one call.\n     */\n    public get slotId(): string | undefined {\n        return slotDescriptionToId(this.slotDescription);\n    }\n\n    /**\n     * Returns all the call memberships for a room that match the provided `sessionDescription`,\n     * oldest first.\n     *\n     * By default, this will return *both* sticky and member state events.\n     */\n    public static async sessionMembershipsForSlot(\n        room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"hasMembershipState\" | \"_unstable_getStickyEvents\">,\n        slotId: string,\n        // default both true this implied we combine sticky and state events for the final call state\n        // (prefer sticky events in case of a duplicate)\n        options: SessionMembershipsForSlotOpts = DEFAULT_SESSION_MEMBERSHIPS_FOR_SLOT_OPTS,\n    ): Promise<CallMembership[]> {\n        const logger = rootLogger.getChild(`[MatrixRTCSession ${room.roomId}]`);\n        const callMemberEvents = collectMembersEvents(room, options, logger);\n\n        const callMemberships = await computeBackendIdentityAndVerifyMemberEvents(\n            room,\n            callMemberEvents,\n            slotId,\n            logger,\n        );\n\n        callMemberships.sort((a, b) => a.createdTs() - b.createdTs());\n        if (callMemberships.length > 1) {\n            logger.debug(\n                `Call memberships in room ${room.roomId}, in order: `,\n                callMemberships.map((m) => [m.createdTs(), m.userId]),\n            );\n        }\n\n        return callMemberships;\n    }\n\n    /**\n     * Return the MatrixRTC session for the room.\n     * This returned session can be used to find out if there are active sessions\n     * for the requested room and `slotDescription`.\n     */\n    public static sessionForSlot(\n        client: MatrixClient,\n        room: Room,\n        slotDescription: SlotDescription,\n        opts?: SessionMembershipsForSlotOpts,\n    ): MatrixRTCSession {\n        return new MatrixRTCSession(client, room, slotDescription, opts);\n    }\n\n    /**\n     * WARN: this can in theory only be a subset of the room with the properties required by\n     * this class.\n     * Outside of tests this most likely will be a full room, however.\n     * @deprecated Relying on a full Room object being available here is an anti-pattern. You should be tracking\n     * the room object in your own code and passing it in when needed.\n     */\n    public get room(): Room {\n        return this.roomSubset as Room;\n    }\n\n    /**\n     * This constructs a room session. When using MatrixRTC inside the js-sdk this is expected\n     * to be used with the MatrixRTCSessionManager exclusively.\n     *\n     * In cases where you don't use the js-sdk but build on top of another Matrix stack this class can be used standalone\n     * to manage a joined MatrixRTC session.\n     *\n     * @param client A subset of the {@link MatrixClient} that lets the session interact with the Matrix room.\n     * @param roomSubset The room this session is attached to. A subset of a js-sdk Room that the session needs.\n     * @param slotDescription The slot description is a virtual address where participants are allowed to meet.\n     * This session will only manage memberships that match this slot description.Sessions are distinct if any of\n     * those properties are distinct: `roomSubset.roomId`, `slotDescription.application`, `slotDescription.id`.\n     */\n    public constructor(\n        private readonly client: Pick<\n            MatrixClient,\n            | \"getUserId\"\n            | \"getDeviceId\"\n            | \"sendEvent\"\n            | \"sendStateEvent\"\n            | \"_unstable_sendDelayedStateEvent\"\n            | \"_unstable_updateDelayedEvent\"\n            | \"_unstable_cancelScheduledDelayedEvent\"\n            | \"_unstable_restartScheduledDelayedEvent\"\n            | \"_unstable_sendScheduledDelayedEvent\"\n            | \"_unstable_sendStickyEvent\"\n            | \"_unstable_sendStickyDelayedEvent\"\n            | \"cancelPendingEvent\"\n            | \"encryptAndSendToDevice\"\n            | \"off\"\n            | \"on\"\n            | \"decryptEventIfNeeded\"\n        >,\n        private roomSubset: Pick<\n            Room,\n            \"getLiveTimeline\" | \"roomId\" | \"getVersion\" | \"hasMembershipState\" | \"on\" | \"off\"\n        >,\n\n        public readonly slotDescription: SlotDescription,\n        private readonly calculateMembershipsOpts?: SessionMembershipsForSlotOpts,\n    ) {\n        super();\n        this.logger = rootLogger.getChild(`[MatrixRTCSession ${roomSubset.roomId}]`);\n\n        this.roomSubset.on(RoomStateEvent.Members, this.onRoomMemberUpdate);\n        this.roomSubset.on(RoomStickyEventsEvent.Update, this.onStickyEventUpdate);\n\n        // We can ignore this promise because `recalculateSessionMembers` will emit\n        // `MatrixRTCSessionEvent.MembershipsChanged` once it has completed.\n        this.ensureRecalculateSessionMembers();\n        this.setExpiryTimer();\n    }\n    /*\n     * Returns true if we intend to be participating in the MatrixRTC session.\n     * This is determined by checking if the relativeExpiry has been set.\n     */\n    public isJoined(): boolean {\n        return this.membershipManager?.isJoined() ?? false;\n    }\n\n    /**\n     * Performs cleanup & removes timers for client shutdown\n     */\n    public async stop(): Promise<void> {\n        await this.membershipManager?.leave(1000);\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n\n        this.roomSubset.off(RoomStateEvent.Members, this.onRoomMemberUpdate);\n        this.roomSubset.off(RoomStickyEventsEvent.Update, this.onStickyEventUpdate);\n    }\n\n    private reEmitter = new TypedReEmitter<\n        MatrixRTCSessionEvent | MembershipManagerEvent,\n        MatrixRTCSessionEventHandlerMap & MembershipManagerEventHandlerMap\n    >(this);\n\n    /**\n     * Announces this user and device as joined to the MatrixRTC session,\n     * and continues to update the membership event to keep it valid until\n     * leaveRoomSession() is called\n     * This will not subscribe to updates: remember to call subscribe() separately if\n     * desired.\n     * This method will return immediately and the session will be joined in the background.\n     * @param ownMembershipIdentity the identity of the user and device joining the session.\n     * This will be put into the content.member.\n     * @param fociPreferred the list of preferred foci to use in the joined RTC membership event.\n     * If multiSfuFocus is set, this is only needed if this client wants to publish to multiple transports simultaneously.\n     * @param multiSfuFocus the active focus to use in the joined RTC membership event. Setting this implies the\n     * membership manager will operate in a multi-SFU connection mode. If `undefined`, an `oldest_membership`\n     * transport selection will be used instead.\n     * @param joinConfig - Additional configuration for the joined session.\n     */\n    public joinRTCSession(\n        ownMembershipIdentity: CallMembershipIdentityParts,\n        fociPreferred: Transport[],\n        multiSfuFocus?: Transport,\n        joinConfig?: JoinSessionConfig,\n    ): void {\n        if (this.isJoined()) {\n            this.logger.info(`Already joined to session in room ${this.roomSubset.roomId}: ignoring join call`);\n            return;\n        } else {\n            // Create MembershipManager and pass the RTCSession logger (with room id info)\n            this.membershipManager = joinConfig?.unstableSendStickyEvents\n                ? new StickyEventMembershipManager(\n                      joinConfig,\n                      this.roomSubset,\n                      this.client,\n                      this.slotDescription,\n                      ownMembershipIdentity.memberId,\n                      this.logger,\n                  )\n                : new MembershipManager(joinConfig, this.roomSubset, this.client, this.slotDescription, this.logger);\n\n            this.reEmitter.reEmit(this.membershipManager!, [\n                MembershipManagerEvent.ProbablyLeft,\n                MembershipManagerEvent.StatusChanged,\n                MembershipManagerEvent.DelayIdChanged,\n            ]);\n            // Create Encryption manager\n            let transport;\n            if (joinConfig?.useExperimentalToDeviceTransport) {\n                this.logger.info(\"Using experimental to-device transport for encryption keys\");\n                this.logger.info(\"Using to-device with room fallback transport for encryption keys\");\n                const [room, client, statistics] = [this.roomSubset, this.client, this.statistics];\n                const transport = new ToDeviceKeyTransport(ownMembershipIdentity, room.roomId, client, statistics);\n                this.encryptionManager = new RTCEncryptionManager(\n                    ownMembershipIdentity,\n                    () => this.memberships,\n                    transport,\n                    this.statistics,\n                    (\n                        keyBin: Uint8Array<ArrayBuffer>,\n                        encryptionKeyIndex: number,\n                        membership: CallMembershipIdentityParts,\n                        rtcBackendIdentity: string,\n                    ) => {\n                        this.emit(\n                            MatrixRTCSessionEvent.EncryptionKeyChanged,\n                            keyBin,\n                            encryptionKeyIndex,\n                            membership,\n                            rtcBackendIdentity,\n                        );\n                    },\n                    this.logger,\n                );\n            } else {\n                // TODO REMOVE ME!\n                transport = new RoomKeyTransport(this.roomSubset, this.client, this.statistics);\n                this.encryptionManager = new EncryptionManager(\n                    ownMembershipIdentity,\n                    () => this.memberships,\n                    transport,\n                    this.statistics,\n                    (\n                        keyBin: Uint8Array<ArrayBuffer>,\n                        encryptionKeyIndex: number,\n                        membership: CallMembershipIdentityParts,\n                        rtcBackendIdentity: string,\n                    ) => {\n                        this.emit(\n                            MatrixRTCSessionEvent.EncryptionKeyChanged,\n                            keyBin,\n                            encryptionKeyIndex,\n                            membership,\n                            rtcBackendIdentity,\n                        );\n                    },\n                );\n            }\n        }\n\n        this.joinConfig = joinConfig;\n        this.pendingNotificationToSend = this.joinConfig?.notificationType;\n\n        // Join!\n        this.membershipManager!.join(fociPreferred, multiSfuFocus, (e) => {\n            this.logger.error(\"MembershipManager encountered an unrecoverable error: \", e);\n            this.emit(MatrixRTCSessionEvent.MembershipManagerError, e);\n            this.emit(MatrixRTCSessionEvent.JoinStateChanged, this.isJoined());\n        });\n        this.encryptionManager!.join(joinConfig);\n\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, true);\n    }\n\n    /**\n     *\n     * @param fociPreferred\n     * @param multiSfuFocus\n     * @param joinConfig\n     * @deprecated use the joinRTCSession method instead\n     */\n    public joinRoomSession(\n        fociPreferred: Transport[],\n        multiSfuFocus?: Transport,\n        joinConfig?: JoinSessionConfig,\n    ): void {\n        const [userId, deviceId] = [this.client.getUserId()!, this.client.getDeviceId()!];\n        // TODO this wants to become a UUID\n        const memberId = `${userId}:${deviceId}`;\n        this.joinRTCSession({ userId, deviceId, memberId }, fociPreferred, multiSfuFocus, joinConfig);\n    }\n\n    /**\n     * Announces this user and device as having left the MatrixRTC session\n     * and stops scheduled updates.\n     * This will not unsubscribe from updates: remember to call unsubscribe() separately if\n     * desired.\n     * The membership update required to leave the session will retry if it fails.\n     * Without network connection the promise will never resolve.\n     * A timeout can be provided so that there is a guarantee for the promise to resolve.\n     * @returns Whether the membership update was attempted and did not time out.\n     */\n    public async leaveRoomSession(timeout: number | undefined = undefined): Promise<boolean> {\n        if (!this.isJoined()) {\n            this.logger.info(`Not joined to session in room ${this.roomSubset.roomId}: ignoring leave call`);\n            return false;\n        }\n\n        this.logger.info(`Leaving call session in room ${this.roomSubset.roomId}`);\n\n        this.encryptionManager!.leave();\n\n        const leavePromise = this.membershipManager!.leave(timeout);\n        this.emit(MatrixRTCSessionEvent.JoinStateChanged, false);\n\n        return await leavePromise;\n    }\n    /**\n     * This returns the focus in use by the oldest membership.\n     * Do not use since this might be just the focus for the oldest membership. others might use a different focus.\n     * @deprecated use `member.getTransport(session.getOldestMembership())` instead for the specific member you want to get the focus for.\n     */\n    public getFocusInUse(): Transport | undefined {\n        const oldestMembership = this.getOldestMembership();\n        return oldestMembership?.getTransport(oldestMembership);\n    }\n\n    /**\n     * The used focusActive of the oldest membership (to find out the selection type multi-sfu or oldest membership active focus)\n     * @deprecated does not work with m.rtc.member. Do not rely on it.\n     */\n    public getActiveFocus(): Transport | undefined {\n        return this.getOldestMembership()?.getFocusActive();\n    }\n    public getOldestMembership(): CallMembership | undefined {\n        return this.memberships[0];\n    }\n\n    /**\n     * Get the call intent for the current call, based on what members are advertising. If one or more\n     * members disagree on the current call intent, or nobody specifies one then `undefined` is returned.\n     *\n     * If all members that specify a call intent agree, that value is returned.\n     * @returns A call intent, or `undefined` if no consensus or not given.\n     */\n    public getConsensusCallIntent(): RTCCallIntent | undefined {\n        const getFirstCallIntent = this.memberships.find((m) => !!m.callIntent)?.callIntent;\n        if (!getFirstCallIntent) {\n            return undefined;\n        }\n        if (this.memberships.every((m) => !m.callIntent || m.callIntent === getFirstCallIntent)) {\n            return getFirstCallIntent;\n        }\n        return undefined;\n    }\n\n    public async updateCallIntent(callIntent: RTCCallIntent): Promise<void> {\n        const myMembership = this.membershipManager?.ownMembership;\n        if (!myMembership) {\n            throw Error(\"Not connected yet\");\n        }\n        await this.membershipManager?.updateCallIntent(callIntent);\n    }\n\n    /**\n     * Re-emit an EncryptionKeyChanged event for each tracked encryption key. This can be used to export\n     * the keys.\n     */\n    public reemitEncryptionKeys(): void {\n        this.encryptionManager?.getEncryptionKeys().forEach((keyRing, key) => {\n            keyRing.forEach((keyInfo) => {\n                this.emit(\n                    MatrixRTCSessionEvent.EncryptionKeyChanged,\n                    keyInfo.key,\n                    keyInfo.keyIndex,\n                    keyInfo.membership,\n                    keyInfo.rtcBackendIdentity,\n                );\n            });\n        });\n    }\n\n    /**\n     * Sets a timer for the soonest membership expiry\n     */\n    private setExpiryTimer(): void {\n        if (this.expiryTimeout) {\n            clearTimeout(this.expiryTimeout);\n            this.expiryTimeout = undefined;\n        }\n\n        let soonestExpiry;\n        for (const membership of this.memberships) {\n            const thisExpiry = membership.getMsUntilExpiry();\n            // If getMsUntilExpiry is undefined we have a MSC4143 (MatrixRTC) compliant event - it never expires\n            // but will be reliably resent on disconnect.\n            if (thisExpiry !== undefined && (soonestExpiry === undefined || thisExpiry < soonestExpiry)) {\n                soonestExpiry = thisExpiry;\n            }\n        }\n\n        if (soonestExpiry != undefined) {\n            this.expiryTimeout = setTimeout(this.ensureRecalculateSessionMembers.bind(this), soonestExpiry);\n        }\n    }\n\n    /**\n     * Sends notification events to indiciate the call has started.\n     * Note: This does not return a promise, instead scheduling the notification events to be sent.\n     * @param parentEventId Event id linking to your RTC call membership event.\n     * @param notificationType The type of notification to send\n     * @param callIntent The type of call this is (e.g. \"audio\").\n     */\n    private sendCallNotify(\n        parentEventId: string,\n        notificationType: RTCNotificationType,\n        callIntent?: RTCCallIntent,\n    ): void {\n        const sendNotificationEvent = async (): Promise<{\n            response: ISendEventResponse;\n            content: IRTCNotificationContent;\n        }> => {\n            const content: IRTCNotificationContent = {\n                \"m.mentions\": { user_ids: [], room: true },\n                \"notification_type\": notificationType,\n                \"m.relates_to\": {\n                    event_id: parentEventId,\n                    rel_type: RelationType.Reference,\n                },\n                \"sender_ts\": Date.now(),\n                \"lifetime\": 30_000, // 30 seconds\n            };\n            if (callIntent) {\n                content[\"m.call.intent\"] = callIntent;\n            }\n            const response = await this.client.sendEvent(this.roomSubset.roomId, EventType.RTCNotification, content);\n            return { response, content };\n        };\n\n        void sendNotificationEvent()\n            .then((notification) => {\n                // Join event_id and origin event content\n                const newResult = { ...notification.response, ...notification.content };\n                this.emit(MatrixRTCSessionEvent.DidSendCallNotification, newResult);\n            })\n            .catch(([errorLegacy, errorNew]) =>\n                this.logger.error(\"Failed to send call notification\", errorLegacy, errorNew),\n            );\n    }\n\n    /**\n     * Call this when the Matrix room members have changed.\n     */\n    private readonly onRoomMemberUpdate = (): void => {\n        this.ensureRecalculateSessionMembers();\n    };\n\n    /**\n     * Call this when a sticky event update has occured.\n     */\n    private readonly onStickyEventUpdate: RoomStickyEventsMap[RoomStickyEventsEvent.Update] = (\n        added,\n        updated,\n        removed,\n    ): void => {\n        if (\n            [...added, ...removed, ...updated.flatMap((v) => [v.current, v.previous])].some(\n                (e) => e.getType() === EventType.RTCMembership,\n            )\n        ) {\n            this.ensureRecalculateSessionMembers();\n        }\n    };\n\n    /**\n     * Call this when something changed that may impacts the current MatrixRTC members in this session.\n     */\n    // We allow this name schema since this function should only be used for testing purposes.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public _onRTCSessionMemberUpdate = async (): Promise<void> => {\n        await this.recalculateSessionMembers();\n    };\n\n    // helper variables to make sure we do not have parallel running recalculations.\n\n    private recalculateSessionMembersDirty = false;\n    private recalculateSessionMembersPromise: Promise<void> | undefined = undefined;\n\n    private ensureRecalculateSessionMembers(): void {\n        if (this.recalculateSessionMembersPromise === undefined) {\n            this.recalculateSessionMembersPromise = this.recalculateSessionMembers().then(() => {\n                this.recalculateSessionMembersPromise = undefined;\n                if (this.recalculateSessionMembersDirty) {\n                    this.ensureRecalculateSessionMembers();\n                    this.recalculateSessionMembersDirty = false;\n                }\n            });\n        } else {\n            this.recalculateSessionMembersDirty = true;\n        }\n    }\n\n    /**\n     * Call this when anything that could impact rtc memberships has changed: Room Members or RTC members.\n     *\n     * Examines the latest call memberships and handles any encryption key sending or rotation that is needed.\n     *\n     * This function should be called when the room members or call memberships might have changed.\n     */\n    private readonly recalculateSessionMembers = async (): Promise<void> => {\n        const oldMemberships = this.memberships;\n\n        this.memberships = await MatrixRTCSession.sessionMembershipsForSlot(\n            this.room,\n            slotDescriptionToId(this.slotDescription),\n            this.calculateMembershipsOpts,\n        );\n\n        const changed =\n            oldMemberships.length != this.memberships.length ||\n            oldMemberships.some((m, i) => !CallMembership.equal(m, this.memberships[i]));\n\n        if (changed) {\n            this.logger.info(\n                `Memberships for call in room ${this.roomSubset.roomId} have changed: emitting (${this.memberships.length} members)`,\n            );\n            logDurationSync(this.logger, \"emit MatrixRTCSessionEvent.MembershipsChanged\", () => {\n                this.emit(MatrixRTCSessionEvent.MembershipsChanged, oldMemberships, this.memberships);\n            });\n\n            void this.membershipManager?.onRTCSessionMemberUpdate(this.memberships);\n            // The `ownMembership` will be set when calling `onRTCSessionMemberUpdate`.\n            const ownMembership = this.membershipManager?.ownMembership;\n            if (this.pendingNotificationToSend && ownMembership && oldMemberships.length === 0) {\n                // If we're the first member in the call, we're responsible for\n                // sending the notification event\n                if (ownMembership.eventId && this.joinConfig?.notificationType) {\n                    this.sendCallNotify(\n                        ownMembership.eventId,\n                        this.joinConfig.notificationType,\n                        ownMembership.callIntent,\n                    );\n                } else {\n                    this.logger.warn(\"Own membership eventId is undefined, cannot send call notification\");\n                }\n            }\n            // If anyone else joins the session it is no longer our responsibility to send the notification.\n            // (If we were the joiner we already did sent the notification in the block above.)\n            if (this.memberships.length > 0) this.pendingNotificationToSend = undefined;\n        } else {\n            this.logger.debug(`No membership changes detected for room ${this.roomSubset.roomId}`);\n        }\n        // This also needs to be done if `changed` = false\n        // A member might have updated their fingerprint (created_ts)\n        void this.encryptionManager?.onMembershipsUpdate(oldMemberships);\n\n        this.setExpiryTimer();\n    };\n}\n\n/// Private helpers\nasync function computeBackendIdentityAndVerifyMemberEvents(\n    room: Pick<Room, \"hasMembershipState\">,\n    callMemberEvents: MatrixEvent[],\n    slotId: string,\n    logger: Logger,\n): Promise<CallMembership[]> {\n    const callMemberships: CallMembership[] = [];\n\n    for (const memberEvent of callMemberEvents) {\n        const content = memberEvent.getContent();\n\n        // Quick filter to avoid unneeded processing of invalid events or left events.\n        // A more thorough validation will be done later with CallMembership.membershipDataFromMatrixEvent.\n        if (!quickFilterNonRelevantContents(content, logger)) {\n            continue;\n        }\n\n        try {\n            const membershipData = CallMembership.membershipDataFromMatrixEvent(memberEvent);\n\n            const membership = new CallMembership(\n                memberEvent,\n                membershipData,\n                await CallMembership.computeRtcBackendIdentity(memberEvent, membershipData),\n                logger,\n            );\n\n            if (isValidMembership(membership, room, slotId, logger)) {\n                callMemberships.push(membership);\n            }\n        } catch (e) {\n            logger.warn(\"Couldn't construct call membership: \", e);\n        }\n    }\n\n    return callMemberships;\n}\n\nfunction quickFilterNonRelevantContents(content: IContent, logger: Logger): boolean {\n    // Ignore sticky keys for the count\n    const eventKeysCount = Object.keys(content).filter((k) => k !== \"msc4354_sticky_key\").length;\n    // Don't even bother about empty events (saves us from costly type/\"key in\" checks in bigger rooms)\n    if (eventKeysCount === 0) return false;\n\n    // We first decide if it's a MSC4143 event (per device state key)\n    if (eventKeysCount > 1 && \"application\" in content) {\n        // We have a MSC4143 event membership event with a proper joined content\n        return true;\n    } else if (eventKeysCount === 1 && \"memberships\" in content) {\n        logger.warn(`Legacy event found. Those are ignored, they do not contribute to the MatrixRTC session`);\n        return false;\n    } else {\n        // Invalid or left content\n        return false;\n    }\n}\n\nfunction isValidMembership(\n    membership: CallMembership,\n    room: Pick<Room, \"hasMembershipState\">,\n    slotId: string,\n    logger: Logger,\n): boolean {\n    if (membership.slotId !== slotId) {\n        logger.info(\n            `Ignoring membership of user ${membership.userId} for a different slot:  user: ${JSON.stringify(membership.slotDescription)}, slotId: ${slotId})`,\n        );\n        return false;\n    }\n\n    if (membership.isExpired()) {\n        logger.info(`Ignoring expired device membership ${membership.userId}/${membership.deviceId}`);\n        return false;\n    }\n\n    if (!room.hasMembershipState(membership.userId ?? \"\", KnownMembership.Join)) {\n        logger.info(`Ignoring membership of user ${membership.userId} who is not in the room.`);\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Collects the raw member events from room state and sticky store.\n */\nfunction collectMembersEvents(\n    room: Pick<Room, \"getLiveTimeline\" | \"roomId\" | \"_unstable_getStickyEvents\">,\n    options: SessionMembershipsForSlotOpts,\n    logger: Logger,\n): MatrixEvent[] {\n    const { listenForStickyEvents, listenForMemberStateEvents } = options;\n    let callMemberEvents: MatrixEvent[] = [];\n    if (listenForStickyEvents) {\n        // prefill with sticky events\n        callMemberEvents = [...room._unstable_getStickyEvents()].filter((e) => e.getType() === EventType.RTCMembership);\n    }\n    if (listenForMemberStateEvents) {\n        const roomState = room.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!roomState) {\n            logger.warn(\"Couldn't get state for room \" + room.roomId + \"using empty membership array\");\n            return [];\n        }\n        const callMemberStateEvents = roomState.getStateEvents(EventType.GroupCallMemberPrefix);\n        callMemberEvents = callMemberEvents.concat(\n            callMemberStateEvents.filter(\n                (callMemberStateEvent) =>\n                    !callMemberEvents.some(\n                        // only care about state events which have keys which we have not yet seen in the sticky events.\n                        // TODO: I believe this can discard a joined state event if there is a matching left sticky event.\n                        (stickyEvent) =>\n                            stickyEvent.getContent().msc4354_sticky_key === callMemberStateEvent.getStateKey(),\n                    ),\n            ),\n        );\n    }\n    return callMemberEvents;\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type Logger } from \"../logger.ts\";\nimport { type MatrixClient, ClientEvent } from \"../client.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { RoomStateEvent } from \"../models/room-state.ts\";\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { MatrixRTCSession, type SlotDescription } from \"./MatrixRTCSession.ts\";\nimport { EventType } from \"../@types/event.ts\";\n\nexport enum MatrixRTCSessionManagerEvents {\n    // A member has joined the MatrixRTC session, creating an active session in a room where there wasn't previously\n    SessionStarted = \"session_started\",\n    // All participants have left a given MatrixRTC session.\n    SessionEnded = \"session_ended\",\n}\n\ntype EventHandlerMap = {\n    [MatrixRTCSessionManagerEvents.SessionStarted]: (roomId: string, session: MatrixRTCSession) => void;\n    [MatrixRTCSessionManagerEvents.SessionEnded]: (roomId: string, session: MatrixRTCSession) => void;\n};\n\n/**\n * Holds all active MatrixRTC session objects and creates new ones as events arrive.\n * One `MatrixRTCSessionManager` is required for each MatrixRTC sessionDescription (application, session id) that the client wants to support.\n * If no application type is specified in the constructor, the default is \"m.call\".\n *\n * This interface is UNSTABLE and may change without warning.\n */\nexport class MatrixRTCSessionManager extends TypedEventEmitter<MatrixRTCSessionManagerEvents, EventHandlerMap> {\n    // All the room-scoped sessions we know about. This will include any where the app\n    // has queried for the MatrixRTC sessions in a room, whether it's ever had any members\n    // or not). We keep a (lazily created) session object for every room to ensure that there\n    // is only ever one single room session object for any given room for the lifetime of the\n    // client: that way there can never be any code holding onto a stale object that is no\n    // longer the correct session object for the room.\n    private roomSessions = new Map<string, MatrixRTCSession>();\n\n    private readonly logger: Logger;\n\n    public constructor(\n        rootLogger: Logger,\n        private client: MatrixClient,\n        private readonly slotDescription: SlotDescription = { application: \"m.call\", id: \"ROOM\" }, // Default to the Matrix Call application\n    ) {\n        super();\n        this.logger = rootLogger.getChild(\"[MatrixRTCSessionManager]\");\n    }\n\n    public start(): void {\n        // We shouldn't need to null-check here, but matrix-client.spec.ts mocks getRooms\n        // returning nothing, and breaks tests if you change it to return an empty array :'(\n        for (const room of this.client.getRooms() ?? []) {\n            const session = MatrixRTCSession.sessionForSlot(this.client, room, this.slotDescription);\n            if (session.memberships.length > 0) {\n                this.roomSessions.set(room.roomId, session);\n            }\n        }\n\n        this.client.on(ClientEvent.Room, this.onRoom);\n        this.client.on(ClientEvent.Event, this.onEvent);\n        this.client.on(RoomStateEvent.Events, this.onRoomState);\n    }\n\n    public stop(): void {\n        for (const sess of this.roomSessions.values()) {\n            void sess.stop();\n        }\n        this.roomSessions.clear();\n\n        this.client.off(ClientEvent.Room, this.onRoom);\n        this.client.off(ClientEvent.Event, this.onEvent);\n        this.client.off(RoomStateEvent.Events, this.onRoomState);\n    }\n\n    /**\n     * Gets the main MatrixRTC session for a room, or undefined if there is\n     * no current session\n     */\n    public getActiveRoomSession(room: Room): MatrixRTCSession | undefined {\n        return this.roomSessions.get(room.roomId)!;\n    }\n\n    /**\n     * Gets the main MatrixRTC session for a room, returning an empty session\n     * if no members are currently participating\n     */\n    public getRoomSession(room: Room): MatrixRTCSession {\n        if (!this.roomSessions.has(room.roomId)) {\n            this.roomSessions.set(\n                room.roomId,\n                MatrixRTCSession.sessionForSlot(this.client, room, this.slotDescription),\n            );\n        }\n\n        return this.roomSessions.get(room.roomId)!;\n    }\n\n    private onRoom = (room: Room): void => {\n        void this.refreshRoom(room);\n    };\n\n    private readonly onEvent = (event: MatrixEvent): void => {\n        if (!event.unstableStickyExpiresAt) return; // Not sticky, not interested.\n\n        if (event.getType() !== EventType.RTCMembership) return;\n\n        const room = this.client.getRoom(event.getRoomId());\n        if (!room) return;\n\n        void this.refreshRoom(room);\n    };\n\n    private readonly onRoomState = (event: MatrixEvent): void => {\n        if (event.getType() !== EventType.GroupCallMemberPrefix) {\n            return;\n        }\n        const room = this.client.getRoom(event.getRoomId());\n        if (!room) {\n            this.logger.error(`Got room state event for unknown room ${event.getRoomId()}!`);\n            return;\n        }\n\n        void this.refreshRoom(room);\n    };\n\n    private async refreshRoom(room: Room): Promise<void> {\n        const isNewSession = !this.roomSessions.has(room.roomId);\n        const session = this.getRoomSession(room);\n\n        const wasActiveAndKnown = session.memberships.length > 0 && !isNewSession;\n        // This needs to be here and the event listener cannot be setup in the MatrixRTCSession,\n        // because we need the update to happen between:\n        // wasActiveAndKnown = session.memberships.length > 0 and\n        // nowActive = session.memberships.length\n        // Alternatively we would need to setup some event emission when the RTC session ended.\n        // TODO we want to add the emission en session end. This makes the responsibility of the session manager more clear.\n\n        await session._onRTCSessionMemberUpdate().catch((error) => {\n            this.logger.error(`Error updating RTC session members for ${room.roomId}: ${error}`);\n        });\n\n        const nowActive = session.memberships.length > 0;\n\n        if (wasActiveAndKnown && !nowActive) {\n            this.logger.trace(`Session ended for ${room.roomId} (${session.memberships.length} members)`);\n            this.emit(MatrixRTCSessionManagerEvents.SessionEnded, room.roomId, this.roomSessions.get(room.roomId)!);\n        } else if (!wasActiveAndKnown && nowActive) {\n            this.logger.trace(`Session started for ${room.roomId} (${session.memberships.length} members)`);\n            this.emit(MatrixRTCSessionManagerEvents.SessionStarted, room.roomId, this.roomSessions.get(room.roomId)!);\n        }\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport type { IContent, IMentions } from \"../matrix.ts\";\nimport type { RelationEvent } from \"../types.ts\";\nimport type { CallMembership } from \"./CallMembership.ts\";\nimport { type CallMembershipIdentityParts } from \"./EncryptionManager.ts\";\n\nexport type EncryptionKeyMapKey = string;\n\nexport interface EncryptionKeyEntry {\n    index: number;\n    key: string;\n}\n\n/**\n * The mxID, deviceId and membership timestamp of a RTC session participant.\n */\nexport type ParticipantDeviceInfo = {\n    userId: string;\n    deviceId: string;\n    membershipTs: number;\n};\n\n/**\n * A type representing the information needed to decrypt video streams.\n */\nexport type InboundEncryptionSession = {\n    key: Uint8Array<ArrayBuffer>;\n    membership: CallMembershipIdentityParts;\n    keyIndex: number;\n    creationTS: number;\n};\n\n/**\n * The information about the key used to encrypt video streams.\n */\nexport type OutboundEncryptionSession = {\n    key: Uint8Array<ArrayBuffer>;\n    creationTS: number;\n    // The devices that this key is shared with.\n    sharedWith: Array<ParticipantDeviceInfo>;\n    // This is an index acting as the id of the key\n    keyId: number;\n};\n\nexport interface EncryptionKeysEventContent {\n    keys: EncryptionKeyEntry[];\n    device_id: string;\n    call_id: string;\n    sent_ts?: number;\n}\n\n/**\n * THe content of a to-device event that contains encryption keys.\n */\nexport interface EncryptionKeysToDeviceEventContent {\n    keys: { index: number; key: string };\n    member: {\n        id: string;\n        // TODO Remove that it is claimed, need to get the sealed sender from decryption info\n        // Or add some validation on it based on the encryption info\n        claimed_device_id: string;\n    };\n    room_id: string;\n    session: {\n        application: string;\n        call_id: string;\n        scope: string;\n    };\n    // Why is this needed?\n    sent_ts?: number;\n}\n/**\n * @deprecated Use `RTCNotificationType` instead.\n */\nexport type CallNotifyType = \"ring\" | \"notify\";\n/**\n * @deprecated Use `IRTCNotificationContent` instead.\n */\nexport interface ICallNotifyContent {\n    \"application\": string;\n    \"m.mentions\": IMentions;\n    \"notify_type\": CallNotifyType;\n    \"call_id\": string;\n}\n\nexport type RTCNotificationType = \"ring\" | \"notification\";\n\n/**\n * Represents the intention of the call from the perspective of the sending user.\n * May be any string, although `\"audio\"` and `\"video\"` are commonly accepted values.\n */\nexport type RTCCallIntent = \"audio\" | \"video\" | string;\n\n/**\n * This will check if the content has all the expected fields to be a valid IRTCNotificationContent.\n * It will also cap the lifetime to 90000ms (1.5 min) if a higher value is provided.\n * @param content\n * @throws if the content is invalid\n * @returns a parsed IRTCNotificationContent\n */\nexport function parseCallNotificationContent(content: IContent): IRTCNotificationContent {\n    if (content[\"m.mentions\"] && typeof content[\"m.mentions\"] !== \"object\") {\n        throw new Error(\"malformed m.mentions\");\n    }\n    if (typeof content[\"notification_type\"] !== \"string\") {\n        throw new Error(\"Missing or invalid notification_type\");\n    }\n    if (typeof content[\"sender_ts\"] !== \"number\") {\n        throw new Error(\"Missing or invalid sender_ts\");\n    }\n    if (typeof content[\"lifetime\"] !== \"number\") {\n        throw new Error(\"Missing or invalid lifetime\");\n    }\n\n    if (content[\"relation\"] && content[\"relation\"][\"rel_type\"] !== \"m.reference\") {\n        throw new Error(\"Invalid relation\");\n    }\n    if (content[\"m.call.intent\"] && typeof content[\"m.call.intent\"] !== \"string\") {\n        throw new Error(\"Invalid m.call.intent\");\n    }\n\n    const cappedLifetime = content[\"lifetime\"] >= 90000 ? 90000 : content[\"lifetime\"];\n    return { ...content, lifetime: cappedLifetime } as IRTCNotificationContent;\n}\n\n/**\n * Interface for `org.matrix.msc4075.rtc.notification` events.\n * Don't cast event content to this directly. Use `parseCallNotificationContent` instead to validate the content first.\n */\nexport interface IRTCNotificationContent extends RelationEvent {\n    \"m.mentions\"?: IMentions;\n    \"notification_type\": RTCNotificationType;\n    /**\n     * The initial intent of the calling user.\n     */\n    \"m.call.intent\"?: RTCCallIntent;\n    \"sender_ts\": number;\n    \"lifetime\": number;\n}\n\n/**\n * MSC4310 decline event content for `org.matrix.msc4310.rtc.decline`.\n * Sent as a standard m.reference relation to an `org.matrix.msc4075.rtc.notification` event.\n */\nexport interface IRTCDeclineContent extends RelationEvent {}\n\nexport enum Status {\n    Disconnected = \"Disconnected\",\n    Connecting = \"Connecting\",\n    Connected = \"Connected\",\n    Disconnecting = \"Disconnecting\",\n    Unknown = \"Unknown\",\n}\n\n/**\n * A type collecting call encryption statistics for a session.\n */\nexport type Statistics = {\n    counters: {\n        /**\n         * The number of times we have sent a room event containing encryption keys.\n         */\n        roomEventEncryptionKeysSent: number;\n        /**\n         * The number of times we have received a room event containing encryption keys.\n         */\n        roomEventEncryptionKeysReceived: number;\n    };\n    totals: {\n        /**\n         * The total age (in milliseconds) of all room events containing encryption keys that we have received.\n         * We track the total age so that we can later calculate the average age of all keys received.\n         */\n        roomEventEncryptionKeysReceivedTotalAge: number;\n    };\n};\n\nexport const isMyMembership = (m: CallMembership, userId: string, deviceId: string): boolean =>\n    m.sender === userId && m.deviceId === deviceId;\n\n/**\n *  A RTC transport is a JSON object that describes how to connect to a RTC member.\n */\nexport interface Transport {\n    type: string;\n    [key: string]: unknown;\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MBeaconEventContent } from \"../@types/beacon.ts\";\nimport {\n    type BeaconInfoState,\n    type BeaconLocationState,\n    parseBeaconContent,\n    parseBeaconInfoContent,\n} from \"../content-helpers.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { sortEventsByLatestContentTimestamp } from \"../utils.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\n\nexport enum BeaconEvent {\n    New = \"Beacon.new\",\n    Update = \"Beacon.update\",\n    LivenessChange = \"Beacon.LivenessChange\",\n    Destroy = \"Beacon.Destroy\",\n    LocationUpdate = \"Beacon.LocationUpdate\",\n}\n\nexport type BeaconEventHandlerMap = {\n    [BeaconEvent.Update]: (event: MatrixEvent, beacon: Beacon) => void;\n    [BeaconEvent.LivenessChange]: (isLive: boolean, beacon: Beacon) => void;\n    [BeaconEvent.Destroy]: (beaconIdentifier: string) => void;\n    [BeaconEvent.LocationUpdate]: (locationState: BeaconLocationState) => void;\n};\n\nexport const isTimestampInDuration = (startTimestamp: number, durationMs: number, timestamp: number): boolean =>\n    timestamp >= startTimestamp && startTimestamp + durationMs >= timestamp;\n\n// beacon info events are uniquely identified by\n// `<roomId>_<state_key>`\nexport type BeaconIdentifier = string;\nexport const getBeaconInfoIdentifier = (event: MatrixEvent): BeaconIdentifier =>\n    `${event.getRoomId()}_${event.getStateKey()}`;\n\n// https://github.com/matrix-org/matrix-spec-proposals/pull/3672\nexport class Beacon extends TypedEventEmitter<Exclude<BeaconEvent, BeaconEvent.New>, BeaconEventHandlerMap> {\n    public readonly roomId: string;\n    // beaconInfo is assigned by setBeaconInfo in the constructor\n    // ! to make tsc believe it is definitely assigned\n    private _beaconInfo!: BeaconInfoState;\n    private _isLive?: boolean;\n    private livenessWatchTimeout?: ReturnType<typeof setTimeout>;\n    private _latestLocationEvent?: MatrixEvent;\n\n    public constructor(private rootEvent: MatrixEvent) {\n        super();\n        this.roomId = this.rootEvent.getRoomId()!;\n        this.setBeaconInfo(this.rootEvent);\n    }\n\n    public get isLive(): boolean {\n        return !!this._isLive;\n    }\n\n    public get identifier(): BeaconIdentifier {\n        return getBeaconInfoIdentifier(this.rootEvent);\n    }\n\n    public get beaconInfoId(): string {\n        return this.rootEvent.getId()!;\n    }\n\n    public get beaconInfoOwner(): string {\n        return this.rootEvent.getStateKey()!;\n    }\n\n    public get beaconInfoEventType(): string {\n        return this.rootEvent.getType();\n    }\n\n    public get beaconInfo(): BeaconInfoState {\n        return this._beaconInfo;\n    }\n\n    public get latestLocationState(): BeaconLocationState | undefined {\n        return this._latestLocationEvent && parseBeaconContent(this._latestLocationEvent.getContent());\n    }\n\n    public get latestLocationEvent(): MatrixEvent | undefined {\n        return this._latestLocationEvent;\n    }\n\n    public update(beaconInfoEvent: MatrixEvent): void {\n        if (getBeaconInfoIdentifier(beaconInfoEvent) !== this.identifier) {\n            throw new Error(\"Invalid updating event\");\n        }\n        // don't update beacon with an older event\n        if (beaconInfoEvent.getTs() < this.rootEvent.getTs()) {\n            return;\n        }\n        this.rootEvent = beaconInfoEvent;\n        this.setBeaconInfo(this.rootEvent);\n\n        this.emit(BeaconEvent.Update, beaconInfoEvent, this);\n        this.clearLatestLocation();\n    }\n\n    public destroy(): void {\n        if (this.livenessWatchTimeout) {\n            clearTimeout(this.livenessWatchTimeout);\n        }\n\n        this._isLive = false;\n        this.emit(BeaconEvent.Destroy, this.identifier);\n    }\n\n    /**\n     * Monitor liveness of a beacon\n     * Emits BeaconEvent.LivenessChange when beacon expires\n     */\n    public monitorLiveness(): void {\n        if (this.livenessWatchTimeout) {\n            clearTimeout(this.livenessWatchTimeout);\n        }\n\n        this.checkLiveness();\n        if (!this.beaconInfo) return;\n        if (this.isLive) {\n            const expiryInMs = this.beaconInfo.timestamp! + this.beaconInfo.timeout - Date.now();\n            if (expiryInMs > 1) {\n                this.livenessWatchTimeout = setTimeout(() => {\n                    this.monitorLiveness();\n                }, expiryInMs);\n            }\n        } else if (this.beaconInfo.timestamp! > Date.now()) {\n            // beacon start timestamp is in the future\n            // check liveness again then\n            this.livenessWatchTimeout = setTimeout(() => {\n                this.monitorLiveness();\n            }, this.beaconInfo.timestamp! - Date.now());\n        }\n    }\n\n    /**\n     * Process Beacon locations\n     * Emits BeaconEvent.LocationUpdate\n     */\n    public addLocations(beaconLocationEvents: MatrixEvent[]): void {\n        // discard locations for beacons that are not live\n        if (!this.isLive) {\n            return;\n        }\n\n        const validLocationEvents = beaconLocationEvents.filter((event) => {\n            const content = event.getContent<MBeaconEventContent>();\n            const parsed = parseBeaconContent(content);\n            if (!parsed.uri || !parsed.timestamp) return false; // we won't be able to process these\n            const { timestamp } = parsed;\n            return (\n                this._beaconInfo.timestamp &&\n                // only include positions that were taken inside the beacon's live period\n                isTimestampInDuration(this._beaconInfo.timestamp, this._beaconInfo.timeout, timestamp) &&\n                // ignore positions older than our current latest location\n                (!this.latestLocationState || timestamp > this.latestLocationState.timestamp!)\n            );\n        });\n        const latestLocationEvent = validLocationEvents.sort(sortEventsByLatestContentTimestamp)?.[0];\n\n        if (latestLocationEvent) {\n            this._latestLocationEvent = latestLocationEvent;\n            this.emit(BeaconEvent.LocationUpdate, this.latestLocationState!);\n        }\n    }\n\n    private clearLatestLocation = (): void => {\n        this._latestLocationEvent = undefined;\n        this.emit(BeaconEvent.LocationUpdate, this.latestLocationState!);\n    };\n\n    private setBeaconInfo(event: MatrixEvent): void {\n        this._beaconInfo = parseBeaconInfoContent(event.getContent());\n        this.checkLiveness();\n    }\n\n    private checkLiveness(): void {\n        const prevLiveness = this.isLive;\n\n        // element web sets a beacon's start timestamp to the senders local current time\n        // when Alice's system clock deviates slightly from Bob's a beacon Alice intended to be live\n        // may have a start timestamp in the future from Bob's POV\n        // handle this by adding 6min of leniency to the start timestamp when it is in the future\n        if (!this.beaconInfo) return;\n        const startTimestamp =\n            this.beaconInfo.timestamp! > Date.now()\n                ? this.beaconInfo.timestamp! - 360000 /* 6min */\n                : this.beaconInfo.timestamp;\n        this._isLive =\n            !!this._beaconInfo.live &&\n            !!startTimestamp &&\n            isTimestampInDuration(startTimestamp, this._beaconInfo.timeout, Date.now());\n\n        if (prevLiveness !== this.isLive) {\n            this.emit(BeaconEvent.LivenessChange, this.isLive, this);\n        }\n    }\n}\n","/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EventTimeline, type IAddEventOptions } from \"./event-timeline.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { logger } from \"../logger.ts\";\nimport { type Room, RoomEvent } from \"./room.ts\";\nimport { type Filter } from \"../filter.ts\";\nimport { type RoomState } from \"./room-state.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\nimport { RelationsContainer } from \"./relations-container.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { type Thread, type ThreadFilterType } from \"./thread.ts\";\n\nconst DEBUG = true;\n\n/* istanbul ignore next */\nlet debuglog: (...args: any[]) => void;\nif (DEBUG) {\n    // using bind means that we get to keep useful line numbers in the console\n    debuglog = logger.log.bind(logger);\n} else {\n    /* istanbul ignore next */\n    debuglog = function (): void {};\n}\n\ninterface IOpts {\n    // Set to true to enable improved timeline support.\n    timelineSupport?: boolean;\n    // The filter object, if any, for this timelineSet.\n    filter?: Filter;\n    pendingEvents?: boolean;\n}\n\nexport enum DuplicateStrategy {\n    Ignore = \"ignore\",\n    Replace = \"replace\",\n}\n\nexport interface IRoomTimelineData {\n    // the timeline the event was added to/removed from\n    timeline: EventTimeline;\n    // true if the event was a real-time event added to the end of the live timeline\n    liveEvent?: boolean;\n}\n\nexport interface IAddEventToTimelineOptions extends Pick<\n    IAddEventOptions,\n    \"toStartOfTimeline\" | \"roomState\" | \"timelineWasEmpty\" | \"addToState\"\n> {\n    /** Whether the sync response came from cache */\n    fromCache?: boolean;\n}\n\nexport interface IAddLiveEventOptions extends Pick<\n    IAddEventToTimelineOptions,\n    \"fromCache\" | \"roomState\" | \"timelineWasEmpty\" | \"addToState\"\n> {\n    /** Applies to events in the timeline only. If this is 'replace' then if a\n     * duplicate is encountered, the event passed to this function will replace\n     * the existing event in the timeline. If this is not specified, or is\n     * 'ignore', then the event passed to this function will be ignored\n     * entirely, preserving the existing event in the timeline. Events are\n     * identical based on their event ID <b>only</b>. */\n    duplicateStrategy?: DuplicateStrategy;\n}\n\ntype EmittedEvents = RoomEvent.Timeline | RoomEvent.TimelineReset;\n\nexport type EventTimelineSetHandlerMap = {\n    /**\n     * Fires whenever the timeline in a room is updated.\n     * @param event - The matrix event which caused this event to fire.\n     * @param room - The room, if any, whose timeline was updated.\n     * @param toStartOfTimeline - True if this event was added to the start\n     * @param removed - True if this event has just been removed from the timeline\n     * (beginning; oldest) of the timeline e.g. due to pagination.\n     *\n     * @param data - more data about the event\n     *\n     * @example\n     * ```\n     * matrixClient.on(\"Room.timeline\",\n     *                 function(event, room, toStartOfTimeline, removed, data) {\n     *   if (!toStartOfTimeline && data.liveEvent) {\n     *     var messageToAppend = room.timeline.[room.timeline.length - 1];\n     *   }\n     * });\n     * ```\n     */\n    [RoomEvent.Timeline]: (\n        event: MatrixEvent,\n        room: Room | undefined,\n        toStartOfTimeline: boolean | undefined,\n        removed: boolean,\n        data: IRoomTimelineData,\n    ) => void;\n    /**\n     * Fires whenever the live timeline in a room is reset.\n     *\n     * When we get a 'limited' sync (for example, after a network outage), we reset\n     * the live timeline to be empty before adding the recent events to the new\n     * timeline. This event is fired after the timeline is reset, and before the\n     * new events are added.\n     *\n     * @param room - The room whose live timeline was reset, if any\n     * @param timelineSet - timelineSet room whose live timeline was reset\n     * @param resetAllTimelines - True if all timelines were reset.\n     */\n    [RoomEvent.TimelineReset]: (\n        room: Room | undefined,\n        timelineSet: EventTimelineSet,\n        resetAllTimelines: boolean,\n    ) => void;\n};\n\nexport class EventTimelineSet extends TypedEventEmitter<EmittedEvents, EventTimelineSetHandlerMap> {\n    public readonly relations: RelationsContainer;\n    private readonly timelineSupport: boolean;\n    private readonly displayPendingEvents: boolean;\n    private liveTimeline: EventTimeline;\n    private timelines: EventTimeline[];\n    private _eventIdToTimeline = new Map<string, EventTimeline>();\n    private filter?: Filter;\n\n    /**\n     * Construct a set of EventTimeline objects, typically on behalf of a given\n     * room.  A room may have multiple EventTimelineSets for different levels\n     * of filtering.  The global notification list is also an EventTimelineSet, but\n     * lacks a room.\n     *\n     * <p>This is an ordered sequence of timelines, which may or may not\n     * be continuous. Each timeline lists a series of events, as well as tracking\n     * the room state at the start and the end of the timeline (if appropriate).\n     * It also tracks forward and backward pagination tokens, as well as containing\n     * links to the next timeline in the sequence.\n     *\n     * <p>There is one special timeline - the 'live' timeline, which represents the\n     * timeline to which events are being added in real-time as they are received\n     * from the /sync API. Note that you should not retain references to this\n     * timeline - even if it is the current timeline right now, it may not remain\n     * so if the server gives us a timeline gap in /sync.\n     *\n     * <p>In order that we can find events from their ids later, we also maintain a\n     * map from event_id to timeline and index.\n     *\n     * @param room - Room for this timelineSet. May be null for non-room cases, such as the\n     * notification timeline.\n     * @param opts - Options inherited from Room.\n     * @param client - the Matrix client which owns this EventTimelineSet,\n     * can be omitted if room is specified.\n     * @param thread - the thread to which this timeline set relates.\n     * @param threadListType - the type of thread list represented, if any\n     * (e.g., All threads or My threads)\n     */\n    public constructor(\n        public readonly room: Room | undefined,\n        opts: IOpts = {},\n        client?: MatrixClient,\n        public readonly thread?: Thread,\n        public readonly threadListType: ThreadFilterType | null = null,\n    ) {\n        super();\n\n        this.timelineSupport = Boolean(opts.timelineSupport);\n        this.liveTimeline = new EventTimeline(this);\n        this.displayPendingEvents = opts.pendingEvents !== false;\n\n        // just a list - *not* ordered.\n        this.timelines = [this.liveTimeline];\n        this._eventIdToTimeline = new Map<string, EventTimeline>();\n\n        this.filter = opts.filter;\n\n        this.relations = this.room?.relations ?? new RelationsContainer(room?.client ?? client!);\n    }\n\n    /**\n     * Get all the timelines in this set\n     * @returns the timelines in this set\n     */\n    public getTimelines(): EventTimeline[] {\n        return this.timelines;\n    }\n\n    /**\n     * Get the filter object this timeline set is filtered on, if any\n     * @returns the optional filter for this timelineSet\n     */\n    public getFilter(): Filter | undefined {\n        return this.filter;\n    }\n\n    /**\n     * Set the filter object this timeline set is filtered on\n     * (passed to the server when paginating via /messages).\n     * @param filter - the filter for this timelineSet\n     */\n    public setFilter(filter?: Filter): void {\n        this.filter = filter;\n    }\n\n    /**\n     * Get the list of pending sent events for this timelineSet's room, filtered\n     * by the timelineSet's filter if appropriate.\n     *\n     * @returns A list of the sent events\n     * waiting for remote echo.\n     *\n     * @throws If `opts.pendingEventOrdering` was not 'detached'\n     */\n    public getPendingEvents(): MatrixEvent[] {\n        if (!this.room || !this.displayPendingEvents) {\n            return [];\n        }\n\n        return this.room.getPendingEvents();\n    }\n    /**\n     * Get the live timeline for this room.\n     *\n     * @returns live timeline\n     */\n    public getLiveTimeline(): EventTimeline {\n        return this.liveTimeline;\n    }\n\n    /**\n     * Set the live timeline for this room.\n     *\n     * @returns live timeline\n     */\n    public setLiveTimeline(timeline: EventTimeline): void {\n        this.liveTimeline = timeline;\n    }\n\n    /**\n     * Return the timeline (if any) this event is in.\n     * @param eventId - the eventId being sought\n     * @returns timeline\n     */\n    public eventIdToTimeline(eventId: string): EventTimeline | undefined {\n        return this._eventIdToTimeline.get(eventId);\n    }\n\n    /**\n     * Track a new event as if it were in the same timeline as an old event,\n     * replacing it.\n     * @param oldEventId -  event ID of the original event\n     * @param newEventId -  event ID of the replacement event\n     */\n    public replaceEventId(oldEventId: string, newEventId: string): void {\n        const existingTimeline = this._eventIdToTimeline.get(oldEventId);\n        if (existingTimeline) {\n            this._eventIdToTimeline.delete(oldEventId);\n            this._eventIdToTimeline.set(newEventId, existingTimeline);\n        }\n    }\n\n    /**\n     * Reset the live timeline, and start a new one.\n     *\n     * <p>This is used when /sync returns a 'limited' timeline.\n     *\n     * @param backPaginationToken -   token for back-paginating the new timeline\n     * @param forwardPaginationToken - token for forward-paginating the old live timeline,\n     * if absent or null, all timelines are reset.\n     *\n     * @remarks\n     * Fires {@link RoomEvent.TimelineReset}\n     */\n    public resetLiveTimeline(backPaginationToken?: string, forwardPaginationToken?: string): void {\n        // Each EventTimeline has RoomState objects tracking the state at the start\n        // and end of that timeline. The copies at the end of the live timeline are\n        // special because they will have listeners attached to monitor changes to\n        // the current room state, so we move this RoomState from the end of the\n        // current live timeline to the end of the new one and, if necessary,\n        // replace it with a newly created one. We also make a copy for the start\n        // of the new timeline.\n\n        // if timeline support is disabled, forget about the old timelines\n        const resetAllTimelines = !this.timelineSupport || !forwardPaginationToken;\n\n        const oldTimeline = this.liveTimeline;\n        const newTimeline = resetAllTimelines\n            ? oldTimeline.forkLive(EventTimeline.FORWARDS)\n            : oldTimeline.fork(EventTimeline.FORWARDS);\n\n        if (resetAllTimelines) {\n            this.timelines = [newTimeline];\n            this._eventIdToTimeline = new Map<string, EventTimeline>();\n        } else {\n            this.timelines.push(newTimeline);\n        }\n\n        if (forwardPaginationToken) {\n            // Now set the forward pagination token on the old live timeline\n            // so it can be forward-paginated.\n            oldTimeline.setPaginationToken(forwardPaginationToken, EventTimeline.FORWARDS);\n        }\n\n        // make sure we set the pagination token before firing timelineReset,\n        // otherwise clients which start back-paginating will fail, and then get\n        // stuck without realising that they *can* back-paginate.\n        newTimeline.setPaginationToken(backPaginationToken ?? null, EventTimeline.BACKWARDS);\n\n        // Now we can swap the live timeline to the new one.\n        this.liveTimeline = newTimeline;\n        this.emit(RoomEvent.TimelineReset, this.room, this, resetAllTimelines);\n    }\n\n    /**\n     * Get the timeline which contains the given event, if any\n     *\n     * @param eventId -  event ID to look for\n     * @returns timeline containing\n     * the given event, or null if unknown\n     */\n    public getTimelineForEvent(eventId?: string): EventTimeline | null {\n        if (eventId === null || eventId === undefined) {\n            return null;\n        }\n        const res = this._eventIdToTimeline.get(eventId);\n        return res === undefined ? null : res;\n    }\n\n    /**\n     * Get an event which is stored in our timelines\n     *\n     * @param eventId -  event ID to look for\n     * @returns the given event, or undefined if unknown\n     */\n    public findEventById(eventId: string): MatrixEvent | undefined {\n        const tl = this.getTimelineForEvent(eventId);\n        if (!tl) {\n            return undefined;\n        }\n        return tl.getEvents().find(function (ev) {\n            return ev.getId() == eventId;\n        });\n    }\n\n    /**\n     * Add a new timeline to this timeline list\n     *\n     * @returns newly-created timeline\n     */\n    public addTimeline(): EventTimeline {\n        if (!this.timelineSupport) {\n            throw new Error(\n                \"timeline support is disabled. Set the 'timelineSupport'\" +\n                    \" parameter to true when creating MatrixClient to enable\" +\n                    \" it.\",\n            );\n        }\n\n        const timeline = new EventTimeline(this);\n        this.timelines.push(timeline);\n        return timeline;\n    }\n\n    /**\n     * Add events to a timeline\n     *\n     * <p>Will fire \"Room.timeline\" for each event added.\n     *\n     * @param events - A list of events to add.\n     *\n     * @param toStartOfTimeline -   True to add these events to the start\n     * (oldest) instead of the end (newest) of the timeline. If true, the oldest\n     * event will be the <b>last</b> element of 'events'.\n     *\n     * @param timeline -   timeline to\n     *    add events to.\n     *\n     * @param paginationToken -   token for the next batch of events\n     *\n     * @remarks\n     * Fires {@link RoomEvent.Timeline}\n     *\n     */\n    public addEventsToTimeline(\n        events: MatrixEvent[],\n        toStartOfTimeline: boolean,\n        addToState: boolean,\n        timeline: EventTimeline,\n        paginationToken?: string | null,\n    ): void {\n        if (!timeline) {\n            throw new Error(\"'timeline' not specified for EventTimelineSet.addEventsToTimeline\");\n        }\n\n        if (!toStartOfTimeline && timeline == this.liveTimeline) {\n            throw new Error(\n                \"EventTimelineSet.addEventsToTimeline cannot be used for adding events to \" +\n                    \"the live timeline - use Room.addLiveEvents instead\",\n            );\n        }\n\n        if (this.filter) {\n            events = this.filter.filterRoomTimeline(events);\n            if (!events.length) {\n                return;\n            }\n        }\n\n        const direction = toStartOfTimeline ? EventTimeline.BACKWARDS : EventTimeline.FORWARDS;\n        const inverseDirection = toStartOfTimeline ? EventTimeline.FORWARDS : EventTimeline.BACKWARDS;\n\n        // Adding events to timelines can be quite complicated. The following\n        // illustrates some of the corner-cases.\n        //\n        // Let's say we start by knowing about four timelines. timeline3 and\n        // timeline4 are neighbours:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M]          [P]          [S] <------> [T]\n        //\n        // Now we paginate timeline1, and get the following events from the server:\n        // [M, N, P, R, S, T, U].\n        //\n        // 1. First, we ignore event M, since we already know about it.\n        //\n        // 2. Next, we append N to timeline 1.\n        //\n        // 3. Next, we don't add event P, since we already know about it,\n        //    but we do link together the timelines. We now have:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P]          [S] <------> [T]\n        //\n        // 4. Now we add event R to timeline2:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P, R]       [S] <------> [T]\n        //\n        //    Note that we have switched the timeline we are working on from\n        //    timeline1 to timeline2.\n        //\n        // 5. We ignore event S, but again join the timelines:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P, R] <---> [S] <------> [T]\n        //\n        // 6. We ignore event T, and the timelines are already joined, so there\n        //    is nothing to do.\n        //\n        // 7. Finally, we add event U to timeline4:\n        //\n        //    timeline1    timeline2    timeline3    timeline4\n        //      [M, N] <---> [P, R] <---> [S] <------> [T, U]\n        //\n        // The important thing to note in the above is what happened when we\n        // already knew about a given event:\n        //\n        //   - if it was appropriate, we joined up the timelines (steps 3, 5).\n        //   - in any case, we started adding further events to the timeline which\n        //       contained the event we knew about (steps 3, 5, 6).\n        //\n        //\n        // So much for adding events to the timeline. But what do we want to do\n        // with the pagination token?\n        //\n        // In the case above, we will be given a pagination token which tells us how to\n        // get events beyond 'U' - in this case, it makes sense to store this\n        // against timeline4. But what if timeline4 already had 'U' and beyond? in\n        // that case, our best bet is to throw away the pagination token we were\n        // given and stick with whatever token timeline4 had previously. In short,\n        // we want to only store the pagination token if the last event we receive\n        // is one we didn't previously know about.\n        //\n        // We make an exception for this if it turns out that we already knew about\n        // *all* of the events, and we weren't able to join up any timelines. When\n        // that happens, it means our existing pagination token is faulty, since it\n        // is only telling us what we already know. Rather than repeatedly\n        // paginating with the same token, we might as well use the new pagination\n        // token in the hope that we eventually work our way out of the mess.\n\n        let didUpdate = false;\n        let lastEventWasNew = false;\n        for (const event of events) {\n            const eventId = event.getId()!;\n\n            const existingTimeline = this._eventIdToTimeline.get(eventId);\n\n            if (!existingTimeline) {\n                // we don't know about this event yet. Just add it to the timeline.\n                this.addEventToTimeline(event, timeline, {\n                    toStartOfTimeline,\n                    addToState,\n                });\n                lastEventWasNew = true;\n                didUpdate = true;\n                continue;\n            }\n\n            lastEventWasNew = false;\n\n            if (existingTimeline == timeline) {\n                debuglog(\"Event \" + eventId + \" already in timeline \" + timeline);\n                continue;\n            }\n\n            const neighbour = timeline.getNeighbouringTimeline(direction);\n            if (neighbour) {\n                // this timeline already has a neighbour in the relevant direction;\n                // let's assume the timelines are already correctly linked up, and\n                // skip over to it.\n                //\n                // there's probably some edge-case here where we end up with an\n                // event which is in a timeline a way down the chain, and there is\n                // a break in the chain somewhere. But I can't really imagine how\n                // that would happen, so I'm going to ignore it for now.\n                //\n                if (existingTimeline == neighbour) {\n                    debuglog(\"Event \" + eventId + \" in neighbouring timeline - \" + \"switching to \" + existingTimeline);\n                } else {\n                    debuglog(\"Event \" + eventId + \" already in a different \" + \"timeline \" + existingTimeline);\n                }\n                timeline = existingTimeline;\n                continue;\n            }\n\n            // time to join the timelines.\n            logger.info(\n                \"Already have timeline for \" + eventId + \" - joining timeline \" + timeline + \" to \" + existingTimeline,\n            );\n\n            // Variables to keep the line length limited below.\n            const existingIsLive = existingTimeline === this.liveTimeline;\n            const timelineIsLive = timeline === this.liveTimeline;\n\n            const backwardsIsLive = direction === EventTimeline.BACKWARDS && existingIsLive;\n            const forwardsIsLive = direction === EventTimeline.FORWARDS && timelineIsLive;\n\n            if (backwardsIsLive || forwardsIsLive) {\n                // The live timeline should never be spliced into a non-live position.\n                // We use independent logging to better discover the problem at a glance.\n                if (backwardsIsLive) {\n                    logger.warn(\n                        \"Refusing to set a preceding existingTimeLine on our \" +\n                            \"timeline as the existingTimeLine is live (\" +\n                            existingTimeline +\n                            \")\",\n                    );\n                }\n                if (forwardsIsLive) {\n                    logger.warn(\n                        \"Refusing to set our preceding timeline on a existingTimeLine \" +\n                            \"as our timeline is live (\" +\n                            timeline +\n                            \")\",\n                    );\n                }\n                continue; // abort splicing - try next event\n            }\n\n            timeline.setNeighbouringTimeline(existingTimeline, direction);\n            existingTimeline.setNeighbouringTimeline(timeline, inverseDirection);\n\n            timeline = existingTimeline;\n            didUpdate = true;\n        }\n\n        // see above - if the last event was new to us, or if we didn't find any\n        // new information, we update the pagination token for whatever\n        // timeline we ended up on.\n        if (lastEventWasNew || !didUpdate) {\n            if (direction === EventTimeline.FORWARDS && timeline === this.liveTimeline) {\n                logger.warn({ lastEventWasNew, didUpdate }); // for debugging\n                logger.warn(\n                    `Refusing to set forwards pagination token of live timeline ` + `${timeline} to ${paginationToken}`,\n                );\n                return;\n            }\n            timeline.setPaginationToken(paginationToken ?? null, direction);\n        }\n    }\n\n    /**\n     * Add an event to the end of this live timeline.\n     *\n     * @param event - Event to be added\n     * @param options - addLiveEvent options\n     */\n    public addLiveEvent(\n        event: MatrixEvent,\n        { duplicateStrategy, fromCache, roomState, timelineWasEmpty, addToState }: IAddLiveEventOptions,\n    ): void {\n        if (this.filter) {\n            const events = this.filter.filterRoomTimeline([event]);\n            if (!events.length) {\n                return;\n            }\n        }\n\n        const timeline = this._eventIdToTimeline.get(event.getId()!);\n        if (timeline) {\n            if (duplicateStrategy === DuplicateStrategy.Replace) {\n                debuglog(\"EventTimelineSet.addLiveEvent: replacing duplicate event \" + event.getId());\n                const tlEvents = timeline.getEvents();\n                for (let j = 0; j < tlEvents.length; j++) {\n                    if (tlEvents[j].getId() === event.getId()) {\n                        // still need to set the right metadata on this event\n                        if (!roomState) {\n                            roomState = timeline.getState(EventTimeline.FORWARDS);\n                        }\n                        EventTimeline.setEventMetadata(event, roomState!, false);\n                        tlEvents[j] = event;\n\n                        // XXX: we need to fire an event when this happens.\n                        break;\n                    }\n                }\n            } else {\n                debuglog(\"EventTimelineSet.addLiveEvent: ignoring duplicate event \" + event.getId());\n            }\n            return;\n        }\n\n        this.addEventToTimeline(event, this.liveTimeline, {\n            toStartOfTimeline: false,\n            fromCache,\n            roomState,\n            timelineWasEmpty,\n            addToState,\n        });\n    }\n\n    /**\n     * Add event to the given timeline, and emit Room.timeline. Assumes\n     * we have already checked we don't know about this event.\n     *\n     * Will fire \"Room.timeline\" for each event added.\n     *\n     * @param event - the event to add\n     * @param timeline - the timeline onto which to add it\n     * @param options - addEventToTimeline options\n     *\n     * @remarks\n     * Fires {@link RoomEvent.Timeline}\n     */\n    public addEventToTimeline(\n        event: MatrixEvent,\n        timeline: EventTimeline,\n        { toStartOfTimeline, fromCache = false, roomState, timelineWasEmpty, addToState }: IAddEventToTimelineOptions,\n    ): void {\n        if (timeline.getTimelineSet() !== this) {\n            throw new Error(`EventTimelineSet.addEventToTimeline: Timeline=${timeline.toString()} does not belong \" +\n                \"in timelineSet(threadId=${this.thread?.id})`);\n        }\n\n        const eventId = event.getId()!;\n        this.relations.aggregateParentEvent(event);\n        this.relations.aggregateChildEvent(event, this);\n\n        // Make sure events don't get mixed in timelines they shouldn't be in (e.g. a\n        // threaded message should not be in the main timeline).\n        //\n        // We can only run this check for timelines with a `room` because `canContain`\n        // requires it\n        if (this.room && !this.canContain(event)) {\n            let eventDebugString = `event=${eventId}`;\n            if (event.threadRootId) {\n                eventDebugString += `(belongs to thread=${event.threadRootId})`;\n            }\n            logger.warn(\n                `EventTimelineSet.addEventToTimeline: Ignoring ${eventDebugString} that does not belong ` +\n                    `in timeline=${timeline.toString()} timelineSet(threadId=${this.thread?.id})`,\n            );\n            return;\n        }\n\n        timeline.addEvent(event, {\n            toStartOfTimeline,\n            roomState,\n            timelineWasEmpty,\n            addToState,\n        });\n        this._eventIdToTimeline.set(eventId, timeline);\n\n        const data: IRoomTimelineData = {\n            timeline: timeline,\n            liveEvent: !toStartOfTimeline && timeline == this.liveTimeline && !fromCache,\n        };\n        this.emit(RoomEvent.Timeline, event, this.room, Boolean(toStartOfTimeline), false, data);\n    }\n\n    /**\n     * Insert event to the given timeline, and emit Room.timeline. Assumes\n     * we have already checked we don't know about this event.\n     *\n     * TEMPORARY: until we have recursive relations, we need this function\n     * to exist to allow us to insert events in timeline order, which is our\n     * best guess for Sync Order.\n     * This is a copy of addEventToTimeline above, modified to insert the event\n     * after the event it relates to, and before any event with a later\n     * timestamp. This is our best guess at Sync Order.\n     *\n     * Will fire \"Room.timeline\" for each event added.\n     *\n     * @internal\n     *\n     * @remarks\n     * Fires {@link RoomEvent.Timeline}\n     */\n    public insertEventIntoTimeline(\n        event: MatrixEvent,\n        timeline: EventTimeline,\n        roomState: RoomState,\n        addToState: boolean,\n    ): void {\n        if (timeline.getTimelineSet() !== this) {\n            throw new Error(`EventTimelineSet.insertEventIntoTimeline: Timeline=${timeline.toString()} does not belong \" +\n                \"in timelineSet(threadId=${this.thread?.id})`);\n        }\n\n        const eventId = event.getId()!;\n        this.relations.aggregateParentEvent(event);\n        this.relations.aggregateChildEvent(event, this);\n\n        // Make sure events don't get mixed in timelines they shouldn't be in (e.g. a\n        // threaded message should not be in the main timeline).\n        //\n        // We can only run this check for timelines with a `room` because `canContain`\n        // requires it\n        if (this.room && !this.canContain(event)) {\n            let eventDebugString = `event=${eventId}`;\n            if (event.threadRootId) {\n                eventDebugString += `(belongs to thread=${event.threadRootId})`;\n            }\n            logger.warn(\n                `EventTimelineSet.insertEventIntoTimeline: Ignoring ${eventDebugString} that does not belong ` +\n                    `in timeline=${timeline.toString()} timelineSet(threadId=${this.thread?.id})`,\n            );\n            return;\n        }\n\n        // Find the event that this event is related to - the \"parent\"\n        const parentEventId = event.relationEventId;\n        if (!parentEventId) {\n            // Not related to anything - we just append\n            this.addEventToTimeline(event, timeline, {\n                toStartOfTimeline: false,\n                fromCache: false,\n                timelineWasEmpty: false,\n                roomState,\n                addToState,\n            });\n            return;\n        }\n\n        const parentEvent = this.findEventById(parentEventId);\n\n        const timelineEvents = timeline.getEvents();\n\n        // Start searching from the parent event, or if it's not loaded, start\n        // at the beginning and insert purely using timestamp order.\n        const parentIndex = parentEvent !== undefined ? timelineEvents.indexOf(parentEvent) : 0;\n        let insertIndex = parentIndex;\n        for (; insertIndex < timelineEvents.length; insertIndex++) {\n            const nextEvent = timelineEvents[insertIndex];\n            if (nextEvent.getTs() > event.getTs()) {\n                // We found an event later than ours, so insert before that.\n                break;\n            }\n        }\n        // If we got to the end of the loop, insertIndex points at the end of\n        // the list.\n\n        timeline.insertEvent(event, insertIndex, roomState, addToState);\n        this._eventIdToTimeline.set(eventId, timeline);\n\n        const data: IRoomTimelineData = {\n            timeline: timeline,\n            // The purpose of this method is inserting events in the middle of the\n            // timeline, so the events are, by definition, not live (whether or not\n            // we're adding them to the live timeline).\n            liveEvent: false,\n        };\n        this.emit(RoomEvent.Timeline, event, this.room, false, false, data);\n    }\n\n    /**\n     * Replaces event with ID oldEventId with one with newEventId, if oldEventId is\n     * recognised.  Otherwise, add to the live timeline.  Used to handle remote echos.\n     *\n     * @param localEvent -     the new event to be added to the timeline\n     * @param oldEventId -          the ID of the original event\n     * @param newEventId -         the ID of the replacement event\n     *\n     * @remarks\n     * Fires {@link RoomEvent.Timeline}\n     */\n    public handleRemoteEcho(localEvent: MatrixEvent, oldEventId: string, newEventId: string): void {\n        // XXX: why don't we infer newEventId from localEvent?\n        const existingTimeline = this._eventIdToTimeline.get(oldEventId);\n        if (existingTimeline) {\n            this._eventIdToTimeline.delete(oldEventId);\n            this._eventIdToTimeline.set(newEventId, existingTimeline);\n        } else if (!this.filter || this.filter.filterRoomTimeline([localEvent]).length) {\n            this.addEventToTimeline(localEvent, this.liveTimeline, {\n                toStartOfTimeline: false,\n                addToState: false,\n            });\n        }\n    }\n\n    /**\n     * Removes a single event from this room.\n     *\n     * @param eventId -  The id of the event to remove\n     *\n     * @returns the removed event, or null if the event was not found\n     * in this room.\n     */\n    public removeEvent(eventId: string): MatrixEvent | null {\n        const timeline = this._eventIdToTimeline.get(eventId);\n        if (!timeline) {\n            return null;\n        }\n\n        const removed = timeline.removeEvent(eventId);\n        if (removed) {\n            this._eventIdToTimeline.delete(eventId);\n            const data = {\n                timeline: timeline,\n            };\n            this.emit(RoomEvent.Timeline, removed, this.room, undefined, true, data);\n        }\n        return removed;\n    }\n\n    /**\n     * Determine where two events appear in the timeline relative to one another\n     *\n     * @param eventId1 -   The id of the first event\n     * @param eventId2 -   The id of the second event\n\n     * @returns -1 if eventId1 precedes eventId2, and +1 eventId1 succeeds\n     * eventId2. 0 if they are the same event; null if we can't tell (either\n     * because we don't know about one of the events, or because they are in\n     * separate timelines which don't join up).\n     */\n    public compareEventOrdering(eventId1: string, eventId2: string): number | null {\n        if (eventId1 == eventId2) {\n            // optimise this case\n            return 0;\n        }\n\n        const timeline1 = this._eventIdToTimeline.get(eventId1);\n        const timeline2 = this._eventIdToTimeline.get(eventId2);\n\n        if (timeline1 === undefined) {\n            return null;\n        }\n        if (timeline2 === undefined) {\n            return null;\n        }\n\n        if (timeline1 === timeline2) {\n            // both events are in the same timeline - figure out their relative indices\n            let idx1: number | undefined = undefined;\n            let idx2: number | undefined = undefined;\n            const events = timeline1.getEvents();\n            for (let idx = 0; idx < events.length && (idx1 === undefined || idx2 === undefined); idx++) {\n                const evId = events[idx].getId();\n                if (evId == eventId1) {\n                    idx1 = idx;\n                }\n                if (evId == eventId2) {\n                    idx2 = idx;\n                }\n            }\n            const difference = idx1! - idx2!;\n\n            // Return the sign of difference.\n            if (difference < 0) {\n                return -1;\n            } else if (difference > 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n\n        // the events are in different timelines. Iterate through the\n        // linkedlist to see which comes first.\n\n        // first work forwards from timeline1\n        let tl: EventTimeline | null = timeline1;\n        while (tl) {\n            if (tl === timeline2) {\n                // timeline1 is before timeline2\n                return -1;\n            }\n            tl = tl.getNeighbouringTimeline(EventTimeline.FORWARDS);\n        }\n\n        // now try backwards from timeline1\n        tl = timeline1;\n        while (tl) {\n            if (tl === timeline2) {\n                // timeline2 is before timeline1\n                return 1;\n            }\n            tl = tl.getNeighbouringTimeline(EventTimeline.BACKWARDS);\n        }\n\n        // the timelines are not contiguous.\n        return null;\n    }\n\n    /**\n     * Determine whether a given event can sanely be added to this event timeline set,\n     * for timeline sets relating to a thread, only return true for events in the same\n     * thread timeline, for timeline sets not relating to a thread only return true\n     * for events which should be shown in the main room timeline.\n     * Requires the `room` property to have been set at EventTimelineSet construction time.\n     *\n     * @param event - the event to check whether it belongs to this timeline set.\n     * @throws Error if `room` was not set when constructing this timeline set.\n     * @returns whether the event belongs to this timeline set.\n     */\n    public canContain(event: MatrixEvent): boolean {\n        if (!this.room) {\n            throw new Error(\n                \"Cannot call `EventTimelineSet::canContain without a `room` set. \" +\n                    \"Set the room when creating the EventTimelineSet to call this method.\",\n            );\n        }\n\n        const { threadId, shouldLiveInRoom, shouldLiveInThread } = this.room.eventShouldLiveIn(event);\n\n        if (this.thread) {\n            return this.thread.id === threadId;\n        }\n\n        if (!shouldLiveInRoom && !shouldLiveInThread) {\n            logger.warn(\n                `EventTimelineSet:canContain event encountered which cannot be added to any timeline roomId=${\n                    this.room?.roomId\n                } eventId=${event.getId()} threadId=${event.threadRootId}`,\n            );\n        }\n\n        return shouldLiveInRoom;\n    }\n}\n","/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IMarkerFoundOptions, RoomState } from \"./room-state.ts\";\nimport { type EventTimelineSet } from \"./event-timeline-set.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { type Filter } from \"../filter.ts\";\nimport { EventType } from \"../@types/event.ts\";\n\nexport interface IInitialiseStateOptions extends Pick<IMarkerFoundOptions, \"timelineWasEmpty\"> {\n    // This is a separate interface without any extra stuff currently added on\n    // top of `IMarkerFoundOptions` just because it feels like they have\n    // different concerns. One shouldn't necessarily look to add to\n    // `IMarkerFoundOptions` just because they want to add an extra option to\n    // `initialiseState`.\n}\n\nexport interface IAddEventOptions extends Pick<IMarkerFoundOptions, \"timelineWasEmpty\"> {\n    /** Whether to insert the new event at the start of the timeline where the\n     * oldest events are (timeline is in chronological order, oldest to most\n     * recent) */\n    toStartOfTimeline: boolean;\n    /** The state events to reconcile metadata from */\n    roomState?: RoomState;\n    /** Whether to add timeline events to the state as was done in legacy sync v2.\n     * If true then timeline events will be added to the state.\n     * In sync v2 with org.matrix.msc4222.use_state_after and simplified sliding sync,\n     * all state arrives explicitly and timeline events should not be added. */\n    addToState: boolean;\n}\n\nexport enum Direction {\n    Backward = \"b\",\n    Forward = \"f\",\n}\n\nexport class EventTimeline {\n    /**\n     * Symbolic constant for methods which take a 'direction' argument:\n     * refers to the start of the timeline, or backwards in time.\n     */\n    public static readonly BACKWARDS = Direction.Backward;\n\n    /**\n     * Symbolic constant for methods which take a 'direction' argument:\n     * refers to the end of the timeline, or forwards in time.\n     */\n    public static readonly FORWARDS = Direction.Forward;\n\n    /**\n     * Static helper method to set sender and target properties\n     *\n     * @param event -   the event whose metadata is to be set\n     * @param stateContext -  the room state to be queried\n     * @param toStartOfTimeline -  if true the event's forwardLooking flag is set false\n     */\n    public static setEventMetadata(event: MatrixEvent, stateContext: RoomState, toStartOfTimeline: boolean): void {\n        event.setMetadata(stateContext, toStartOfTimeline);\n    }\n\n    private readonly roomId: string | null;\n    private readonly name: string;\n    private events: MatrixEvent[] = [];\n    private baseIndex = 0;\n\n    private startState?: RoomState;\n    private endState?: RoomState;\n    // If we have a roomId then we delegate pagination token storage to the room state objects `startState` and\n    // `endState`, but for things like the notification timeline which mix multiple rooms we store the tokens ourselves.\n    private startToken: string | null = null;\n    private endToken: string | null = null;\n\n    private prevTimeline: EventTimeline | null = null;\n    private nextTimeline: EventTimeline | null = null;\n    public paginationRequests: Record<Direction, Promise<boolean> | null> = {\n        [Direction.Backward]: null,\n        [Direction.Forward]: null,\n    };\n\n    /**\n     * Construct a new EventTimeline\n     *\n     * <p>An EventTimeline represents a contiguous sequence of events in a room.\n     *\n     * <p>As well as keeping track of the events themselves, it stores the state of\n     * the room at the beginning and end of the timeline, and pagination tokens for\n     * going backwards and forwards in the timeline.\n     *\n     * <p>In order that clients can meaningfully maintain an index into a timeline,\n     * the EventTimeline object tracks a 'baseIndex'. This starts at zero, but is\n     * incremented when events are prepended to the timeline. The index of an event\n     * relative to baseIndex therefore remains constant.\n     *\n     * <p>Once a timeline joins up with its neighbour, they are linked together into a\n     * doubly-linked list.\n     *\n     * @param eventTimelineSet - the set of timelines this is part of\n     */\n    public constructor(private readonly eventTimelineSet: EventTimelineSet) {\n        this.roomId = eventTimelineSet.room?.roomId ?? null;\n        if (this.roomId) {\n            this.startState = new RoomState(this.roomId);\n            this.endState = new RoomState(this.roomId);\n        }\n\n        // this is used by client.js\n        this.paginationRequests = { b: null, f: null };\n\n        this.name = this.roomId + \":\" + new Date().toISOString();\n    }\n\n    /**\n     * Initialise the start and end state with the given events\n     *\n     * <p>This can only be called before any events are added.\n     *\n     * @param stateEvents - list of state events to initialise the\n     * state with.\n     * @throws Error if an attempt is made to call this after addEvent is called.\n     */\n    public initialiseState(stateEvents: MatrixEvent[], { timelineWasEmpty }: IInitialiseStateOptions = {}): void {\n        if (this.events.length > 0) {\n            throw new Error(\"Cannot initialise state after events are added\");\n        }\n\n        this.startState?.setStateEvents(stateEvents, { timelineWasEmpty });\n        this.endState?.setStateEvents(stateEvents, { timelineWasEmpty });\n    }\n\n    /**\n     * Forks the (live) timeline, taking ownership of the existing directional state of this timeline.\n     * All attached listeners will keep receiving state updates from the new live timeline state.\n     * The end state of this timeline gets replaced with an independent copy of the current RoomState,\n     * and will need a new pagination token if it ever needs to paginate forwards.\n\n     * @param direction -   EventTimeline.BACKWARDS to get the state at the\n     *   start of the timeline; EventTimeline.FORWARDS to get the state at the end\n     *   of the timeline.\n     *\n     * @returns the new timeline\n     */\n    public forkLive(direction: Direction): EventTimeline {\n        const forkState = this.getState(direction);\n        const timeline = new EventTimeline(this.eventTimelineSet);\n        timeline.startState = forkState?.clone();\n        // Now clobber the end state of the new live timeline with that from the\n        // previous live timeline. It will be identical except that we'll keep\n        // using the same RoomMember objects for the 'live' set of members with any\n        // listeners still attached\n        timeline.endState = forkState;\n        // Firstly, we just stole the current timeline's end state, so it needs a new one.\n        // Make an immutable copy of the state so back pagination will get the correct sentinels.\n        this.endState = forkState?.clone();\n        return timeline;\n    }\n\n    /**\n     * Creates an independent timeline, inheriting the directional state from this timeline.\n     *\n     * @param direction -   EventTimeline.BACKWARDS to get the state at the\n     *   start of the timeline; EventTimeline.FORWARDS to get the state at the end\n     *   of the timeline.\n     *\n     * @returns the new timeline\n     */\n    public fork(direction: Direction): EventTimeline {\n        const forkState = this.getState(direction);\n        const timeline = new EventTimeline(this.eventTimelineSet);\n        timeline.startState = forkState?.clone();\n        timeline.endState = forkState?.clone();\n        return timeline;\n    }\n\n    /**\n     * Get the ID of the room for this timeline\n     * @returns room ID\n     */\n    public getRoomId(): string | null {\n        return this.roomId;\n    }\n\n    /**\n     * Get the filter for this timeline's timelineSet (if any)\n     * @returns filter\n     */\n    public getFilter(): Filter | undefined {\n        return this.eventTimelineSet.getFilter();\n    }\n\n    /**\n     * Get the timelineSet for this timeline\n     * @returns timelineSet\n     */\n    public getTimelineSet(): EventTimelineSet {\n        return this.eventTimelineSet;\n    }\n\n    /**\n     * Get the base index.\n     *\n     * <p>This is an index which is incremented when events are prepended to the\n     * timeline. An individual event therefore stays at the same index in the array\n     * relative to the base index (although note that a given event's index may\n     * well be less than the base index, thus giving that event a negative relative\n     * index).\n     */\n    public getBaseIndex(): number {\n        return this.baseIndex;\n    }\n\n    /**\n     * Get the list of events in this context\n     *\n     * @returns An array of MatrixEvents\n     */\n    public getEvents(): MatrixEvent[] {\n        return this.events;\n    }\n\n    /**\n     * Get the room state at the start/end of the timeline\n     *\n     * @param direction -   EventTimeline.BACKWARDS to get the state at the\n     *   start of the timeline; EventTimeline.FORWARDS to get the state at the end\n     *   of the timeline.\n     *\n     * @returns state at the start/end of the timeline\n     */\n    public getState(direction: Direction): RoomState | undefined {\n        if (direction == EventTimeline.BACKWARDS) {\n            return this.startState;\n        } else if (direction == EventTimeline.FORWARDS) {\n            return this.endState;\n        } else {\n            throw new Error(\"Invalid direction '\" + direction + \"'\");\n        }\n    }\n\n    /**\n     * Get a pagination token\n     *\n     * @param direction - EventTimeline.BACKWARDS to get the pagination\n     *   token for going backwards in time; EventTimeline.FORWARDS to get the\n     *   pagination token for going forwards in time.\n     *\n     * @returns pagination token\n     */\n    public getPaginationToken(direction: Direction): string | null {\n        if (this.roomId) {\n            return this.getState(direction)!.paginationToken;\n        } else if (direction === Direction.Backward) {\n            return this.startToken;\n        } else {\n            return this.endToken;\n        }\n    }\n\n    /**\n     * Set a pagination token\n     *\n     * @param token -       pagination token\n     *\n     * @param direction -    EventTimeline.BACKWARDS to set the pagination\n     *   token for going backwards in time; EventTimeline.FORWARDS to set the\n     *   pagination token for going forwards in time.\n     */\n    public setPaginationToken(token: string | null, direction: Direction): void {\n        if (this.roomId) {\n            this.getState(direction)!.paginationToken = token;\n        } else if (direction === Direction.Backward) {\n            this.startToken = token;\n        } else {\n            this.endToken = token;\n        }\n    }\n\n    /**\n     * Get the next timeline in the series\n     *\n     * @param direction - EventTimeline.BACKWARDS to get the previous\n     *   timeline; EventTimeline.FORWARDS to get the next timeline.\n     *\n     * @returns previous or following timeline, if they have been\n     * joined up.\n     */\n    public getNeighbouringTimeline(direction: Direction): EventTimeline | null {\n        if (direction == EventTimeline.BACKWARDS) {\n            return this.prevTimeline;\n        } else if (direction == EventTimeline.FORWARDS) {\n            return this.nextTimeline;\n        } else {\n            throw new Error(\"Invalid direction '\" + direction + \"'\");\n        }\n    }\n\n    /**\n     * Set the next timeline in the series\n     *\n     * @param neighbour - previous/following timeline\n     *\n     * @param direction - EventTimeline.BACKWARDS to set the previous\n     *   timeline; EventTimeline.FORWARDS to set the next timeline.\n     *\n     * @throws Error if an attempt is made to set the neighbouring timeline when\n     * it is already set.\n     */\n    public setNeighbouringTimeline(neighbour: EventTimeline, direction: Direction): void {\n        if (this.getNeighbouringTimeline(direction)) {\n            throw new Error(\n                \"timeline already has a neighbouring timeline - \" +\n                    \"cannot reset neighbour (direction: \" +\n                    direction +\n                    \")\",\n            );\n        }\n\n        if (direction == EventTimeline.BACKWARDS) {\n            this.prevTimeline = neighbour;\n        } else if (direction == EventTimeline.FORWARDS) {\n            this.nextTimeline = neighbour;\n        } else {\n            throw new Error(\"Invalid direction '\" + direction + \"'\");\n        }\n\n        // make sure we don't try to paginate this timeline\n        this.setPaginationToken(null, direction);\n    }\n\n    /**\n     * Add a new event to the timeline, and update the state\n     *\n     * @param event - new event\n     * @param options - addEvent options\n     */\n    public addEvent(\n        event: MatrixEvent,\n        { toStartOfTimeline, roomState, timelineWasEmpty, addToState }: IAddEventOptions,\n    ): void {\n        if (!roomState) {\n            roomState = toStartOfTimeline ? this.startState : this.endState;\n        }\n\n        const timelineSet = this.getTimelineSet();\n\n        if (timelineSet.room) {\n            EventTimeline.setEventMetadata(event, roomState!, toStartOfTimeline);\n\n            // modify state but only on unfiltered timelineSets\n            if (addToState && event.isState() && timelineSet.room.getUnfilteredTimelineSet() === timelineSet) {\n                roomState?.setStateEvents([event], { timelineWasEmpty });\n                // it is possible that the act of setting the state event means we\n                // can set more metadata (specifically sender/target props), so try\n                // it again if the prop wasn't previously set. It may also mean that\n                // the sender/target is updated (if the event set was a room member event)\n                // so we want to use the *updated* member (new avatar/name) instead.\n                //\n                // However, we do NOT want to do this on member events if we're going\n                // back in time, else we'll set the .sender value for BEFORE the given\n                // member event, whereas we want to set the .sender value for the ACTUAL\n                // member event itself.\n                if (!event.sender || (event.getType() === EventType.RoomMember && !toStartOfTimeline)) {\n                    EventTimeline.setEventMetadata(event, roomState!, toStartOfTimeline);\n                }\n            }\n        }\n\n        let insertIndex: number;\n\n        if (toStartOfTimeline) {\n            insertIndex = 0;\n        } else {\n            insertIndex = this.events.length;\n        }\n\n        this.events.splice(insertIndex, 0, event); // insert element\n        if (toStartOfTimeline) {\n            this.baseIndex++;\n        }\n    }\n\n    /**\n     * Insert a new event into the timeline, and update the state.\n     *\n     * TEMPORARY: until we have recursive relations, we need this function\n     * to exist to allow us to insert events in timeline order, which is our\n     * best guess for Sync Order.\n     * This is a copy of addEvent above, modified to allow inserting an event at\n     * a specific index.\n     *\n     * @internal\n     */\n    public insertEvent(event: MatrixEvent, insertIndex: number, roomState: RoomState, addToState: boolean): void {\n        const timelineSet = this.getTimelineSet();\n\n        if (timelineSet.room) {\n            EventTimeline.setEventMetadata(event, roomState, false);\n\n            // modify state but only on unfiltered timelineSets\n            if (addToState && event.isState() && timelineSet.room.getUnfilteredTimelineSet() === timelineSet) {\n                roomState.setStateEvents([event], {});\n                // it is possible that the act of setting the state event means we\n                // can set more metadata (specifically sender/target props), so try\n                // it again if the prop wasn't previously set. It may also mean that\n                // the sender/target is updated (if the event set was a room member event)\n                // so we want to use the *updated* member (new avatar/name) instead.\n                //\n                // However, we do NOT want to do this on member events if we're going\n                // back in time, else we'll set the .sender value for BEFORE the given\n                // member event, whereas we want to set the .sender value for the ACTUAL\n                // member event itself.\n                if (!event.sender || event.getType() === EventType.RoomMember) {\n                    EventTimeline.setEventMetadata(event, roomState, false);\n                }\n            }\n        }\n\n        this.events.splice(insertIndex, 0, event); // insert element\n    }\n\n    /**\n     * Remove an event from the timeline\n     *\n     * @param eventId -  ID of event to be removed\n     * @returns removed event, or null if not found\n     */\n    public removeEvent(eventId: string): MatrixEvent | null {\n        for (let i = this.events.length - 1; i >= 0; i--) {\n            const ev = this.events[i];\n            if (ev.getId() == eventId) {\n                this.events.splice(i, 1);\n                if (i < this.baseIndex) {\n                    this.baseIndex--;\n                }\n                return ev;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Return a string to identify this timeline, for debugging\n     *\n     * @returns name for this timeline\n     */\n    public toString(): string {\n        return this.name;\n    }\n}\n","/*\nCopyright 2015 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixEvent} and {@link RoomEvent} for\n * the public classes.\n */\n\nimport { type ExtensibleEvent, ExtensibleEvents } from \"matrix-events-sdk\";\n\nimport { logger } from \"../logger.ts\";\nimport {\n    EVENT_VISIBILITY_CHANGE_TYPE,\n    EventType,\n    type MsgType,\n    RelationType,\n    ToDeviceMessageId,\n    UNSIGNED_THREAD_ID_FIELD,\n    UNSIGNED_MEMBERSHIP_FIELD,\n} from \"../@types/event.ts\";\nimport { deepSortedObjectEntries, internaliseString } from \"../utils.ts\";\nimport { type RoomMember } from \"./room-member.ts\";\nimport { type Thread, THREAD_RELATION_TYPE, ThreadEvent, type ThreadEventHandlerMap } from \"./thread.ts\";\nimport { type IActionsObject } from \"../pushprocessor.ts\";\nimport { TypedReEmitter } from \"../ReEmitter.ts\";\nimport { type MatrixError } from \"../http-api/index.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\nimport { type EventStatus } from \"./event-status.ts\";\nimport { type CryptoBackend, DecryptionError, type EventDecryptionResult } from \"../common-crypto/CryptoBackend.ts\";\nimport { type IAnnotatedPushRule } from \"../@types/PushRules.ts\";\nimport { type Room } from \"./room.ts\";\nimport { EventTimeline } from \"./event-timeline.ts\";\nimport { type Membership } from \"../@types/membership.ts\";\nimport { DecryptionFailureCode } from \"../crypto-api/index.ts\";\nimport { type RoomState } from \"./room-state.ts\";\nimport { type EmptyObject } from \"../@types/common.ts\";\n\nexport { EventStatus } from \"./event-status.ts\";\n\n/* eslint-disable camelcase */\nexport interface IContent {\n    [key: string]: any;\n    \"msgtype\"?: MsgType | string;\n    \"membership\"?: Membership;\n    \"avatar_url\"?: string;\n    \"displayname\"?: string;\n    \"m.relates_to\"?: IEventRelation;\n\n    \"m.mentions\"?: IMentions;\n}\n\ntype StrippedState = Required<Pick<IEvent, \"content\" | \"state_key\" | \"type\" | \"sender\">>;\n\nexport interface IUnsigned {\n    [key: string]: any;\n    \"age\"?: number;\n    \"prev_sender\"?: string;\n    \"prev_content\"?: IContent;\n    \"redacted_because\"?: IEvent;\n    \"replaces_state\"?: string;\n    \"transaction_id\"?: string;\n    \"invite_room_state\"?: StrippedState[];\n    \"m.relations\"?: Record<RelationType | string, any>; // No common pattern for aggregated relations\n    \"msc4354_sticky_duration_ttl_ms\"?: number;\n    [UNSIGNED_THREAD_ID_FIELD.name]?: string;\n}\n\nexport interface IThreadBundledRelationship {\n    latest_event: IEvent;\n    count: number;\n    current_user_participated?: boolean;\n}\n\nexport interface IEvent {\n    event_id: string;\n    type: string;\n    content: IContent;\n    sender: string;\n    room_id?: string;\n    origin_server_ts: number;\n    txn_id?: string;\n    state_key?: string;\n    membership?: Membership;\n    unsigned: IUnsigned;\n    redacts?: string;\n    msc4354_sticky?: { duration_ms: number };\n}\n\nexport interface IAggregatedRelation {\n    origin_server_ts: number;\n    event_id?: string;\n    sender?: string;\n    type?: string;\n    count?: number;\n    key?: string;\n}\n\nexport interface IEventRelation {\n    \"rel_type\"?: RelationType | string;\n    \"event_id\"?: string;\n    \"is_falling_back\"?: boolean;\n    \"m.in_reply_to\"?: {\n        event_id?: string;\n    };\n    \"key\"?: string;\n}\n\nexport interface IMentions {\n    user_ids?: string[];\n    room?: boolean;\n}\n\nexport interface PushDetails {\n    rule?: IAnnotatedPushRule;\n    actions?: IActionsObject;\n}\n\n/**\n * When an event is a visibility change event, as per MSC3531,\n * the visibility change implied by the event.\n */\nexport interface IVisibilityChange {\n    /**\n     * If `true`, the target event should be made visible.\n     * Otherwise, it should be hidden.\n     */\n    visible: boolean;\n\n    /**\n     * The event id affected.\n     */\n    eventId: string;\n\n    /**\n     * Optionally, a human-readable reason explaining why\n     * the event was hidden. Ignored if the event was made\n     * visible.\n     */\n    reason: string | null;\n}\n\nexport interface IMarkedUnreadEvent {\n    unread: boolean;\n}\n\nexport interface IClearEvent {\n    room_id?: string;\n    type: string;\n    state_key?: string;\n    content: Omit<IContent, \"membership\" | \"avatar_url\" | \"displayname\" | \"m.relates_to\">;\n    unsigned?: IUnsigned;\n}\n/* eslint-enable camelcase */\n\ninterface IKeyRequestRecipient {\n    userId: string;\n    deviceId: \"*\" | string;\n}\n\nexport interface IDecryptOptions {\n    /** Whether to emit {@link MatrixEventEvent.Decrypted} events on successful decryption. Defaults to true.\n     */\n    emit?: boolean;\n\n    /**\n     * True if this is a retry, after receiving an update to the session key. (Enables more logging.)\n     *\n     * This is only intended for use within the js-sdk.\n     *\n     * @internal\n     */\n    isRetry?: boolean;\n\n    /**\n     * @deprecated does nothing\n     */\n    forceRedecryptIfUntrusted?: boolean;\n}\n\n/**\n * Message hiding, as specified by https://github.com/matrix-org/matrix-doc/pull/3531.\n */\nexport type MessageVisibility = IMessageVisibilityHidden | IMessageVisibilityVisible;\n/**\n * Variant of `MessageVisibility` for the case in which the message should be displayed.\n */\nexport interface IMessageVisibilityVisible {\n    readonly visible: true;\n}\n/**\n * Variant of `MessageVisibility` for the case in which the message should be hidden.\n */\nexport interface IMessageVisibilityHidden {\n    readonly visible: false;\n    /**\n     * Optionally, a human-readable reason to show to the user indicating why the\n     * message has been hidden (e.g. \"Message Pending Moderation\").\n     */\n    readonly reason: string | null;\n}\n// A singleton implementing `IMessageVisibilityVisible`.\nconst MESSAGE_VISIBLE: IMessageVisibilityVisible = Object.freeze({ visible: true });\nexport const MAX_STICKY_DURATION_MS = 3600000;\n\nexport enum MatrixEventEvent {\n    /**\n     * An event has been decrypted, or we have failed to decrypt it.\n     *\n     * The payload consists of:\n     *\n     *  * `event` - The {@link MatrixEvent} which we attempted to decrypt.\n     *\n     *  * `err` - The error that occurred during decryption, or `undefined` if no error occurred.\n     *     Avoid use of this: {@link MatrixEvent.decryptionFailureReason} is more useful.\n     */\n    Decrypted = \"Event.decrypted\",\n\n    BeforeRedaction = \"Event.beforeRedaction\",\n    VisibilityChange = \"Event.visibilityChange\",\n    LocalEventIdReplaced = \"Event.localEventIdReplaced\",\n    Status = \"Event.status\",\n    Replaced = \"Event.replaced\",\n    RelationsCreated = \"Event.relationsCreated\",\n    SentinelUpdated = \"Event.sentinelUpdated\",\n}\n\nexport type MatrixEventEmittedEvents = MatrixEventEvent | ThreadEvent.Update;\n\nexport type MatrixEventHandlerMap = {\n    [MatrixEventEvent.Decrypted]: (event: MatrixEvent, err?: Error) => void;\n    [MatrixEventEvent.BeforeRedaction]: (event: MatrixEvent, redactionEvent: MatrixEvent) => void;\n    [MatrixEventEvent.VisibilityChange]: (event: MatrixEvent, visible: boolean) => void;\n    [MatrixEventEvent.LocalEventIdReplaced]: (event: MatrixEvent) => void;\n    [MatrixEventEvent.Status]: (event: MatrixEvent, status: EventStatus | null) => void;\n    [MatrixEventEvent.Replaced]: (event: MatrixEvent) => void;\n    [MatrixEventEvent.RelationsCreated]: (relationType: string, eventType: string) => void;\n    [MatrixEventEvent.SentinelUpdated]: () => void;\n} & Pick<ThreadEventHandlerMap, ThreadEvent.Update>;\n\nexport class MatrixEvent extends TypedEventEmitter<MatrixEventEmittedEvents, MatrixEventHandlerMap> {\n    // applied push rule and action for this event\n    private pushDetails: PushDetails = {};\n    private _replacingEvent: MatrixEvent | null = null;\n    private _localRedactionEvent: MatrixEvent | null = null;\n    private _isCancelled = false;\n    private clearEvent?: IClearEvent;\n\n    /* Message hiding, as specified by https://github.com/matrix-org/matrix-doc/pull/3531.\n\n    Note: We're returning this object, so any value stored here MUST be frozen.\n    */\n    private visibility: MessageVisibility = MESSAGE_VISIBLE;\n\n    // Not all events will be extensible-event compatible, so cache a flag in\n    // addition to a falsy cached event value. We check the flag later on in\n    // a public getter to decide if the cache is valid.\n    private _hasCachedExtEv = false;\n    private _cachedExtEv?: ExtensibleEvent = undefined;\n\n    /** If we failed to decrypt this event, the reason for the failure. Otherwise, `null`. */\n    private _decryptionFailureReason: DecryptionFailureCode | null = null;\n\n    /* curve25519 key which we believe belongs to the sender of the event. See\n     * getSenderKey()\n     */\n    private senderCurve25519Key: string | null = null;\n\n    /* ed25519 key which the sender of this event (for olm) or the creator of\n     * the megolm session (for megolm) claims to own. See getClaimedEd25519Key()\n     */\n    private claimedEd25519Key: string | null = null;\n\n    /**\n     * If another user forwarded the key to this message\n     * (eg via [MSC4268](https://github.com/matrix-org/matrix-spec-proposals/pull/4268)),\n     * the ID of that user.\n     */\n    private keyForwardedBy?: string;\n\n    /* if we have a process decrypting this event, a Promise which resolves\n     * when it is finished. Normally null.\n     */\n    private decryptionPromise: Promise<void> | null = null;\n\n    /* flag to indicate if we should retry decrypting this event after the\n     * first attempt (eg, we have received new data which means that a second\n     * attempt may succeed)\n     */\n    private retryDecryption = false;\n\n    /* The txnId with which this event was sent if it was during this session,\n     * allows for a unique ID which does not change when the event comes back down sync.\n     */\n    private txnId?: string;\n\n    /**\n     * A reference to the thread this event belongs to\n     */\n    private thread?: Thread;\n    private threadId?: string;\n\n    /* Set an approximate timestamp for the event relative the local clock.\n     * This will inherently be approximate because it doesn't take into account\n     * the time between the server putting the 'age' field on the event as it sent\n     * it to us and the time we're now constructing this event, but that's better\n     * than assuming the local clock is in sync with the origin HS's clock.\n     */\n    public localTimestamp: number;\n\n    /**\n     * The room member who sent this event, or null e.g.\n     * this is a presence event. This is only guaranteed to be set for events that\n     * appear in a timeline, ie. do not guarantee that it will be set on state\n     * events.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public sender: RoomMember | null = null;\n\n    /**\n     * The room member who is the target of this event, e.g.\n     * the invitee, the person being banned, etc.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public target: RoomMember | null = null;\n\n    /**\n     * Update the sentinels and forwardLooking flag for this event.\n     * @param stateContext -  the room state to be queried\n     * @param toStartOfTimeline -  if true the event's forwardLooking flag is set false\n     * @internal\n     */\n    public setMetadata(stateContext: RoomState, toStartOfTimeline: boolean): void {\n        // If an event is an m.room.member state event then we should set the sentinels again in case setEventMetadata\n        // was already called before the state was applied and thus the sentinel points at the member from before this event.\n        const affectsSelf =\n            this.isState() && this.getType() === EventType.RoomMember && this.getSender() === this.getStateKey();\n\n        let changed = false;\n        // When we try to generate a sentinel member before we have that member\n        // in the members object, we still generate a sentinel but it doesn't\n        // have a membership event, so test to see if events.member is set. We\n        // check this to avoid overriding non-sentinel members by sentinel ones\n        // when adding the event to a filtered timeline\n        if (affectsSelf || !this.sender?.events?.member) {\n            const newSender = stateContext.getSentinelMember(this.getSender()!);\n            if (newSender !== this.sender) changed = true;\n            this.sender = newSender;\n        }\n        if (affectsSelf || (!this.target?.events?.member && this.getType() === EventType.RoomMember)) {\n            const newTarget = stateContext.getSentinelMember(this.getStateKey()!);\n            if (newTarget !== this.target) changed = true;\n            this.target = newTarget;\n        }\n\n        if (this.isState()) {\n            // room state has no concept of 'old' or 'current', but we want the\n            // room state to regress back to previous values if toStartOfTimeline\n            // is set, which means inspecting prev_content if it exists. This\n            // is done by toggling the forwardLooking flag.\n            if (toStartOfTimeline) {\n                this.forwardLooking = false;\n            }\n        }\n\n        if (changed) {\n            this.emit(MatrixEventEvent.SentinelUpdated);\n        }\n    }\n\n    /**\n     * The sending status of the event.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public status: EventStatus | null = null;\n    /**\n     * most recent error associated with sending the event, if any\n     * @privateRemarks\n     * Should be read-only. May not be a MatrixError.\n     */\n    public error: MatrixError | null = null;\n    /**\n     * True if this event is 'forward looking', meaning\n     * that getDirectionalContent() will return event.content and not event.prev_content.\n     * Only state events may be backwards looking\n     * Default: true. <strong>This property is experimental and may change.</strong>\n     * @privateRemarks\n     * Should be read-only\n     */\n    public forwardLooking = true;\n\n    private readonly reEmitter: TypedReEmitter<MatrixEventEmittedEvents, MatrixEventHandlerMap>;\n\n    /**\n     * The timestamp for when this event should expire, in milliseconds.\n     * Prefers using the server-provided value, but will fall back to local calculation.\n     *\n     * This value is **safe** to use, as malicious start time and duration are appropriately capped.\n     *\n     * If the event is not a sticky event (or not supported by the server),\n     * then this returns `undefined`.\n     */\n    public readonly unstableStickyExpiresAt: number | undefined;\n\n    /**\n     * Construct a Matrix Event object\n     *\n     * @param event - The raw (possibly encrypted) event. <b>Do not access\n     * this property</b> directly unless you absolutely have to. Prefer the getter\n     * methods defined on this class. Using the getter methods shields your app\n     * from changes to event JSON between Matrix versions.\n     */\n    public constructor(public event: Partial<IEvent> = {}) {\n        super();\n\n        // intern the values of matrix events to force share strings and reduce the\n        // amount of needless string duplication. This can save moderate amounts of\n        // memory (~10% on a 350MB heap).\n        // 'membership' at the event level (rather than the content level) is a legacy\n        // field that Element never otherwise looks at, but it will still take up a lot\n        // of space if we don't intern it.\n        ([\"state_key\", \"type\", \"sender\", \"room_id\", \"membership\"] as const).forEach((prop) => {\n            if (typeof event[prop] !== \"string\") return;\n            event[prop] = internaliseString(event[prop]!);\n        });\n\n        ([\"membership\", \"avatar_url\", \"displayname\"] as const).forEach((prop) => {\n            if (typeof event.content?.[prop] !== \"string\") return;\n            event.content[prop] = internaliseString(event.content[prop]!);\n        });\n\n        ([\"rel_type\"] as const).forEach((prop) => {\n            if (typeof event.content?.[\"m.relates_to\"]?.[prop] !== \"string\") return;\n            event.content[\"m.relates_to\"][prop] = internaliseString(event.content[\"m.relates_to\"][prop]!);\n        });\n\n        this.txnId = event.txn_id;\n        // The localTimestamp is calculated using the age.\n        // Some events lack an `age` property, either because they are EDUs such as typing events,\n        // or due to server-side bugs such as https://github.com/matrix-org/synapse/issues/8429.\n        // The fallback in these cases will be to use the origin_server_ts.\n        // For EDUs, the origin_server_ts also is not defined so we use Date.now().\n        const age = this.getAge();\n        const now = Date.now();\n        this.localTimestamp = age !== undefined ? now - age : (this.getTs() ?? now);\n        this.reEmitter = new TypedReEmitter(this);\n        if (this.unstableStickyInfo) {\n            if (this.unstableStickyInfo.duration_ttl_ms) {\n                this.unstableStickyExpiresAt = now + this.unstableStickyInfo.duration_ttl_ms;\n            } else {\n                // Bound the timestamp so it doesn't come from the future.\n                this.unstableStickyExpiresAt = Math.min(now, this.getTs()) + this.unstableStickyInfo.duration_ms;\n            }\n        }\n    }\n\n    /**\n     * Unstable getter to try and get an extensible event. Note that this might\n     * return a falsy value if the event could not be parsed as an extensible\n     * event.\n     *\n     * @deprecated Use stable functions where possible.\n     */\n    public get unstableExtensibleEvent(): ExtensibleEvent | undefined {\n        if (!this._hasCachedExtEv) {\n            this._cachedExtEv = ExtensibleEvents.parse(this.getEffectiveEvent()) ?? undefined;\n        }\n        return this._cachedExtEv;\n    }\n\n    private invalidateExtensibleEvent(): void {\n        // just reset the flag - that'll trick the getter into parsing a new event\n        this._hasCachedExtEv = false;\n    }\n\n    /**\n     * Gets the event as it would appear if it had been sent unencrypted.\n     *\n     * If the event is encrypted, we attempt to mock up an event as it would have looked had the sender not encrypted it.\n     * If the event is not encrypted, a copy of it is simply returned as-is.\n     *\n     * @returns A shallow copy of the event, in wire format, as it would have been had it not been encrypted.\n     */\n    public getEffectiveEvent(): IEvent {\n        const content = Object.assign({}, this.getContent()); // clone for mutation\n\n        if (this.getWireType() === EventType.RoomMessageEncrypted) {\n            // Encrypted events sometimes aren't symmetrical on the `content` so we'll copy\n            // that over too, but only for missing properties. We don't copy over mismatches\n            // between the plain and decrypted copies of `content` because we assume that the\n            // app is relying on the decrypted version, so we want to expose that as a source\n            // of truth here too.\n            for (const [key, value] of Object.entries(this.getWireContent())) {\n                // Skip fields from the encrypted event schema though - we don't want to leak\n                // these.\n                if ([\"algorithm\", \"ciphertext\", \"device_id\", \"sender_key\", \"session_id\"].includes(key)) {\n                    continue;\n                }\n\n                if (content[key] === undefined) content[key] = value;\n            }\n        }\n\n        // clearEvent doesn't have all the fields, so we'll copy what we can from this.event.\n        // We also copy over our \"fixed\" content key.\n        return Object.assign({}, this.event, this.clearEvent, { content }) as IEvent;\n    }\n\n    /**\n     * Get the event_id for this event.\n     * @returns The event ID, e.g. <code>$143350589368169JsLZx:localhost\n     * </code>\n     */\n    public getId(): string | undefined {\n        return this.event.event_id;\n    }\n\n    /**\n     * Get the user_id for this event.\n     * @returns The user ID, e.g. `@alice:matrix.org`\n     */\n    public getSender(): string | undefined {\n        return this.event.sender; // v2 / v1\n    }\n\n    /**\n     * Get the (decrypted, if necessary) type of event.\n     *\n     * @returns The event type, e.g. `m.room.message`\n     */\n    public getType(): EventType | string {\n        if (this.clearEvent) {\n            return this.clearEvent.type;\n        }\n        return this.event.type!;\n    }\n\n    /**\n     * Get the (possibly encrypted) type of the event that will be sent to the\n     * homeserver.\n     *\n     * @returns The event type.\n     */\n    public getWireType(): EventType | string {\n        return this.event.type!;\n    }\n\n    /**\n     * Get the room_id for this event. This will return `undefined`\n     * for `m.presence` events.\n     * @returns The room ID, e.g. <code>!cURbafjkfsMDVwdRDQ:matrix.org\n     * </code>\n     */\n    public getRoomId(): string | undefined {\n        return this.event.room_id;\n    }\n\n    /**\n     * Get the timestamp of this event.\n     * @returns The event timestamp, e.g. `1433502692297`\n     */\n    public getTs(): number {\n        return this.event.origin_server_ts!;\n    }\n\n    /**\n     * Get the timestamp of this event, as a Date object.\n     * @returns The event date, e.g. `new Date(1433502692297)`\n     */\n    public getDate(): Date | null {\n        return this.event.origin_server_ts ? new Date(this.event.origin_server_ts) : null;\n    }\n\n    /**\n     * Get a string containing details of this event\n     *\n     * This is intended for logging, to help trace errors. Example output:\n     *\n     * @example\n     * ```\n     * id=$HjnOHV646n0SjLDAqFrgIjim7RCpB7cdMXFrekWYAn type=m.room.encrypted\n     * sender=@user:example.com room=!room:example.com ts=2022-10-25T17:30:28.404Z\n     * ```\n     */\n    public getDetails(): string {\n        const room = this.getRoomId();\n        if (room) {\n            // in-room event\n            return `id=${this.getId()} type=${this.getWireType()} sender=${this.getSender()} room=${room} ts=${this.getDate()?.toISOString()}`;\n        } else {\n            // to-device event\n            const msgid = this.getContent()[ToDeviceMessageId];\n            return `msgid=${msgid} type=${this.getWireType()} sender=${this.getSender()}`;\n        }\n    }\n\n    /**\n     * Get the (decrypted, if necessary) event content JSON, even if the event\n     * was replaced by another event.\n     *\n     * @returns The event content JSON, or an empty object.\n     */\n    public getOriginalContent<T = IContent>(): T {\n        if (this._localRedactionEvent) {\n            return {} as T;\n        }\n        if (this.clearEvent) {\n            return (this.clearEvent.content ?? {}) as T;\n        }\n        return (this.event.content ?? {}) as T;\n    }\n\n    /**\n     * Get the (decrypted, if necessary) event content JSON,\n     * or the content from the replacing event, if any.\n     * See `makeReplaced`.\n     *\n     * @returns The event content JSON, or an empty object.\n     */\n    public getContent<T extends IContent = IContent>(): T {\n        if (this._localRedactionEvent) {\n            return {} as T;\n        } else if (this._replacingEvent) {\n            return this._replacingEvent.getContent()[\"m.new_content\"] ?? {};\n        } else {\n            return this.getOriginalContent();\n        }\n    }\n\n    /**\n     * Get the (possibly encrypted) event content JSON that will be sent to the\n     * homeserver.\n     *\n     * @returns The event content JSON, or an empty object.\n     */\n    public getWireContent(): IContent {\n        return this.event.content || {};\n    }\n\n    /**\n     * Get the event ID of the thread head\n     */\n    public get threadRootId(): string | undefined {\n        // don't allow state events to be threaded as per the spec\n        if (this.isState()) {\n            return undefined;\n        }\n        const relatesTo = this.getWireContent()?.[\"m.relates_to\"];\n        if (relatesTo?.rel_type === THREAD_RELATION_TYPE.name) {\n            return relatesTo.event_id;\n        }\n        if (this.thread) {\n            return this.thread.id;\n        }\n        if (this.threadId !== undefined) {\n            return this.threadId;\n        }\n        const unsigned = this.getUnsigned();\n        if (typeof unsigned[UNSIGNED_THREAD_ID_FIELD.name] === \"string\") {\n            return unsigned[UNSIGNED_THREAD_ID_FIELD.name];\n        }\n        return undefined;\n    }\n\n    /**\n     * A helper to check if an event is a thread's head or not\n     */\n    public get isThreadRoot(): boolean {\n        // don't allow state events to be threaded as per the spec\n        if (this.isState()) {\n            return false;\n        }\n\n        const threadDetails = this.getServerAggregatedRelation<IThreadBundledRelationship>(THREAD_RELATION_TYPE.name);\n\n        // Bundled relationships only returned when the sync response is limited\n        // hence us having to check both bundled relation and inspect the thread\n        // model\n        return !!threadDetails || this.threadRootId === this.getId();\n    }\n\n    public get replyEventId(): string | undefined {\n        return this.getWireContent()[\"m.relates_to\"]?.[\"m.in_reply_to\"]?.event_id;\n    }\n\n    public get relationEventId(): string | undefined {\n        return this.getWireContent()?.[\"m.relates_to\"]?.event_id;\n    }\n\n    /**\n     * Get the previous event content JSON. This will only return something for\n     * state events which exist in the timeline.\n     * @returns The previous event content JSON, or an empty object.\n     */\n    public getPrevContent(): IContent {\n        // v2 then v1 then default\n        return this.getUnsigned().prev_content || {};\n    }\n\n    /**\n     * Get either 'content' or 'prev_content' depending on if this event is\n     * 'forward-looking' or not. This can be modified via event.forwardLooking.\n     * In practice, this means we get the chronologically earlier content value\n     * for this event (this method should surely be called getEarlierContent)\n     * <strong>This method is experimental and may change.</strong>\n     * @returns event.content if this event is forward-looking, else\n     * event.prev_content.\n     */\n    public getDirectionalContent(): IContent {\n        return this.forwardLooking ? this.getContent() : this.getPrevContent();\n    }\n\n    /**\n     * Get the age of this event. This represents the age of the event when the\n     * event arrived at the device, and not the age of the event when this\n     * function was called.\n     * Can only be returned once the server has echo'ed back\n     * @returns The age of this event in milliseconds.\n     */\n    public getAge(): number | undefined {\n        return this.getUnsigned().age;\n    }\n\n    /**\n     * Get the age of the event when this function was called.\n     * This is the 'age' field adjusted according to how long this client has\n     * had the event.\n     * @returns The age of this event in milliseconds.\n     */\n    public getLocalAge(): number {\n        return Date.now() - this.localTimestamp;\n    }\n\n    /**\n     * Get the event state_key if it has one. If necessary, this will perform\n     * string-unpacking on the state key, as per MSC4362. This will return\n     * <code>undefined</code> for message events.\n     * @returns The event's `state_key`.\n     */\n    public getStateKey(): string | undefined {\n        if (this.clearEvent) {\n            return this.clearEvent.state_key;\n        }\n        return this.event.state_key;\n    }\n\n    /**\n     * Get the raw event state_key if it has one. This may be string-packed as per\n     * MSC4362 if the state event is encrypted. This will return <code>undefined\n     * </code> for message events.\n     * @returns The event's `state_key`.\n     */\n    public getWireStateKey(): string | undefined {\n        return this.event.state_key;\n    }\n\n    /**\n     * Check if this event is a state event.\n     * @returns True if this is a state event.\n     */\n    public isState(): boolean {\n        return this.event.state_key !== undefined;\n    }\n\n    /**\n     * Get the user's room membership at the time the event was sent, as reported\n     * by the server.  This uses MSC4115.\n     *\n     * @returns The user's room membership, or `undefined` if the server does\n     *   not report it.\n     */\n    public getMembershipAtEvent(): Membership | string | undefined {\n        const unsigned = this.getUnsigned();\n        return UNSIGNED_MEMBERSHIP_FIELD.findIn<Membership | string>(unsigned);\n    }\n\n    /**\n     * Replace the content of this event with encrypted versions.\n     * (This is used when sending an event; it should not be used by applications).\n     *\n     * @internal\n     *\n     * @param cryptoType - type of the encrypted event - typically\n     * <tt>\"m.room.encrypted\"</tt>\n     *\n     * @param cryptoContent - raw 'content' for the encrypted event.\n     *\n     * @param senderCurve25519Key - curve25519 key to record for the\n     *   sender of this event.\n     *   See {@link MatrixEvent#getSenderKey}.\n     *\n     * @param claimedEd25519Key - claimed ed25519 key to record for the\n     *   sender if this event.\n     *   See {@link MatrixEvent#getClaimedEd25519Key}\n     */\n    public makeEncrypted(\n        cryptoType: string,\n        cryptoContent: object,\n        senderCurve25519Key: string,\n        claimedEd25519Key: string,\n    ): void {\n        // keep the plain-text data for 'view source'\n        this.clearEvent = {\n            type: this.event.type!,\n            content: this.event.content!,\n            state_key: this.event.state_key,\n        };\n        this.event.type = cryptoType;\n        this.event.content = cryptoContent;\n        this.senderCurve25519Key = senderCurve25519Key;\n        this.claimedEd25519Key = claimedEd25519Key;\n\n        // if this is a state event, pack cleartext type and statekey\n        if (this.isState()) {\n            this.event.state_key = `${this.clearEvent!.type}:${this.clearEvent!.state_key}`;\n        }\n    }\n\n    /**\n     * Check if this event is currently being decrypted.\n     *\n     * @returns True if this event is currently being decrypted, else false.\n     */\n    public isBeingDecrypted(): boolean {\n        return this.decryptionPromise != null;\n    }\n\n    public getDecryptionPromise(): Promise<void> | null {\n        return this.decryptionPromise;\n    }\n\n    /**\n     * Check if this event is an encrypted event which we failed to decrypt\n     *\n     * (This implies that we might retry decryption at some point in the future)\n     *\n     * @returns True if this event is an encrypted event which we\n     *     couldn't decrypt.\n     */\n    public isDecryptionFailure(): boolean {\n        return this._decryptionFailureReason !== null;\n    }\n\n    /** If we failed to decrypt this event, the reason for the failure. Otherwise, `null`. */\n    public get decryptionFailureReason(): DecryptionFailureCode | null {\n        return this._decryptionFailureReason;\n    }\n\n    public shouldAttemptDecryption(): boolean {\n        if (this.isRedacted()) return false;\n        if (this.isBeingDecrypted()) return false;\n        if (this.clearEvent) return false;\n        if (!this.isEncrypted()) return false;\n\n        return true;\n    }\n\n    /**\n     * Start the process of trying to decrypt this event.\n     *\n     * (This is used within the SDK: it isn't intended for use by applications)\n     *\n     * @internal\n     *\n     * @param crypto - crypto module\n     *\n     * @returns promise which resolves (to undefined) when the decryption\n     * attempt is completed.\n     */\n    public async attemptDecryption(crypto: CryptoBackend, options: IDecryptOptions = {}): Promise<void> {\n        // start with a couple of sanity checks.\n        if (!this.isEncrypted()) {\n            throw new Error(\"Attempt to decrypt event which isn't encrypted\");\n        }\n\n        const alreadyDecrypted = this.clearEvent && !this.isDecryptionFailure();\n        if (alreadyDecrypted) {\n            // we may want to just ignore this? let's start with rejecting it.\n            throw new Error(\"Attempt to decrypt event which has already been decrypted\");\n        }\n\n        // if we already have a decryption attempt in progress, then it may\n        // fail because it was using outdated info. We now have reason to\n        // succeed where it failed before, but we don't want to have multiple\n        // attempts going at the same time, so just set a flag that says we have\n        // new info.\n        //\n        if (this.decryptionPromise) {\n            logger.log(`Event ${this.getId()} already being decrypted; queueing a retry`);\n            this.retryDecryption = true;\n            return this.decryptionPromise;\n        }\n\n        this.decryptionPromise = this.decryptionLoop(crypto, options);\n        return this.decryptionPromise;\n    }\n\n    /**\n     * Calculate the recipients for keyshare requests.\n     *\n     * @param userId - the user who received this event.\n     *\n     * @returns array of recipients\n     */\n    public getKeyRequestRecipients(userId: string): IKeyRequestRecipient[] {\n        // send the request to all of our own devices\n        const recipients = [\n            {\n                userId,\n                deviceId: \"*\",\n            },\n        ];\n\n        return recipients;\n    }\n\n    private async decryptionLoop(crypto: CryptoBackend, options: IDecryptOptions = {}): Promise<void> {\n        // make sure that this method never runs completely synchronously.\n        // (doing so would mean that we would clear decryptionPromise *before*\n        // it is set in attemptDecryption - and hence end up with a stuck\n        // `decryptionPromise`).\n        await Promise.resolve();\n\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            this.retryDecryption = false;\n\n            let err: Error | undefined = undefined;\n            try {\n                const res = await crypto.decryptEvent(this);\n                if (options.isRetry === true) {\n                    logger.info(`Decrypted event on retry (${this.getDetails()})`);\n                }\n                this.setClearData(res);\n                this._decryptionFailureReason = null;\n            } catch (e) {\n                const detailedError = e instanceof DecryptionError ? (<DecryptionError>e).detailedString : String(e);\n\n                err = e as Error;\n\n                // see if we have a retry queued.\n                //\n                // NB: make sure to keep this check in the same tick of the\n                //   event loop as `decryptionPromise = null` below - otherwise we\n                //   risk a race:\n                //\n                //   * A: we check retryDecryption here and see that it is\n                //        false\n                //   * B: we get a second call to attemptDecryption, which sees\n                //        that decryptionPromise is set so sets\n                //        retryDecryption\n                //   * A: we continue below, clear decryptionPromise, and\n                //        never do the retry.\n                //\n                if (this.retryDecryption) {\n                    // decryption error, but we have a retry queued.\n                    logger.log(`Error decrypting event (${this.getDetails()}), but retrying: ${detailedError}`);\n                    continue;\n                }\n\n                // decryption error, no retries queued. Warn about the error and\n                // set it to m.bad.encrypted.\n                //\n                // the detailedString already includes the name and message of the error, and the stack isn't much use,\n                // so we don't bother to log `e` separately.\n                logger.warn(`Error decrypting event (${this.getDetails()}): ${detailedError}`);\n\n                this.setClearDataForDecryptionFailure(String(e));\n                this._decryptionFailureReason =\n                    e instanceof DecryptionError ? (<DecryptionError>e).code : DecryptionFailureCode.UNKNOWN_ERROR;\n            }\n\n            // Make sure we clear 'decryptionPromise' before sending the 'Event.decrypted' event,\n            // otherwise the app will be confused to see `isBeingDecrypted` still set when\n            // there isn't an `Event.decrypted` on the way.\n            //\n            // see also notes on retryDecryption above.\n            //\n            this.decryptionPromise = null;\n            this.retryDecryption = false;\n\n            // Before we emit the event, clear the push actions so that they can be recalculated\n            // by relevant code. We do this because the clear event has now changed, making it\n            // so that existing rules can be re-run over the applicable properties. Stuff like\n            // highlighting when the user's name is mentioned rely on this happening. We also want\n            // to set the push actions before emitting so that any notification listeners don't\n            // pick up the wrong contents.\n            this.setPushDetails();\n\n            if (options.emit !== false) {\n                this.emit(MatrixEventEvent.Decrypted, this, err);\n            }\n\n            return;\n        }\n    }\n\n    /**\n     * Update the cleartext data on this event.\n     *\n     * (This is used after decrypting an event; it should not be used by applications).\n     *\n     * @internal\n     *\n     * @param decryptionResult - the decryption result, including the plaintext and some key info\n     */\n    private setClearData(decryptionResult: EventDecryptionResult): void {\n        this.clearEvent = decryptionResult.clearEvent;\n        this.senderCurve25519Key = decryptionResult.senderCurve25519Key ?? null;\n        this.claimedEd25519Key = decryptionResult.claimedEd25519Key ?? null;\n        this.keyForwardedBy = decryptionResult.keyForwardedBy;\n        this.invalidateExtensibleEvent();\n    }\n\n    /**\n     * Update the cleartext data on this event after a decryption failure.\n     *\n     * @param reason - the textual reason for the failure\n     */\n    private setClearDataForDecryptionFailure(reason: string): void {\n        this.clearEvent = {\n            type: EventType.RoomMessage,\n            content: {\n                msgtype: \"m.bad.encrypted\",\n                body: `** Unable to decrypt: ${reason} **`,\n            },\n        };\n        this.senderCurve25519Key = null;\n        this.claimedEd25519Key = null;\n        this.invalidateExtensibleEvent();\n    }\n\n    /**\n     * Gets the cleartext content for this event. If the event is not encrypted,\n     * or encryption has not been completed, this will return null.\n     *\n     * @returns The cleartext (decrypted) content for the event\n     */\n    public getClearContent(): IContent | null {\n        return this.clearEvent ? this.clearEvent.content : null;\n    }\n\n    /**\n     * Check if the event is encrypted.\n     * @returns True if this event is encrypted.\n     */\n    public isEncrypted(): boolean {\n        return this.event.type === EventType.RoomMessageEncrypted;\n    }\n\n    /**\n     * The curve25519 key for the device that we think sent this event\n     *\n     * For an Olm-encrypted event, this is inferred directly from the DH\n     * exchange at the start of the session: the curve25519 key is involved in\n     * the DH exchange, so only a device which holds the private part of that\n     * key can establish such a session.\n     *\n     * For a megolm-encrypted event, it is inferred from the Olm message which\n     * established the megolm session\n     */\n    public getSenderKey(): string | null {\n        return this.senderCurve25519Key;\n    }\n\n    /**\n     * The additional keys the sender of this encrypted event claims to possess.\n     *\n     * Just a wrapper for #getClaimedEd25519Key (q.v.)\n     */\n    public getKeysClaimed(): Partial<Record<\"ed25519\", string>> {\n        if (!this.claimedEd25519Key) return {};\n\n        return {\n            ed25519: this.claimedEd25519Key,\n        };\n    }\n\n    /**\n     * Get the ed25519 the sender of this event claims to own.\n     *\n     * For Olm messages, this claim is encoded directly in the plaintext of the\n     * event itself. For megolm messages, it is implied by the m.room_key event\n     * which established the megolm session.\n     *\n     * Until we download the device list of the sender, it's just a claim: the\n     * device list gives a proof that the owner of the curve25519 key used for\n     * this event (and returned by #getSenderKey) also owns the ed25519 key by\n     * signing the public curve25519 key with the ed25519 key.\n     *\n     * In general, applications should not use this method directly, but should\n     * instead use {@link crypto-api!CryptoApi#getEncryptionInfoForEvent}.\n     */\n    public getClaimedEd25519Key(): string | null {\n        return this.claimedEd25519Key;\n    }\n\n    /**\n     *  Returns an empty array.\n     *\n     * Previously, this returned the chain of Curve25519 keys through which\n     * this session was forwarded, via `m.forwarded_room_key` events.\n     * However, that is not cryptographically reliable, and clients should not\n     * be using it.\n     *\n     * @see https://github.com/matrix-org/matrix-spec/issues/1089\n     * @deprecated\n     */\n    public getForwardingCurve25519KeyChain(): string[] {\n        return [];\n    }\n\n    /**\n     * @deprecated always returns false\n     */\n    public isKeySourceUntrusted(): false {\n        return false;\n    }\n\n    /**\n     * If another user forwarded the key to this message\n     * (eg via [MSC4268](https://github.com/matrix-org/matrix-spec-proposals/pull/4268)),\n     * get the ID of that user.\n     */\n    public getKeyForwardingUser(): string | undefined {\n        return this.keyForwardedBy;\n    }\n\n    public getUnsigned(): IUnsigned {\n        return this.event.unsigned || {};\n    }\n\n    public setUnsigned(unsigned: IUnsigned): void {\n        this.event.unsigned = unsigned;\n    }\n\n    public unmarkLocallyRedacted(): boolean {\n        const value = this._localRedactionEvent;\n        this._localRedactionEvent = null;\n        if (this.event.unsigned) {\n            this.event.unsigned.redacted_because = undefined;\n        }\n        return !!value;\n    }\n\n    public markLocallyRedacted(redactionEvent: MatrixEvent): void {\n        if (this._localRedactionEvent) return;\n        this.emit(MatrixEventEvent.BeforeRedaction, this, redactionEvent);\n        this._localRedactionEvent = redactionEvent;\n        if (!this.event.unsigned) {\n            this.event.unsigned = {};\n        }\n        this.event.unsigned.redacted_because = redactionEvent.event as IEvent;\n    }\n\n    /**\n     * Change the visibility of an event, as per https://github.com/matrix-org/matrix-doc/pull/3531 .\n     *\n     * @param visibilityChange - event holding a hide/unhide payload, or nothing\n     *   if the event is being reset to its original visibility (presumably\n     *   by a visibility event being redacted).\n     *\n     * @remarks\n     * Fires {@link MatrixEventEvent.VisibilityChange} if `visibilityEvent`\n     *   caused a change in the actual visibility of this event, either by making it\n     *   visible (if it was hidden), by making it hidden (if it was visible) or by\n     *   changing the reason (if it was hidden).\n     */\n    public applyVisibilityEvent(visibilityChange?: IVisibilityChange): void {\n        const visible = visibilityChange?.visible ?? true;\n        const reason = visibilityChange?.reason ?? null;\n        let change = false;\n        if (this.visibility.visible !== visible) {\n            change = true;\n        } else if (!this.visibility.visible && this.visibility[\"reason\"] !== reason) {\n            change = true;\n        }\n        if (change) {\n            if (visible) {\n                this.visibility = MESSAGE_VISIBLE;\n            } else {\n                this.visibility = Object.freeze({\n                    visible: false,\n                    reason,\n                });\n            }\n            this.emit(MatrixEventEvent.VisibilityChange, this, visible);\n        }\n    }\n\n    /**\n     * Return instructions to display or hide the message.\n     *\n     * @returns Instructions determining whether the message\n     * should be displayed.\n     */\n    public messageVisibility(): MessageVisibility {\n        // Note: We may return `this.visibility` without fear, as\n        // this is a shallow frozen object.\n        return this.visibility;\n    }\n\n    /**\n     * Update the content of an event in the same way it would be by the server\n     * if it were redacted before it was sent to us\n     *\n     * @param redactionEvent - event causing the redaction\n     * @param room - the room in which the event exists\n     */\n    public makeRedacted(redactionEvent: MatrixEvent, room: Room): void {\n        // quick sanity-check\n        if (!redactionEvent.event) {\n            throw new Error(\"invalid redactionEvent in makeRedacted\");\n        }\n\n        this._localRedactionEvent = null;\n\n        this.emit(MatrixEventEvent.BeforeRedaction, this, redactionEvent);\n\n        this._replacingEvent = null;\n        // we attempt to replicate what we would see from the server if\n        // the event had been redacted before we saw it.\n        //\n        // The server removes (most of) the content of the event, and adds a\n        // \"redacted_because\" key to the unsigned section containing the\n        // redacted event.\n        if (!this.event.unsigned) {\n            this.event.unsigned = {};\n        }\n        this.event.unsigned.redacted_because = redactionEvent.event as IEvent;\n\n        for (const key in this.event) {\n            if (this.event.hasOwnProperty(key) && !REDACT_KEEP_KEYS.has(key)) {\n                delete this.event[key as keyof IEvent];\n            }\n        }\n\n        // If the event is encrypted prune the decrypted bits\n        if (this.isEncrypted()) {\n            this.clearEvent = undefined;\n        }\n\n        const keeps =\n            this.getType() in REDACT_KEEP_CONTENT_MAP\n                ? REDACT_KEEP_CONTENT_MAP[this.getType() as keyof typeof REDACT_KEEP_CONTENT_MAP]\n                : {};\n        const content = this.getContent();\n        for (const key in content) {\n            if (content.hasOwnProperty(key) && !keeps[key]) {\n                delete content[key];\n            }\n        }\n\n        // If the redacted event was in a thread (but not thread root), move it\n        // to the main timeline. This will change if MSC3389 is merged.\n        if (!this.isThreadRoot && this.threadRootId && this.threadRootId !== this.getId()) {\n            this.moveAllRelatedToMainTimeline(room);\n            redactionEvent.moveToMainTimeline(room);\n        }\n\n        this.invalidateExtensibleEvent();\n    }\n\n    private moveAllRelatedToMainTimeline(room: Room): void {\n        const thread = this.thread;\n        this.moveToMainTimeline(room);\n\n        // If we dont have access to the thread, we can only move this\n        // event, not things related to it.\n        if (thread) {\n            for (const event of thread.events) {\n                if (event.getRelation()?.event_id === this.getId()) {\n                    event.moveAllRelatedToMainTimeline(room);\n                }\n            }\n        }\n    }\n\n    private moveToMainTimeline(room: Room): void {\n        // Remove it from its thread\n        this.thread?.timelineSet.removeEvent(this.getId()!);\n        this.setThread(undefined);\n\n        // And insert it into the main timeline\n        const timeline = room.getLiveTimeline();\n        // We use insertEventIntoTimeline to insert it in timestamp order,\n        // because we don't know where it should go (until we have MSC4033).\n        timeline\n            .getTimelineSet()\n            .insertEventIntoTimeline(this, timeline, timeline.getState(EventTimeline.FORWARDS)!, false);\n    }\n\n    /**\n     * Check if this event has been redacted\n     *\n     * @returns True if this event has been redacted\n     */\n    public isRedacted(): boolean {\n        return Boolean(this.getUnsigned().redacted_because);\n    }\n\n    /**\n     * Check if this event is a redaction of another event\n     *\n     * @returns True if this event is a redaction\n     */\n    public isRedaction(): boolean {\n        return this.getType() === EventType.RoomRedaction;\n    }\n\n    /**\n     * Return the visibility change caused by this event,\n     * as per https://github.com/matrix-org/matrix-doc/pull/3531.\n     *\n     * @returns If the event is a well-formed visibility change event,\n     * an instance of `IVisibilityChange`, otherwise `null`.\n     */\n    public asVisibilityChange(): IVisibilityChange | null {\n        if (!EVENT_VISIBILITY_CHANGE_TYPE.matches(this.getType())) {\n            // Not a visibility change event.\n            return null;\n        }\n        const relation = this.getRelation();\n        if (!relation || relation.rel_type != \"m.reference\") {\n            // Ill-formed, ignore this event.\n            return null;\n        }\n        const eventId = relation.event_id;\n        if (!eventId) {\n            // Ill-formed, ignore this event.\n            return null;\n        }\n        const content = this.getWireContent();\n        const visible = !!content.visible;\n        const reason = content.reason;\n        if (reason && typeof reason != \"string\") {\n            // Ill-formed, ignore this event.\n            return null;\n        }\n        // Well-formed visibility change event.\n        return {\n            visible,\n            reason,\n            eventId,\n        };\n    }\n\n    /**\n     * Check if this event alters the visibility of another event,\n     * as per https://github.com/matrix-org/matrix-doc/pull/3531.\n     *\n     * @returns True if this event alters the visibility\n     * of another event.\n     */\n    public isVisibilityEvent(): boolean {\n        return EVENT_VISIBILITY_CHANGE_TYPE.matches(this.getType());\n    }\n\n    /**\n     * Get the (decrypted, if necessary) redaction event JSON\n     * if event was redacted\n     *\n     * @returns The redaction event JSON, or an empty object\n     */\n    public getRedactionEvent(): IEvent | EmptyObject | null {\n        if (!this.isRedacted()) return null;\n\n        if (this.clearEvent?.unsigned) {\n            return this.clearEvent?.unsigned.redacted_because ?? null;\n        } else if (this.event.unsigned?.redacted_because) {\n            return this.event.unsigned.redacted_because;\n        } else {\n            return {};\n        }\n    }\n\n    /**\n     * Get the push actions, if known, for this event\n     *\n     * @returns push actions\n     */\n    public getPushActions(): IActionsObject | null {\n        return this.pushDetails.actions || null;\n    }\n\n    /**\n     * Get the push details, if known, for this event\n     *\n     * @returns push actions\n     */\n    public getPushDetails(): PushDetails {\n        return this.pushDetails;\n    }\n\n    /**\n     * Set the push details for this event.\n     *\n     * @param pushActions - push actions\n     * @param rule - the executed push rule\n     */\n    public setPushDetails(pushActions?: IActionsObject, rule?: IAnnotatedPushRule): void {\n        this.pushDetails = {\n            actions: pushActions,\n            rule,\n        };\n    }\n\n    /**\n     * Replace the `event` property and recalculate any properties based on it.\n     * @param event - the object to assign to the `event` property\n     */\n    public handleRemoteEcho(event: object): void {\n        const oldUnsigned = this.getUnsigned();\n        const oldId = this.getId();\n        this.event = event;\n        // if this event was redacted before it was sent, it's locally marked as redacted.\n        // At this point, we've received the remote echo for the event, but not yet for\n        // the redaction that we are sending ourselves. Preserve the locally redacted\n        // state by copying over redacted_because so we don't get a flash of\n        // redacted, not-redacted, redacted as remote echos come in\n        if (oldUnsigned.redacted_because) {\n            if (!this.event.unsigned) {\n                this.event.unsigned = {};\n            }\n            this.event.unsigned.redacted_because = oldUnsigned.redacted_because;\n        }\n        // successfully sent.\n        this.setStatus(null);\n        if (this.getId() !== oldId) {\n            // emit the event if it changed\n            this.emit(MatrixEventEvent.LocalEventIdReplaced, this);\n        }\n\n        this.localTimestamp = Date.now() - (this.getAge() ?? 0);\n    }\n\n    /**\n     * Whether the event is in any phase of sending, send failure, waiting for\n     * remote echo, etc.\n     */\n    public isSending(): boolean {\n        return !!this.status;\n    }\n\n    /**\n     * Update the event's sending status and emit an event as well.\n     *\n     * @param status - The new status\n     */\n    public setStatus(status: EventStatus | null): void {\n        this.status = status;\n        this.emit(MatrixEventEvent.Status, this, status);\n    }\n\n    public replaceLocalEventId(eventId: string): void {\n        this.event.event_id = eventId;\n        this.emit(MatrixEventEvent.LocalEventIdReplaced, this);\n    }\n\n    /**\n     * Get whether the event is a relation event, and of a given type if\n     * `relType` is passed in. State events cannot be relation events\n     *\n     * @param relType - if given, checks that the relation is of the\n     * given type\n     */\n    public isRelation(relType?: string): boolean {\n        // Relation info is lifted out of the encrypted content when sent to\n        // encrypted rooms, so we have to check `getWireContent` for this.\n        const relation = this.getWireContent()?.[\"m.relates_to\"];\n        if (\n            this.isState() &&\n            !!relation?.rel_type &&\n            ([RelationType.Replace, RelationType.Thread] as string[]).includes(relation.rel_type)\n        ) {\n            // State events cannot be m.replace or m.thread relations\n            return false;\n        }\n        return !!(relation?.rel_type && relation.event_id && (relType ? relation.rel_type === relType : true));\n    }\n\n    /**\n     * Get relation info for the event, if any.\n     */\n    public getRelation(): IEventRelation | null {\n        if (!this.isRelation()) {\n            return null;\n        }\n        return this.getWireContent()[\"m.relates_to\"] ?? null;\n    }\n\n    /**\n     * Set an event that replaces the content of this event, through an m.replace relation.\n     *\n     * @param newEvent - the event with the replacing content, if any.\n     *\n     * @remarks\n     * Fires {@link MatrixEventEvent.Replaced}\n     */\n    public makeReplaced(newEvent?: MatrixEvent): void {\n        // don't allow redacted events to be replaced.\n        // if newEvent is null we allow to go through though,\n        // as with local redaction, the replacing event might get\n        // cancelled, which should be reflected on the target event.\n        if (this.isRedacted() && newEvent) {\n            return;\n        }\n        // don't allow state events to be replaced using this mechanism as per MSC2676\n        if (this.isState()) {\n            return;\n        }\n        if (this._replacingEvent !== newEvent) {\n            this._replacingEvent = newEvent ?? null;\n            this.emit(MatrixEventEvent.Replaced, this);\n            this.invalidateExtensibleEvent();\n        }\n    }\n\n    /**\n     * Returns the status of any associated edit or redaction\n     * (not for reactions/annotations as their local echo doesn't affect the original event),\n     * or else the status of the event.\n     */\n    public getAssociatedStatus(): EventStatus | null {\n        if (this._replacingEvent) {\n            return this._replacingEvent.status;\n        } else if (this._localRedactionEvent) {\n            return this._localRedactionEvent.status;\n        }\n        return this.status;\n    }\n\n    public getServerAggregatedRelation<T>(relType: RelationType | string): T | undefined {\n        return this.getUnsigned()[\"m.relations\"]?.[relType];\n    }\n\n    /**\n     * Returns the event ID of the event replacing the content of this event, if any.\n     */\n    public replacingEventId(): string | undefined {\n        const replaceRelation = this.getServerAggregatedRelation<IAggregatedRelation>(RelationType.Replace);\n        if (replaceRelation) {\n            return replaceRelation.event_id;\n        } else if (this._replacingEvent) {\n            return this._replacingEvent.getId();\n        }\n    }\n\n    /**\n     * Returns the event replacing the content of this event, if any.\n     * Replacements are aggregated on the server, so this would only\n     * return an event in case it came down the sync, or for local echo of edits.\n     */\n    public replacingEvent(): MatrixEvent | null {\n        return this._replacingEvent;\n    }\n\n    /**\n     * Returns the origin_server_ts of the event replacing the content of this event, if any.\n     */\n    public replacingEventDate(): Date | undefined {\n        const replaceRelation = this.getServerAggregatedRelation<IAggregatedRelation>(RelationType.Replace);\n        if (replaceRelation) {\n            const ts = replaceRelation.origin_server_ts;\n            if (Number.isFinite(ts)) {\n                return new Date(ts);\n            }\n        } else if (this._replacingEvent) {\n            return this._replacingEvent.getDate() ?? undefined;\n        }\n    }\n\n    /**\n     * Returns the event that wants to redact this event, but hasn't been sent yet.\n     * @returns the event\n     */\n    public localRedactionEvent(): MatrixEvent | null {\n        return this._localRedactionEvent;\n    }\n\n    /**\n     * For relations and redactions, returns the event_id this event is referring to.\n     */\n    public getAssociatedId(): string | undefined {\n        const relation = this.getRelation();\n        if (this.replyEventId) {\n            return this.replyEventId;\n        } else if (relation) {\n            return relation.event_id;\n        } else if (this.isRedaction()) {\n            return this.event.redacts;\n        }\n    }\n\n    /**\n     * Checks if this event is associated with another event. See `getAssociatedId`.\n     */\n    public hasAssociation(): boolean {\n        return !!this.getAssociatedId();\n    }\n\n    /**\n     * Update the related id with a new one.\n     *\n     * Used to replace a local id with remote one before sending\n     * an event with a related id.\n     *\n     * @param eventId - the new event id\n     */\n    public updateAssociatedId(eventId: string): void {\n        const relation = this.getRelation();\n        if (relation) {\n            relation.event_id = eventId;\n        } else if (this.isRedaction()) {\n            this.event.redacts = eventId;\n        }\n    }\n\n    /**\n     * Flags an event as cancelled due to future conditions. For example, a verification\n     * request event in the same sync transaction may be flagged as cancelled to warn\n     * listeners that a cancellation event is coming down the same pipe shortly.\n     * @param cancelled - Whether the event is to be cancelled or not.\n     */\n    public flagCancelled(cancelled = true): void {\n        this._isCancelled = cancelled;\n    }\n\n    /**\n     * Gets whether or not the event is flagged as cancelled. See flagCancelled() for\n     * more information.\n     * @returns True if the event is cancelled, false otherwise.\n     */\n    public isCancelled(): boolean {\n        return this._isCancelled;\n    }\n\n    /**\n     * Get a copy/snapshot of this event. The returned copy will be loosely linked\n     * back to this instance, though will have \"frozen\" event information. Other\n     * properties of this MatrixEvent instance will be copied verbatim, which can\n     * mean they are in reference to this instance despite being on the copy too.\n     * The reference the snapshot uses does not change, however members aside from\n     * the underlying event will not be deeply cloned, thus may be mutated internally.\n     * For example, the sender profile will be copied over at snapshot time, and\n     * the sender profile internally may mutate without notice to the consumer.\n     *\n     * This is meant to be used to snapshot the event details themselves, not the\n     * features (such as sender) surrounding the event.\n     * @returns A snapshot of this event.\n     */\n    public toSnapshot(): MatrixEvent {\n        const ev = new MatrixEvent(JSON.parse(JSON.stringify(this.event)));\n        for (const [p, v] of Object.entries(this)) {\n            if (p !== \"event\") {\n                // exclude the thing we just cloned\n                // @ts-ignore - XXX: this is just nasty\n                ev[p as keyof MatrixEvent] = v;\n            }\n        }\n        return ev;\n    }\n\n    /**\n     * Determines if this event is equivalent to the given event. This only checks\n     * the event object itself, not the other properties of the event. Intended for\n     * use with toSnapshot() to identify events changing.\n     * @param otherEvent - The other event to check against.\n     * @returns True if the events are the same, false otherwise.\n     */\n    public isEquivalentTo(otherEvent?: MatrixEvent): boolean {\n        if (!otherEvent) return false;\n        if (otherEvent === this) return true;\n        const myProps = deepSortedObjectEntries(this.event);\n        const theirProps = deepSortedObjectEntries(otherEvent.event);\n        return JSON.stringify(myProps) === JSON.stringify(theirProps);\n    }\n\n    /**\n     * Summarise the event as JSON.\n     *\n     * If encrypted, include both the decrypted and encrypted view of the event.\n     *\n     * This is named `toJSON` for use with `JSON.stringify` which checks objects\n     * for functions named `toJSON` and will call them to customise the output\n     * if they are defined.\n     *\n     * **WARNING** Do not log the result of this method; otherwise, it will end up\n     * in rageshakes, leading to a privacy violation.\n     *\n     * @deprecated Prefer to use {@link MatrixEvent#getEffectiveEvent} or similar.\n     * This method will be removed soon; it is too easy to use it accidentally\n     * and cause a privacy violation (cf https://github.com/vector-im/element-web/issues/26380).\n     * In any case, the value it returns is not a faithful serialization of the object.\n     */\n    public toJSON(): object {\n        const event = this.getEffectiveEvent();\n\n        if (!this.isEncrypted()) {\n            return event;\n        }\n\n        return {\n            decrypted: event,\n            encrypted: this.event,\n        };\n    }\n\n    public setTxnId(txnId: string): void {\n        this.txnId = txnId;\n    }\n\n    public getTxnId(): string | undefined {\n        return this.txnId;\n    }\n\n    /**\n     * Set the instance of a thread associated with the current event\n     * @param thread - the thread\n     */\n    public setThread(thread?: Thread): void {\n        // don't allow state events to be threaded as per the spec\n        if (this.isState()) {\n            return;\n        }\n        if (this.thread) {\n            this.reEmitter.stopReEmitting(this.thread, [ThreadEvent.Update]);\n        }\n        this.thread = thread;\n        this.setThreadId(thread?.id);\n        if (thread) {\n            this.reEmitter.reEmit(thread, [ThreadEvent.Update]);\n        }\n    }\n\n    /**\n     * Get the instance of the thread associated with the current event\n     */\n    public getThread(): Thread | undefined {\n        return this.thread;\n    }\n\n    public setThreadId(threadId?: string): void {\n        this.threadId = threadId;\n    }\n\n    /**\n     * Unstable getter to try and get the sticky information for the event.\n     * If the event is not a sticky event (or not supported by the server),\n     * then this returns `undefined`.\n     *\n     * `duration_ms` is safely bounded to a hour.\n     */\n    public get unstableStickyInfo(): { duration_ms: number; duration_ttl_ms?: number } | undefined {\n        if (!this.event.msc4354_sticky?.duration_ms) {\n            return undefined;\n        }\n        return {\n            duration_ms: Math.min(MAX_STICKY_DURATION_MS, this.event.msc4354_sticky.duration_ms),\n            // This is assumed to be bounded server-side.\n            duration_ttl_ms: this.event.unsigned?.msc4354_sticky_duration_ttl_ms,\n        };\n    }\n}\n\n/* REDACT_KEEP_KEYS gives the keys we keep when an event is redacted\n *\n * This is specified here:\n *  http://matrix.org/speculator/spec/HEAD/client_server/latest.html#redactions\n *\n * Also:\n *  - We keep 'unsigned' since that is created by the local server\n *  - We keep user_id for backwards-compat with v1\n */\nconst REDACT_KEEP_KEYS = new Set([\n    \"event_id\",\n    \"type\",\n    \"room_id\",\n    \"user_id\",\n    \"sender\",\n    \"state_key\",\n    \"prev_state\",\n    \"content\",\n    \"unsigned\",\n    \"origin_server_ts\",\n]);\n\n// a map from state event type to the .content keys we keep when an event is redacted\nconst REDACT_KEEP_CONTENT_MAP: Record<string, Record<string, 1>> = {\n    [EventType.RoomMember]: { membership: 1 },\n    [EventType.RoomJoinRules]: { join_rule: 1 },\n    [EventType.RoomPowerLevels]: {\n        ban: 1,\n        events: 1,\n        events_default: 1,\n        kick: 1,\n        redact: 1,\n        state_default: 1,\n        users: 1,\n        users_default: 1,\n    },\n} as const;\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixClient } from \"../client.ts\";\nimport { type IContent, type MatrixEvent } from \"./event.ts\";\nimport { EventTimeline } from \"./event-timeline.ts\";\nimport { Preset } from \"../@types/partials.ts\";\nimport { globToRegexp } from \"../utils.ts\";\nimport { type Room } from \"./room.ts\";\nimport { EventType, type StateEvents } from \"../@types/event.ts\";\nimport {\n    IGNORE_INVITES_ACCOUNT_EVENT_KEY,\n    POLICIES_ACCOUNT_EVENT_TYPE,\n    PolicyRecommendation,\n    PolicyScope,\n} from \"./invites-ignorer-types.ts\";\n\nexport { IGNORE_INVITES_ACCOUNT_EVENT_KEY, POLICIES_ACCOUNT_EVENT_TYPE, PolicyRecommendation, PolicyScope };\n\nconst scopeToEventTypeMap: Record<PolicyScope, keyof StateEvents> = {\n    [PolicyScope.User]: EventType.PolicyRuleUser,\n    [PolicyScope.Room]: EventType.PolicyRuleRoom,\n    [PolicyScope.Server]: EventType.PolicyRuleServer,\n};\n\n/**\n * A container for ignored invites.\n *\n * # Performance\n *\n * This implementation is extremely naive. It expects that we are dealing\n * with a very short list of sources (e.g. only one). If real-world\n * applications turn out to require longer lists, we may need to rework\n * our data structures.\n */\nexport class IgnoredInvites {\n    public constructor(private readonly client: MatrixClient) {}\n\n    /**\n     * Add a new rule.\n     *\n     * @param scope - The scope for this rule.\n     * @param entity - The entity covered by this rule. Globs are supported.\n     * @param reason - A human-readable reason for introducing this new rule.\n     * @returns The event id for the new rule.\n     */\n    public async addRule(scope: PolicyScope, entity: string, reason: string): Promise<string> {\n        const target = await this.getOrCreateTargetRoom();\n        const response = await this.client.sendStateEvent(target.roomId, scopeToEventTypeMap[scope], {\n            entity,\n            reason,\n            recommendation: PolicyRecommendation.Ban,\n        });\n        return response.event_id;\n    }\n\n    /**\n     * Remove a rule.\n     */\n    public async removeRule(event: MatrixEvent): Promise<void> {\n        await this.client.redactEvent(event.getRoomId()!, event.getId()!);\n    }\n\n    /**\n     * Add a new room to the list of sources. If the user isn't a member of the\n     * room, attempt to join it.\n     *\n     * @param roomId - A valid room id. If this room is already in the list\n     * of sources, it will not be duplicated.\n     * @returns `true` if the source was added, `false` if it was already present.\n     * @throws If `roomId` isn't the id of a room that the current user is already\n     * member of or can join.\n     *\n     * # Safety\n     *\n     * This method will rewrite the `Policies` object in the user's account data.\n     * This rewrite is inherently racy and could overwrite or be overwritten by\n     * other concurrent rewrites of the same object.\n     */\n    public async addSource(roomId: string): Promise<boolean> {\n        // We attempt to join the room *before* calling\n        // `await this.getOrCreateSourceRooms()` to decrease the duration\n        // of the racy section.\n        await this.client.joinRoom(roomId);\n        // Race starts.\n        const sources = (await this.getOrCreateSourceRooms()).map((room) => room.roomId);\n        if (sources.includes(roomId)) {\n            return false;\n        }\n        sources.push(roomId);\n        await this.withIgnoreInvitesPolicies((ignoreInvitesPolicies) => {\n            ignoreInvitesPolicies.sources = sources;\n        });\n\n        // Race ends.\n        return true;\n    }\n\n    /**\n     * Find out whether an invite should be ignored.\n     *\n     * @param params\n     * @param params.sender - The user id for the user who issued the invite.\n     * @param params.roomId - The room to which the user is invited.\n     * @returns A rule matching the entity, if any was found, `null` otherwise.\n     */\n    public async getRuleForInvite({\n        sender,\n        roomId,\n    }: {\n        sender: string;\n        roomId: string;\n    }): Promise<Readonly<MatrixEvent | null>> {\n        // In this implementation, we perform a very naive lookup:\n        // - search in each policy room;\n        // - turn each (potentially glob) rule entity into a regexp.\n        //\n        // Real-world testing will tell us whether this is performant enough.\n        // In the (unfortunately likely) case it isn't, there are several manners\n        // in which we could optimize this:\n        // - match several entities per go;\n        // - pre-compile each rule entity into a regexp;\n        // - pre-compile entire rooms into a single regexp.\n        const policyRooms = await this.getOrCreateSourceRooms();\n        const senderServer = sender.split(\":\")[1];\n        const roomServer = roomId.split(\":\")[1];\n        for (const room of policyRooms) {\n            const state = room.getUnfilteredTimelineSet().getLiveTimeline().getState(EventTimeline.FORWARDS)!;\n\n            for (const { scope, entities } of [\n                { scope: PolicyScope.Room, entities: [roomId] },\n                { scope: PolicyScope.User, entities: [sender] },\n                { scope: PolicyScope.Server, entities: [senderServer, roomServer] },\n            ]) {\n                const events = state.getStateEvents(scopeToEventTypeMap[scope]);\n                for (const event of events) {\n                    const content = event.getContent();\n                    if (content?.recommendation != PolicyRecommendation.Ban) {\n                        // Ignoring invites only looks at `m.ban` recommendations.\n                        continue;\n                    }\n                    const glob = content?.entity;\n                    if (!glob) {\n                        // Invalid event.\n                        continue;\n                    }\n                    let regexp: RegExp;\n                    try {\n                        regexp = new RegExp(globToRegexp(glob));\n                    } catch {\n                        // Assume invalid event.\n                        continue;\n                    }\n                    for (const entity of entities) {\n                        if (entity && regexp.test(entity)) {\n                            return event;\n                        }\n                    }\n                    // No match.\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the target room, i.e. the room in which any new rule should be written.\n     *\n     * If there is no target room setup, a target room is created.\n     *\n     * Note: This method is public for testing reasons. Most clients should not need\n     * to call it directly.\n     *\n     * # Safety\n     *\n     * This method will rewrite the `Policies` object in the user's account data.\n     * This rewrite is inherently racy and could overwrite or be overwritten by\n     * other concurrent rewrites of the same object.\n     */\n    public async getOrCreateTargetRoom(): Promise<Room> {\n        const ignoreInvitesPolicies = this.getIgnoreInvitesPolicies();\n        let target = ignoreInvitesPolicies.target;\n        // Validate `target`. If it is invalid, trash out the current `target`\n        // and create a new room.\n        if (typeof target !== \"string\") {\n            target = null;\n        }\n        if (target) {\n            // Check that the room exists and is valid.\n            const room = this.client.getRoom(target);\n            if (room) {\n                return room;\n            } else {\n                target = null;\n            }\n        }\n        // We need to create our own policy room for ignoring invites.\n        target = (\n            await this.client.createRoom({\n                name: \"Individual Policy Room\",\n                preset: Preset.PrivateChat,\n            })\n        ).room_id;\n        await this.withIgnoreInvitesPolicies((ignoreInvitesPolicies) => {\n            ignoreInvitesPolicies.target = target;\n        });\n\n        // Since we have just called `createRoom`, `getRoom` should not be `null`.\n        return this.client.getRoom(target)!;\n    }\n\n    /**\n     * Get the list of source rooms, i.e. the rooms from which rules need to be read.\n     *\n     * If no source rooms are setup, the target room is used as sole source room.\n     *\n     * Note: This method is public for testing reasons. Most clients should not need\n     * to call it directly.\n     *\n     * # Safety\n     *\n     * This method will rewrite the `Policies` object in the user's account data.\n     * This rewrite is inherently racy and could overwrite or be overwritten by\n     * other concurrent rewrites of the same object.\n     */\n    public async getOrCreateSourceRooms(): Promise<Room[]> {\n        const ignoreInvitesPolicies = this.getIgnoreInvitesPolicies();\n        let sources: string[] = ignoreInvitesPolicies.sources;\n\n        // Validate `sources`. If it is invalid, trash out the current `sources`\n        // and create a new list of sources from `target`.\n        let hasChanges = false;\n        if (!Array.isArray(sources)) {\n            // `sources` could not be an array.\n            hasChanges = true;\n            sources = [];\n        }\n        let sourceRooms = sources\n            // `sources` could contain non-string / invalid room ids\n            .filter((roomId) => typeof roomId === \"string\")\n            .map((roomId) => this.client.getRoom(roomId))\n            .filter((room) => !!room) as Room[];\n        if (sourceRooms.length != sources.length) {\n            hasChanges = true;\n        }\n        if (sourceRooms.length == 0) {\n            // `sources` could be empty (possibly because we've removed\n            // invalid content)\n            const target = await this.getOrCreateTargetRoom();\n            hasChanges = true;\n            sourceRooms = [target];\n        }\n        if (hasChanges) {\n            // Reload `policies`/`ignoreInvitesPolicies` in case it has been changed\n            // during or by our call to `this.getTargetRoom()`.\n            await this.withIgnoreInvitesPolicies((ignoreInvitesPolicies) => {\n                ignoreInvitesPolicies.sources = sources;\n            });\n        }\n        return sourceRooms;\n    }\n\n    /**\n     * Fetch the `IGNORE_INVITES_POLICIES` object from account data.\n     *\n     * If both an unstable prefix version and a stable prefix version are available,\n     * it will return the stable prefix version preferentially.\n     *\n     * The result is *not* validated but is guaranteed to be a non-null object.\n     *\n     * @returns A non-null object.\n     */\n    private getIgnoreInvitesPolicies(): { [key: string]: any } {\n        return this.getPoliciesAndIgnoreInvitesPolicies().ignoreInvitesPolicies;\n    }\n\n    /**\n     * Modify in place the `IGNORE_INVITES_POLICIES` object from account data.\n     */\n    private async withIgnoreInvitesPolicies(\n        cb: (ignoreInvitesPolicies: { [key: string]: any }) => void,\n    ): Promise<void> {\n        const { policies, ignoreInvitesPolicies } = this.getPoliciesAndIgnoreInvitesPolicies();\n        cb(ignoreInvitesPolicies);\n        policies[IGNORE_INVITES_ACCOUNT_EVENT_KEY.name] = ignoreInvitesPolicies;\n        await this.client.setAccountData(POLICIES_ACCOUNT_EVENT_TYPE.name, policies);\n    }\n\n    /**\n     * As `getIgnoreInvitesPolicies` but also return the `POLICIES_ACCOUNT_EVENT_TYPE`\n     * object.\n     */\n    private getPoliciesAndIgnoreInvitesPolicies(): {\n        policies: { [key: string]: any };\n        ignoreInvitesPolicies: { [key: string]: any };\n    } {\n        let policies: IContent = {};\n        for (const key of [POLICIES_ACCOUNT_EVENT_TYPE.name, POLICIES_ACCOUNT_EVENT_TYPE.altName]) {\n            if (!key) {\n                continue;\n            }\n            const value = this.client.getAccountData(key)?.getContent();\n            if (value) {\n                policies = value;\n                break;\n            }\n        }\n\n        let ignoreInvitesPolicies = {};\n        let hasIgnoreInvitesPolicies = false;\n        for (const key of [IGNORE_INVITES_ACCOUNT_EVENT_KEY.name, IGNORE_INVITES_ACCOUNT_EVENT_KEY.altName]) {\n            if (!key) {\n                continue;\n            }\n            const value = policies[key];\n            if (value && typeof value == \"object\") {\n                ignoreInvitesPolicies = value;\n                hasIgnoreInvitesPolicies = true;\n                break;\n            }\n        }\n        if (!hasIgnoreInvitesPolicies) {\n            policies[IGNORE_INVITES_ACCOUNT_EVENT_KEY.name] = ignoreInvitesPolicies;\n        }\n\n        return { policies, ignoreInvitesPolicies };\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { M_POLL_START } from \"matrix-events-sdk\";\n\nimport { M_POLL_END, M_POLL_RESPONSE } from \"../@types/polls.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { type PollStartEvent } from \"../extensible_events_v1/PollStartEvent.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { Relations } from \"./relations.ts\";\nimport { type Room } from \"./room.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\n\nexport enum PollEvent {\n    New = \"Poll.new\",\n    End = \"Poll.end\",\n    Update = \"Poll.update\",\n    Responses = \"Poll.Responses\",\n    Destroy = \"Poll.Destroy\",\n    UndecryptableRelations = \"Poll.UndecryptableRelations\",\n}\n\nexport type PollEventHandlerMap = {\n    [PollEvent.Update]: (event: MatrixEvent, poll: Poll) => void;\n    [PollEvent.Destroy]: (pollIdentifier: string) => void;\n    [PollEvent.End]: () => void;\n    [PollEvent.Responses]: (responses: Relations) => void;\n    [PollEvent.UndecryptableRelations]: (count: number) => void;\n};\n\nconst filterResponseRelations = (\n    relationEvents: MatrixEvent[],\n    pollEndTimestamp: number,\n): {\n    responseEvents: MatrixEvent[];\n} => {\n    const responseEvents = relationEvents.filter((event) => {\n        if (event.isDecryptionFailure()) {\n            return;\n        }\n        return (\n            M_POLL_RESPONSE.matches(event.getType()) &&\n            // From MSC3381:\n            // \"Votes sent on or before the end event's timestamp are valid votes\"\n            event.getTs() <= pollEndTimestamp\n        );\n    });\n\n    return { responseEvents };\n};\n\nexport class Poll extends TypedEventEmitter<Exclude<PollEvent, PollEvent.New>, PollEventHandlerMap> {\n    public readonly roomId: string;\n    public readonly pollEvent: PollStartEvent;\n    private _isFetchingResponses = false;\n    private relationsNextBatch: string | undefined;\n    private responses: null | Relations = null;\n    private endEvent: MatrixEvent | undefined;\n    /**\n     * Keep track of undecryptable relations\n     * As incomplete result sets affect poll results\n     */\n    private undecryptableRelationEventIds = new Set<string>();\n\n    public constructor(\n        public readonly rootEvent: MatrixEvent,\n        private matrixClient: MatrixClient,\n        private room: Room,\n    ) {\n        super();\n        if (!this.rootEvent.getRoomId() || !this.rootEvent.getId()) {\n            throw new Error(\"Invalid poll start event.\");\n        }\n        this.roomId = this.rootEvent.getRoomId()!;\n        this.pollEvent = this.rootEvent.unstableExtensibleEvent as unknown as PollStartEvent;\n    }\n\n    public get pollId(): string {\n        return this.rootEvent.getId()!;\n    }\n\n    public get endEventId(): string | undefined {\n        return this.endEvent?.getId();\n    }\n\n    public get isEnded(): boolean {\n        return !!this.endEvent;\n    }\n\n    public get isFetchingResponses(): boolean {\n        return this._isFetchingResponses;\n    }\n\n    public get undecryptableRelationsCount(): number {\n        return this.undecryptableRelationEventIds.size;\n    }\n\n    public async getResponses(): Promise<Relations> {\n        // if we have already fetched some responses\n        // just return them\n        if (this.responses) {\n            return this.responses;\n        }\n\n        // if there is no fetching in progress\n        // start fetching\n        if (!this.isFetchingResponses) {\n            await this.fetchResponses();\n        }\n        // return whatever responses we got from the first page\n        return this.responses!;\n    }\n\n    /**\n     *\n     * @param event - event with a relation to the rootEvent\n     * @returns void\n     */\n    public onNewRelation(event: MatrixEvent): void {\n        if (M_POLL_END.matches(event.getType()) && this.validateEndEvent(event)) {\n            this.endEvent = event;\n            this.refilterResponsesOnEnd();\n            this.emit(PollEvent.End);\n        }\n\n        // wait for poll responses to be initialised\n        if (!this.responses) {\n            return;\n        }\n\n        const pollEndTimestamp = this.endEvent?.getTs() || Number.MAX_SAFE_INTEGER;\n        const { responseEvents } = filterResponseRelations([event], pollEndTimestamp);\n\n        this.countUndecryptableEvents([event]);\n\n        if (responseEvents.length) {\n            responseEvents.forEach((event) => {\n                this.responses!.addEvent(event);\n            });\n\n            this.emit(PollEvent.Responses, this.responses);\n        }\n    }\n\n    private async fetchResponses(): Promise<void> {\n        this._isFetchingResponses = true;\n\n        // we want:\n        // - stable and unstable M_POLL_RESPONSE\n        // - stable and unstable M_POLL_END\n        // so make one api call and filter by event type client side\n        const allRelations = await this.matrixClient.relations(\n            this.roomId,\n            this.rootEvent.getId()!,\n            \"m.reference\",\n            undefined,\n            {\n                from: this.relationsNextBatch || undefined,\n            },\n        );\n\n        await Promise.all(allRelations.events.map((event) => this.matrixClient.decryptEventIfNeeded(event)));\n\n        const responses =\n            this.responses ||\n            new Relations(\"m.reference\", M_POLL_RESPONSE.name, this.matrixClient, [M_POLL_RESPONSE.altName!]);\n\n        const pollEndEvent = allRelations.events.find((event) => M_POLL_END.matches(event.getType()));\n\n        if (this.validateEndEvent(pollEndEvent)) {\n            this.endEvent = pollEndEvent;\n            this.refilterResponsesOnEnd();\n            this.emit(PollEvent.End);\n        }\n\n        const pollCloseTimestamp = this.endEvent?.getTs() || Number.MAX_SAFE_INTEGER;\n\n        const { responseEvents } = filterResponseRelations(allRelations.events, pollCloseTimestamp);\n\n        responseEvents.forEach((event) => {\n            responses.addEvent(event);\n        });\n\n        this.relationsNextBatch = allRelations.nextBatch ?? undefined;\n        this.responses = responses;\n        this.countUndecryptableEvents(allRelations.events);\n\n        // while there are more pages of relations\n        // fetch them\n        if (this.relationsNextBatch) {\n            // don't await\n            // we want to return the first page as soon as possible\n            this.fetchResponses();\n        } else {\n            // no more pages\n            this._isFetchingResponses = false;\n        }\n\n        // emit after updating _isFetchingResponses state\n        this.emit(PollEvent.Responses, this.responses);\n    }\n\n    /**\n     * Only responses made before the poll ended are valid\n     * Refilter after an end event is recieved\n     * To ensure responses are valid\n     */\n    private refilterResponsesOnEnd(): void {\n        if (!this.responses) {\n            return;\n        }\n\n        const pollEndTimestamp = this.endEvent?.getTs() || Number.MAX_SAFE_INTEGER;\n        this.responses.getRelations().forEach((event) => {\n            if (event.getTs() > pollEndTimestamp) {\n                this.responses?.removeEvent(event);\n            }\n        });\n\n        this.emit(PollEvent.Responses, this.responses);\n    }\n\n    private countUndecryptableEvents = (events: MatrixEvent[]): void => {\n        const undecryptableEventIds = events\n            .filter((event) => event.isDecryptionFailure())\n            .map((event) => event.getId()!);\n\n        const previousCount = this.undecryptableRelationsCount;\n        this.undecryptableRelationEventIds = new Set([...this.undecryptableRelationEventIds, ...undecryptableEventIds]);\n\n        if (this.undecryptableRelationsCount !== previousCount) {\n            this.emit(PollEvent.UndecryptableRelations, this.undecryptableRelationsCount);\n        }\n    };\n\n    private validateEndEvent(endEvent?: MatrixEvent): boolean {\n        if (!endEvent) {\n            return false;\n        }\n        /**\n         * Repeated end events are ignored -\n         * only the first (valid) closure event by origin_server_ts is counted.\n         */\n        if (this.endEvent && this.endEvent.getTs() < endEvent.getTs()) {\n            return false;\n        }\n\n        /**\n         * MSC3381\n         * If a m.poll.end event is received from someone other than the poll creator or user with permission to redact\n         * others' messages in the room, the event must be ignored by clients due to being invalid.\n         */\n        const roomCurrentState = this.room.currentState;\n        const endEventSender = endEvent.getSender();\n        return (\n            !!endEventSender &&\n            (endEventSender === this.rootEvent.getSender() ||\n                roomCurrentState.maySendRedactionForEvent(this.rootEvent, endEventSender))\n        );\n    }\n}\n\n/**\n * Tests whether the event is a start, response or end poll event.\n *\n * @param event - Event to test\n * @returns true if the event is a poll event, else false\n */\nexport const isPollEvent = (event: MatrixEvent): boolean => {\n    const eventType = event.getType();\n    return M_POLL_START.matches(eventType) || M_POLL_RESPONSE.matches(eventType) || M_POLL_END.matches(eventType);\n};\n","/*\nCopyright 2019, 2021, 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EventStatus, type IAggregatedRelation, type MatrixEvent, MatrixEventEvent } from \"./event.ts\";\nimport { logger } from \"../logger.ts\";\nimport { RelationType } from \"../@types/event.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { Room } from \"./room.ts\";\nimport { type CryptoBackend } from \"../common-crypto/CryptoBackend.ts\";\n\nexport enum RelationsEvent {\n    Add = \"Relations.add\",\n    Remove = \"Relations.remove\",\n    Redaction = \"Relations.redaction\",\n}\n\nexport type EventHandlerMap = {\n    [RelationsEvent.Add]: (event: MatrixEvent) => void;\n    [RelationsEvent.Remove]: (event: MatrixEvent) => void;\n    [RelationsEvent.Redaction]: (event: MatrixEvent) => void;\n};\n\nconst matchesEventType = (eventType: string, targetEventType: string, altTargetEventTypes: string[] = []): boolean =>\n    [targetEventType, ...altTargetEventTypes].includes(eventType);\n\n/**\n * A container for relation events that supports easy access to common ways of\n * aggregating such events. Each instance holds events that of a single relation\n * type and event type. All of the events also relate to the same original event.\n *\n * The typical way to get one of these containers is via\n * EventTimelineSet#getRelationsForEvent.\n */\nexport class Relations extends TypedEventEmitter<RelationsEvent, EventHandlerMap> {\n    private relationEventIds = new Set<string>();\n    private relations = new Set<MatrixEvent>();\n    private annotationsByKey: Record<string, Set<MatrixEvent>> = {};\n    private annotationsBySender: Record<string, Set<MatrixEvent>> = {};\n    private sortedAnnotationsByKey: [string, Set<MatrixEvent>][] = [];\n    private targetEvent: MatrixEvent | null = null;\n    private creationEmitted = false;\n    private readonly client: MatrixClient;\n\n    /**\n     * @param relationType - The type of relation involved, such as \"m.annotation\", \"m.reference\", \"m.replace\", etc.\n     * @param eventType - The relation event's type, such as \"m.reaction\", etc.\n     * @param client - The client which created this instance. For backwards compatibility also accepts a Room.\n     * @param altEventTypes - alt event types for relation events, for example to support unstable prefixed event types\n     */\n    public constructor(\n        public readonly relationType: RelationType | string,\n        public readonly eventType: string,\n        client: MatrixClient | Room,\n        public readonly altEventTypes?: string[],\n    ) {\n        super();\n        this.client = client instanceof Room ? client.client : client;\n    }\n\n    /**\n     * Add relation events to this collection.\n     *\n     * @param event - The new relation event to be added.\n     */\n    public async addEvent(event: MatrixEvent): Promise<void> {\n        if (this.relationEventIds.has(event.getId()!)) {\n            return;\n        }\n\n        const relation = event.getRelation();\n        if (!relation) {\n            logger.error(\"Event must have relation info\");\n            return;\n        }\n\n        const relationType = relation.rel_type;\n        const eventType = event.getType();\n\n        if (this.relationType !== relationType || !matchesEventType(eventType, this.eventType, this.altEventTypes)) {\n            logger.error(\"Event relation info doesn't match this container\");\n            return;\n        }\n\n        // If the event is in the process of being sent, listen for cancellation\n        // so we can remove the event from the collection.\n        if (event.isSending()) {\n            event.on(MatrixEventEvent.Status, this.onEventStatus);\n        }\n\n        this.relations.add(event);\n        this.relationEventIds.add(event.getId()!);\n\n        if (this.relationType === RelationType.Annotation) {\n            this.addAnnotationToAggregation(event);\n        } else if (this.relationType === RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {\n            const lastReplacement = await this.getLastReplacement();\n            this.targetEvent.makeReplaced(lastReplacement!);\n        }\n\n        event.on(MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction);\n\n        this.emit(RelationsEvent.Add, event);\n\n        this.maybeEmitCreated();\n    }\n\n    /**\n     * Remove relation event from this collection.\n     *\n     * @param event - The relation event to remove.\n     */\n    public async removeEvent(event: MatrixEvent): Promise<void> {\n        if (!this.relations.has(event)) {\n            return;\n        }\n\n        this.relations.delete(event);\n\n        if (this.relationType === RelationType.Annotation) {\n            this.removeAnnotationFromAggregation(event);\n        } else if (this.relationType === RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {\n            const lastReplacement = await this.getLastReplacement();\n            this.targetEvent.makeReplaced(lastReplacement!);\n        }\n\n        this.emit(RelationsEvent.Remove, event);\n    }\n\n    /**\n     * Listens for event status changes to remove cancelled events.\n     *\n     * @param event - The event whose status has changed\n     * @param status - The new status\n     */\n    private onEventStatus = (event: MatrixEvent, status: EventStatus | null): void => {\n        if (!event.isSending()) {\n            // Sending is done, so we don't need to listen anymore\n            event.removeListener(MatrixEventEvent.Status, this.onEventStatus);\n            return;\n        }\n        if (status !== EventStatus.CANCELLED) {\n            return;\n        }\n        // Event was cancelled, remove from the collection\n        event.removeListener(MatrixEventEvent.Status, this.onEventStatus);\n        this.removeEvent(event);\n    };\n\n    /**\n     * Get all relation events in this collection.\n     *\n     * These are currently in the order of insertion to this collection, which\n     * won't match timeline order in the case of scrollback.\n     * TODO: Tweak `addEvent` to insert correctly for scrollback.\n     *\n     * Relation events in insertion order.\n     */\n    public getRelations(): MatrixEvent[] {\n        return [...this.relations];\n    }\n\n    private addAnnotationToAggregation(event: MatrixEvent): void {\n        const { key } = event.getRelation() ?? {};\n        if (!key) return;\n\n        let eventsForKey = this.annotationsByKey[key];\n        if (!eventsForKey) {\n            eventsForKey = this.annotationsByKey[key] = new Set();\n            this.sortedAnnotationsByKey.push([key, eventsForKey]);\n        }\n        // Add the new event to the set for this key\n        eventsForKey.add(event);\n        // Re-sort the [key, events] pairs in descending order of event count\n        this.sortedAnnotationsByKey.sort((a, b) => {\n            const aEvents = a[1];\n            const bEvents = b[1];\n            return bEvents.size - aEvents.size;\n        });\n\n        const sender = event.getSender()!;\n        let eventsFromSender = this.annotationsBySender[sender];\n        if (!eventsFromSender) {\n            eventsFromSender = this.annotationsBySender[sender] = new Set();\n        }\n        // Add the new event to the set for this sender\n        eventsFromSender.add(event);\n    }\n\n    private removeAnnotationFromAggregation(event: MatrixEvent): void {\n        const { key } = event.getRelation() ?? {};\n        if (!key) return;\n\n        const eventsForKey = this.annotationsByKey[key];\n        if (eventsForKey) {\n            eventsForKey.delete(event);\n\n            // Re-sort the [key, events] pairs in descending order of event count\n            this.sortedAnnotationsByKey.sort((a, b) => {\n                const aEvents = a[1];\n                const bEvents = b[1];\n                return bEvents.size - aEvents.size;\n            });\n        }\n\n        const sender = event.getSender()!;\n        const eventsFromSender = this.annotationsBySender[sender];\n        if (eventsFromSender) {\n            eventsFromSender.delete(event);\n        }\n    }\n\n    /**\n     * For relations that have been redacted, we want to remove them from\n     * aggregation data sets and emit an update event.\n     *\n     * To do so, we listen for `Event.beforeRedaction`, which happens:\n     *   - after the server accepted the redaction and remote echoed back to us\n     *   - before the original event has been marked redacted in the client\n     *\n     * @param redactedEvent - The original relation event that is about to be redacted.\n     */\n    private onBeforeRedaction = async (redactedEvent: MatrixEvent): Promise<void> => {\n        if (!this.relations.has(redactedEvent)) {\n            return;\n        }\n\n        this.relations.delete(redactedEvent);\n\n        if (this.relationType === RelationType.Annotation) {\n            // Remove the redacted annotation from aggregation by key\n            this.removeAnnotationFromAggregation(redactedEvent);\n        } else if (this.relationType === RelationType.Replace && this.targetEvent && !this.targetEvent.isState()) {\n            const lastReplacement = await this.getLastReplacement();\n            this.targetEvent.makeReplaced(lastReplacement!);\n        }\n\n        redactedEvent.removeListener(MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction);\n\n        this.emit(RelationsEvent.Redaction, redactedEvent);\n    };\n\n    /**\n     * Get all events in this collection grouped by key and sorted by descending\n     * event count in each group.\n     *\n     * This is currently only supported for the annotation relation type.\n     *\n     * An array of [key, events] pairs sorted by descending event count.\n     * The events are stored in a Set (which preserves insertion order).\n     */\n    public getSortedAnnotationsByKey(): [string, Set<MatrixEvent>][] | null {\n        if (this.relationType !== RelationType.Annotation) {\n            // Other relation types are not grouped currently.\n            return null;\n        }\n\n        return this.sortedAnnotationsByKey;\n    }\n\n    /**\n     * Get all events in this collection grouped by sender.\n     *\n     * This is currently only supported for the annotation relation type.\n     *\n     * An object with each relation sender as a key and the matching Set of\n     * events for that sender as a value.\n     */\n    public getAnnotationsBySender(): Record<string, Set<MatrixEvent>> | null {\n        if (this.relationType !== RelationType.Annotation) {\n            // Other relation types are not grouped currently.\n            return null;\n        }\n\n        return this.annotationsBySender;\n    }\n\n    /**\n     * Returns the most recent (and allowed) m.replace relation, if any.\n     *\n     * This is currently only supported for the m.replace relation type,\n     * once the target event is known, see `addEvent`.\n     */\n    public async getLastReplacement(): Promise<MatrixEvent | null> {\n        if (this.relationType !== RelationType.Replace) {\n            // Aggregating on last only makes sense for this relation type\n            return null;\n        }\n        if (!this.targetEvent) {\n            // Don't know which replacements to accept yet.\n            // This method shouldn't be called before the original\n            // event is known anyway.\n            return null;\n        }\n\n        // the all-knowning server tells us that the event at some point had\n        // this timestamp for its replacement, so any following replacement should definitely not be less\n        const replaceRelation = this.targetEvent.getServerAggregatedRelation<IAggregatedRelation>(RelationType.Replace);\n        const minTs = replaceRelation?.origin_server_ts;\n\n        const lastReplacement = this.getRelations().reduce<MatrixEvent | null>((last, event) => {\n            if (event.getSender() !== this.targetEvent!.getSender()) {\n                return last;\n            }\n            if (minTs && minTs > event.getTs()) {\n                return last;\n            }\n            if (last && last.getTs() > event.getTs()) {\n                return last;\n            }\n            return event;\n        }, null);\n\n        if (lastReplacement?.shouldAttemptDecryption() && this.client.getCrypto()) {\n            // Dirty but we are expecting to pass the cryptoBackend which is not accessible here\n            await lastReplacement.attemptDecryption(this.client.getCrypto() as CryptoBackend);\n        } else if (lastReplacement?.isBeingDecrypted()) {\n            await lastReplacement.getDecryptionPromise();\n        }\n\n        return lastReplacement;\n    }\n\n    /*\n     * @param targetEvent - the event the relations are related to.\n     */\n    public async setTargetEvent(event: MatrixEvent): Promise<void> {\n        if (this.targetEvent) {\n            return;\n        }\n        this.targetEvent = event;\n\n        if (this.relationType === RelationType.Replace && !this.targetEvent.isState()) {\n            const replacement = await this.getLastReplacement();\n            // this is the initial update, so only call it if we already have something\n            // to not emit Event.replaced needlessly\n            if (replacement) {\n                this.targetEvent.makeReplaced(replacement);\n            }\n        }\n\n        this.maybeEmitCreated();\n    }\n\n    private maybeEmitCreated(): void {\n        if (this.creationEmitted) {\n            return;\n        }\n        // Only emit we're \"created\" once we have a target event instance _and_\n        // at least one related event.\n        if (!this.targetEvent || !this.relations.size) {\n            return;\n        }\n        this.creationEmitted = true;\n        this.targetEvent.emit(MatrixEventEvent.RelationsCreated, this.relationType, this.eventType);\n    }\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { getHttpUriForMxc } from \"../content-repo.ts\";\nimport { removeDirectionOverrideChars, removeHiddenChars } from \"../utils.ts\";\nimport { type User } from \"./user.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { type RoomState } from \"./room-state.ts\";\nimport { logger } from \"../logger.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { KnownMembership, type Membership } from \"../@types/membership.ts\";\n\nexport enum RoomMemberEvent {\n    Membership = \"RoomMember.membership\",\n    Name = \"RoomMember.name\",\n    PowerLevel = \"RoomMember.powerLevel\",\n    Typing = \"RoomMember.typing\",\n}\n\nexport type RoomMemberEventHandlerMap = {\n    /**\n     * Fires whenever any room member's membership state changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param member - The member whose RoomMember.membership changed.\n     * @param oldMembership - The previous membership state. Null if it's a new member.\n     * @example\n     * ```\n     * matrixClient.on(\"RoomMember.membership\", function(event, member, oldMembership){\n     *   var newState = member.membership;\n     * });\n     * ```\n     */\n    [RoomMemberEvent.Membership]: (event: MatrixEvent, member: RoomMember, oldMembership?: string) => void;\n    /**\n     * Fires whenever any room member's name changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param member - The member whose RoomMember.name changed.\n     * @param oldName - The previous name. Null if the member didn't have a name previously.\n     * @example\n     * ```\n     * matrixClient.on(\"RoomMember.name\", function(event, member){\n     *   var newName = member.name;\n     * });\n     * ```\n     */\n    [RoomMemberEvent.Name]: (event: MatrixEvent, member: RoomMember, oldName: string | null) => void;\n    /**\n     * Fires whenever any room member's power level changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param member - The member whose RoomMember.powerLevel changed.\n     * @example\n     * ```\n     * matrixClient.on(\"RoomMember.powerLevel\", function(event, member){\n     *   var newPowerLevel = member.powerLevel;\n     * });\n     * ```\n     */\n    [RoomMemberEvent.PowerLevel]: (event: MatrixEvent, member: RoomMember) => void;\n    /**\n     * Fires whenever any room member's typing state changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param member - The member whose RoomMember.typing changed.\n     * @example\n     * ```\n     * matrixClient.on(\"RoomMember.typing\", function(event, member){\n     *   var isTyping = member.typing;\n     * });\n     * ```\n     */\n    [RoomMemberEvent.Typing]: (event: MatrixEvent, member: RoomMember) => void;\n};\n\nexport class RoomMember extends TypedEventEmitter<RoomMemberEvent, RoomMemberEventHandlerMap> {\n    private _isOutOfBand = false;\n    private modified = -1;\n    public requestedProfileInfo = false; // used by sync.ts\n\n    // XXX these should be read-only\n    /**\n     * True if the room member is currently typing.\n     */\n    public typing = false;\n\n    /**\n     * The human-readable name for this room member. Similar to {@link rawDisplayName}, but\n     * disambiguated with a suffix of \" (\\@user_id:matrix.org)\" if another member shares the\n     * same displayname.\n     */\n    public name: string;\n\n    /**\n     * The ambiguous displayname of this room member, with some preprocessing:\n     *\n     *  * Direction override characters (RTO and LRO) are removed.\n     *  * If the displayname is empty, or contains only blank, non-printing, or diacritcic characters, it is\n     *    replaced with the user ID.\n     */\n    public rawDisplayName: string;\n\n    /**\n     * The power level for this room member.\n     */\n    public powerLevel = 0;\n    /**\n     * The User object for this room member, if one exists.\n     */\n    public user?: User;\n    /**\n     * The membership state for this room member e.g. 'join'.\n     */\n    public membership?: Membership;\n    /**\n     * True if the member's name is disambiguated.\n     */\n    public disambiguate = false;\n    /**\n     * The events describing this RoomMember.\n     */\n    public events: {\n        /**\n         * The m.room.member event for this RoomMember.\n         */\n        member?: MatrixEvent;\n    } = {};\n\n    /**\n     * Construct a new room member.\n     *\n     * @param roomId - The room ID of the member.\n     * @param userId - The user ID of the member.\n     */\n    public constructor(\n        public readonly roomId: string,\n        public readonly userId: string,\n    ) {\n        super();\n\n        this.name = userId;\n        this.rawDisplayName = userId;\n        this.updateModifiedTime();\n    }\n\n    /**\n     * Mark the member as coming from a channel that is not sync\n     */\n    public markOutOfBand(): void {\n        this._isOutOfBand = true;\n    }\n\n    /**\n     * @returns does the member come from a channel that is not sync?\n     * This is used to store the member seperately\n     * from the sync state so it available across browser sessions.\n     */\n    public isOutOfBand(): boolean {\n        return this._isOutOfBand;\n    }\n\n    /**\n     * Update this room member's membership event. May fire \"RoomMember.name\" if\n     * this event updates this member's name.\n     * @param event - The `m.room.member` event\n     * @param roomState - Optional. The room state to take into account\n     * when calculating (e.g. for disambiguating users with the same name).\n     *\n     * @remarks\n     * Fires {@link RoomMemberEvent.Name}\n     * Fires {@link RoomMemberEvent.Membership}\n     */\n    public setMembershipEvent(event: MatrixEvent, roomState?: RoomState): void {\n        const displayName = event.getDirectionalContent().displayname ?? \"\";\n\n        if (event.getType() !== EventType.RoomMember) {\n            return;\n        }\n\n        this._isOutOfBand = false;\n\n        this.events.member = event;\n\n        const oldMembership = this.membership;\n        this.membership = event.getDirectionalContent().membership;\n        if (this.membership === undefined) {\n            // logging to diagnose https://github.com/vector-im/element-web/issues/20962\n            // (logs event content, although only of membership events)\n            logger.trace(\n                `membership event with membership undefined (forwardLooking: ${event.forwardLooking})!`,\n                event.getContent(),\n                `prevcontent is `,\n                event.getPrevContent(),\n            );\n        }\n\n        this.disambiguate = shouldDisambiguate(this.userId, displayName, roomState);\n\n        const oldName = this.name;\n        this.name = calculateDisplayName(this.userId, displayName, this.disambiguate);\n\n        // not quite raw: we strip direction override chars so it can safely be inserted into\n        // blocks of text without breaking the text direction\n        this.rawDisplayName = removeDirectionOverrideChars(event.getDirectionalContent().displayname ?? \"\");\n        if (!this.rawDisplayName || !removeHiddenChars(this.rawDisplayName)) {\n            this.rawDisplayName = this.userId;\n        }\n\n        if (oldMembership !== this.membership) {\n            this.updateModifiedTime();\n            this.emit(RoomMemberEvent.Membership, event, this, oldMembership);\n        }\n        if (oldName !== this.name) {\n            this.updateModifiedTime();\n            this.emit(RoomMemberEvent.Name, event, this, oldName);\n        }\n    }\n\n    /**\n     * Update this room member's power level event. Will fire\n     * \"RoomMember.powerLevel\" if the new power level is different\n     * @param powerLevel - The power level of the room member.\n     *\n     * @remarks\n     * Fires {@link RoomMemberEvent.PowerLevel}\n     */\n    public setPowerLevel(powerLevel: number, powerLevelEvent: MatrixEvent): void {\n        const oldPowerLevel = this.powerLevel;\n        this.powerLevel = powerLevel;\n\n        if (oldPowerLevel !== this.powerLevel) {\n            this.updateModifiedTime();\n            this.emit(RoomMemberEvent.PowerLevel, powerLevelEvent, this);\n        }\n    }\n\n    /**\n     * Update this room member's typing event. May fire \"RoomMember.typing\" if\n     * this event changes this member's typing state.\n     * @param event - The typing event\n     *\n     * @remarks\n     * Fires {@link RoomMemberEvent.Typing}\n     */\n    public setTypingEvent(event: MatrixEvent): void {\n        if (event.getType() !== \"m.typing\") {\n            return;\n        }\n        const oldTyping = this.typing;\n        this.typing = false;\n        const typingList = event.getContent().user_ids;\n        if (!Array.isArray(typingList)) {\n            // malformed event :/ bail early. TODO: whine?\n            return;\n        }\n        if (typingList.indexOf(this.userId) !== -1) {\n            this.typing = true;\n        }\n        if (oldTyping !== this.typing) {\n            this.updateModifiedTime();\n            this.emit(RoomMemberEvent.Typing, event, this);\n        }\n    }\n\n    /**\n     * Update the last modified time to the current time.\n     */\n    private updateModifiedTime(): void {\n        this.modified = Date.now();\n    }\n\n    /**\n     * Get the timestamp when this RoomMember was last updated. This timestamp is\n     * updated when properties on this RoomMember are updated.\n     * It is updated <i>before</i> firing events.\n     * @returns The timestamp\n     */\n    public getLastModifiedTime(): number {\n        return this.modified;\n    }\n\n    public isKicked(): boolean {\n        return (\n            this.membership === KnownMembership.Leave &&\n            this.events.member !== undefined &&\n            this.events.member.getSender() !== this.events.member.getStateKey()\n        );\n    }\n\n    /**\n     * If this member was invited with the is_direct flag set, return\n     * the user that invited this member\n     * @returns user id of the inviter\n     */\n    public getDMInviter(): string | undefined {\n        // when not available because that room state hasn't been loaded in,\n        // we don't really know, but more likely to not be a direct chat\n        if (this.events.member) {\n            // TODO: persist the is_direct flag on the member as more member events\n            //       come in caused by displayName changes.\n\n            // the is_direct flag is set on the invite member event.\n            // This is copied on the prev_content section of the join member event\n            // when the invite is accepted.\n\n            const memberEvent = this.events.member;\n            let memberContent = memberEvent.getContent();\n            let inviteSender: string | undefined = memberEvent.getSender();\n\n            if (memberContent.membership === KnownMembership.Join) {\n                memberContent = memberEvent.getPrevContent();\n                inviteSender = memberEvent.getUnsigned().prev_sender;\n            }\n\n            if (memberContent.membership === KnownMembership.Invite && memberContent.is_direct) {\n                return inviteSender;\n            }\n        }\n    }\n\n    /**\n     * Get the avatar URL for a room member.\n     * @param baseUrl - The base homeserver URL See\n     * {@link MatrixClient#getHomeserverUrl}.\n     * @param width - The desired width of the thumbnail.\n     * @param height - The desired height of the thumbnail.\n     * @param resizeMethod - The thumbnail resize method to use, either\n     * \"crop\" or \"scale\".\n     * @param allowDefault - (optional) Passing false causes this method to\n     * return null if the user has no avatar image. Otherwise, a default image URL\n     * will be returned. Default: true. (Deprecated)\n     * @param allowDirectLinks - (optional) If true, the avatar URL will be\n     * returned even if it is a direct hyperlink rather than a matrix content URL.\n     * If false, any non-matrix content URLs will be ignored. Setting this option to\n     * true will expose URLs that, if fetched, will leak information about the user\n     * to anyone who they share a room with.\n     * @param useAuthentication - (optional) If true, the caller supports authenticated\n     * media and wants an authentication-required URL. Note that server support for\n     * authenticated media will not be checked - it is the caller's responsibility\n     * to do so before calling this function. Note also that useAuthentication\n     * implies allowRedirects. Defaults to false (unauthenticated endpoints).\n     * @returns the avatar URL or null.\n     */\n    public getAvatarUrl(\n        baseUrl: string,\n        width: number,\n        height: number,\n        resizeMethod: string,\n        allowDefault = true,\n        allowDirectLinks: boolean,\n        useAuthentication: boolean = false,\n    ): string | null {\n        const rawUrl = this.getMxcAvatarUrl();\n\n        if (!rawUrl && !allowDefault) {\n            return null;\n        }\n        const httpUrl = getHttpUriForMxc(\n            baseUrl,\n            rawUrl,\n            width,\n            height,\n            resizeMethod,\n            allowDirectLinks,\n            undefined,\n            useAuthentication,\n        );\n        if (httpUrl) {\n            return httpUrl;\n        }\n        return null;\n    }\n\n    /**\n     * get the mxc avatar url, either from a state event, or from a lazily loaded member\n     * @returns the mxc avatar url\n     */\n    public getMxcAvatarUrl(): string | undefined {\n        if (this.events.member) {\n            return this.events.member.getDirectionalContent().avatar_url;\n        } else if (this.user) {\n            return this.user.avatarUrl;\n        }\n    }\n}\n\nexport const MXID_PATTERN = /@.+:.+/;\nconst LTR_RTL_PATTERN = /[\\u200E\\u200F\\u202A-\\u202F]/;\n\nfunction shouldDisambiguate(selfUserId: string, displayName?: string, roomState?: RoomState): boolean {\n    if (!displayName || displayName === selfUserId) return false;\n    if (!roomState) return false;\n\n    const strippedDisplayName = removeHiddenChars(displayName);\n\n    // First check if the displayname is something we consider truthy\n    // after stripping it of zero width characters and padding spaces\n    if (!strippedDisplayName) return false;\n\n    // Next check if the name contains something that look like a mxid\n    // If it does, it may be someone trying to impersonate someone else\n    // Show full mxid in this case\n    if (MXID_PATTERN.test(strippedDisplayName)) return true;\n\n    // Also show mxid if the display name contains any LTR/RTL characters as these\n    // make it very difficult for us to find similar *looking* display names\n    // E.g \"Mark\" could be cloned by writing \"kraM\" but in RTL.\n    if (LTR_RTL_PATTERN.test(displayName)) return true;\n\n    // Also show mxid if there are other people with the same or similar\n    // displayname, after hidden character removal.\n    const userIds = roomState.getUserIdsWithDisplayName(displayName);\n    if (userIds.some((u) => u !== selfUserId)) return true;\n\n    return false;\n}\n\nfunction calculateDisplayName(selfUserId: string, displayName: string | undefined, disambiguate: boolean): string {\n    if (!displayName || displayName === selfUserId) return selfUserId;\n\n    if (disambiguate) return removeDirectionOverrideChars(displayName) + \" (\" + selfUserId + \")\";\n\n    // First check if the displayname is something we consider truthy\n    // after stripping it of zero width characters and padding spaces\n    if (!removeHiddenChars(displayName)) return selfUserId;\n\n    // We always strip the direction override characters (LRO and RLO).\n    // These override the text direction for all subsequent characters\n    // in the paragraph so if display names contained these, they'd\n    // need to be wrapped in something to prevent this from leaking out\n    // (which we can do in HTML but not text) or we'd need to add\n    // control characters to the string to reset any overrides (eg.\n    // adding PDF characters at the end). As far as we can see,\n    // there should be no reason these would be necessary - rtl display\n    // names should flip into the correct direction automatically based on\n    // the characters, and you can still embed rtl in ltr or vice versa\n    // with the embed chars or marker chars.\n    return removeDirectionOverrideChars(displayName);\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { RoomMember } from \"./room-member.ts\";\nimport { logger } from \"../logger.ts\";\nimport { isNumber, removeHiddenChars } from \"../utils.ts\";\nimport { EventType, UNSTABLE_MSC2716_MARKER } from \"../@types/event.ts\";\nimport { type IEvent, type MatrixEvent, MatrixEventEvent } from \"./event.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { GuestAccess, HistoryVisibility, JoinRule } from \"../@types/partials.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\nimport {\n    Beacon,\n    BeaconEvent,\n    type BeaconEventHandlerMap,\n    getBeaconInfoIdentifier,\n    type BeaconIdentifier,\n} from \"./beacon.ts\";\nimport { TypedReEmitter } from \"../ReEmitter.ts\";\nimport { M_BEACON, M_BEACON_INFO } from \"../@types/beacon.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\nimport { type RoomJoinRulesEventContent } from \"../@types/state_events.ts\";\nimport { shouldUseHydraForRoomVersion } from \"../utils/roomVersion.ts\";\n\nexport interface IMarkerFoundOptions {\n    /** Whether the timeline was empty before the marker event arrived in the\n     *  room. This could be happen in a variety of cases:\n     *  1. From the initial sync\n     *  2. It's the first state we're seeing after joining the room\n     *  3. Or whether it's coming from `syncFromCache`\n     *\n     * A marker event refers to `UNSTABLE_MSC2716_MARKER` and indicates that\n     * history was imported somewhere back in time. It specifically points to an\n     * MSC2716 insertion event where the history was imported at. Marker events\n     * are sent as state events so they are easily discoverable by clients and\n     * homeservers and don't get lost in timeline gaps.\n     */\n    timelineWasEmpty?: boolean;\n}\n\n// possible statuses for out-of-band member loading\nenum OobStatus {\n    NotStarted,\n    InProgress,\n    Finished,\n}\n\nexport interface IPowerLevelsContent {\n    users?: Record<string, number>;\n    events?: Record<string, number>;\n    notifications?: Partial<Record<\"room\", number>>;\n    // eslint-disable-next-line camelcase\n    users_default?: number;\n    // eslint-disable-next-line camelcase\n    events_default?: number;\n    // eslint-disable-next-line camelcase\n    state_default?: number;\n    ban?: number;\n    invite?: number;\n    kick?: number;\n    redact?: number;\n}\n\nexport enum RoomStateEvent {\n    Events = \"RoomState.events\",\n    Members = \"RoomState.members\",\n    NewMember = \"RoomState.newMember\",\n    Update = \"RoomState.update\", // signals batches of updates without specificity\n    BeaconLiveness = \"RoomState.BeaconLiveness\",\n    Marker = \"RoomState.Marker\",\n}\n\nexport type RoomStateEventHandlerMap = {\n    /**\n     * Fires whenever the event dictionary in room state is updated.\n     * This does not guarantee that any related objects (like RoomMember) have been updated.\n     * Use RoomStateEvent.Update for that.\n     * @param event - The matrix event which caused this event to fire.\n     * @param state - The room state whose RoomState.events dictionary\n     * was updated.\n     * @param prevEvent - The event being replaced by the new state, if\n     * known. Note that this can differ from `getPrevContent()` on the new state event\n     * as this is the store's view of the last state, not the previous state provided\n     * by the server.\n     * @example\n     * ```\n     * matrixClient.on(\"RoomState.events\", function(event, state, prevEvent){\n     *   var newStateEvent = event;\n     * });\n     * ```\n     */\n    [RoomStateEvent.Events]: (event: MatrixEvent, state: RoomState, prevEvent: MatrixEvent | null) => void;\n    /**\n     * Fires whenever a member in the members dictionary is updated in any way.\n     * @param event - The matrix event which caused this event to fire.\n     * @param state - The room state whose RoomState.members dictionary\n     * was updated.\n     * @param member - The room member that was updated.\n     * @example\n     * ```\n     * matrixClient.on(\"RoomState.members\", function(event, state, member){\n     *   var newMembershipState = member.membership;\n     * });\n     * ```\n     */\n    [RoomStateEvent.Members]: (event: MatrixEvent, state: RoomState, member: RoomMember) => void;\n    /**\n     * Fires whenever a member is added to the members dictionary. The RoomMember\n     * will not be fully populated yet (e.g. no membership state) but will already\n     * be available in the members dictionary.\n     * @param event - The matrix event which caused this event to fire.\n     * @param state - The room state whose RoomState.members dictionary\n     * was updated with a new entry.\n     * @param member - The room member that was added.\n     * @example\n     * ```\n     * matrixClient.on(\"RoomState.newMember\", function(event, state, member){\n     *   // add event listeners on 'member'\n     * });\n     * ```\n     */\n    [RoomStateEvent.NewMember]: (event: MatrixEvent, state: RoomState, member: RoomMember) => void;\n    [RoomStateEvent.Update]: (state: RoomState) => void;\n    [RoomStateEvent.BeaconLiveness]: (state: RoomState, hasLiveBeacons: boolean) => void;\n    [RoomStateEvent.Marker]: (event: MatrixEvent, setStateOptions?: IMarkerFoundOptions) => void;\n    [BeaconEvent.New]: (event: MatrixEvent, beacon: Beacon) => void;\n};\n\ntype EmittedEvents = RoomStateEvent | BeaconEvent;\ntype EventHandlerMap = RoomStateEventHandlerMap & BeaconEventHandlerMap;\n\ntype KeysMatching<T, V> = { [K in keyof T]-?: T[K] extends V ? K : never }[keyof T];\n\nexport class RoomState extends TypedEventEmitter<EmittedEvents, EventHandlerMap> {\n    public readonly reEmitter = new TypedReEmitter<EmittedEvents, EventHandlerMap>(this);\n    private sentinels: Record<string, RoomMember> = {}; // userId: RoomMember\n    // stores fuzzy matches to a list of userIDs (applies utils.removeHiddenChars to keys)\n    private displayNameToUserIds = new Map<string, string[]>();\n    private userIdsToDisplayNames: Record<string, string> = {};\n    private tokenToInvite: Record<string, MatrixEvent> = {}; // 3pid invite state_key to m.room.member invite\n    private joinedMemberCount: number | null = null; // cache of the number of joined members\n    // joined members count from summary api\n    // once set, we know the server supports the summary api\n    // and we should only trust that\n    // we could also only trust that before OOB members\n    // are loaded but doesn't seem worth the hassle atm\n    private summaryJoinedMemberCount: number | null = null;\n    // same for invited member count\n    private invitedMemberCount: number | null = null;\n    private summaryInvitedMemberCount: number | null = null;\n    private modified = -1;\n\n    // XXX: Should be read-only\n    // The room member dictionary, keyed on the user's ID.\n    public members: Record<string, RoomMember> = {}; // userId: RoomMember\n    // The state events dictionary, keyed on the event type and then the state_key value.\n    public events = new Map<string, Map<string, MatrixEvent>>(); // Map<eventType, Map<stateKey, MatrixEvent>>\n    // The pagination token for this state.\n    public paginationToken: string | null = null;\n\n    public readonly beacons = new Map<BeaconIdentifier, Beacon>();\n    private _liveBeaconIds: BeaconIdentifier[] = [];\n\n    // We only wants to print warnings about bad room state once.\n    private getVersionWarning = false;\n\n    /**\n     * Construct room state.\n     *\n     * Room State represents the state of the room at a given point.\n     * It can be mutated by adding state events to it.\n     * There are two types of room member associated with a state event:\n     * normal member objects (accessed via getMember/getMembers) which mutate\n     * with the state to represent the current state of that room/user, e.g.\n     * the object returned by `getMember('@bob:example.com')` will mutate to\n     * get a different display name if Bob later changes his display name\n     * in the room.\n     * There are also 'sentinel' members (accessed via getSentinelMember).\n     * These also represent the state of room members at the point in time\n     * represented by the RoomState object, but unlike objects from getMember,\n     * sentinel objects will always represent the room state as at the time\n     * getSentinelMember was called, so if Bob subsequently changes his display\n     * name, a room member object previously acquired with getSentinelMember\n     * will still have his old display name. Calling getSentinelMember again\n     * after the display name change will return a new RoomMember object\n     * with Bob's new display name.\n     *\n     * @param roomId - Optional. The ID of the room which has this state.\n     * If none is specified it just tracks paginationTokens, useful for notifTimelineSet\n     * @param oobMemberFlags - Optional. The state of loading out of bound members.\n     * As the timeline might get reset while they are loading, this state needs to be inherited\n     * and shared when the room state is cloned for the new timeline.\n     * This should only be passed from clone.\n     */\n    public constructor(\n        public readonly roomId: string,\n        private oobMemberFlags = { status: OobStatus.NotStarted },\n    ) {\n        super();\n        this.updateModifiedTime();\n    }\n\n    /**\n     * Gets the version of the room\n     * @returns The version of the room\n     */\n    public getRoomVersion(): string {\n        const createEvent = this.getStateEvents(EventType.RoomCreate, \"\");\n        if (!createEvent) {\n            if (!this.getVersionWarning) {\n                logger.warn(\"[getVersion] Room \" + this.roomId + \" does not have an m.room.create event\");\n                this.getVersionWarning = true;\n            }\n            return \"1\";\n        }\n        return createEvent.getContent()[\"room_version\"] ?? \"1\";\n    }\n\n    /**\n     * Returns the number of joined members in this room\n     * This method caches the result.\n     * @returns The number of members in this room whose membership is 'join'\n     */\n    public getJoinedMemberCount(): number {\n        if (this.summaryJoinedMemberCount !== null) {\n            return this.summaryJoinedMemberCount;\n        }\n        if (this.joinedMemberCount === null) {\n            this.joinedMemberCount = this.getMembers().reduce((count, m) => {\n                return m.membership === KnownMembership.Join ? count + 1 : count;\n            }, 0);\n        }\n        return this.joinedMemberCount;\n    }\n\n    /**\n     * Set the joined member count explicitly (like from summary part of the sync response)\n     * @param count - the amount of joined members\n     */\n    public setJoinedMemberCount(count: number): void {\n        this.summaryJoinedMemberCount = count;\n    }\n\n    /**\n     * Returns the number of invited members in this room\n     * @returns The number of members in this room whose membership is 'invite'\n     */\n    public getInvitedMemberCount(): number {\n        if (this.summaryInvitedMemberCount !== null) {\n            return this.summaryInvitedMemberCount;\n        }\n        if (this.invitedMemberCount === null) {\n            this.invitedMemberCount = this.getMembers().reduce((count, m) => {\n                return m.membership === KnownMembership.Invite ? count + 1 : count;\n            }, 0);\n        }\n        return this.invitedMemberCount;\n    }\n\n    /**\n     * Set the amount of invited members in this room\n     * @param count - the amount of invited members\n     */\n    public setInvitedMemberCount(count: number): void {\n        this.summaryInvitedMemberCount = count;\n    }\n\n    /**\n     * Get all RoomMembers in this room.\n     * @returns A list of RoomMembers.\n     */\n    public getMembers(): RoomMember[] {\n        return Object.values(this.members);\n    }\n\n    /**\n     * Get all RoomMembers in this room, excluding the user IDs provided.\n     * @param excludedIds - The user IDs to exclude.\n     * @returns A list of RoomMembers.\n     */\n    public getMembersExcept(excludedIds: string[]): RoomMember[] {\n        return this.getMembers().filter((m) => !excludedIds.includes(m.userId));\n    }\n\n    /**\n     * Get a room member by their user ID.\n     * @param userId - The room member's user ID.\n     * @returns The member or null if they do not exist.\n     */\n    public getMember(userId: string): RoomMember | null {\n        return this.members[userId] || null;\n    }\n\n    /**\n     * Get a room member whose properties will not change with this room state. You\n     * typically want this if you want to attach a RoomMember to a MatrixEvent which\n     * may no longer be represented correctly by Room.currentState or Room.oldState.\n     * The term 'sentinel' refers to the fact that this RoomMember is an unchanging\n     * guardian for state at this particular point in time.\n     * @param userId - The room member's user ID.\n     * @returns The member or null if they do not exist.\n     */\n    public getSentinelMember(userId: string): RoomMember | null {\n        if (!userId) return null;\n        let sentinel = this.sentinels[userId];\n\n        if (sentinel === undefined) {\n            sentinel = new RoomMember(this.roomId, userId);\n            const member = this.members[userId];\n            if (member?.events.member) {\n                sentinel.setMembershipEvent(member.events.member, this);\n            }\n            this.sentinels[userId] = sentinel;\n        }\n        return sentinel;\n    }\n\n    /**\n     * Get state events from the state of the room.\n     * @param eventType - The event type of the state event.\n     * @returns A list of events\n     */\n    public getStateEvents(eventType: EventType | string): MatrixEvent[];\n    /**\n     * Get state events from the state of the room.\n     * @param eventType - The event type of the state event.\n     * @param stateKey - The state_key of the state event.\n     * @returns A single event (or null if no match found).\n     */\n    public getStateEvents(eventType: EventType | string, stateKey: string): MatrixEvent | null;\n    public getStateEvents(eventType: EventType | string, stateKey?: string): MatrixEvent[] | MatrixEvent | null {\n        if (!this.events.has(eventType)) {\n            // no match\n            return stateKey === undefined ? [] : null;\n        }\n        if (stateKey === undefined) {\n            // return all values\n            return Array.from(this.events.get(eventType)!.values());\n        }\n        const event = this.events.get(eventType)!.get(stateKey);\n        return event ? event : null;\n    }\n\n    public get hasLiveBeacons(): boolean {\n        return !!this.liveBeaconIds?.length;\n    }\n\n    public get liveBeaconIds(): BeaconIdentifier[] {\n        return this._liveBeaconIds;\n    }\n\n    /**\n     * Creates a copy of this room state so that mutations to either won't affect the other.\n     * @returns the copy of the room state\n     */\n    public clone(): RoomState {\n        const copy = new RoomState(this.roomId, this.oobMemberFlags);\n\n        // Ugly hack: because setStateEvents will mark\n        // members as susperseding future out of bound members\n        // if loading is in progress (through oobMemberFlags)\n        // since these are not new members, we're merely copying them\n        // set the status to not started\n        // after copying, we set back the status\n        const status = this.oobMemberFlags.status;\n        this.oobMemberFlags.status = OobStatus.NotStarted;\n\n        Array.from(this.events.values()).forEach((eventsByStateKey) => {\n            copy.setStateEvents(Array.from(eventsByStateKey.values()));\n        });\n\n        // Ugly hack: see above\n        this.oobMemberFlags.status = status;\n\n        if (this.summaryInvitedMemberCount !== null) {\n            copy.setInvitedMemberCount(this.getInvitedMemberCount());\n        }\n        if (this.summaryJoinedMemberCount !== null) {\n            copy.setJoinedMemberCount(this.getJoinedMemberCount());\n        }\n\n        // copy out of band flags if needed\n        if (this.oobMemberFlags.status == OobStatus.Finished) {\n            // copy markOutOfBand flags\n            this.getMembers().forEach((member) => {\n                if (member.isOutOfBand()) {\n                    copy.getMember(member.userId)?.markOutOfBand();\n                }\n            });\n        }\n\n        return copy;\n    }\n\n    /**\n     * Add previously unknown state events.\n     * When lazy loading members while back-paginating,\n     * the relevant room state for the timeline chunk at the end\n     * of the chunk can be set with this method.\n     * @param events - state events to prepend\n     */\n    public setUnknownStateEvents(events: MatrixEvent[]): void {\n        const unknownStateEvents = events.filter((event) => {\n            return !this.events.has(event.getType()) || !this.events.get(event.getType())!.has(event.getStateKey()!);\n        });\n\n        this.setStateEvents(unknownStateEvents);\n    }\n\n    /**\n     * Add an array of one or more state MatrixEvents, overwriting any existing\n     * state with the same `{type, stateKey}` tuple. Will fire \"RoomState.events\"\n     * for every event added. May fire \"RoomState.members\" if there are\n     * `m.room.member` events. May fire \"RoomStateEvent.Marker\" if there are\n     * `UNSTABLE_MSC2716_MARKER` events.\n     * @param stateEvents - a list of state events for this room.\n     *\n     * @remarks\n     * Fires {@link RoomStateEvent.Members}\n     * Fires {@link RoomStateEvent.NewMember}\n     * Fires {@link RoomStateEvent.Events}\n     * Fires {@link RoomStateEvent.Marker}\n     */\n    public setStateEvents(stateEvents: MatrixEvent[], markerFoundOptions?: IMarkerFoundOptions): void {\n        this.updateModifiedTime();\n\n        // update the core event dict\n        stateEvents.forEach((event) => {\n            if (event.getRoomId() !== this.roomId || !event.isState()) return;\n\n            if (M_BEACON_INFO.matches(event.getType())) {\n                this.setBeacon(event);\n            }\n\n            const lastStateEvent = this.getStateEventMatching(event);\n            this.setStateEvent(event);\n            if (event.getType() === EventType.RoomMember) {\n                this.updateDisplayNameCache(event.getStateKey()!, event.getContent().displayname ?? \"\");\n                this.updateThirdPartyTokenCache(event);\n            }\n            this.emit(RoomStateEvent.Events, event, this, lastStateEvent);\n        });\n\n        this.onBeaconLivenessChange();\n        // update higher level data structures. This needs to be done AFTER the\n        // core event dict as these structures may depend on other state events in\n        // the given array (e.g. disambiguating display names in one go to do both\n        // clashing names rather than progressively which only catches 1 of them).\n        stateEvents.forEach((event) => {\n            if (event.getRoomId() !== this.roomId || !event.isState()) return;\n\n            if (event.getType() === EventType.RoomMember) {\n                const userId = event.getStateKey()!;\n\n                // leave events apparently elide the displayname or avatar_url,\n                // so let's fake one up so that we don't leak user ids\n                // into the timeline\n                if (\n                    event.getContent().membership === KnownMembership.Leave ||\n                    event.getContent().membership === KnownMembership.Ban\n                ) {\n                    event.getContent().avatar_url = event.getContent().avatar_url || event.getPrevContent().avatar_url;\n                    event.getContent().displayname =\n                        event.getContent().displayname || event.getPrevContent().displayname;\n                }\n\n                const member = this.getOrCreateMember(userId, event);\n                member.setMembershipEvent(event, this);\n                this.updateMember(member);\n                this.emit(RoomStateEvent.Members, event, this, member);\n            } else if (event.getType() === EventType.RoomPowerLevels) {\n                // events with unknown state keys should be ignored\n                // and should not aggregate onto members power levels\n                if (event.getStateKey() !== \"\") {\n                    return;\n                }\n                const members = Object.values(this.members);\n\n                const createEvent = this.getStateEvents(EventType.RoomCreate, \"\");\n                const creators = getCreators(this.getRoomVersion(), createEvent);\n\n                members.forEach((member) => {\n                    // We only propagate `RoomState.members` event if the\n                    // power levels has been changed\n                    // large room suffer from large re-rendering especially when not needed\n                    const oldLastModified = member.getLastModifiedTime();\n\n                    if (createEvent) {\n                        const pl = powerLevelForUserId(member.userId, event, creators);\n                        member.setPowerLevel(pl, event);\n                    }\n                    if (oldLastModified !== member.getLastModifiedTime()) {\n                        this.emit(RoomStateEvent.Members, event, this, member);\n                    }\n                });\n\n                // assume all our sentinels are now out-of-date\n                this.sentinels = {};\n            } else if (UNSTABLE_MSC2716_MARKER.matches(event.getType())) {\n                this.emit(RoomStateEvent.Marker, event, markerFoundOptions);\n            }\n        });\n\n        this.emit(RoomStateEvent.Update, this);\n    }\n\n    public async processBeaconEvents(events: MatrixEvent[], matrixClient: MatrixClient): Promise<void> {\n        if (\n            !events.length ||\n            // discard locations if we have no beacons\n            !this.beacons.size\n        ) {\n            return;\n        }\n\n        const beaconByEventIdDict = [...this.beacons.values()].reduce<Record<string, Beacon>>((dict, beacon) => {\n            dict[beacon.beaconInfoId] = beacon;\n            return dict;\n        }, {});\n\n        const processBeaconRelation = (beaconInfoEventId: string, event: MatrixEvent): void => {\n            if (!M_BEACON.matches(event.getType())) {\n                return;\n            }\n\n            const beacon = beaconByEventIdDict[beaconInfoEventId];\n\n            if (beacon) {\n                beacon.addLocations([event]);\n            }\n        };\n\n        for (const event of events) {\n            const relatedToEventId = event.getRelation()?.event_id;\n            // not related to a beacon we know about; discard\n            if (!relatedToEventId || !beaconByEventIdDict[relatedToEventId]) return;\n            if (!M_BEACON.matches(event.getType()) && !event.isEncrypted()) return;\n\n            try {\n                await matrixClient.decryptEventIfNeeded(event);\n                processBeaconRelation(relatedToEventId, event);\n            } catch {\n                if (event.isDecryptionFailure()) {\n                    // add an event listener for once the event is decrypted.\n                    event.once(MatrixEventEvent.Decrypted, async () => {\n                        processBeaconRelation(relatedToEventId, event);\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks up a member by the given userId, and if it doesn't exist,\n     * create it and emit the `RoomState.newMember` event.\n     * This method makes sure the member is added to the members dictionary\n     * before emitting, as this is done from setStateEvents and setOutOfBandMember.\n     * @param userId - the id of the user to look up\n     * @param event - the membership event for the (new) member. Used to emit.\n     * @returns the member, existing or newly created.\n     *\n     * @remarks\n     * Fires {@link RoomStateEvent.NewMember}\n     */\n    private getOrCreateMember(userId: string, event: MatrixEvent): RoomMember {\n        let member = this.members[userId];\n        if (!member) {\n            member = new RoomMember(this.roomId, userId);\n            // add member to members before emitting any events,\n            // as event handlers often lookup the member\n            this.members[userId] = member;\n            this.emit(RoomStateEvent.NewMember, event, this, member);\n        }\n        return member;\n    }\n\n    private setStateEvent(event: MatrixEvent): void {\n        if (!this.events.has(event.getType())) {\n            this.events.set(event.getType(), new Map());\n        }\n        this.events.get(event.getType())!.set(event.getStateKey()!, event);\n    }\n\n    /**\n     * @experimental\n     */\n    private setBeacon(event: MatrixEvent): void {\n        const beaconIdentifier = getBeaconInfoIdentifier(event);\n\n        if (this.beacons.has(beaconIdentifier)) {\n            const beacon = this.beacons.get(beaconIdentifier)!;\n\n            if (event.isRedacted()) {\n                if (beacon.beaconInfoId === (<IEvent>event.getRedactionEvent())?.redacts) {\n                    beacon.destroy();\n                    this.beacons.delete(beaconIdentifier);\n                }\n                return;\n            }\n\n            return beacon.update(event);\n        }\n\n        if (event.isRedacted()) {\n            return;\n        }\n\n        const beacon = new Beacon(event);\n\n        this.reEmitter.reEmit<BeaconEvent, BeaconEvent>(beacon, [\n            BeaconEvent.New,\n            BeaconEvent.Update,\n            BeaconEvent.Destroy,\n            BeaconEvent.LivenessChange,\n        ]);\n\n        this.emit(BeaconEvent.New, event, beacon);\n        beacon.on(BeaconEvent.LivenessChange, this.onBeaconLivenessChange.bind(this));\n        beacon.on(BeaconEvent.Destroy, this.onBeaconLivenessChange.bind(this));\n\n        this.beacons.set(beacon.identifier, beacon);\n    }\n\n    /**\n     * @experimental\n     * Check liveness of room beacons\n     * emit RoomStateEvent.BeaconLiveness event\n     */\n    private onBeaconLivenessChange(): void {\n        this._liveBeaconIds = Array.from(this.beacons.values())\n            .filter((beacon) => beacon.isLive)\n            .map((beacon) => beacon.identifier);\n\n        this.emit(RoomStateEvent.BeaconLiveness, this, this.hasLiveBeacons);\n    }\n\n    private getStateEventMatching(event: MatrixEvent): MatrixEvent | null {\n        return this.events.get(event.getType())?.get(event.getStateKey()!) ?? null;\n    }\n\n    private updateMember(member: RoomMember): void {\n        // this member may have a power level already, so set it.\n        const createEvent = this.getStateEvents(EventType.RoomCreate, \"\");\n        const pwrLvlEvent = this.getStateEvents(EventType.RoomPowerLevels, \"\");\n        if (pwrLvlEvent && createEvent) {\n            const powerLevel = powerLevelForUserId(\n                member.userId,\n                pwrLvlEvent,\n                getCreators(this.getRoomVersion(), createEvent),\n            );\n\n            member.setPowerLevel(powerLevel, pwrLvlEvent);\n        }\n\n        // blow away the sentinel which is now outdated\n        delete this.sentinels[member.userId];\n\n        this.members[member.userId] = member;\n        this.joinedMemberCount = null;\n        this.invitedMemberCount = null;\n    }\n\n    /**\n     * Get the out-of-band members loading state, whether loading is needed or not.\n     * Note that loading might be in progress and hence isn't needed.\n     * @returns whether or not the members of this room need to be loaded\n     */\n    public needsOutOfBandMembers(): boolean {\n        return this.oobMemberFlags.status === OobStatus.NotStarted;\n    }\n\n    /**\n     * Check if loading of out-of-band-members has completed\n     *\n     * @returns true if the full membership list of this room has been loaded. False if it is not started or is in\n     *    progress.\n     */\n    public outOfBandMembersReady(): boolean {\n        return this.oobMemberFlags.status === OobStatus.Finished;\n    }\n\n    /**\n     * Mark this room state as waiting for out-of-band members,\n     * ensuring it doesn't ask for them to be requested again\n     * through needsOutOfBandMembers\n     */\n    public markOutOfBandMembersStarted(): void {\n        if (this.oobMemberFlags.status !== OobStatus.NotStarted) {\n            return;\n        }\n        this.oobMemberFlags.status = OobStatus.InProgress;\n    }\n\n    /**\n     * Mark this room state as having failed to fetch out-of-band members\n     */\n    public markOutOfBandMembersFailed(): void {\n        if (this.oobMemberFlags.status !== OobStatus.InProgress) {\n            return;\n        }\n        this.oobMemberFlags.status = OobStatus.NotStarted;\n    }\n\n    /**\n     * Clears the loaded out-of-band members\n     */\n    public clearOutOfBandMembers(): void {\n        let count = 0;\n        Object.keys(this.members).forEach((userId) => {\n            const member = this.members[userId];\n            if (member.isOutOfBand()) {\n                ++count;\n                delete this.members[userId];\n            }\n        });\n        logger.log(`LL: RoomState removed ${count} members...`);\n        this.oobMemberFlags.status = OobStatus.NotStarted;\n    }\n\n    /**\n     * Sets the loaded out-of-band members.\n     * @param stateEvents - array of membership state events\n     */\n    public setOutOfBandMembers(stateEvents: MatrixEvent[]): void {\n        logger.log(`LL: RoomState about to set ${stateEvents.length} OOB members ...`);\n        if (this.oobMemberFlags.status !== OobStatus.InProgress) {\n            return;\n        }\n        logger.log(`LL: RoomState put in finished state ...`);\n        this.oobMemberFlags.status = OobStatus.Finished;\n        stateEvents.forEach((e) => this.setOutOfBandMember(e));\n        this.emit(RoomStateEvent.Update, this);\n    }\n\n    /**\n     * Sets a single out of band member, used by both setOutOfBandMembers and clone\n     * @param stateEvent - membership state event\n     */\n    private setOutOfBandMember(stateEvent: MatrixEvent): void {\n        if (stateEvent.getType() !== EventType.RoomMember) {\n            return;\n        }\n        const userId = stateEvent.getStateKey()!;\n        const existingMember = this.getMember(userId);\n        // never replace members received as part of the sync\n        if (existingMember && !existingMember.isOutOfBand()) {\n            return;\n        }\n\n        const member = this.getOrCreateMember(userId, stateEvent);\n        member.setMembershipEvent(stateEvent, this);\n        // needed to know which members need to be stored seperately\n        // as they are not part of the sync accumulator\n        // this is cleared by setMembershipEvent so when it's updated through /sync\n        member.markOutOfBand();\n\n        this.updateDisplayNameCache(member.userId, member.name);\n\n        this.setStateEvent(stateEvent);\n        this.updateMember(member);\n        this.emit(RoomStateEvent.Members, stateEvent, this, member);\n    }\n\n    /**\n     * Set the current typing event for this room.\n     * @param event - The typing event\n     */\n    public setTypingEvent(event: MatrixEvent): void {\n        Object.values(this.members).forEach(function (member) {\n            member.setTypingEvent(event);\n        });\n    }\n\n    /**\n     * Get the m.room.member event which has the given third party invite token.\n     *\n     * @param token - The token\n     * @returns The m.room.member event or null\n     */\n    public getInviteForThreePidToken(token: string): MatrixEvent | null {\n        return this.tokenToInvite[token] || null;\n    }\n\n    /**\n     * Update the last modified time to the current time.\n     */\n    private updateModifiedTime(): void {\n        this.modified = Date.now();\n    }\n\n    /**\n     * Get the timestamp when this room state was last updated. This timestamp is\n     * updated when this object has received new state events.\n     * @returns The timestamp\n     */\n    public getLastModifiedTime(): number {\n        return this.modified;\n    }\n\n    /**\n     * Get user IDs with the specified or similar display names.\n     * @param displayName - The display name to get user IDs from.\n     * @returns An array of user IDs or an empty array.\n     */\n    public getUserIdsWithDisplayName(displayName: string): string[] {\n        return this.displayNameToUserIds.get(removeHiddenChars(displayName)) ?? [];\n    }\n\n    /**\n     * Returns true if userId is in room, event is not redacted and either sender of\n     * mxEvent or has power level sufficient to redact events other than their own.\n     * @param mxEvent - The event to test permission for\n     * @param userId - The user ID of the user to test permission for\n     * @returns true if the given used ID can redact given event\n     */\n    public maySendRedactionForEvent(mxEvent: MatrixEvent, userId: string): boolean {\n        const member = this.getMember(userId);\n        if (!member || member.membership === KnownMembership.Leave) return false;\n\n        if (mxEvent.status || mxEvent.isRedacted()) return false;\n\n        // The user may have been the sender, but they can't redact their own message\n        // if redactions are blocked.\n        const canRedact = this.maySendEvent(EventType.RoomRedaction, userId);\n\n        if (!canRedact) return false;\n        if (mxEvent.getSender() === userId) return true;\n\n        return this.hasSufficientPowerLevelFor(\"redact\", member.powerLevel);\n    }\n\n    /**\n     * Returns true if the given power level is sufficient for action\n     * @param action - The type of power level to check\n     * @param powerLevel - The power level of the member\n     * @returns true if the given power level is sufficient\n     */\n    public hasSufficientPowerLevelFor(\n        action: KeysMatching<Required<IPowerLevelsContent>, number>,\n        powerLevel: number,\n    ): boolean {\n        const powerLevelsEvent = this.getStateEvents(EventType.RoomPowerLevels, \"\");\n\n        let powerLevels: IPowerLevelsContent = {};\n        if (powerLevelsEvent) {\n            powerLevels = powerLevelsEvent.getContent();\n        }\n\n        let requiredLevel = 50;\n        if (isNumber(powerLevels[action])) {\n            requiredLevel = powerLevels[action]!;\n        }\n\n        return powerLevel >= requiredLevel;\n    }\n\n    /**\n     * Short-form for maySendEvent('m.room.message', userId)\n     * @param userId - The user ID of the user to test permission for\n     * @returns true if the given user ID should be permitted to send\n     *                   message events into the given room.\n     */\n    public maySendMessage(userId: string): boolean {\n        return this.maySendEventOfType(EventType.RoomMessage, userId, false);\n    }\n\n    /**\n     * Returns true if the given user ID has permission to send a normal\n     * event of type `eventType` into this room.\n     * @param eventType - The type of event to test\n     * @param userId - The user ID of the user to test permission for\n     * @returns true if the given user ID should be permitted to send\n     *                        the given type of event into this room,\n     *                        according to the room's state.\n     */\n    public maySendEvent(eventType: EventType | string, userId: string): boolean {\n        return this.maySendEventOfType(eventType, userId, false);\n    }\n\n    /**\n     * Returns true if the given MatrixClient has permission to send a state\n     * event of type `stateEventType` into this room.\n     * @param stateEventType - The type of state events to test\n     * @param cli - The client to test permission for\n     * @returns true if the given client should be permitted to send\n     *                        the given type of state event into this room,\n     *                        according to the room's state.\n     */\n    public mayClientSendStateEvent(stateEventType: EventType | string, cli: MatrixClient): boolean {\n        if (cli.isGuest() || !cli.credentials.userId) {\n            return false;\n        }\n        return this.maySendStateEvent(stateEventType, cli.credentials.userId);\n    }\n\n    /**\n     * Returns true if the given user ID has permission to send a state\n     * event of type `stateEventType` into this room.\n     * @param stateEventType - The type of state events to test\n     * @param userId - The user ID of the user to test permission for\n     * @returns true if the given user ID should be permitted to send\n     *                        the given type of state event into this room,\n     *                        according to the room's state.\n     */\n    public maySendStateEvent(stateEventType: EventType | string, userId: string): boolean {\n        return this.maySendEventOfType(stateEventType, userId, true);\n    }\n\n    /**\n     * Returns true if the given user ID has permission to send a normal or state\n     * event of type `eventType` into this room.\n     * @param eventType - The type of event to test\n     * @param userId - The user ID of the user to test permission for\n     * @param state - If true, tests if the user may send a state\n     event of this type. Otherwise tests whether\n     they may send a regular event.\n     * @returns true if the given user ID should be permitted to send\n     *                        the given type of event into this room,\n     *                        according to the room's state.\n     */\n    private maySendEventOfType(eventType: EventType | string, userId: string, state: boolean): boolean {\n        const powerLevelsEvent = this.getStateEvents(EventType.RoomPowerLevels, \"\");\n\n        let powerLevels: IPowerLevelsContent;\n        let eventsLevels: Record<EventType | string, number> = {};\n\n        let stateDefault = 0;\n        let eventsDefault = 0;\n        if (powerLevelsEvent) {\n            powerLevels = powerLevelsEvent.getContent();\n            eventsLevels = powerLevels.events || {};\n\n            if (Number.isSafeInteger(powerLevels.state_default)) {\n                stateDefault = powerLevels.state_default!;\n            } else {\n                stateDefault = 50;\n            }\n\n            if (Number.isSafeInteger(powerLevels.events_default)) {\n                eventsDefault = powerLevels.events_default!;\n            }\n        }\n\n        let requiredLevel = state ? stateDefault : eventsDefault;\n        if (Number.isSafeInteger(eventsLevels[eventType])) {\n            requiredLevel = eventsLevels[eventType];\n        }\n\n        const roomMember = this.getMember(userId);\n        const userPowerLevel = roomMember?.powerLevel ?? 0;\n\n        return userPowerLevel >= requiredLevel;\n    }\n\n    /**\n     * Returns true if the given user ID has permission to trigger notification\n     * of type `notifLevelKey`\n     * @param notifLevelKey - The level of notification to test (eg. 'room')\n     * @param userId - The user ID of the user to test permission for\n     * @returns true if the given user ID has permission to trigger a\n     *                        notification of this type.\n     */\n    public mayTriggerNotifOfType(notifLevelKey: string, userId: string): boolean {\n        const member = this.getMember(userId);\n        if (!member) {\n            return false;\n        }\n\n        const powerLevelsEvent = this.getStateEvents(EventType.RoomPowerLevels, \"\");\n\n        let notifLevel = 50;\n        if (\n            powerLevelsEvent &&\n            powerLevelsEvent.getContent() &&\n            powerLevelsEvent.getContent().notifications &&\n            isNumber(powerLevelsEvent.getContent().notifications[notifLevelKey])\n        ) {\n            notifLevel = powerLevelsEvent.getContent().notifications[notifLevelKey];\n        }\n\n        return member.powerLevel >= notifLevel;\n    }\n\n    /**\n     * Returns the join rule based on the m.room.join_rule state event, defaulting to `invite`.\n     * @returns the join_rule applied to this room\n     */\n    public getJoinRule(): JoinRule {\n        const joinRuleEvent = this.getStateEvents(EventType.RoomJoinRules, \"\");\n        const joinRuleContent: Partial<RoomJoinRulesEventContent> = joinRuleEvent?.getContent() ?? {};\n        return joinRuleContent[\"join_rule\"] || JoinRule.Invite;\n    }\n\n    /**\n     * Returns the history visibility based on the m.room.history_visibility state event, defaulting to `shared`.\n     * @returns the history_visibility applied to this room\n     */\n    public getHistoryVisibility(): HistoryVisibility {\n        const historyVisibilityEvent = this.getStateEvents(EventType.RoomHistoryVisibility, \"\");\n        const historyVisibilityContent = historyVisibilityEvent?.getContent() ?? {};\n        return historyVisibilityContent[\"history_visibility\"] || HistoryVisibility.Shared;\n    }\n\n    /**\n     * Returns the guest access based on the m.room.guest_access state event, defaulting to `shared`.\n     * @returns the guest_access applied to this room\n     */\n    public getGuestAccess(): GuestAccess {\n        const guestAccessEvent = this.getStateEvents(EventType.RoomGuestAccess, \"\");\n        const guestAccessContent = guestAccessEvent?.getContent() ?? {};\n        return guestAccessContent[\"guest_access\"] || GuestAccess.Forbidden;\n    }\n\n    /**\n     * Find the predecessor room based on this room state.\n     *\n     * @param msc3946ProcessDynamicPredecessor - if true, look for an\n     * m.room.predecessor state event and use it if found (MSC3946).\n     * @returns null if this room has no predecessor. Otherwise, returns\n     * the roomId, last eventId and viaServers of the predecessor room.\n     *\n     * If msc3946ProcessDynamicPredecessor is true, use m.predecessor events\n     * as well as m.room.create events to find predecessors.\n     *\n     * Note: if an m.predecessor event is used, eventId may be undefined\n     * since last_known_event_id is optional.\n     *\n     * Note: viaServers may be undefined, and will definitely be undefined if\n     * this predecessor comes from a RoomCreate event (rather than a\n     * RoomPredecessor, which has the optional via_servers property).\n     */\n    public findPredecessor(\n        msc3946ProcessDynamicPredecessor = false,\n    ): { roomId: string; eventId?: string; viaServers?: string[] } | null {\n        // Note: the tests for this function are against Room.findPredecessor,\n        // which just calls through to here.\n\n        if (msc3946ProcessDynamicPredecessor) {\n            const predecessorEvent = this.getStateEvents(EventType.RoomPredecessor, \"\");\n            if (predecessorEvent) {\n                const content = predecessorEvent.getContent<{\n                    predecessor_room_id: string;\n                    last_known_event_id?: string;\n                    via_servers?: string[];\n                }>();\n                const roomId = content.predecessor_room_id;\n                let eventId = content.last_known_event_id;\n                if (typeof eventId !== \"string\") {\n                    eventId = undefined;\n                }\n                let viaServers = content.via_servers;\n                if (!Array.isArray(viaServers)) {\n                    viaServers = undefined;\n                }\n                if (typeof roomId === \"string\") {\n                    return { roomId, eventId, viaServers };\n                }\n            }\n        }\n\n        const createEvent = this.getStateEvents(EventType.RoomCreate, \"\");\n        if (createEvent) {\n            const predecessor = createEvent.getContent<{\n                predecessor?: Partial<{\n                    room_id: string;\n                    event_id: string;\n                }>;\n            }>()[\"predecessor\"];\n            if (predecessor) {\n                const roomId = predecessor[\"room_id\"];\n                if (typeof roomId === \"string\") {\n                    let eventId = predecessor[\"event_id\"];\n                    if (typeof eventId !== \"string\" || eventId === \"\") {\n                        eventId = undefined;\n                    }\n                    return { roomId, eventId };\n                }\n            }\n        }\n        return null;\n    }\n\n    private updateThirdPartyTokenCache(memberEvent: MatrixEvent): void {\n        if (!memberEvent.getContent().third_party_invite) {\n            return;\n        }\n        const token = (memberEvent.getContent().third_party_invite.signed || {}).token;\n        if (!token) {\n            return;\n        }\n        const threePidInvite = this.getStateEvents(EventType.RoomThirdPartyInvite, token);\n        if (!threePidInvite) {\n            return;\n        }\n        this.tokenToInvite[token] = memberEvent;\n    }\n\n    private updateDisplayNameCache(userId: string, displayName: string): void {\n        const oldName = this.userIdsToDisplayNames[userId];\n        delete this.userIdsToDisplayNames[userId];\n        if (oldName) {\n            // Remove the old name from the cache.\n            // We clobber the user_id > name lookup but the name -> [user_id] lookup\n            // means we need to remove that user ID from that array rather than nuking\n            // the lot.\n            const strippedOldName = removeHiddenChars(oldName);\n\n            const existingUserIds = this.displayNameToUserIds.get(strippedOldName);\n            if (existingUserIds) {\n                // remove this user ID from this array\n                const filteredUserIDs = existingUserIds.filter((id) => id !== userId);\n                this.displayNameToUserIds.set(strippedOldName, filteredUserIDs);\n            }\n        }\n\n        this.userIdsToDisplayNames[userId] = displayName;\n\n        const strippedDisplayname = displayName && removeHiddenChars(displayName);\n        // an empty stripped displayname (undefined/'') will be set to MXID in room-member.js\n        if (strippedDisplayname) {\n            const arr = this.displayNameToUserIds.get(strippedDisplayname) ?? [];\n            arr.push(userId);\n            this.displayNameToUserIds.set(strippedDisplayname, arr);\n        }\n    }\n}\n\n/**\n * Get the set of creator user IDs for a room: empty if the room is not a 'hydra' room, otherwise\n * computed from the sender of the m.room.create event plus the additional_creators field.\n * @param roomVersion The version of the room\n * @param roomCreateEvent The m.room.create event for the room\n * @returns A set of user IDs of the creators of the room.\n */\nfunction getCreators(roomVersion: string, roomCreateEvent: MatrixEvent | null): Set<string> {\n    const creators = new Set<string>();\n    if (shouldUseHydraForRoomVersion(roomVersion) && roomCreateEvent) {\n        const roomCreateSender = roomCreateEvent.getSender();\n        if (roomCreateSender) creators.add(roomCreateSender);\n        const additionalCreators = roomCreateEvent.getDirectionalContent().additional_creators;\n        if (Array.isArray(additionalCreators)) additionalCreators.forEach((c) => creators.add(c));\n    }\n    return creators;\n}\n\n/**\n *\n * @param userId The user ID to compute the power level for\n * @param powerLevelEvents The power level event for the room\n * @param creators The set of creator user IDs for the room if the room is a 'hydra' room, otherwise the empty set.\n */\nfunction powerLevelForUserId(userId: string, powerLevelEvent: MatrixEvent, creators: Set<string>): number {\n    if (creators.has(userId)) {\n        // As of \"Hydra\", If the user is a creator, they always have the highest power level\n        return Infinity;\n    } else {\n        const evContent = powerLevelEvent.getDirectionalContent();\n\n        const users: { [userId: string]: number } = evContent.users || {};\n\n        if (users[userId] !== undefined && Number.isInteger(users[userId])) {\n            return users[userId];\n        } else if (evContent.users_default !== undefined) {\n            return evContent.users_default;\n        } else {\n            return 0;\n        }\n    }\n}\n","/*\nCopyright 2015 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { M_POLL_START } from \"matrix-events-sdk\";\n\nimport {\n    DuplicateStrategy,\n    EventTimelineSet,\n    type EventTimelineSetHandlerMap,\n    type IAddLiveEventOptions,\n} from \"./event-timeline-set.ts\";\nimport { Direction, EventTimeline } from \"./event-timeline.ts\";\nimport { getHttpUriForMxc } from \"../content-repo.ts\";\nimport * as utils from \"../utils.ts\";\nimport { normalize, noUnsafeEventProps, removeElement } from \"../utils.ts\";\nimport {\n    type IEvent,\n    type IThreadBundledRelationship,\n    MatrixEvent,\n    MatrixEventEvent,\n    type MatrixEventHandlerMap,\n} from \"./event.ts\";\nimport { EventStatus } from \"./event-status.ts\";\nimport { RoomMember } from \"./room-member.ts\";\nimport { type Hero, type IRoomSummary, RoomSummary } from \"./room-summary.ts\";\nimport { logger } from \"../logger.ts\";\nimport { TypedReEmitter } from \"../ReEmitter.ts\";\nimport {\n    EVENT_VISIBILITY_CHANGE_TYPE,\n    EventType,\n    RelationType,\n    RoomCreateTypeField,\n    RoomType,\n    UNSIGNED_THREAD_ID_FIELD,\n    UNSTABLE_ELEMENT_FUNCTIONAL_USERS,\n} from \"../@types/event.ts\";\nimport { type MatrixClient, PendingEventOrdering } from \"../client.ts\";\nimport { type GuestAccess, type HistoryVisibility, type JoinRule, type ResizeMethod } from \"../@types/partials.ts\";\nimport { Filter, type IFilterDefinition } from \"../filter.ts\";\nimport { type RoomState, RoomStateEvent, type RoomStateEventHandlerMap } from \"./room-state.ts\";\nimport { BeaconEvent, type BeaconEventHandlerMap } from \"./beacon.ts\";\nimport {\n    FILTER_RELATED_BY_REL_TYPES,\n    FILTER_RELATED_BY_SENDERS,\n    Thread,\n    THREAD_RELATION_TYPE,\n    ThreadEvent,\n    type ThreadEventHandlerMap as ThreadHandlerMap,\n    ThreadFilterType,\n} from \"./thread.ts\";\nimport {\n    type CachedReceiptStructure,\n    MAIN_ROOM_TIMELINE,\n    type Receipt,\n    type ReceiptContent,\n    ReceiptType,\n} from \"../@types/read_receipts.ts\";\nimport { type IStateEventWithRoomId } from \"../@types/search.ts\";\nimport { RelationsContainer } from \"./relations-container.ts\";\nimport { ReadReceipt, synthesizeReceipt } from \"./read-receipt.ts\";\nimport { isPollEvent, Poll, PollEvent } from \"./poll.ts\";\nimport { RoomReceipts } from \"./room-receipts.ts\";\nimport { compareEventOrdering } from \"./compare-event-ordering.ts\";\nimport { KnownMembership, type Membership } from \"../@types/membership.ts\";\nimport { type Capabilities, type IRoomVersionsCapability, RoomVersionStability } from \"../serverCapabilities.ts\";\nimport { type MSC4186Hero } from \"../sliding-sync.ts\";\nimport { RoomStickyEventsStore, RoomStickyEventsEvent, type RoomStickyEventsMap } from \"./room-sticky-events.ts\";\n\n// These constants are used as sane defaults when the homeserver doesn't support\n// the m.room_versions capability. In practice, KNOWN_SAFE_ROOM_VERSION should be\n// the same as the common default room version whereas SAFE_ROOM_VERSIONS are the\n// room versions which are considered okay for people to run without being asked\n// to upgrade (ie: \"stable\"). Eventually, we should remove these when all homeservers\n// return an m.room_versions capability.\nexport const KNOWN_SAFE_ROOM_VERSION = \"10\";\nconst SAFE_ROOM_VERSIONS = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"];\n\ninterface IOpts {\n    /**\n     * Controls where pending messages appear in a room's timeline.\n     * If \"<b>chronological</b>\", messages will appear in the timeline when the call to `sendEvent` was made.\n     * If \"<b>detached</b>\", pending messages will appear in a separate list,\n     * accessible via {@link Room#getPendingEvents}.\n     * Default: \"chronological\".\n     */\n    pendingEventOrdering?: PendingEventOrdering;\n    /**\n     * Set to true to enable improved timeline support.\n     */\n    timelineSupport?: boolean;\n    lazyLoadMembers?: boolean;\n}\n\nexport interface IRecommendedVersion {\n    version: string;\n    needsUpgrade: boolean;\n    urgent: boolean;\n}\n\n// When inserting a visibility event affecting event `eventId`, we\n// need to scan through existing visibility events for `eventId`.\n// In theory, this could take an unlimited amount of time if:\n//\n// - the visibility event was sent by a moderator; and\n// - `eventId` already has many visibility changes (usually, it should\n//   be 2 or less); and\n// - for some reason, the visibility changes are received out of order\n//   (usually, this shouldn't happen at all).\n//\n// For this reason, we limit the number of events to scan through,\n// expecting that a broken visibility change for a single event in\n// an extremely uncommon case (possibly a DoS) is a small\n// price to pay to keep matrix-js-sdk responsive.\nconst MAX_NUMBER_OF_VISIBILITY_EVENTS_TO_SCAN_THROUGH = 30;\n\nexport type NotificationCount = Partial<Record<NotificationCountType, number>>;\n\nexport enum NotificationCountType {\n    Highlight = \"highlight\",\n    Total = \"total\",\n}\n\nexport interface ICreateFilterOpts {\n    // Populate the filtered timeline with already loaded events in the room\n    // timeline. Useful to disable for some filters that can't be achieved by the\n    // client in an efficient manner\n    prepopulateTimeline?: boolean;\n    useSyncEvents?: boolean;\n    pendingEvents?: boolean;\n}\n\nexport enum RoomEvent {\n    MyMembership = \"Room.myMembership\",\n    Tags = \"Room.tags\",\n    AccountData = \"Room.accountData\",\n    Receipt = \"Room.receipt\",\n    Name = \"Room.name\",\n    Redaction = \"Room.redaction\",\n    RedactionCancelled = \"Room.redactionCancelled\",\n    LocalEchoUpdated = \"Room.localEchoUpdated\",\n    Timeline = \"Room.timeline\",\n    TimelineReset = \"Room.timelineReset\",\n    TimelineRefresh = \"Room.TimelineRefresh\",\n    OldStateUpdated = \"Room.OldStateUpdated\",\n    CurrentStateUpdated = \"Room.CurrentStateUpdated\",\n    HistoryImportedWithinTimeline = \"Room.historyImportedWithinTimeline\",\n    UnreadNotifications = \"Room.UnreadNotifications\",\n    Summary = \"Room.Summary\",\n}\n\nexport type RoomEmittedEvents =\n    | RoomEvent\n    | RoomStateEvent.Events\n    | RoomStateEvent.Members\n    | RoomStateEvent.NewMember\n    | RoomStateEvent.Update\n    | RoomStateEvent.Marker\n    | RoomStickyEventsEvent.Update\n    | ThreadEvent.New\n    | ThreadEvent.Update\n    | ThreadEvent.NewReply\n    | ThreadEvent.Delete\n    | MatrixEventEvent.BeforeRedaction\n    | BeaconEvent.New\n    | BeaconEvent.Update\n    | BeaconEvent.Destroy\n    | BeaconEvent.LivenessChange\n    | PollEvent.New;\n\nexport type RoomEventHandlerMap = {\n    /**\n     * Fires when the logged in user's membership in the room is updated.\n     *\n     * @param room - The room in which the membership has been updated\n     * @param membership - The new membership value\n     * @param prevMembership - The previous membership value\n     */\n    [RoomEvent.MyMembership]: (room: Room, membership: Membership, prevMembership?: Membership) => void;\n    /**\n     * Fires whenever a room's tags are updated.\n     * @param event - The tags event\n     * @param room - The room whose Room.tags was updated.\n     * @example\n     * ```\n     * matrixClient.on(\"Room.tags\", function(event, room){\n     *   var newTags = event.getContent().tags;\n     *   if (newTags[\"favourite\"]) showStar(room);\n     * });\n     * ```\n     */\n    [RoomEvent.Tags]: (event: MatrixEvent, room: Room) => void;\n    /**\n     * Fires whenever a room's account_data is updated.\n     * @param event - The account_data event\n     * @param room - The room whose account_data was updated.\n     * @param prevEvent - The event being replaced by\n     * the new account data, if known.\n     * @example\n     * ```\n     * matrixClient.on(\"Room.accountData\", function(event, room, oldEvent){\n     *   if (event.getType() === \"m.room.colorscheme\") {\n     *       applyColorScheme(event.getContents());\n     *   }\n     * });\n     * ```\n     */\n    [RoomEvent.AccountData]: (event: MatrixEvent, room: Room, prevEvent?: MatrixEvent) => void;\n    /**\n     * Fires whenever a receipt is received for a room\n     * @param event - The receipt event\n     * @param room - The room whose receipts was updated.\n     * @example\n     * ```\n     * matrixClient.on(\"Room.receipt\", function(event, room){\n     *   var receiptContent = event.getContent();\n     * });\n     * ```\n     */\n    [RoomEvent.Receipt]: (event: MatrixEvent, room: Room) => void;\n    /**\n     * Fires whenever the name of a room is updated.\n     * @param room - The room whose Room.name was updated.\n     * @example\n     * ```\n     * matrixClient.on(\"Room.name\", function(room){\n     *   var newName = room.name;\n     * });\n     * ```\n     */\n    [RoomEvent.Name]: (room: Room) => void;\n    /**\n     * Fires when an event we had previously received is redacted.\n     *\n     * (Note this is *not* fired when the redaction happens before we receive the\n     * event).\n     *\n     * @param event - The matrix redaction event\n     * @param room - The room containing the redacted event\n     * @param threadId - The thread containing the redacted event (before it was redacted)\n     */\n    [RoomEvent.Redaction]: (event: MatrixEvent, room: Room, threadId?: string) => void;\n    /**\n     * Fires when an event that was previously redacted isn't anymore.\n     * This happens when the redaction couldn't be sent and\n     * was subsequently cancelled by the user. Redactions have a local echo\n     * which is undone in this scenario.\n     *\n     * @param event - The matrix redaction event that was cancelled.\n     * @param room - The room containing the unredacted event\n     */\n    [RoomEvent.RedactionCancelled]: (event: MatrixEvent, room: Room) => void;\n    /**\n     * Fires when the status of a transmitted event is updated.\n     *\n     * <p>When an event is first transmitted, a temporary copy of the event is\n     * inserted into the timeline, with a temporary event id, and a status of\n     * 'SENDING'.\n     *\n     * <p>Once the echo comes back from the server, the content of the event\n     * (MatrixEvent.event) is replaced by the complete event from the homeserver,\n     * thus updating its event id, as well as server-generated fields such as the\n     * timestamp. Its status is set to null.\n     *\n     * <p>Once the /send request completes, if the remote echo has not already\n     * arrived, the event is updated with a new event id and the status is set to\n     * 'SENT'. The server-generated fields are of course not updated yet.\n     *\n     * <p>If the /send fails, In this case, the event's status is set to\n     * 'NOT_SENT'. If it is later resent, the process starts again, setting the\n     * status to 'SENDING'. Alternatively, the message may be cancelled, which\n     * removes the event from the room, and sets the status to 'CANCELLED'.\n     *\n     * <p>This event is raised to reflect each of the transitions above.\n     *\n     * @param event - The matrix event which has been updated\n     *\n     * @param room - The room containing the redacted event\n     *\n     * @param oldEventId - The previous event id (the temporary event id,\n     *    except when updating a successfully-sent event when its echo arrives)\n     *\n     * @param oldStatus - The previous event status.\n     */\n    [RoomEvent.LocalEchoUpdated]: (\n        event: MatrixEvent,\n        room: Room,\n        oldEventId?: string,\n        oldStatus?: EventStatus | null,\n    ) => void;\n    [RoomEvent.OldStateUpdated]: (room: Room, previousRoomState: RoomState, roomState: RoomState) => void;\n    [RoomEvent.CurrentStateUpdated]: (room: Room, previousRoomState: RoomState, roomState: RoomState) => void;\n    [RoomEvent.HistoryImportedWithinTimeline]: (markerEvent: MatrixEvent, room: Room) => void;\n    [RoomEvent.UnreadNotifications]: (unreadNotifications?: NotificationCount, threadId?: string) => void;\n    [RoomEvent.TimelineRefresh]: (room: Room, eventTimelineSet: EventTimelineSet) => void;\n    /**\n     * Fires when a new room summary is returned by `/sync`.\n     *\n     * See https://spec.matrix.org/v1.8/client-server-api/#_matrixclientv3sync_roomsummary\n     * for full details\n     * @param summary - the room summary object\n     */\n    [RoomEvent.Summary]: (summary: IRoomSummary) => void;\n    [ThreadEvent.New]: (thread: Thread, toStartOfTimeline: boolean) => void;\n    /**\n     * Fires when a new poll instance is added to the room state\n     * @param poll - the new poll\n     */\n    [PollEvent.New]: (poll: Poll) => void;\n} & Pick<ThreadHandlerMap, ThreadEvent.Update | ThreadEvent.NewReply | ThreadEvent.Delete> &\n    EventTimelineSetHandlerMap &\n    Pick<MatrixEventHandlerMap, MatrixEventEvent.BeforeRedaction> &\n    Pick<RoomStickyEventsMap, RoomStickyEventsEvent.Update> &\n    Pick<\n        RoomStateEventHandlerMap,\n        | RoomStateEvent.Events\n        | RoomStateEvent.Members\n        | RoomStateEvent.NewMember\n        | RoomStateEvent.Update\n        | RoomStateEvent.Marker\n        | BeaconEvent.New\n    > &\n    Pick<BeaconEventHandlerMap, BeaconEvent.Update | BeaconEvent.Destroy | BeaconEvent.LivenessChange>;\n\nexport class Room extends ReadReceipt<RoomEmittedEvents, RoomEventHandlerMap> {\n    public readonly reEmitter: TypedReEmitter<RoomEmittedEvents, RoomEventHandlerMap>;\n    private txnToEvent: Map<string, MatrixEvent> = new Map(); // Pending in-flight requests { string: MatrixEvent }\n    private notificationCounts: NotificationCount = {};\n    private bumpStamp: number | undefined = undefined;\n    private readonly threadNotifications = new Map<string, NotificationCount>();\n    public readonly cachedThreadReadReceipts = new Map<string, CachedReceiptStructure[]>();\n    // Useful to know at what point the current user has started using threads in this room\n    private oldestThreadedReceiptTs = Infinity;\n    /**\n     * A record of the latest unthread receipts per user\n     * This is useful in determining whether a user has read a thread or not\n     */\n    private unthreadedReceipts = new Map<string, Receipt>();\n    private readonly timelineSets: EventTimelineSet[];\n    public readonly polls: Map<string, Poll> = new Map<string, Poll>();\n\n    /**\n     * Empty array if the timeline sets have not been initialised. After initialisation:\n     * 0: All threads\n     * 1: Threads the current user has participated in\n     */\n    public readonly threadsTimelineSets: [] | [EventTimelineSet, EventTimelineSet] = [];\n\n    // any filtered timeline sets we're maintaining for this room\n    private readonly filteredTimelineSets: Record<string, EventTimelineSet> = {}; // filter_id: timelineSet\n    private timelineNeedsRefresh = false;\n    private readonly pendingEventList?: MatrixEvent[];\n    // read by megolm via getter; boolean value - null indicates \"use global value\"\n    private blacklistUnverifiedDevices?: boolean;\n    private selfMembership?: Membership;\n    /**\n     * A `Hero` is a stripped `m.room.member` event which contains the important renderable fields from the event.\n     *\n     * It is used in MSC4186 (Simplified Sliding Sync) as a replacement for the old `summary` field.\n     *\n     * When we are doing old-style (`/v3/sync`) sync, we simulate the SSS behaviour by constructing\n     * a `Hero` object based on the user id we get from the summary. Obviously, in that case,\n     * the `Hero` will lack a `displayName` or `avatarUrl`.\n     */\n    private heroes: Hero[] | null = null;\n    // flags to stop logspam about missing m.room.create events\n    private getTypeWarning = false;\n    private membersPromise?: Promise<boolean>;\n\n    // XXX: These should be read-only\n    /**\n     * The human-readable display name for this room.\n     */\n    public name: string;\n    /**\n     * The un-homoglyphed name for this room.\n     */\n    public normalizedName: string;\n    /**\n     * Dict of room tags; the keys are the tag name and the values\n     * are any metadata associated with the tag - e.g. `{ \"fav\" : { order: 1 } }`\n     */\n    public tags: Record<string, Record<string, any>> = {}; // $tagName: { $metadata: $value }\n    /**\n     * accountData Dict of per-room account_data events; the keys are the\n     * event type and the values are the events.\n     */\n    public accountData: Map<string, MatrixEvent> = new Map(); // $eventType: $event\n    /**\n     * The room summary.\n     */\n    public summary: RoomSummary | null = null;\n    /**\n     * oldState The state of the room at the time of the oldest event in the live timeline.\n     *\n     * @deprecated Present for backwards compatibility.\n     *             Use getLiveTimeline().getState(EventTimeline.BACKWARDS) instead\n     */\n    public oldState!: RoomState;\n    /**\n     * currentState The state of the room at the time of the newest event in the timeline.\n     *\n     * @deprecated Present for backwards compatibility.\n     *             Use getLiveTimeline().getState(EventTimeline.FORWARDS) instead.\n     */\n    public currentState!: RoomState;\n\n    public readonly relations;\n\n    /**\n     * A collection of events known by the client\n     * This is not a comprehensive list of the threads that exist in this room\n     */\n    private threads = new Map<string, Thread>();\n\n    /**\n     * A mapping of eventId to all visibility changes to apply\n     * to the event, by chronological order, as per\n     * https://github.com/matrix-org/matrix-doc/pull/3531\n     *\n     * # Invariants\n     *\n     * - within each list, all events are classed by\n     *   chronological order;\n     * - all events are events such that\n     *  `asVisibilityEvent()` returns a non-null `IVisibilityChange`;\n     * - within each list with key `eventId`, all events\n     *   are in relation to `eventId`.\n     *\n     * @experimental\n     */\n    private visibilityEvents = new Map<string, MatrixEvent[]>();\n\n    /**\n     * The latest receipts (synthetic and real) for each user in each thread\n     * (and unthreaded).\n     */\n    private roomReceipts = new RoomReceipts(this);\n\n    /**\n     * Stores and tracks sticky events\n     */\n    private stickyEvents = new RoomStickyEventsStore();\n\n    /**\n     * Construct a new Room.\n     *\n     * <p>For a room, we store an ordered sequence of timelines, which may or may not\n     * be continuous. Each timeline lists a series of events, as well as tracking\n     * the room state at the start and the end of the timeline. It also tracks\n     * forward and backward pagination tokens, as well as containing links to the\n     * next timeline in the sequence.\n     *\n     * <p>There is one special timeline - the 'live' timeline, which represents the\n     * timeline to which events are being added in real-time as they are received\n     * from the /sync API. Note that you should not retain references to this\n     * timeline - even if it is the current timeline right now, it may not remain\n     * so if the server gives us a timeline gap in /sync.\n     *\n     * <p>In order that we can find events from their ids later, we also maintain a\n     * map from event_id to timeline and index.\n     *\n     * @param roomId - Required. The ID of this room.\n     * @param client - Required. The client, used to lazy load members.\n     * @param myUserId - Required. The ID of the syncing user.\n     * @param opts - Configuration options\n     */\n    public constructor(\n        public readonly roomId: string,\n        public readonly client: MatrixClient,\n        public readonly myUserId: string,\n        private readonly opts: IOpts = {},\n    ) {\n        super();\n\n        // In some cases, we add listeners for every displayed Matrix event, so it's\n        // common to have quite a few more than the default limit.\n        this.setMaxListeners(100);\n        this.reEmitter = new TypedReEmitter(this);\n\n        opts.pendingEventOrdering = opts.pendingEventOrdering || PendingEventOrdering.Chronological;\n\n        this.name = roomId;\n        this.normalizedName = roomId;\n\n        this.relations = new RelationsContainer(this.client, this);\n\n        // Listen to our own receipt event as a more modular way of processing our own\n        // receipts. No need to remove the listener: it's on ourself anyway.\n        this.on(RoomEvent.Receipt, this.onReceipt);\n        this.reEmitter.reEmit(this.stickyEvents, [RoomStickyEventsEvent.Update]);\n\n        // all our per-room timeline sets. the first one is the unfiltered ones;\n        // the subsequent ones are the filtered ones in no particular order.\n        this.timelineSets = [new EventTimelineSet(this, opts)];\n        this.reEmitter.reEmit(this.getUnfilteredTimelineSet(), [RoomEvent.Timeline, RoomEvent.TimelineReset]);\n\n        this.fixUpLegacyTimelineFields();\n\n        if (this.opts.pendingEventOrdering === PendingEventOrdering.Detached) {\n            this.pendingEventList = [];\n            this.client.store.getPendingEvents(this.roomId).then((events) => {\n                const mapper = this.client.getEventMapper({\n                    decrypt: false,\n                });\n                events.forEach(async (serializedEvent: Partial<IEvent>) => {\n                    const event = mapper(serializedEvent);\n                    await client.decryptEventIfNeeded(event);\n                    event.setStatus(EventStatus.NOT_SENT);\n                    this.addPendingEvent(event, event.getTxnId()!);\n                });\n            });\n        }\n\n        // awaited by getEncryptionTargetMembers while room members are loading\n        if (!this.opts.lazyLoadMembers) {\n            this.membersPromise = Promise.resolve(false);\n        } else {\n            this.membersPromise = undefined;\n        }\n    }\n\n    private threadTimelineSetsPromise: Promise<[EventTimelineSet, EventTimelineSet]> | null = null;\n    public async createThreadsTimelineSets(): Promise<[EventTimelineSet, EventTimelineSet] | null> {\n        if (this.threadTimelineSetsPromise) {\n            return this.threadTimelineSetsPromise;\n        }\n\n        if (this.client?.supportsThreads()) {\n            try {\n                this.threadTimelineSetsPromise = Promise.all([\n                    this.createThreadTimelineSet(),\n                    this.createThreadTimelineSet(ThreadFilterType.My),\n                ]);\n                const timelineSets = await this.threadTimelineSetsPromise;\n                this.threadsTimelineSets[0] = timelineSets[0];\n                this.threadsTimelineSets[1] = timelineSets[1];\n                return timelineSets;\n            } catch {\n                this.threadTimelineSetsPromise = null;\n                return null;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Bulk decrypt critical events in a room\n     *\n     * Critical events represents the minimal set of events to decrypt\n     * for a typical UI to function properly\n     *\n     * - Last event of every room (to generate likely message preview)\n     * - All events up to the read receipt (to calculate an accurate notification count)\n     *\n     * @returns Signals when all events have been decrypted\n     */\n    public async decryptCriticalEvents(): Promise<void> {\n        if (!this.client.getCrypto()) return;\n\n        const readReceiptEventId = this.getEventReadUpTo(this.client.getUserId()!, true);\n        const events = this.getLiveTimeline().getEvents();\n        const readReceiptTimelineIndex = events.findIndex((matrixEvent) => {\n            return matrixEvent.event.event_id === readReceiptEventId;\n        });\n\n        const decryptionPromises = events\n            .slice(readReceiptTimelineIndex)\n            .reverse()\n            .map((event) => this.client.decryptEventIfNeeded(event));\n\n        await Promise.allSettled(decryptionPromises);\n    }\n\n    /**\n     * Bulk decrypt events in a room\n     *\n     * @returns Signals when all events have been decrypted\n     */\n    public async decryptAllEvents(): Promise<void> {\n        if (!this.client.getCrypto()) return;\n\n        const decryptionPromises = this.getUnfilteredTimelineSet()\n            .getLiveTimeline()\n            .getEvents()\n            .slice(0) // copy before reversing\n            .reverse()\n            .map((event) => this.client.decryptEventIfNeeded(event));\n\n        await Promise.allSettled(decryptionPromises);\n    }\n\n    /**\n     * Gets the creator of the room\n     * @returns The creator of the room, or null if it could not be determined\n     */\n    public getCreator(): string | null {\n        const createEvent = this.currentState.getStateEvents(EventType.RoomCreate, \"\");\n        return createEvent?.getSender() ?? null;\n    }\n\n    /**\n     * Gets the version of the room\n     * @returns The version of the room\n     */\n    public getVersion(): string {\n        return this.currentState.getRoomVersion();\n    }\n\n    /**\n     * Determines the recommended room version for the room. This returns an\n     * object with 3 properties: `version` as the new version the\n     * room should be upgraded to (may be the same as the current version);\n     * `needsUpgrade` to indicate if the room actually can be\n     * upgraded (ie: does the current version not match?); and `urgent`\n     * to indicate if the new version patches a vulnerability in a previous\n     * version.\n     * @returns\n     * Resolves to the version the room should be upgraded to.\n     */\n    public async getRecommendedVersion(): Promise<IRecommendedVersion> {\n        let capabilities: Capabilities = {};\n        try {\n            capabilities = await this.client.getCapabilities();\n        } catch {}\n        let versionCap = capabilities[\"m.room_versions\"];\n        if (!versionCap) {\n            versionCap = {\n                default: KNOWN_SAFE_ROOM_VERSION,\n                available: {},\n            };\n            for (const safeVer of SAFE_ROOM_VERSIONS) {\n                versionCap.available[safeVer] = RoomVersionStability.Stable;\n            }\n        }\n\n        let result = this.checkVersionAgainstCapability(versionCap);\n        if (result.urgent && result.needsUpgrade) {\n            // Something doesn't feel right: we shouldn't need to update\n            // because the version we're on should be in the protocol's\n            // namespace. This usually means that the server was updated\n            // before the client was, making us think the newest possible\n            // room version is not stable. As a solution, we'll refresh\n            // the capability we're using to determine this.\n            logger.warn(\n                \"Refreshing room version capability because the server looks \" +\n                    \"to be supporting a newer room version we don't know about.\",\n            );\n\n            try {\n                capabilities = await this.client.fetchCapabilities();\n            } catch (e) {\n                logger.warn(\"Failed to refresh room version capabilities\", e);\n            }\n            versionCap = capabilities[\"m.room_versions\"];\n            if (!versionCap) {\n                logger.warn(\"No room version capability - assuming upgrade required.\");\n                return result;\n            } else {\n                result = this.checkVersionAgainstCapability(versionCap);\n            }\n        }\n\n        return result;\n    }\n\n    private checkVersionAgainstCapability(versionCap: IRoomVersionsCapability): IRecommendedVersion {\n        const currentVersion = this.getVersion();\n        logger.log(`[${this.roomId}] Current version: ${currentVersion}`);\n        logger.log(`[${this.roomId}] Version capability: `, versionCap);\n\n        const result: IRecommendedVersion = {\n            version: currentVersion,\n            needsUpgrade: false,\n            urgent: false,\n        };\n\n        // If the room is on the default version then nothing needs to change\n        if (currentVersion === versionCap.default) return result;\n\n        const stableVersions = Object.keys(versionCap.available).filter((v) => versionCap.available[v] === \"stable\");\n\n        // Check if the room is on an unstable version. We determine urgency based\n        // off the version being in the Matrix spec namespace or not (if the version\n        // is in the current namespace and unstable, the room is probably vulnerable).\n        if (!stableVersions.includes(currentVersion)) {\n            result.version = versionCap.default;\n            result.needsUpgrade = true;\n            result.urgent = !!this.getVersion().match(/^[0-9]+[0-9.]*$/g);\n            if (result.urgent) {\n                logger.warn(`URGENT upgrade required on ${this.roomId}`);\n            } else {\n                logger.warn(`Non-urgent upgrade required on ${this.roomId}`);\n            }\n            return result;\n        }\n\n        // The room is on a stable, but non-default, version by this point.\n        // No upgrade needed.\n        return result;\n    }\n\n    /**\n     * Determines whether the given user is permitted to perform a room upgrade\n     * @param userId - The ID of the user to test against\n     * @returns True if the given user is permitted to upgrade the room\n     */\n    public userMayUpgradeRoom(userId: string): boolean {\n        return this.currentState.maySendStateEvent(EventType.RoomTombstone, userId);\n    }\n\n    /**\n     * Get the list of pending sent events for this room\n     *\n     * @returns A list of the sent events\n     * waiting for remote echo.\n     *\n     * @throws If `opts.pendingEventOrdering` was not 'detached'\n     */\n    public getPendingEvents(): MatrixEvent[] {\n        if (!this.pendingEventList) {\n            throw new Error(\n                \"Cannot call getPendingEvents with pendingEventOrdering == \" + this.opts.pendingEventOrdering,\n            );\n        }\n\n        return this.pendingEventList;\n    }\n\n    /**\n     * Removes a pending event for this room\n     *\n     * @returns True if an element was removed.\n     */\n    public removePendingEvent(eventId: string): boolean {\n        if (!this.pendingEventList) {\n            throw new Error(\n                \"Cannot call removePendingEvent with pendingEventOrdering == \" + this.opts.pendingEventOrdering,\n            );\n        }\n\n        const removed = removeElement(\n            this.pendingEventList,\n            function (ev) {\n                return ev.getId() == eventId;\n            },\n            false,\n        );\n\n        this.savePendingEvents();\n\n        return removed;\n    }\n\n    /**\n     * Check whether the pending event list contains a given event by ID.\n     * If pending event ordering is not \"detached\" then this returns false.\n     *\n     * @param eventId - The event ID to check for.\n     */\n    public hasPendingEvent(eventId: string): boolean {\n        return this.pendingEventList?.some((event) => event.getId() === eventId) ?? false;\n    }\n\n    /**\n     * Get a specific event from the pending event list, if configured, null otherwise.\n     *\n     * @param eventId - The event ID to check for.\n     */\n    public getPendingEvent(eventId: string): MatrixEvent | null {\n        return this.pendingEventList?.find((event) => event.getId() === eventId) ?? null;\n    }\n\n    /**\n     * Get the live unfiltered timeline for this room.\n     *\n     * @returns live timeline\n     */\n    public getLiveTimeline(): EventTimeline {\n        return this.getUnfilteredTimelineSet().getLiveTimeline();\n    }\n\n    /**\n     * The live event timeline for this room, with the oldest event at index 0.\n     *\n     * @deprecated Present for backwards compatibility.\n     *             Use getLiveTimeline().getEvents() instead\n     */\n    public get timeline(): MatrixEvent[] {\n        return this.getLiveTimeline().getEvents();\n    }\n\n    /**\n     * Get the timestamp of the last message in the room\n     *\n     * @returns the timestamp of the last message in the room\n     */\n    public getLastActiveTimestamp(): number {\n        const timeline = this.getLiveTimeline();\n        const events = timeline.getEvents();\n        if (events.length) {\n            const lastEvent = events[events.length - 1];\n            return lastEvent.getTs();\n        } else {\n            return Number.MIN_SAFE_INTEGER;\n        }\n    }\n\n    /**\n     * Returns the last live event of this room.\n     * \"last\" means latest timestamp.\n     * Instead of using timestamps, it would be better to do the comparison based on the order of the homeserver DAG.\n     * Unfortunately, this information is currently not available in the client.\n     * See {@link https://github.com/matrix-org/matrix-js-sdk/issues/3325}.\n     * \"live of this room\" means from all live timelines: the room and the threads.\n     *\n     * @returns MatrixEvent if there is a last event; else undefined.\n     */\n    public getLastLiveEvent(): MatrixEvent | undefined {\n        const roomEvents = this.getLiveTimeline().getEvents();\n        const lastRoomEvent = roomEvents[roomEvents.length - 1] as MatrixEvent | undefined;\n        const lastThread = this.getLastThread();\n\n        if (!lastThread) return lastRoomEvent;\n\n        const lastThreadEvent = lastThread.events[lastThread.events.length - 1];\n\n        return (lastRoomEvent?.getTs() ?? 0) > (lastThreadEvent?.getTs() ?? 0) ? lastRoomEvent : lastThreadEvent;\n    }\n\n    /**\n     * Returns the last thread of this room.\n     * \"last\" means latest timestamp of the last thread event.\n     * Instead of using timestamps, it would be better to do the comparison based on the order of the homeserver DAG.\n     * Unfortunately, this information is currently not available in the client.\n     * See {@link https://github.com/matrix-org/matrix-js-sdk/issues/3325}.\n     *\n     * @returns the thread with the most recent event in its live time line. undefined if there is no thread.\n     */\n    public getLastThread(): Thread | undefined {\n        return this.getThreads().reduce<Thread | undefined>((lastThread: Thread | undefined, thread: Thread) => {\n            if (!lastThread) return thread;\n\n            const threadEvent = thread.events[thread.events.length - 1];\n            const lastThreadEvent = lastThread.events[lastThread.events.length - 1];\n\n            if ((threadEvent?.getTs() ?? 0) >= (lastThreadEvent?.getTs() ?? 0)) {\n                // Last message of current thread is newer  new last thread.\n                // Equal also means newer, because it was added to the thread map later.\n                return thread;\n            }\n\n            return lastThread;\n        }, undefined);\n    }\n\n    /**\n     * @returns the membership type (join | leave | invite | knock) for the logged in user\n     */\n    public getMyMembership(): Membership {\n        return this.selfMembership ?? KnownMembership.Leave;\n    }\n\n    /**\n     * If this room is a DM we're invited to,\n     * try to find out who invited us\n     * @returns user id of the inviter\n     */\n    public getDMInviter(): string | undefined {\n        const me = this.getMember(this.myUserId);\n        if (me) {\n            return me.getDMInviter();\n        }\n\n        if (this.selfMembership === KnownMembership.Invite) {\n            // fall back to summary information\n            const memberCount = this.getInvitedAndJoinedMemberCount();\n            if (memberCount === 2) {\n                return this.heroes?.[0]?.userId;\n            }\n        }\n    }\n\n    /**\n     * Assuming this room is a DM room, tries to guess with which user.\n     * @returns user id of the other member (could be syncing user)\n     */\n    public guessDMUserId(): string {\n        const me = this.getMember(this.myUserId);\n        if (me) {\n            const inviterId = me.getDMInviter();\n            if (inviterId) {\n                return inviterId;\n            }\n        }\n        // Remember, we're assuming this room is a DM, so returning the first member we find should be fine\n        if (Array.isArray(this.heroes) && this.heroes.length) {\n            return this.heroes[0].userId;\n        }\n        const members = this.currentState.getMembers();\n        const anyMember = members.find((m) => m.userId !== this.myUserId);\n        if (anyMember) {\n            return anyMember.userId;\n        }\n        // it really seems like I'm the only user in the room\n        // so I probably created a room with just me in it\n        // and marked it as a DM. Ok then\n        return this.myUserId;\n    }\n\n    /**\n     * Gets the \"functional members\" in this room.\n     *\n     * Returns the list of userIDs from the `io.element.functional_members` event. Does not consider the\n     * current membership states of those users.\n     *\n     * @see https://github.com/element-hq/element-meta/blob/develop/spec/functional_members.md.\n     */\n    private getFunctionalMembers(): string[] {\n        const mFunctionalMembers = this.currentState.getStateEvents(UNSTABLE_ELEMENT_FUNCTIONAL_USERS.name, \"\");\n        if (Array.isArray(mFunctionalMembers?.getContent().service_members)) {\n            return mFunctionalMembers!.getContent().service_members;\n        }\n        return [];\n    }\n\n    public getAvatarFallbackMember(): RoomMember | undefined {\n        const functionalMembers = this.getFunctionalMembers();\n\n        // Only generate a fallback avatar if the conversation is with a single specific other user (a \"DM\").\n        let nonFunctionalMemberCount = 0;\n        this.getMembers()!.forEach((m) => {\n            if (m.membership !== \"join\" && m.membership !== \"invite\") return;\n            if (functionalMembers.includes(m.userId)) return;\n            nonFunctionalMemberCount++;\n        });\n        if (nonFunctionalMemberCount > 2) return;\n\n        // Prefer the list of heroes, if present. It should only include the single other user in the DM.\n        const nonFunctionalHeroes = this.heroes?.filter((h) => !functionalMembers.includes(h.userId));\n        const hasHeroes = Array.isArray(nonFunctionalHeroes) && nonFunctionalHeroes.length;\n        if (hasHeroes) {\n            // use first hero that has a display name or avatar url, or whose user ID\n            // can be looked up as a member of the room\n            for (const hero of nonFunctionalHeroes) {\n                // If the hero was from a legacy sync (`/v3/sync`), we will need to look the user ID up in the room\n                // the display name and avatar URL will not be set.\n                if (!hero.fromMSC4186) {\n                    // attempt to look up renderable fields from the m.room.member event if it exists\n                    const member = this.getMember(hero.userId);\n                    if (member) {\n                        return member;\n                    }\n                } else {\n                    // use the Hero supplied values for the room member.\n                    // TODO: It's unfortunate that this function, which clearly only cares about the\n                    //       avatar url, returns the entire RoomMember event. We need to fake an event\n                    //       to meet this API shape.\n                    const heroMember = new RoomMember(this.roomId, hero.userId);\n                    // set the display name and avatar url\n                    heroMember.setMembershipEvent(\n                        new MatrixEvent({\n                            // ensure it's unique even if we hit the same millisecond\n                            event_id: \"$\" + this.roomId + hero.userId + new Date().getTime(),\n                            type: EventType.RoomMember,\n                            state_key: hero.userId,\n                            content: {\n                                displayname: hero.displayName,\n                                avatar_url: hero.avatarUrl,\n                            },\n                        }),\n                    );\n                    return heroMember;\n                }\n            }\n            const availableMember = nonFunctionalHeroes\n                .map((hero) => {\n                    return this.getMember(hero.userId);\n                })\n                .find((member) => !!member);\n            if (availableMember) {\n                return availableMember;\n            }\n        }\n\n        // Consider *all*, including previous, members, to generate the avatar for DMs where the other user left.\n        // Needed to generate a matching avatar for rooms named \"Empty Room (was Alice)\".\n        const members = this.getMembers();\n        const nonFunctionalMembers = members?.filter((m) => !functionalMembers.includes(m.userId));\n        if (nonFunctionalMembers.length <= 2) {\n            const availableMember = nonFunctionalMembers.find((m) => {\n                return m.userId !== this.myUserId;\n            });\n            if (availableMember) {\n                return availableMember;\n            }\n        }\n\n        // If all else failed, but the homeserver gave us heroes that previously could not be found in the room members,\n        // trust and try falling back to a hero, creating a one-off member for it\n        if (hasHeroes) {\n            const availableUser = nonFunctionalHeroes\n                .map((hero) => {\n                    return this.client.getUser(hero.userId);\n                })\n                .find((user) => !!user);\n            if (availableUser) {\n                const member = new RoomMember(this.roomId, availableUser.userId);\n                member.user = availableUser;\n                return member;\n            }\n        }\n    }\n\n    /**\n     * Sets the membership this room was received as during sync\n     * @param membership - join | leave | invite\n     */\n    public updateMyMembership(membership: Membership): void {\n        const prevMembership = this.selfMembership;\n        this.selfMembership = membership;\n        if (prevMembership !== membership) {\n            if (membership === KnownMembership.Leave) {\n                this.cleanupAfterLeaving();\n            }\n            this.emit(RoomEvent.MyMembership, this, membership, prevMembership);\n        }\n    }\n\n    private async loadMembersFromServer(): Promise<IStateEventWithRoomId[]> {\n        const lastSyncToken = this.client.store.getSyncToken();\n        const response = await this.client.members(\n            this.roomId,\n            undefined,\n            KnownMembership.Leave,\n            lastSyncToken ?? undefined,\n        );\n        return response.chunk;\n    }\n\n    private async loadMembers(): Promise<{ memberEvents: MatrixEvent[]; fromServer: boolean }> {\n        // were the members loaded from the server?\n        let fromServer = false;\n        let rawMembersEvents = await this.client.store.getOutOfBandMembers(this.roomId);\n        // If the room is encrypted, we always fetch members from the server at\n        // least once, in case the latest state wasn't persisted properly. Note\n        // that this function is only called once (unless loading the members\n        // fails), since loadMembersIfNeeded always returns this.membersPromise\n        // if set, which will be the result of the first (successful) call.\n        if (rawMembersEvents === null || this.hasEncryptionStateEvent()) {\n            fromServer = true;\n            rawMembersEvents = await this.loadMembersFromServer();\n            logger.log(`LL: got ${rawMembersEvents.length} ` + `members from server for room ${this.roomId}`);\n        }\n        const memberEvents = rawMembersEvents.filter(noUnsafeEventProps).map(this.client.getEventMapper());\n        return { memberEvents, fromServer };\n    }\n\n    /**\n     * Check if loading of out-of-band-members has completed\n     *\n     * @returns true if the full membership list of this room has been loaded (including if lazy-loading is disabled).\n     *    False if the load is not started or is in progress.\n     */\n    public membersLoaded(): boolean {\n        if (!this.opts.lazyLoadMembers) {\n            return true;\n        }\n\n        return this.currentState.outOfBandMembersReady();\n    }\n\n    /**\n     * Preloads the member list in case lazy loading\n     * of memberships is in use. Can be called multiple times,\n     * it will only preload once.\n     * @returns when preloading is done and\n     * accessing the members on the room will take\n     * all members in the room into account\n     */\n    public loadMembersIfNeeded(): Promise<boolean> {\n        if (this.membersPromise) {\n            return this.membersPromise;\n        }\n\n        // mark the state so that incoming messages while\n        // the request is in flight get marked as superseding\n        // the OOB members\n        this.currentState.markOutOfBandMembersStarted();\n\n        const inMemoryUpdate = this.loadMembers()\n            .then((result) => {\n                this.currentState.setOutOfBandMembers(result.memberEvents);\n                // recalculate the room name: it may have been based on members, so may have changed\n                this.recalculate();\n                return result.fromServer;\n            })\n            .catch((err) => {\n                // allow retries on fail\n                this.membersPromise = undefined;\n                this.currentState.markOutOfBandMembersFailed();\n                throw err;\n            });\n        // update members in storage, but don't wait for it\n        inMemoryUpdate\n            .then((fromServer) => {\n                if (fromServer) {\n                    const oobMembers = this.currentState\n                        .getMembers()\n                        .filter((m) => m.isOutOfBand())\n                        .map((m) => m.events.member?.event as IStateEventWithRoomId);\n                    logger.log(`LL: telling store to write ${oobMembers.length}` + ` members for room ${this.roomId}`);\n                    const store = this.client.store;\n                    return (\n                        store\n                            .setOutOfBandMembers(this.roomId, oobMembers)\n                            // swallow any IDB error as we don't want to fail\n                            // because of this\n                            .catch((err) => {\n                                logger.log(\"LL: storing OOB room members failed, oh well\", err);\n                            })\n                    );\n                }\n            })\n            .catch((err) => {\n                // as this is not awaited anywhere,\n                // at least show the error in the console\n                logger.error(err);\n            });\n\n        this.membersPromise = inMemoryUpdate;\n\n        return this.membersPromise;\n    }\n\n    /**\n     * Removes the lazily loaded members from storage if needed\n     */\n    public async clearLoadedMembersIfNeeded(): Promise<void> {\n        if (this.opts.lazyLoadMembers && this.membersPromise) {\n            await this.loadMembersIfNeeded();\n            await this.client.store.clearOutOfBandMembers(this.roomId);\n            this.currentState.clearOutOfBandMembers();\n            this.membersPromise = undefined;\n        }\n    }\n\n    /**\n     * called when sync receives this room in the leave section\n     * to do cleanup after leaving a room. Possibly called multiple times.\n     */\n    private cleanupAfterLeaving(): void {\n        this.clearLoadedMembersIfNeeded().catch((err) => {\n            logger.error(`error after clearing loaded members from ` + `room ${this.roomId} after leaving`);\n            logger.log(err);\n        });\n    }\n\n    /**\n     * Empty out the current live timeline and re-request it. This is used when\n     * historical messages are imported into the room via MSC2716 `/batch_send`\n     * because the client may already have that section of the timeline loaded.\n     * We need to force the client to throw away their current timeline so that\n     * when they back paginate over the area again with the historical messages\n     * in between, it grabs the newly imported messages. We can listen for\n     * `UNSTABLE_MSC2716_MARKER`, in order to tell when historical messages are ready\n     * to be discovered in the room and the timeline needs a refresh. The SDK\n     * emits a `RoomEvent.HistoryImportedWithinTimeline` event when we detect a\n     * valid marker and can check the needs refresh status via\n     * `room.getTimelineNeedsRefresh()`.\n     */\n    public async refreshLiveTimeline(): Promise<void> {\n        const liveTimelineBefore = this.getLiveTimeline();\n        const forwardPaginationToken = liveTimelineBefore.getPaginationToken(EventTimeline.FORWARDS);\n        const backwardPaginationToken = liveTimelineBefore.getPaginationToken(EventTimeline.BACKWARDS);\n        const eventsBefore = liveTimelineBefore.getEvents();\n        const mostRecentEventInTimeline = eventsBefore[eventsBefore.length - 1];\n        logger.log(\n            `[refreshLiveTimeline for ${this.roomId}] at ` +\n                `mostRecentEventInTimeline=${mostRecentEventInTimeline && mostRecentEventInTimeline.getId()} ` +\n                `liveTimelineBefore=${liveTimelineBefore.toString()} ` +\n                `forwardPaginationToken=${forwardPaginationToken} ` +\n                `backwardPaginationToken=${backwardPaginationToken}`,\n        );\n\n        // Get the main TimelineSet\n        const timelineSet = this.getUnfilteredTimelineSet();\n\n        let newTimeline: EventTimeline | null = null;\n        // If there isn't any event in the timeline, let's go fetch the latest\n        // event and construct a timeline from it.\n        //\n        // This should only really happen if the user ran into an error\n        // with refreshing the timeline before which left them in a blank\n        // timeline from `resetLiveTimeline`.\n        if (!mostRecentEventInTimeline) {\n            newTimeline = await this.client.getLatestTimeline(timelineSet);\n        } else {\n            // Empty out all of `this.timelineSets`. But we also need to keep the\n            // same `timelineSet` references around so the React code updates\n            // properly and doesn't ignore the room events we emit because it checks\n            // that the `timelineSet` references are the same. We need the\n            // `timelineSet` empty so that the `client.getEventTimeline(...)` call\n            // later, will call `/context` and create a new timeline instead of\n            // returning the same one.\n            this.resetLiveTimeline(null, null);\n\n            // Make the UI timeline show the new blank live timeline we just\n            // reset so that if the network fails below it's showing the\n            // accurate state of what we're working with instead of the\n            // disconnected one in the TimelineWindow which is just hanging\n            // around by reference.\n            this.emit(RoomEvent.TimelineRefresh, this, timelineSet);\n\n            // Use `client.getEventTimeline(...)` to construct a new timeline from a\n            // `/context` response state and events for the most recent event before\n            // we reset everything. The `timelineSet` we pass in needs to be empty\n            // in order for this function to call `/context` and generate a new\n            // timeline.\n            newTimeline = await this.client.getEventTimeline(timelineSet, mostRecentEventInTimeline.getId()!);\n        }\n\n        // If a racing `/sync` beat us to creating a new timeline, use that\n        // instead because it's the latest in the room and any new messages in\n        // the scrollback will include the history.\n        const liveTimeline = timelineSet.getLiveTimeline();\n        if (\n            !liveTimeline ||\n            (liveTimeline.getPaginationToken(Direction.Forward) === null &&\n                liveTimeline.getPaginationToken(Direction.Backward) === null &&\n                liveTimeline.getEvents().length === 0)\n        ) {\n            logger.log(`[refreshLiveTimeline for ${this.roomId}] using our new live timeline`);\n            // Set the pagination token back to the live sync token (`null`) instead\n            // of using the `/context` historical token (ex. `t12-13_0_0_0_0_0_0_0_0`)\n            // so that it matches the next response from `/sync` and we can properly\n            // continue the timeline.\n            newTimeline!.setPaginationToken(forwardPaginationToken, EventTimeline.FORWARDS);\n\n            // Set our new fresh timeline as the live timeline to continue syncing\n            // forwards and back paginating from.\n            timelineSet.setLiveTimeline(newTimeline!);\n            // Fixup `this.oldstate` so that `scrollback` has the pagination tokens\n            // available\n            this.fixUpLegacyTimelineFields();\n        } else {\n            logger.log(\n                `[refreshLiveTimeline for ${this.roomId}] \\`/sync\\` or some other request beat us to creating a new ` +\n                    `live timeline after we reset it. We'll use that instead since any events in the scrollback from ` +\n                    `this timeline will include the history.`,\n            );\n        }\n\n        // The timeline has now been refreshed \n        this.setTimelineNeedsRefresh(false);\n\n        // Emit an event which clients can react to and re-load the timeline\n        // from the SDK\n        this.emit(RoomEvent.TimelineRefresh, this, timelineSet);\n    }\n\n    /**\n     * Reset the live timeline of all timelineSets, and start new ones.\n     *\n     * <p>This is used when /sync returns a 'limited' timeline.\n     *\n     * @param backPaginationToken -   token for back-paginating the new timeline\n     * @param forwardPaginationToken - token for forward-paginating the old live timeline,\n     * if absent or null, all timelines are reset, removing old ones (including the previous live\n     * timeline which would otherwise be unable to paginate forwards without this token).\n     * Removing just the old live timeline whilst preserving previous ones is not supported.\n     */\n    public resetLiveTimeline(backPaginationToken?: string | null, forwardPaginationToken?: string | null): void {\n        for (const timelineSet of this.timelineSets) {\n            timelineSet.resetLiveTimeline(backPaginationToken ?? undefined, forwardPaginationToken ?? undefined);\n        }\n        for (const thread of this.threads.values()) {\n            thread.resetLiveTimeline(backPaginationToken, forwardPaginationToken);\n        }\n\n        this.fixUpLegacyTimelineFields();\n    }\n\n    /**\n     * Fix up this.timeline, this.oldState and this.currentState\n     *\n     * @internal\n     */\n    private fixUpLegacyTimelineFields(): void {\n        const previousOldState = this.oldState;\n        const previousCurrentState = this.currentState;\n\n        // maintain this.oldState and this.currentState as references to the\n        // state at the start and end of that timeline. These are more\n        // for backwards-compatibility than anything else.\n        this.oldState = this.getLiveTimeline().getState(EventTimeline.BACKWARDS)!;\n        this.currentState = this.getLiveTimeline().getState(EventTimeline.FORWARDS)!;\n\n        // Let people know to register new listeners for the new state\n        // references. The reference won't necessarily change every time so only\n        // emit when we see a change.\n        if (previousOldState !== this.oldState) {\n            this.emit(RoomEvent.OldStateUpdated, this, previousOldState, this.oldState);\n        }\n\n        if (previousCurrentState !== this.currentState) {\n            this.emit(RoomEvent.CurrentStateUpdated, this, previousCurrentState, this.currentState);\n\n            // Re-emit various events on the current room state\n            // TODO: If currentState really only exists for backwards\n            // compatibility, shouldn't we be doing this some other way?\n            this.reEmitter.stopReEmitting(previousCurrentState, [\n                RoomStateEvent.Events,\n                RoomStateEvent.Members,\n                RoomStateEvent.NewMember,\n                RoomStateEvent.Update,\n                RoomStateEvent.Marker,\n                BeaconEvent.New,\n                BeaconEvent.Update,\n                BeaconEvent.Destroy,\n                BeaconEvent.LivenessChange,\n            ]);\n            this.reEmitter.reEmit(this.currentState, [\n                RoomStateEvent.Events,\n                RoomStateEvent.Members,\n                RoomStateEvent.NewMember,\n                RoomStateEvent.Update,\n                RoomStateEvent.Marker,\n                BeaconEvent.New,\n                BeaconEvent.Update,\n                BeaconEvent.Destroy,\n                BeaconEvent.LivenessChange,\n            ]);\n        }\n    }\n\n    private onReceipt(event: MatrixEvent): void {\n        if (this.hasEncryptionStateEvent()) {\n            this.clearNotificationsOnReceipt(event);\n        }\n    }\n\n    private clearNotificationsOnReceipt(event: MatrixEvent): void {\n        // Like above, we have to listen for read receipts from ourselves in order to\n        // correctly handle notification counts on encrypted rooms.\n        // This fixes https://github.com/vector-im/element-web/issues/9421\n\n        // Figure out if we've read something or if it's just informational\n        // We need to work out what threads we've just recieved receipts for, so we\n        // know which ones to update. If we've received an unthreaded receipt, we'll\n        // need to update all threads.\n        let threadIds: string[] = [];\n        let hasUnthreadedReceipt = false;\n\n        const content = event.getContent();\n\n        for (const receiptGroup of Object.values(content)) {\n            for (const [receiptType, userReceipt] of Object.entries(receiptGroup)) {\n                if (!utils.isSupportedReceiptType(receiptType)) continue;\n                if (!userReceipt) continue;\n\n                for (const [userId, singleReceipt] of Object.entries(userReceipt)) {\n                    if (!singleReceipt || typeof singleReceipt !== \"object\") continue;\n                    const typedSingleReceipt = singleReceipt as Record<string, any>;\n                    if (userId !== this.client.getUserId()) continue;\n                    if (typedSingleReceipt.thread_id === undefined) {\n                        hasUnthreadedReceipt = true;\n                    } else if (typeof typedSingleReceipt.thread_id === \"string\") {\n                        threadIds.push(typedSingleReceipt.thread_id);\n                    }\n                }\n            }\n        }\n\n        if (hasUnthreadedReceipt) {\n            // If we have an unthreaded receipt, we need to update any threads that have a notification\n            // in them (because we know the receipt can't go backwards so we don't need to check any with\n            // no notifications: the number can only decrease from a receipt).\n            threadIds = this.getThreads()\n                .filter(\n                    (thread) =>\n                        this.getThreadUnreadNotificationCount(thread.id, NotificationCountType.Total) > 0 ||\n                        this.getThreadUnreadNotificationCount(thread.id, NotificationCountType.Highlight) > 0,\n                )\n                .map((thread) => thread.id);\n            threadIds.push(\"main\");\n        }\n\n        for (const threadId of threadIds) {\n            // Work backwards to determine how many events are unread. We also set\n            // a limit for how back we'll look to avoid spinning CPU for too long.\n            // If we hit the limit, we assume the count is unchanged.\n            const maxHistory = 20;\n            const timeline = threadId === \"main\" ? this.getLiveTimeline() : this.getThread(threadId)?.liveTimeline;\n\n            if (!timeline) {\n                logger.warn(`Couldn't find timeline for thread ID ${threadId} in room ${this.roomId}`);\n                continue;\n            }\n\n            const events = timeline.getEvents();\n\n            let highlightCount = 0;\n\n            for (let i = events.length - 1; i >= 0; i--) {\n                if (i === events.length - maxHistory) return; // limit reached\n\n                const event = events[i];\n\n                if (this.hasUserReadEvent(this.client.getUserId()!, event.getId()!)) {\n                    // If the user has read the event, then the counting is done.\n                    break;\n                }\n\n                const pushActions = this.client.getPushActionsForEvent(event);\n                highlightCount += pushActions?.tweaks?.highlight ? 1 : 0;\n            }\n\n            // Note: we don't need to handle 'total' notifications because the counts\n            // will come from the server.\n            if (threadId === \"main\") {\n                this.setUnreadNotificationCount(NotificationCountType.Highlight, highlightCount);\n            } else {\n                this.setThreadUnreadNotificationCount(threadId, NotificationCountType.Highlight, highlightCount);\n            }\n        }\n    }\n\n    /**\n     * Return the timeline sets for this room.\n     * @returns array of timeline sets for this room\n     */\n    public getTimelineSets(): EventTimelineSet[] {\n        return this.timelineSets;\n    }\n\n    /**\n     * Helper to return the main unfiltered timeline set for this room\n     * @returns room's unfiltered timeline set\n     */\n    public getUnfilteredTimelineSet(): EventTimelineSet {\n        return this.timelineSets[0];\n    }\n\n    /**\n     * Get the timeline which contains the given event from the unfiltered set, if any\n     *\n     * @param eventId -  event ID to look for\n     * @returns timeline containing\n     * the given event, or null if unknown\n     */\n    public getTimelineForEvent(eventId: string): EventTimeline | null {\n        const event = this.findEventById(eventId);\n        const thread = this.findThreadForEvent(event);\n        if (thread) {\n            return thread.timelineSet.getTimelineForEvent(eventId);\n        } else {\n            return this.getUnfilteredTimelineSet().getTimelineForEvent(eventId);\n        }\n    }\n\n    /**\n     * Add a new timeline to this room's unfiltered timeline set\n     *\n     * @returns newly-created timeline\n     */\n    public addTimeline(): EventTimeline {\n        return this.getUnfilteredTimelineSet().addTimeline();\n    }\n\n    /**\n     * Whether the timeline needs to be refreshed in order to pull in new\n     * historical messages that were imported.\n     * @param value - The value to set\n     */\n    public setTimelineNeedsRefresh(value: boolean): void {\n        this.timelineNeedsRefresh = value;\n    }\n\n    /**\n     * Whether the timeline needs to be refreshed in order to pull in new\n     * historical messages that were imported.\n     * @returns .\n     */\n    public getTimelineNeedsRefresh(): boolean {\n        return this.timelineNeedsRefresh;\n    }\n\n    /**\n     * Get an event which is stored in our unfiltered timeline set, or in a thread\n     *\n     * @param eventId - event ID to look for\n     * @returns the given event, or undefined if unknown\n     */\n    public findEventById(eventId: string): MatrixEvent | undefined {\n        let event = this.getUnfilteredTimelineSet().findEventById(eventId);\n\n        if (!event) {\n            const threads = this.getThreads();\n            for (let i = 0; i < threads.length; i++) {\n                const thread = threads[i];\n                event = thread.findEventById(eventId);\n                if (event) {\n                    return event;\n                }\n            }\n        }\n\n        return event;\n    }\n\n    /**\n     * Get one of the notification counts for this room\n     * @param type - The type of notification count to get. default: 'total'\n     * @returns The notification count, or undefined if there is no count\n     *                  for this type.\n     */\n    public getUnreadNotificationCount(type = NotificationCountType.Total): number {\n        let count = this.getRoomUnreadNotificationCount(type);\n        for (const threadNotification of this.threadNotifications.values()) {\n            count += threadNotification[type] ?? 0;\n        }\n        return count;\n    }\n\n    /**\n     * Get the notification for the event context (room or thread timeline)\n     */\n    public getUnreadCountForEventContext(type = NotificationCountType.Total, event: MatrixEvent): number {\n        const isThreadEvent = !!event.threadRootId && !event.isThreadRoot;\n\n        return (\n            (isThreadEvent\n                ? this.getThreadUnreadNotificationCount(event.threadRootId, type)\n                : this.getRoomUnreadNotificationCount(type)) ?? 0\n        );\n    }\n\n    /**\n     * Get one of the notification counts for this room\n     * @param type - The type of notification count to get. default: 'total'\n     * @returns The notification count, or undefined if there is no count\n     *                  for this type.\n     */\n    public getRoomUnreadNotificationCount(type = NotificationCountType.Total): number {\n        return this.notificationCounts[type] ?? 0;\n    }\n\n    /**\n     * Get one of the notification counts for a thread\n     * @param threadId - the root event ID\n     * @param type - The type of notification count to get. default: 'total'\n     * @returns The notification count, or undefined if there is no count\n     *          for this type.\n     */\n    public getThreadUnreadNotificationCount(threadId: string, type = NotificationCountType.Total): number {\n        return this.threadNotifications.get(threadId)?.[type] ?? 0;\n    }\n\n    /**\n     * Checks if the current room has unread thread notifications\n     * @returns\n     */\n    public hasThreadUnreadNotification(): boolean {\n        for (const notification of this.threadNotifications.values()) {\n            if ((notification.highlight ?? 0) > 0 || (notification.total ?? 0) > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Swet one of the notification count for a thread\n     * @param threadId - the root event ID\n     * @param type - The type of notification count to get. default: 'total'\n     * @returns\n     */\n    public setThreadUnreadNotificationCount(threadId: string, type: NotificationCountType, count: number): void {\n        const notification: NotificationCount = {\n            highlight: this.threadNotifications.get(threadId)?.highlight,\n            total: this.threadNotifications.get(threadId)?.total,\n            ...{\n                [type]: count,\n            },\n        };\n\n        this.threadNotifications.set(threadId, notification);\n\n        this.emit(RoomEvent.UnreadNotifications, notification, threadId);\n    }\n\n    /**\n     * @returns the notification count type for all the threads in the room\n     */\n    public get threadsAggregateNotificationType(): NotificationCountType | null {\n        let type: NotificationCountType | null = null;\n        for (const threadNotification of this.threadNotifications.values()) {\n            if ((threadNotification.highlight ?? 0) > 0) {\n                return NotificationCountType.Highlight;\n            } else if ((threadNotification.total ?? 0) > 0 && !type) {\n                type = NotificationCountType.Total;\n            }\n        }\n        return type;\n    }\n\n    /**\n     * Resets the total thread notifications for all threads in this room to zero,\n     * excluding any threads whose IDs are given in `exceptThreadIds`.\n     *\n     * If the room is not encrypted, also resets the highlight notification count to zero\n     * for the same set of threads.\n     *\n     * This is intended for use from the sync code since we calculate highlight notification\n     * counts locally from decrypted messages. We want to partially trust the total from the\n     * server such that we clear notifications when read receipts arrive. The weird name is\n     * intended to reflect this. You probably do not want to use this.\n     *\n     * @param exceptThreadIds - The thread IDs to exclude from the reset.\n     */\n    public resetThreadUnreadNotificationCountFromSync(exceptThreadIds: string[] = []): void {\n        const isEncrypted = this.hasEncryptionStateEvent();\n\n        for (const [threadId, notifs] of this.threadNotifications) {\n            if (!exceptThreadIds.includes(threadId)) {\n                notifs.total = 0;\n                if (!isEncrypted) {\n                    notifs.highlight = 0;\n                }\n            }\n        }\n\n        this.emit(RoomEvent.UnreadNotifications);\n    }\n\n    /**\n     * Set the bump stamp for this room. This can be used for sorting rooms when the timeline\n     * entries are unknown. Used in MSC4186: Simplified Sliding Sync.\n     * @param bumpStamp The bump_stamp value from the server\n     */\n    public setBumpStamp(bumpStamp: number): void {\n        this.bumpStamp = bumpStamp;\n    }\n\n    /**\n     * Get the bump stamp for this room. This can be used for sorting rooms when the timeline\n     * entries are unknown. Used in MSC4186: Simplified Sliding Sync.\n     * @returns The bump stamp for the room, if it exists.\n     */\n    public getBumpStamp(): number | undefined {\n        return this.bumpStamp;\n    }\n\n    /**\n     * Set one of the notification counts for this room\n     * @param type - The type of notification count to set.\n     * @param count - The new count\n     */\n    public setUnreadNotificationCount(type: NotificationCountType, count: number): void {\n        this.notificationCounts[type] = count;\n        this.emit(RoomEvent.UnreadNotifications, this.notificationCounts);\n    }\n\n    public setUnread(type: NotificationCountType, count: number): void {\n        return this.setUnreadNotificationCount(type, count);\n    }\n\n    /**\n     * Takes a legacy room summary (/v3/sync as opposed to MSC4186) and updates the room with it.\n     *\n     * @param summary - The room summary to update the room with\n     */\n    public setSummary(summary: IRoomSummary): void {\n        const heroes = summary[\"m.heroes\"]?.map((h) => ({ userId: h, fromMSC4186: false }));\n        const joinedCount = summary[\"m.joined_member_count\"];\n        const invitedCount = summary[\"m.invited_member_count\"];\n        if (Number.isInteger(joinedCount)) {\n            this.currentState.setJoinedMemberCount(joinedCount!);\n        }\n        if (Number.isInteger(invitedCount)) {\n            this.currentState.setInvitedMemberCount(invitedCount!);\n        }\n        if (Array.isArray(heroes)) {\n            // filter out ourselves just in case\n            this.heroes = heroes.filter((h) => {\n                return h.userId != this.myUserId;\n            });\n        }\n\n        this.emit(RoomEvent.Summary, summary);\n    }\n\n    /**\n     * Takes information from the MSC4186 room summary and updates the room with it.\n     *\n     * @param heroes - The room's hero members\n     * @param joinedCount - The number of joined members\n     * @param invitedCount - The number of invited members\n     */\n    public setMSC4186SummaryData(\n        heroes: MSC4186Hero[] | undefined,\n        joinedCount: number | undefined,\n        invitedCount: number | undefined,\n    ): void {\n        if (heroes) {\n            this.heroes = heroes\n                .filter((h) => h.user_id !== this.myUserId)\n                .map((h) => ({\n                    userId: h.user_id,\n                    displayName: h.displayname,\n                    avatarUrl: h.avatar_url,\n                    fromMSC4186: true,\n                }));\n        }\n        if (joinedCount !== undefined && Number.isInteger(joinedCount)) {\n            this.currentState.setJoinedMemberCount(joinedCount);\n        }\n        if (invitedCount !== undefined && Number.isInteger(invitedCount)) {\n            this.currentState.setInvitedMemberCount(invitedCount);\n        }\n\n        // Construct a summary object to emit as the event wants the info in a single object\n        // more like old-style (/v3/sync) summaries.\n        this.emit(RoomEvent.Summary, {\n            \"m.heroes\": this.heroes ? this.heroes.map((h) => h.userId) : [],\n            \"m.joined_member_count\": joinedCount,\n            \"m.invited_member_count\": invitedCount,\n        });\n    }\n\n    /**\n     * Whether to send encrypted messages to devices within this room.\n     * @param value - true to blacklist unverified devices, null\n     * to use the global value for this room.\n     */\n    public setBlacklistUnverifiedDevices(value: boolean): void {\n        this.blacklistUnverifiedDevices = value;\n    }\n\n    /**\n     * Whether to send encrypted messages to devices within this room.\n     * @returns true if blacklisting unverified devices, null\n     * if the global value should be used for this room.\n     */\n    public getBlacklistUnverifiedDevices(): boolean | null {\n        if (this.blacklistUnverifiedDevices === undefined) return null;\n        return this.blacklistUnverifiedDevices;\n    }\n\n    /**\n     * Get the avatar URL for a room if one was set.\n     * @param baseUrl - The homeserver base URL. See\n     * {@link MatrixClient#getHomeserverUrl}.\n     * @param width - The desired width of the thumbnail.\n     * @param height - The desired height of the thumbnail.\n     * @param resizeMethod - The thumbnail resize method to use, either\n     * \"crop\" or \"scale\".\n     * @param allowDefault - True to allow an identicon for this room if an\n     * avatar URL wasn't explicitly set. Default: true. (Deprecated)\n     * @param useAuthentication - (optional) If true, the caller supports authenticated\n     * media and wants an authentication-required URL. Note that server support for\n     * authenticated media will not be checked - it is the caller's responsibility\n     * to do so before calling this function. Note also that useAuthentication\n     * implies allowRedirects. Defaults to false (unauthenticated endpoints).\n     * @returns the avatar URL or null.\n     */\n    public getAvatarUrl(\n        baseUrl: string,\n        width: number,\n        height: number,\n        resizeMethod: ResizeMethod,\n        allowDefault = true,\n        useAuthentication: boolean = false,\n    ): string | null {\n        const mainUrl = this.getMxcAvatarUrl();\n        if (!mainUrl && !allowDefault) {\n            return null;\n        }\n\n        if (mainUrl) {\n            return getHttpUriForMxc(\n                baseUrl,\n                mainUrl,\n                width,\n                height,\n                resizeMethod,\n                undefined,\n                undefined,\n                useAuthentication,\n            );\n        }\n\n        return null;\n    }\n\n    /**\n     * Get the mxc avatar url for the room, if one was set.\n     * @returns the mxc avatar url or falsy\n     */\n    public getMxcAvatarUrl(): string | null {\n        const url = this.currentState.getStateEvents(EventType.RoomAvatar, \"\")?.getContent().url;\n        return url && typeof url === \"string\" ? url : null;\n    }\n\n    /**\n     * Get this room's canonical alias\n     * The alias returned by this function may not necessarily\n     * still point to this room.\n     * @returns The room's canonical alias, or null if there is none\n     */\n    public getCanonicalAlias(): string | null {\n        const canonicalAlias = this.currentState.getStateEvents(EventType.RoomCanonicalAlias, \"\")?.getContent().alias;\n        return canonicalAlias && typeof canonicalAlias === \"string\" ? canonicalAlias : null;\n    }\n\n    /**\n     * Get this room's alternative aliases\n     * @returns The room's alternative aliases, or an empty array\n     */\n    public getAltAliases(): string[] {\n        const altAliases = this.currentState.getStateEvents(EventType.RoomCanonicalAlias, \"\")?.getContent().alt_aliases;\n        if (Array.isArray(altAliases)) {\n            return altAliases.filter((alias) => typeof alias === \"string\");\n        }\n        return [];\n    }\n\n    /**\n     * Add events to a timeline\n     *\n     * <p>Will fire \"Room.timeline\" for each event added.\n     *\n     * @param events - A list of events to add.\n     *\n     * @param toStartOfTimeline -   True to add these events to the start\n     * (oldest) instead of the end (newest) of the timeline. If true, the oldest\n     * event will be the <b>last</b> element of 'events'.\n     *\n     * @param timeline -   timeline to\n     *    add events to.\n     *\n     * @param paginationToken -   token for the next batch of events\n     *\n     * @remarks\n     * Fires {@link RoomEvent.Timeline}\n     */\n    public addEventsToTimeline(\n        events: MatrixEvent[],\n        toStartOfTimeline: boolean,\n        addToState: boolean,\n        timeline: EventTimeline,\n        paginationToken?: string,\n    ): void {\n        timeline.getTimelineSet().addEventsToTimeline(events, toStartOfTimeline, addToState, timeline, paginationToken);\n    }\n\n    /**\n     * Get the instance of the thread associated with the current event\n     * @param eventId - the ID of the current event\n     * @returns a thread instance if known\n     */\n    public getThread(eventId: string): Thread | null {\n        return this.threads.get(eventId) ?? null;\n    }\n\n    /**\n     * Get all the known threads in the room\n     */\n    public getThreads(): Thread[] {\n        return Array.from(this.threads.values());\n    }\n\n    /**\n     * Get a member from the current room state.\n     * @param userId - The user ID of the member.\n     * @returns The member or `null`.\n     */\n    public getMember(userId: string): RoomMember | null {\n        return this.currentState.getMember(userId);\n    }\n\n    /**\n     * Get all currently loaded members from the current\n     * room state.\n     * @returns Room members\n     */\n    public getMembers(): RoomMember[] {\n        return this.currentState.getMembers();\n    }\n\n    /**\n     * Get a list of members whose membership state is \"join\".\n     * @returns A list of currently joined members.\n     */\n    public getJoinedMembers(): RoomMember[] {\n        return this.getMembersWithMembership(KnownMembership.Join);\n    }\n\n    /**\n     * Returns the number of joined members in this room\n     * This method caches the result.\n     * This is a wrapper around the method of the same name in roomState, returning\n     * its result for the room's current state.\n     * @returns The number of members in this room whose membership is 'join'\n     */\n    public getJoinedMemberCount(): number {\n        return this.currentState.getJoinedMemberCount();\n    }\n\n    /**\n     * Returns the number of invited members in this room\n     * @returns The number of members in this room whose membership is 'invite'\n     */\n    public getInvitedMemberCount(): number {\n        return this.currentState.getInvitedMemberCount();\n    }\n\n    /**\n     * Returns the number of invited + joined members in this room\n     * @returns The number of members in this room whose membership is 'invite' or 'join'\n     */\n    public getInvitedAndJoinedMemberCount(): number {\n        return this.getInvitedMemberCount() + this.getJoinedMemberCount();\n    }\n\n    /**\n     * Get a list of members with given membership state.\n     * @param membership - The membership state.\n     * @returns A list of members with the given membership state.\n     */\n    public getMembersWithMembership(membership: Membership): RoomMember[] {\n        return this.currentState.getMembers().filter(function (m) {\n            return m.membership === membership;\n        });\n    }\n\n    /**\n     * Get a list of members we should be encrypting for in this room\n     * @returns A list of members who\n     * we should encrypt messages for in this room.\n     */\n    public async getEncryptionTargetMembers(): Promise<RoomMember[]> {\n        await this.loadMembersIfNeeded();\n        let members = this.getMembersWithMembership(KnownMembership.Join);\n        if (this.shouldEncryptForInvitedMembers()) {\n            members = members.concat(this.getMembersWithMembership(KnownMembership.Invite));\n        }\n        return members;\n    }\n\n    /**\n     * Determine whether we should encrypt messages for invited users in this room\n     * @returns if we should encrypt messages for invited users\n     */\n    public shouldEncryptForInvitedMembers(): boolean {\n        const ev = this.currentState.getStateEvents(EventType.RoomHistoryVisibility, \"\");\n        return ev?.getContent()?.history_visibility !== \"joined\";\n    }\n\n    /**\n     * Get the default room name (i.e. what a given user would see if the\n     * room had no m.room.name)\n     * @param userId - The userId from whose perspective we want\n     * to calculate the default name\n     * @returns The default room name\n     */\n    public getDefaultRoomName(userId: string): string {\n        return this.calculateRoomName(userId, true);\n    }\n\n    /**\n     * Check if the given user_id has the given membership state.\n     * @param userId - The user ID to check.\n     * @param membership - The membership e.g. `'join'`\n     * @returns True if this user_id has the given membership state.\n     */\n    public hasMembershipState(userId: string, membership: Membership): boolean {\n        const member = this.getMember(userId);\n        if (!member) {\n            return false;\n        }\n        return member.membership === membership;\n    }\n\n    /**\n     * Add a timelineSet for this room with the given filter\n     * @param filter - The filter to be applied to this timelineSet\n     * @param opts - Configuration options\n     * @returns The timelineSet\n     */\n    public getOrCreateFilteredTimelineSet(\n        filter: Filter,\n        { prepopulateTimeline = true, useSyncEvents = true, pendingEvents = true }: ICreateFilterOpts = {},\n    ): EventTimelineSet {\n        if (this.filteredTimelineSets[filter.filterId!]) {\n            return this.filteredTimelineSets[filter.filterId!];\n        }\n        const opts = Object.assign({ filter, pendingEvents }, this.opts);\n        const timelineSet = new EventTimelineSet(this, opts);\n        this.reEmitter.reEmit(timelineSet, [RoomEvent.Timeline, RoomEvent.TimelineReset]);\n        if (useSyncEvents) {\n            this.filteredTimelineSets[filter.filterId!] = timelineSet;\n            this.timelineSets.push(timelineSet);\n        }\n\n        const unfilteredLiveTimeline = this.getLiveTimeline();\n        // Not all filter are possible to replicate client-side only\n        // When that's the case we do not want to prepopulate from the live timeline\n        // as we would get incorrect results compared to what the server would send back\n        if (prepopulateTimeline) {\n            // populate up the new timelineSet with filtered events from our live\n            // unfiltered timeline.\n            //\n            // XXX: This is risky as our timeline\n            // may have grown huge and so take a long time to filter.\n            // see https://github.com/vector-im/vector-web/issues/2109\n\n            unfilteredLiveTimeline.getEvents().forEach(function (event) {\n                timelineSet.addLiveEvent(event, { addToState: false }); // Filtered timeline sets should not track state\n            });\n\n            // find the earliest unfiltered timeline\n            let timeline = unfilteredLiveTimeline;\n            while (timeline.getNeighbouringTimeline(EventTimeline.BACKWARDS)) {\n                timeline = timeline.getNeighbouringTimeline(EventTimeline.BACKWARDS)!;\n            }\n\n            timelineSet\n                .getLiveTimeline()\n                .setPaginationToken(timeline.getPaginationToken(EventTimeline.BACKWARDS), EventTimeline.BACKWARDS);\n        } else if (useSyncEvents) {\n            const livePaginationToken = unfilteredLiveTimeline.getPaginationToken(Direction.Forward);\n            timelineSet.getLiveTimeline().setPaginationToken(livePaginationToken, Direction.Backward);\n        }\n\n        // alternatively, we could try to do something like this to try and re-paginate\n        // in the filtered events from nothing, but Mark says it's an abuse of the API\n        // to do so:\n        //\n        // timelineSet.resetLiveTimeline(\n        //      unfilteredLiveTimeline.getPaginationToken(EventTimeline.FORWARDS)\n        // );\n\n        return timelineSet;\n    }\n\n    private async getThreadListFilter(filterType = ThreadFilterType.All): Promise<Filter> {\n        const myUserId = this.client.getUserId()!;\n        const filter = new Filter(myUserId);\n\n        const definition: IFilterDefinition = {\n            room: {\n                timeline: {\n                    [FILTER_RELATED_BY_REL_TYPES.name]: [THREAD_RELATION_TYPE.name],\n                },\n            },\n        };\n\n        if (filterType === ThreadFilterType.My) {\n            definition!.room!.timeline![FILTER_RELATED_BY_SENDERS.name] = [myUserId];\n        }\n\n        filter.setDefinition(definition);\n        const filterId = await this.client.getOrCreateFilter(`THREAD_PANEL_${this.roomId}_${filterType}`, filter);\n\n        filter.filterId = filterId;\n\n        return filter;\n    }\n\n    private async createThreadTimelineSet(filterType?: ThreadFilterType): Promise<EventTimelineSet> {\n        let timelineSet: EventTimelineSet;\n        if (Thread.hasServerSideListSupport) {\n            timelineSet = new EventTimelineSet(\n                this,\n                {\n                    ...this.opts,\n                    pendingEvents: false,\n                },\n                undefined,\n                undefined,\n                filterType ?? ThreadFilterType.All,\n            );\n            this.reEmitter.reEmit(timelineSet, [RoomEvent.Timeline, RoomEvent.TimelineReset]);\n        } else if (Thread.hasServerSideSupport) {\n            const filter = await this.getThreadListFilter(filterType);\n\n            timelineSet = this.getOrCreateFilteredTimelineSet(filter, {\n                prepopulateTimeline: false,\n                useSyncEvents: false,\n                pendingEvents: false,\n            });\n        } else {\n            timelineSet = new EventTimelineSet(this, {\n                pendingEvents: false,\n            });\n\n            Array.from(this.threads).forEach(([, thread]) => {\n                if (thread.length === 0) return;\n                const currentUserParticipated = thread.timeline.some((event) => {\n                    return event.getSender() === this.client.getUserId();\n                });\n                if (filterType !== ThreadFilterType.My || currentUserParticipated) {\n                    timelineSet.getLiveTimeline().addEvent(thread.rootEvent!, {\n                        toStartOfTimeline: false,\n                        addToState: false,\n                    });\n                }\n            });\n        }\n\n        return timelineSet;\n    }\n\n    private threadsReady = false;\n\n    /**\n     * Takes the given thread root events and creates threads for them.\n     */\n    public processThreadRoots(events: MatrixEvent[], toStartOfTimeline: boolean): void {\n        if (!this.client.supportsThreads()) return;\n        for (const rootEvent of events) {\n            EventTimeline.setEventMetadata(rootEvent, this.currentState, toStartOfTimeline);\n            if (!this.getThread(rootEvent.getId()!)) {\n                this.createThread(rootEvent.getId()!, rootEvent, [], toStartOfTimeline);\n            }\n        }\n    }\n\n    /**\n     * Fetch the bare minimum of room threads required for the thread list to work reliably.\n     * With server support that means fetching one page.\n     * Without server support that means fetching as much at once as the server allows us to.\n     */\n    public async fetchRoomThreads(): Promise<void> {\n        if (this.threadsReady || !this.client.supportsThreads()) {\n            return;\n        }\n\n        if (Thread.hasServerSideListSupport) {\n            await Promise.all([\n                this.fetchRoomThreadList(ThreadFilterType.All),\n                this.fetchRoomThreadList(ThreadFilterType.My),\n            ]);\n        } else {\n            const allThreadsFilter = await this.getThreadListFilter();\n\n            const { chunk: events } = await this.client.createMessagesRequest(\n                this.roomId,\n                \"\",\n                Number.MAX_SAFE_INTEGER,\n                Direction.Backward,\n                allThreadsFilter,\n            );\n\n            if (!events.length) return;\n\n            // Sorted by last_reply origin_server_ts\n            const threadRoots = events.map(this.client.getEventMapper()).sort((eventA, eventB) => {\n                /**\n                 * `origin_server_ts` in a decentralised world is far from ideal\n                 * but for lack of any better, we will have to use this\n                 * Long term the sorting should be handled by homeservers and this\n                 * is only meant as a short term patch\n                 */\n                const threadAMetadata = eventA.getServerAggregatedRelation<IThreadBundledRelationship>(\n                    THREAD_RELATION_TYPE.name,\n                )!;\n                const threadBMetadata = eventB.getServerAggregatedRelation<IThreadBundledRelationship>(\n                    THREAD_RELATION_TYPE.name,\n                )!;\n                return threadAMetadata.latest_event.origin_server_ts - threadBMetadata.latest_event.origin_server_ts;\n            });\n\n            let latestMyThreadsRootEvent: MatrixEvent | undefined;\n            const roomState = this.getLiveTimeline().getState(EventTimeline.FORWARDS);\n            for (const rootEvent of threadRoots) {\n                const opts = {\n                    duplicateStrategy: DuplicateStrategy.Ignore,\n                    fromCache: false,\n                    addToState: false,\n                    roomState,\n                };\n                this.threadsTimelineSets[0]?.addLiveEvent(rootEvent, opts);\n\n                const threadRelationship = rootEvent.getServerAggregatedRelation<IThreadBundledRelationship>(\n                    THREAD_RELATION_TYPE.name,\n                );\n                if (threadRelationship?.current_user_participated) {\n                    this.threadsTimelineSets[1]?.addLiveEvent(rootEvent, opts);\n                    latestMyThreadsRootEvent = rootEvent;\n                }\n            }\n\n            this.processThreadRoots(threadRoots, true);\n\n            this.client.decryptEventIfNeeded(threadRoots[threadRoots.length - 1]);\n            if (latestMyThreadsRootEvent) {\n                this.client.decryptEventIfNeeded(latestMyThreadsRootEvent);\n            }\n        }\n\n        this.on(ThreadEvent.NewReply, this.onThreadReply);\n        this.on(ThreadEvent.Update, this.onThreadUpdate);\n        this.on(ThreadEvent.Delete, this.onThreadDelete);\n        this.threadsReady = true;\n    }\n\n    /**\n     * Process a list of poll events.\n     *\n     * @param events - List of events\n     */\n    public async processPollEvents(events: MatrixEvent[]): Promise<void> {\n        for (const event of events) {\n            try {\n                // Continue if the event is a clear text, non-poll event.\n                if (!event.isEncrypted() && !isPollEvent(event)) continue;\n\n                /**\n                 * Try to decrypt the event. Promise resolution does not guarantee a successful decryption.\n                 * Retry is handled in {@link processPollEvent}.\n                 */\n                await this.client.decryptEventIfNeeded(event);\n                this.processPollEvent(event);\n            } catch (err) {\n                logger.warn(\"Error processing poll event\", event.getId(), err);\n            }\n        }\n    }\n\n    /**\n     * Processes poll events:\n     * If the event has a decryption failure, it will listen for decryption and tries again.\n     * If it is a poll start event (`m.poll.start`),\n     * it creates and stores a Poll model and emits a PollEvent.New event.\n     * If the event is related to a poll, it will add it to the poll.\n     * Noop for other cases.\n     *\n     * @param event - Event that could be a poll event\n     */\n    private async processPollEvent(event: MatrixEvent): Promise<void> {\n        if (event.isDecryptionFailure()) {\n            event.once(MatrixEventEvent.Decrypted, (maybeDecryptedEvent: MatrixEvent) => {\n                this.processPollEvent(maybeDecryptedEvent);\n            });\n            return;\n        }\n\n        if (M_POLL_START.matches(event.getType())) {\n            try {\n                const poll = new Poll(event, this.client, this);\n                this.polls.set(event.getId()!, poll);\n                this.emit(PollEvent.New, poll);\n\n                // remove the poll when redacted\n                event.once(MatrixEventEvent.BeforeRedaction, (redactedEvent: MatrixEvent) => {\n                    this.polls.delete(redactedEvent.getId()!);\n                });\n            } catch {}\n            // poll creation can fail for malformed poll start events\n            return;\n        }\n\n        const relationEventId = event.relationEventId;\n\n        if (relationEventId && this.polls.has(relationEventId)) {\n            const poll = this.polls.get(relationEventId);\n            poll?.onNewRelation(event);\n        }\n    }\n\n    /**\n     * Fetch a single page of threadlist messages for the specific thread filter\n     * @internal\n     */\n    private async fetchRoomThreadList(filter?: ThreadFilterType): Promise<void> {\n        if (!this.client.supportsThreads()) return;\n        if (this.threadsTimelineSets.length === 0) return;\n\n        const timelineSet = filter === ThreadFilterType.My ? this.threadsTimelineSets[1] : this.threadsTimelineSets[0];\n\n        const { chunk: events, end } = await this.client.createThreadListMessagesRequest(\n            this.roomId,\n            null,\n            undefined,\n            Direction.Backward,\n            timelineSet.threadListType,\n            timelineSet.getFilter(),\n        );\n\n        timelineSet.getLiveTimeline().setPaginationToken(end ?? null, Direction.Backward);\n\n        if (!events.length) return;\n\n        const matrixEvents = events.map(this.client.getEventMapper());\n        this.processThreadRoots(matrixEvents, true);\n        const roomState = this.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        for (const rootEvent of matrixEvents) {\n            timelineSet.addLiveEvent(rootEvent, {\n                duplicateStrategy: DuplicateStrategy.Replace,\n                fromCache: false,\n                roomState,\n                addToState: false,\n            });\n        }\n    }\n\n    private onThreadUpdate(thread: Thread): void {\n        this.updateThreadRootEvents(thread, false, false);\n    }\n\n    private onThreadReply(thread: Thread): void {\n        this.updateThreadRootEvents(thread, false, true);\n    }\n\n    private onThreadDelete(thread: Thread): void {\n        this.threads.delete(thread.id);\n\n        const timeline = this.getTimelineForEvent(thread.id);\n        const roomEvent = timeline?.getEvents()?.find((it) => it.getId() === thread.id);\n        if (roomEvent) {\n            thread.clearEventMetadata(roomEvent);\n        } else {\n            logger.debug(\"onThreadDelete: Could not find root event in room timeline\");\n        }\n        for (const timelineSet of this.threadsTimelineSets) {\n            timelineSet.removeEvent(thread.id);\n        }\n    }\n\n    /**\n     * Forget the timelineSet for this room with the given filter\n     *\n     * @param filter - the filter whose timelineSet is to be forgotten\n     */\n    public removeFilteredTimelineSet(filter: Filter): void {\n        const timelineSet = this.filteredTimelineSets[filter.filterId!];\n        delete this.filteredTimelineSets[filter.filterId!];\n        const i = this.timelineSets.indexOf(timelineSet);\n        if (i > -1) {\n            this.timelineSets.splice(i, 1);\n        }\n    }\n\n    /**\n     * Determine which timeline(s) a given event should live in\n     * Thread roots live in both the main timeline and their corresponding thread timeline\n     * Relations, redactions, replies to thread relation events live only in the thread timeline\n     * Relations (other than m.thread), redactions, replies to a thread root live only in the main timeline\n     * Relations, redactions, replies where the parent cannot be found live in no timelines but should be aggregated regardless.\n     * Otherwise, the event lives in the main timeline only.\n     *\n     * Note: when a redaction is applied, the redacted event, events relating\n     * to it, and the redaction event itself, will all move to the main thread.\n     * This method classifies them as inside the thread of the redacted event.\n     * They are moved later as part of makeRedacted.\n     * This will change if MSC3389 is merged.\n     */\n    public eventShouldLiveIn(\n        event: MatrixEvent,\n        events?: MatrixEvent[],\n        roots?: Set<string>,\n    ): {\n        shouldLiveInRoom: boolean;\n        shouldLiveInThread: boolean;\n        threadId?: string;\n    } {\n        if (!this.client?.supportsThreads()) {\n            return {\n                shouldLiveInRoom: true,\n                shouldLiveInThread: false,\n            };\n        }\n\n        // A thread root is the only event shown in both timelines\n        if (event.isThreadRoot || roots?.has(event.getId()!)) {\n            return {\n                shouldLiveInRoom: true,\n                shouldLiveInThread: true,\n                threadId: event.getId(),\n            };\n        }\n\n        const isThreadRelation = event.isRelation(THREAD_RELATION_TYPE.name);\n        const parentEventId = event.getAssociatedId();\n        const threadRootId = event.threadRootId;\n\n        // Where the parent is the thread root and this is a non-thread relation this should live only in the main timeline\n        if (!!parentEventId && !isThreadRelation && (threadRootId === parentEventId || roots?.has(parentEventId!))) {\n            return {\n                shouldLiveInRoom: true,\n                shouldLiveInThread: false,\n            };\n        }\n\n        let parentEvent: MatrixEvent | undefined;\n        if (parentEventId) {\n            parentEvent = this.findEventById(parentEventId) ?? events?.find((e) => e.getId() === parentEventId);\n        }\n\n        // Treat non-thread-relations, redactions, and replies as extensions of their parents so evaluate parentEvent instead\n        if (parentEvent && !isThreadRelation) {\n            return this.eventShouldLiveIn(parentEvent, events, roots);\n        }\n\n        // A thread relation (1st and 2nd order) is always only shown in a thread\n        if (threadRootId != undefined) {\n            return {\n                shouldLiveInRoom: false,\n                shouldLiveInThread: true,\n                threadId: threadRootId,\n            };\n        }\n\n        // Due to replies not being typical relations and being used as fallbacks for threads relations\n        // If we bypass the if case above then we know we are not a thread, so if we are still a reply\n        // then we know that we must be in the main timeline. Same goes if we have no associated parent event.\n        if (!parentEventId || !!event.replyEventId) {\n            return {\n                shouldLiveInRoom: true,\n                shouldLiveInThread: false,\n            };\n        }\n\n        // We've exhausted all scenarios,\n        // we cannot assume that it lives in the main timeline as this may be a relation for an unknown thread\n        // adding the event in the wrong timeline causes stuck notifications and can break ability to send read receipts\n        return {\n            shouldLiveInRoom: false,\n            shouldLiveInThread: false,\n        };\n    }\n\n    public findThreadForEvent(event?: MatrixEvent): Thread | null {\n        if (!event) return null;\n\n        const { threadId } = this.eventShouldLiveIn(event);\n        return threadId ? this.getThread(threadId) : null;\n    }\n\n    private addThreadedEvents(threadId: string, events: MatrixEvent[], toStartOfTimeline = false): void {\n        const thread = this.getThread(threadId);\n        if (thread) {\n            thread.addEvents(events, toStartOfTimeline);\n        } else {\n            const rootEvent = this.findEventById(threadId) ?? events.find((e) => e.getId() === threadId);\n            this.createThread(threadId, rootEvent, events, toStartOfTimeline);\n        }\n    }\n\n    /**\n     * Adds events to a thread's timeline. Will fire \"Thread.update\"\n     */\n    public processThreadedEvents(events: MatrixEvent[], toStartOfTimeline: boolean): void {\n        events.forEach(this.tryApplyRedaction);\n\n        const eventsByThread: { [threadId: string]: MatrixEvent[] } = {};\n        for (const event of events) {\n            const { threadId, shouldLiveInThread } = this.eventShouldLiveIn(event);\n            if (shouldLiveInThread && !eventsByThread[threadId!]) {\n                eventsByThread[threadId!] = [];\n            }\n            eventsByThread[threadId!]?.push(event);\n        }\n\n        Object.entries(eventsByThread).map(([threadId, threadEvents]) =>\n            this.addThreadedEvents(threadId, threadEvents, toStartOfTimeline),\n        );\n    }\n\n    private updateThreadRootEvents = (thread: Thread, toStartOfTimeline: boolean, recreateEvent: boolean): void => {\n        if (thread.length) {\n            this.updateThreadRootEvent(this.threadsTimelineSets?.[0], thread, toStartOfTimeline, recreateEvent);\n            if (thread.hasCurrentUserParticipated) {\n                this.updateThreadRootEvent(this.threadsTimelineSets?.[1], thread, toStartOfTimeline, recreateEvent);\n            }\n        }\n    };\n\n    private updateThreadRootEvent = (\n        timelineSet: EventTimelineSet | undefined,\n        thread: Thread,\n        toStartOfTimeline: boolean,\n        recreateEvent: boolean,\n    ): void => {\n        if (timelineSet && thread.rootEvent) {\n            if (recreateEvent) {\n                timelineSet.removeEvent(thread.id);\n            }\n            if (Thread.hasServerSideSupport) {\n                timelineSet.addLiveEvent(thread.rootEvent, {\n                    duplicateStrategy: DuplicateStrategy.Replace,\n                    fromCache: false,\n                    roomState: this.currentState,\n                    addToState: false,\n                });\n            } else {\n                timelineSet.addEventToTimeline(thread.rootEvent, timelineSet.getLiveTimeline(), {\n                    toStartOfTimeline,\n                    addToState: false,\n                });\n            }\n        }\n    };\n\n    public createThread(\n        threadId: string,\n        rootEvent: MatrixEvent | undefined,\n        events: MatrixEvent[] = [],\n        toStartOfTimeline: boolean,\n    ): Thread {\n        if (this.threads.has(threadId)) {\n            return this.threads.get(threadId)!;\n        }\n\n        if (rootEvent) {\n            const relatedEvents = this.relations.getAllChildEventsForEvent(rootEvent.getId()!);\n            if (relatedEvents?.length) {\n                // Include all relations of the root event, given it'll be visible in both timelines,\n                // except `m.replace` as that will already be applied atop the event using `MatrixEvent::makeReplaced`\n                events = events.concat(relatedEvents.filter((e) => !e.isRelation(RelationType.Replace)));\n            }\n        }\n\n        const thread = new Thread(threadId, rootEvent, {\n            room: this,\n            client: this.client,\n            pendingEventOrdering: this.opts.pendingEventOrdering,\n            receipts: this.cachedThreadReadReceipts.get(threadId) ?? [],\n        });\n\n        // Add the re-emitter before we start adding events to the thread so we don't miss events\n        this.reEmitter.reEmit(thread, [\n            ThreadEvent.Delete,\n            ThreadEvent.Update,\n            ThreadEvent.NewReply,\n            RoomEvent.Timeline,\n            RoomEvent.TimelineReset,\n        ]);\n\n        // All read receipts should now come down from sync, we do not need to keep\n        // a reference to the cached receipts anymore.\n        this.cachedThreadReadReceipts.delete(threadId);\n\n        // If we managed to create a thread and figure out its `id` then we can use it\n        // This has to happen before thread.addEvents, because that adds events to the eventtimeline, and the\n        // eventtimeline sometimes looks up thread information via the room.\n        this.threads.set(thread.id, thread);\n\n        // This is necessary to be able to jump to events in threads:\n        // If we jump to an event in a thread where neither the event, nor the root,\n        // nor any thread event are loaded yet, we'll load the event as well as the thread root, create the thread,\n        // and pass the event through this.\n        thread.addEvents(events, false);\n\n        // We need to update the thread root events, but the thread may not be ready yet.\n        // If it isn't, it will fire ThreadEvent.Update when it is and we'll call updateThreadRootEvents then.\n        if (this.threadsReady && thread.initialEventsFetched) {\n            this.updateThreadRootEvents(thread, toStartOfTimeline, false);\n        }\n        this.emit(ThreadEvent.New, thread, toStartOfTimeline);\n\n        return thread;\n    }\n\n    /**\n     * Applies an event as a redaction of another event, regardless of whether the redacting\n     * event is actually a redaction.\n     *\n     * Callers should use tryApplyRedaction instead.\n     *\n     * @param redactionEvent The event which redacts an event.\n     * @param redactedEvent The event being redacted.\n     * @private\n     */\n    private applyEventAsRedaction(redactionEvent: MatrixEvent, redactedEvent: MatrixEvent): void {\n        const threadRootId = redactedEvent.threadRootId;\n        redactedEvent.makeRedacted(redactionEvent, this);\n\n        // If this is in the current state, replace it with the redacted version\n        if (redactedEvent.isState()) {\n            const currentStateEvent = this.currentState.getStateEvents(\n                redactedEvent.getType(),\n                redactedEvent.getStateKey()!,\n            );\n            if (currentStateEvent?.getId() === redactedEvent.getId()) {\n                this.currentState.setStateEvents([redactedEvent]);\n            }\n        }\n\n        this.emit(RoomEvent.Redaction, redactionEvent, this, threadRootId);\n\n        // TODO: we stash user displaynames (among other things) in\n        // RoomMember objects which are then attached to other events\n        // (in the sender and target fields). We should get those\n        // RoomMember objects to update themselves when the events that\n        // they are based on are changed.\n\n        // Remove any visibility change on this event.\n        this.visibilityEvents.delete(redactedEvent.getId()!);\n\n        // If this event is a visibility change event, remove it from the\n        // list of visibility changes and update any event affected by it.\n        if (redactedEvent.isVisibilityEvent()) {\n            this.redactVisibilityChangeEvent(redactionEvent);\n        }\n    }\n\n    private tryApplyRedaction = (event: MatrixEvent): void => {\n        // FIXME: apply redactions to notification list\n\n        // NB: We continue to add the redaction event to the timeline at the\n        // end of this function so clients can say \"so and so redacted an event\"\n        // if they wish to. Also this may be needed to trigger an update.\n\n        if (event.isRedaction()) {\n            const redactId = event.event.redacts;\n\n            // if we know about this event, redact its contents now.\n            const redactedEvent = redactId ? this.findEventById(redactId) : undefined;\n            if (redactId) {\n                try {\n                    this.stickyEvents.handleRedaction(redactedEvent || redactId);\n                } catch (ex) {\n                    // Non-critical failure, but we should warn.\n                    logger.error(\"Failed to handle redaction for sticky event\", ex);\n                }\n            }\n            if (redactedEvent) {\n                this.applyEventAsRedaction(event, redactedEvent);\n            }\n        } else if (event.getType() === EventType.RoomMember) {\n            const membership = event.getContent()[\"membership\"];\n            if (\n                membership !== KnownMembership.Ban &&\n                !(membership === KnownMembership.Leave && event.getStateKey() !== event.getSender())\n            ) {\n                // Not a ban or kick, therefore not a membership event we care about here.\n                return;\n            }\n            const redactEvents = event.getContent()[\"org.matrix.msc4293.redact_events\"];\n            if (redactEvents !== true) {\n                // Invalid or not set - nothing to redact.\n                return;\n            }\n            const state = this.getLiveTimeline().getState(Direction.Forward)!;\n            if (!state.maySendRedactionForEvent(event, event.getSender()!)) {\n                // If the sender can't redact the membership event, then they won't be able to\n                // redact any of the target's events either, so skip.\n                return;\n            }\n\n            // The redaction is possible, so let's find all the events and apply it.\n            const events = this.getTimelineSets()\n                .map((s) => s.getTimelines())\n                .reduce((p, c) => {\n                    p.push(...c);\n                    return p;\n                }, [])\n                .map((t) => t.getEvents().filter((e) => e.getSender() === event.getStateKey()))\n                .reduce((p, c) => {\n                    p.push(...c);\n                    return c;\n                }, []);\n            for (const toRedact of events) {\n                this.applyEventAsRedaction(event, toRedact);\n            }\n        }\n    };\n\n    private processLiveEvent(event: MatrixEvent): void {\n        this.tryApplyRedaction(event);\n\n        // Implement MSC3531: hiding messages.\n        if (event.isVisibilityEvent()) {\n            // This event changes the visibility of another event, record\n            // the visibility change, inform clients if necessary.\n            this.applyNewVisibilityEvent(event);\n        }\n        // If any pending visibility change is waiting for this (older) event,\n        this.applyPendingVisibilityEvents(event);\n\n        // Sliding Sync modifications:\n        // The proxy cannot guarantee every sent event will have a transaction_id field, so we need\n        // to check the event ID against the list of pending events if there is no transaction ID\n        // field. Only do this for events sent by us though as it's potentially expensive to loop\n        // the pending events map.\n        const txnId = event.getUnsigned().transaction_id;\n        if (!txnId && event.getSender() === this.myUserId) {\n            // check the txn map for a matching event ID\n            for (const [tid, localEvent] of this.txnToEvent) {\n                if (localEvent.getId() === event.getId()) {\n                    logger.debug(\"processLiveEvent: found sent event without txn ID: \", tid, event.getId());\n                    // update the unsigned field so we can re-use the same codepaths\n                    const unsigned = event.getUnsigned();\n                    unsigned.transaction_id = tid;\n                    event.setUnsigned(unsigned);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Add an event to the end of this room's live timelines. Will fire\n     * \"Room.timeline\".\n     *\n     * @param event - Event to be added\n     * @param addLiveEventOptions - addLiveEvent options\n     * @internal\n     *\n     * @remarks\n     * Fires {@link RoomEvent.Timeline}\n     */\n    private addLiveEvent(event: MatrixEvent, addLiveEventOptions: IAddLiveEventOptions): void {\n        const { duplicateStrategy, timelineWasEmpty, fromCache, addToState } = addLiveEventOptions;\n\n        // add to our timeline sets\n        for (const timelineSet of this.timelineSets) {\n            timelineSet.addLiveEvent(event, {\n                duplicateStrategy,\n                fromCache,\n                timelineWasEmpty,\n                addToState,\n            });\n        }\n\n        // synthesize and inject implicit read receipts\n        // Done after adding the event because otherwise the app would get a read receipt\n        // pointing to an event that wasn't yet in the timeline\n        // Don't synthesize RR for m.room.redaction as this causes the RR to go missing.\n        if (event.sender && event.getType() !== EventType.RoomRedaction) {\n            this.addReceipt(synthesizeReceipt(event.sender.userId, event, ReceiptType.Read), true);\n\n            // Any live events from a user could be taken as implicit\n            // presence information: evidence that they are currently active.\n            // ...except in a world where we use 'user.currentlyActive' to reduce\n            // presence spam, this isn't very useful - we'll get a transition when\n            // they are no longer currently active anyway. So don't bother to\n            // reset the lastActiveAgo and lastPresenceTs from the RoomState's user.\n        }\n    }\n\n    /**\n     * Add a pending outgoing event to this room.\n     *\n     * <p>The event is added to either the pendingEventList, or the live timeline,\n     * depending on the setting of opts.pendingEventOrdering.\n     *\n     * <p>This is an internal method, intended for use by MatrixClient.\n     *\n     * @param event - The event to add.\n     *\n     * @param txnId - Transaction id for this outgoing event\n     *\n     * @throws if the event doesn't have status SENDING, or we aren't given a\n     * unique transaction id.\n     *\n     * @remarks\n     * Fires {@link RoomEvent.LocalEchoUpdated}\n     */\n    public addPendingEvent(event: MatrixEvent, txnId: string): void {\n        if (event.status !== EventStatus.SENDING && event.status !== EventStatus.NOT_SENT) {\n            throw new Error(\"addPendingEvent called on an event with status \" + event.status);\n        }\n\n        if (this.txnToEvent.get(txnId)) {\n            throw new Error(\"addPendingEvent called on an event with known txnId \" + txnId);\n        }\n\n        // call setEventMetadata to set up event.sender etc\n        // as event is shared over all timelineSets, we set up its metadata based\n        // on the unfiltered timelineSet.\n        EventTimeline.setEventMetadata(event, this.getLiveTimeline().getState(EventTimeline.FORWARDS)!, false);\n\n        this.txnToEvent.set(txnId, event);\n        if (this.pendingEventList) {\n            if (this.pendingEventList.some((e) => e.status === EventStatus.NOT_SENT)) {\n                logger.warn(\"Setting event as NOT_SENT due to messages in the same state\");\n                event.setStatus(EventStatus.NOT_SENT);\n            }\n            this.pendingEventList.push(event);\n            this.savePendingEvents();\n            if (event.isRelation()) {\n                // For pending events, add them to the relations collection immediately.\n                // (The alternate case below already covers this as part of adding to\n                // the timeline set.)\n                this.aggregateNonLiveRelation(event);\n            }\n\n            if (event.isRedaction()) {\n                const redactId = event.event.redacts;\n                let redactedEvent = this.pendingEventList.find((e) => e.getId() === redactId);\n                if (!redactedEvent && redactId) {\n                    redactedEvent = this.findEventById(redactId);\n                }\n                if (redactedEvent) {\n                    redactedEvent.markLocallyRedacted(event);\n                    this.emit(RoomEvent.Redaction, event, this, redactedEvent.threadRootId);\n                }\n            }\n        } else {\n            for (const timelineSet of this.timelineSets) {\n                if (timelineSet.getFilter()) {\n                    if (timelineSet.getFilter()!.filterRoomTimeline([event]).length) {\n                        timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), {\n                            toStartOfTimeline: false,\n                            addToState: false, // We don't support localEcho of state events yet\n                        });\n                    }\n                } else {\n                    timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), {\n                        toStartOfTimeline: false,\n                        addToState: false, // We don't support localEcho of state events yet\n                    });\n                }\n            }\n        }\n\n        this.emit(RoomEvent.LocalEchoUpdated, event, this);\n    }\n\n    /**\n     * Persists all pending events to local storage\n     *\n     * If the current room is encrypted only encrypted events will be persisted\n     * all messages that are not yet encrypted will be discarded\n     *\n     * This is because the flow of EVENT_STATUS transition is\n     * `queued => sending => encrypting => sending => sent`\n     *\n     * Steps 3 and 4 are skipped for unencrypted room.\n     * It is better to discard an unencrypted message rather than persisting\n     * it locally for everyone to read\n     */\n    private savePendingEvents(): void {\n        if (this.pendingEventList) {\n            const pendingEvents = this.pendingEventList\n                .map((event) => {\n                    return {\n                        ...event.event,\n                        txn_id: event.getTxnId(),\n                    };\n                })\n                .filter((event) => {\n                    // Filter out the unencrypted messages if the room is encrypted\n                    const isEventEncrypted = event.type === EventType.RoomMessageEncrypted;\n                    const isRoomEncrypted = this.hasEncryptionStateEvent();\n                    return isEventEncrypted || !isRoomEncrypted;\n                });\n\n            this.client.store.setPendingEvents(this.roomId, pendingEvents);\n        }\n    }\n\n    /**\n     * Used to aggregate the local echo for a relation, and also\n     * for re-applying a relation after it's redaction has been cancelled,\n     * as the local echo for the redaction of the relation would have\n     * un-aggregated the relation. Note that this is different from regular messages,\n     * which are just kept detached for their local echo.\n     *\n     * Also note that live events are aggregated in the live EventTimelineSet.\n     * @param event - the relation event that needs to be aggregated.\n     */\n    private aggregateNonLiveRelation(event: MatrixEvent): void {\n        this.relations.aggregateChildEvent(event);\n    }\n\n    public getEventForTxnId(txnId: string): MatrixEvent | undefined {\n        return this.txnToEvent.get(txnId);\n    }\n\n    /**\n     * Deal with the echo of a message we sent.\n     *\n     * <p>We move the event to the live timeline if it isn't there already, and\n     * update it.\n     *\n     * @param remoteEvent -   The event received from\n     *    /sync\n     * @param localEvent -    The local echo, which\n     *    should be either in the pendingEventList or the timeline.\n     *\n     * @internal\n     *\n     * @remarks\n     * Fires {@link RoomEvent.LocalEchoUpdated}\n     */\n    public handleRemoteEcho(remoteEvent: MatrixEvent, localEvent: MatrixEvent): void {\n        const oldEventId = localEvent.getId()!;\n        const newEventId = remoteEvent.getId()!;\n        const oldStatus = localEvent.status;\n\n        logger.debug(`Got remote echo for event ${oldEventId} -> ${newEventId} old status ${oldStatus}`);\n\n        // no longer pending\n        this.txnToEvent.delete(remoteEvent.getUnsigned().transaction_id!);\n\n        // if it's in the pending list, remove it\n        if (this.pendingEventList) {\n            this.removePendingEvent(oldEventId);\n        }\n\n        // replace the event source (this will preserve the plaintext payload if\n        // any, which is good, because we don't want to try decoding it again).\n        localEvent.handleRemoteEcho(remoteEvent.event);\n\n        const { shouldLiveInRoom, threadId } = this.eventShouldLiveIn(remoteEvent);\n        const thread = threadId ? this.getThread(threadId) : null;\n        thread?.setEventMetadata(localEvent);\n        thread?.timelineSet.handleRemoteEcho(localEvent, oldEventId, newEventId);\n\n        if (shouldLiveInRoom) {\n            for (const timelineSet of this.timelineSets) {\n                // if it's already in the timeline, update the timeline map. If it's not, add it.\n                timelineSet.handleRemoteEcho(localEvent, oldEventId, newEventId);\n            }\n        }\n\n        this.emit(RoomEvent.LocalEchoUpdated, localEvent, this, oldEventId, oldStatus);\n    }\n\n    /**\n     * Update the status / event id on a pending event, to reflect its transmission\n     * progress.\n     *\n     * <p>This is an internal method.\n     *\n     * @param event -      local echo event\n     * @param newStatus -  status to assign\n     * @param newEventId -      new event id to assign. Ignored unless newStatus == EventStatus.SENT.\n     *\n     * @remarks\n     * Fires {@link RoomEvent.LocalEchoUpdated}\n     */\n    public updatePendingEvent(event: MatrixEvent, newStatus: EventStatus, newEventId?: string): void {\n        logger.log(\n            `setting pendingEvent status to ${newStatus} in ${event.getRoomId()} ` +\n                `event ID ${event.getId()} -> ${newEventId}`,\n        );\n\n        // if the message was sent, we expect an event id\n        if (newStatus == EventStatus.SENT && !newEventId) {\n            throw new Error(\"updatePendingEvent called with status=SENT, but no new event id\");\n        }\n\n        // SENT races against /sync, so we have to special-case it.\n        if (newStatus == EventStatus.SENT) {\n            const timeline = this.getTimelineForEvent(newEventId!);\n            if (timeline) {\n                // we've already received the event via the event stream.\n                // nothing more to do here, assuming the transaction ID was correctly matched.\n                // Let's check that.\n                const remoteEvent = this.findEventById(newEventId!);\n                const remoteTxnId = remoteEvent?.getUnsigned().transaction_id;\n                if (!remoteTxnId && remoteEvent) {\n                    // This code path is mostly relevant for the Sliding Sync proxy.\n                    // The remote event did not contain a transaction ID, so we did not handle\n                    // the remote echo yet. Handle it now.\n                    const unsigned = remoteEvent.getUnsigned();\n                    unsigned.transaction_id = event.getTxnId();\n                    remoteEvent.setUnsigned(unsigned);\n                    // the remote event is _already_ in the timeline, so we need to remove it so\n                    // we can convert the local event into the final event.\n                    this.removeEvent(remoteEvent.getId()!);\n                    this.handleRemoteEcho(remoteEvent, event);\n                }\n                return;\n            }\n        }\n\n        const oldStatus = event.status;\n        const oldEventId = event.getId()!;\n\n        if (!oldStatus) {\n            throw new Error(\"updatePendingEventStatus called on an event which is not a local echo.\");\n        }\n\n        const allowed = ALLOWED_TRANSITIONS[oldStatus];\n        if (!allowed?.includes(newStatus)) {\n            throw new Error(`Invalid EventStatus transition ${oldStatus}->${newStatus}`);\n        }\n\n        event.setStatus(newStatus);\n\n        if (newStatus == EventStatus.SENT) {\n            // update the event id\n            event.replaceLocalEventId(newEventId!);\n\n            const { shouldLiveInRoom, threadId } = this.eventShouldLiveIn(event);\n            const thread = threadId ? this.getThread(threadId) : undefined;\n            thread?.setEventMetadata(event);\n            thread?.timelineSet.replaceEventId(oldEventId, newEventId!);\n\n            if (shouldLiveInRoom) {\n                // if the event was already in the timeline (which will be the case if\n                // opts.pendingEventOrdering==chronological), we need to update the\n                // timeline map.\n                for (const timelineSet of this.timelineSets) {\n                    timelineSet.replaceEventId(oldEventId, newEventId!);\n                }\n            }\n        } else if (newStatus == EventStatus.CANCELLED) {\n            // remove it from the pending event list, or the timeline.\n            if (this.pendingEventList) {\n                const removedEvent = this.getPendingEvent(oldEventId);\n                this.removePendingEvent(oldEventId);\n                if (removedEvent?.isRedaction()) {\n                    this.revertRedactionLocalEcho(removedEvent);\n                }\n            }\n            this.removeEvent(oldEventId);\n        }\n        this.savePendingEvents();\n\n        this.emit(RoomEvent.LocalEchoUpdated, event, this, oldEventId, oldStatus);\n    }\n\n    private revertRedactionLocalEcho(redactionEvent: MatrixEvent): void {\n        const redactId = redactionEvent.event.redacts;\n        if (!redactId) {\n            return;\n        }\n        const redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);\n        if (redactedEvent) {\n            redactedEvent.unmarkLocallyRedacted();\n            // re-render after undoing redaction\n            this.emit(RoomEvent.RedactionCancelled, redactionEvent, this);\n            // reapply relation now redaction failed\n            if (redactedEvent.isRelation()) {\n                this.aggregateNonLiveRelation(redactedEvent);\n            }\n        }\n    }\n\n    private assertTimelineSetsAreLive(): void {\n        for (let i = 0; i < this.timelineSets.length; i++) {\n            const liveTimeline = this.timelineSets[i].getLiveTimeline();\n            if (liveTimeline.getPaginationToken(EventTimeline.FORWARDS)) {\n                throw new Error(\n                    \"live timeline \" +\n                        i +\n                        \" is no longer live - it has a pagination token \" +\n                        \"(\" +\n                        liveTimeline.getPaginationToken(EventTimeline.FORWARDS) +\n                        \")\",\n                );\n            }\n            if (liveTimeline.getNeighbouringTimeline(EventTimeline.FORWARDS)) {\n                throw new Error(`live timeline ${i} is no longer live - it has a neighbouring timeline`);\n            }\n        }\n    }\n\n    /**\n     * Add some events to this room. This can include state events, message\n     * events and typing notifications. These events are treated as \"live\" so\n     * they will go to the end of the timeline.\n     *\n     * @param events - A list of events to add.\n     * @param addLiveEventOptions - addLiveEvent options\n     * @throws If `duplicateStrategy` is not falsey, 'replace' or 'ignore'.\n     */\n    public async addLiveEvents(events: MatrixEvent[], addLiveEventOptions: IAddLiveEventOptions): Promise<void> {\n        const { duplicateStrategy, fromCache, timelineWasEmpty = false, addToState } = addLiveEventOptions;\n        if (duplicateStrategy && [\"replace\", \"ignore\"].indexOf(duplicateStrategy) === -1) {\n            throw new Error(\"duplicateStrategy MUST be either 'replace' or 'ignore'\");\n        }\n\n        // sanity check that the live timeline is still live\n        this.assertTimelineSetsAreLive();\n\n        const threadRoots = this.findThreadRoots(events);\n        const eventsByThread: { [threadId: string]: MatrixEvent[] } = {};\n\n        const options: IAddLiveEventOptions = {\n            duplicateStrategy,\n            fromCache,\n            timelineWasEmpty,\n            addToState,\n        };\n\n        // List of extra events to check for being parents of any relations encountered\n        const neighbouringEvents = [...events];\n\n        for (const event of events) {\n            // TODO: We should have a filter to say \"only add state event types X Y Z to the timeline\".\n            this.processLiveEvent(event);\n\n            if (event.getUnsigned().transaction_id) {\n                const existingEvent = this.txnToEvent.get(event.getUnsigned().transaction_id!);\n                if (existingEvent) {\n                    // remote echo of an event we sent earlier\n                    this.handleRemoteEcho(event, existingEvent);\n                    continue; // we can skip adding the event to the timeline sets, it is already there\n                }\n            }\n\n            let {\n                shouldLiveInRoom,\n                shouldLiveInThread,\n                threadId = \"\",\n            } = this.eventShouldLiveIn(event, neighbouringEvents, threadRoots);\n\n            if (!shouldLiveInThread && !shouldLiveInRoom && event.isRelation()) {\n                try {\n                    const parentEvent = new MatrixEvent(\n                        await this.client.fetchRoomEvent(this.roomId, event.relationEventId!),\n                    );\n                    neighbouringEvents.push(parentEvent);\n                    if (parentEvent.threadRootId) {\n                        threadRoots.add(parentEvent.threadRootId);\n                        const unsigned = event.getUnsigned();\n                        unsigned[UNSIGNED_THREAD_ID_FIELD.name] = parentEvent.threadRootId;\n                        event.setUnsigned(unsigned);\n                    }\n\n                    ({\n                        shouldLiveInRoom,\n                        shouldLiveInThread,\n                        threadId = \"\",\n                    } = this.eventShouldLiveIn(event, neighbouringEvents, threadRoots));\n                } catch (e) {\n                    logger.error(\"Failed to load parent event of unhandled relation\", e);\n                }\n            }\n\n            if (shouldLiveInThread && !eventsByThread[threadId]) {\n                eventsByThread[threadId] = [];\n            }\n            eventsByThread[threadId]?.push(event);\n\n            if (shouldLiveInRoom) {\n                this.addLiveEvent(event, options);\n            } else if (!shouldLiveInThread && event.isRelation()) {\n                this.relations.aggregateChildEvent(event);\n            }\n        }\n\n        Object.entries(eventsByThread).forEach(([threadId, threadEvents]) => {\n            this.addThreadedEvents(threadId, threadEvents, false);\n        });\n    }\n\n    public partitionThreadedEvents(\n        events: MatrixEvent[],\n    ): [timelineEvents: MatrixEvent[], threadedEvents: MatrixEvent[], unknownRelations: MatrixEvent[]] {\n        // Indices to the events array, for readability\n        const ROOM = 0;\n        const THREAD = 1;\n        const UNKNOWN_RELATION = 2;\n        if (this.client.supportsThreads()) {\n            const threadRoots = this.findThreadRoots(events);\n            return events.reduce<[MatrixEvent[], MatrixEvent[], MatrixEvent[]]>(\n                (memo, event: MatrixEvent) => {\n                    const { shouldLiveInRoom, shouldLiveInThread, threadId } = this.eventShouldLiveIn(\n                        event,\n                        events,\n                        threadRoots,\n                    );\n\n                    if (shouldLiveInRoom) {\n                        memo[ROOM].push(event);\n                    }\n\n                    if (shouldLiveInThread) {\n                        event.setThreadId(threadId ?? \"\");\n                        memo[THREAD].push(event);\n                    }\n\n                    if (!shouldLiveInThread && !shouldLiveInRoom) {\n                        memo[UNKNOWN_RELATION].push(event);\n                    }\n\n                    return memo;\n                },\n                [[], [], []],\n            );\n        } else {\n            // When `threadSupport` is disabled treat all events as timelineEvents\n            return [events as MatrixEvent[], [] as MatrixEvent[], [] as MatrixEvent[]];\n        }\n    }\n\n    /**\n     * Given some events, find the IDs of all the thread roots that are referred to by them.\n     */\n    private findThreadRoots(events: MatrixEvent[]): Set<string> {\n        const threadRoots = new Set<string>();\n        for (const event of events) {\n            const threadRootId = event.threadRootId;\n            if (threadRootId != undefined) {\n                threadRoots.add(threadRootId);\n            }\n        }\n        return threadRoots;\n    }\n\n    /**\n     * Add a receipt event to the room.\n     * @param event - The m.receipt event.\n     * @param synthetic - True if this event is implicit.\n     */\n    public addReceipt(event: MatrixEvent, synthetic = false): void {\n        const content = event.getContent<ReceiptContent>();\n\n        this.roomReceipts.add(content, synthetic);\n\n        // TODO: delete the following code when it has been replaced by RoomReceipts\n        Object.keys(content).forEach((eventId: string) => {\n            Object.keys(content[eventId]).forEach((receiptType: ReceiptType | string) => {\n                Object.keys(content[eventId][receiptType]).forEach((userId: string) => {\n                    const receipt = content[eventId][receiptType][userId] as Receipt;\n                    const receiptForMainTimeline = !receipt.thread_id || receipt.thread_id === MAIN_ROOM_TIMELINE;\n                    const receiptDestination: Thread | this | undefined = receiptForMainTimeline\n                        ? this\n                        : this.threads.get(receipt.thread_id ?? \"\");\n\n                    if (receiptDestination) {\n                        receiptDestination.addReceiptToStructure(\n                            eventId,\n                            receiptType as ReceiptType,\n                            userId,\n                            receipt,\n                            synthetic,\n                        );\n\n                        // If the read receipt sent for the logged in user matches\n                        // the last event of the live timeline, then we know for a fact\n                        // that the user has read that message, so we can mark the room\n                        // as read and not wait for the remote echo from synapse.\n                        //\n                        // This needs to be done after the initial sync as we do not want this\n                        // logic to run whilst the room is being initialised\n                        //\n                        // We only do this for non-synthetic receipts, because\n                        // our intention is to do this when the user really did\n                        // just read a message, not when we are e.g. receiving\n                        // an event during the sync. More explanation at:\n                        // https://github.com/matrix-org/matrix-js-sdk/issues/3684\n                        if (!synthetic && this.client.isInitialSyncComplete() && userId === this.client.getUserId()) {\n                            const lastEvent = receiptDestination.timeline[receiptDestination.timeline.length - 1];\n                            if (lastEvent && eventId === lastEvent.getId() && userId === lastEvent.getSender()) {\n                                receiptDestination.setUnread(NotificationCountType.Total, 0);\n                                receiptDestination.setUnread(NotificationCountType.Highlight, 0);\n                            }\n                        }\n                    } else {\n                        // The thread does not exist locally, keep the read receipt\n                        // in a cache locally, and re-apply  the `addReceipt` logic\n                        // when the thread is created\n                        this.cachedThreadReadReceipts.set(receipt.thread_id!, [\n                            ...(this.cachedThreadReadReceipts.get(receipt.thread_id!) ?? []),\n                            { eventId, receiptType, userId, receipt, synthetic },\n                        ]);\n                    }\n\n                    const me = this.client.getUserId();\n                    // Track the time of the current user's oldest threaded receipt in the room.\n                    if (userId === me && !receiptForMainTimeline && receipt.ts < this.oldestThreadedReceiptTs) {\n                        this.oldestThreadedReceiptTs = receipt.ts;\n                    }\n\n                    // Track each user's unthreaded read receipt.\n                    if (!receipt.thread_id && receipt.ts > (this.unthreadedReceipts.get(userId)?.ts ?? 0)) {\n                        this.unthreadedReceipts.set(userId, receipt);\n                    }\n                });\n            });\n        });\n        // End of code to delete when replaced by RoomReceipts\n\n        // send events after we've regenerated the structure & cache, otherwise things that\n        // listened for the event would read stale data.\n        this.emit(RoomEvent.Receipt, event, this);\n    }\n\n    /**\n     * Adds/handles ephemeral events such as typing notifications and read receipts.\n     * @param events - A list of events to process\n     */\n    public addEphemeralEvents(events: MatrixEvent[]): void {\n        for (const event of events) {\n            if (event.getType() === EventType.Typing) {\n                this.currentState.setTypingEvent(event);\n            } else if (event.getType() === EventType.Receipt) {\n                this.addReceipt(event);\n            } // else ignore - life is too short for us to care about these events\n        }\n    }\n\n    /**\n     * Removes events from this room.\n     * @param eventIds - A list of eventIds to remove.\n     */\n    public removeEvents(eventIds: string[]): void {\n        for (const eventId of eventIds) {\n            this.removeEvent(eventId);\n        }\n    }\n\n    /**\n     * Removes a single event from this room.\n     *\n     * @param eventId -  The id of the event to remove\n     *\n     * @returns true if the event was removed from any of the room's timeline sets\n     */\n    public removeEvent(eventId: string): boolean {\n        let removedAny = false;\n        for (const timelineSet of this.timelineSets) {\n            const removed = timelineSet.removeEvent(eventId);\n            if (removed) {\n                if (removed.isRedaction()) {\n                    this.revertRedactionLocalEcho(removed);\n                }\n                removedAny = true;\n            }\n        }\n        return removedAny;\n    }\n\n    /**\n     * Recalculate various aspects of the room, including the room name and\n     * room summary. Call this any time the room's current state is modified.\n     * May fire \"Room.name\" if the room name is updated.\n     *\n     * @remarks\n     * Fires {@link RoomEvent.Name}\n     */\n    public recalculate(): void {\n        // set fake stripped state events if this is an invite room so logic remains\n        // consistent elsewhere.\n        const membershipEvent = this.currentState.getStateEvents(EventType.RoomMember, this.myUserId);\n        if (membershipEvent) {\n            const membership = membershipEvent.getContent().membership;\n            this.updateMyMembership(membership!);\n\n            if (membership === KnownMembership.Invite) {\n                const strippedStateEvents = membershipEvent.getUnsigned().invite_room_state || [];\n                strippedStateEvents.forEach((strippedEvent) => {\n                    const existingEvent = this.currentState.getStateEvents(strippedEvent.type, strippedEvent.state_key);\n                    if (!existingEvent) {\n                        // set the fake stripped event instead\n                        this.currentState.setStateEvents([\n                            new MatrixEvent({\n                                type: strippedEvent.type,\n                                state_key: strippedEvent.state_key,\n                                content: strippedEvent.content,\n                                event_id: \"$fake\" + Date.now(),\n                                room_id: this.roomId,\n                                sender: this.myUserId, // technically a lie\n                            }),\n                        ]);\n                    }\n                });\n            }\n        }\n\n        const oldName = this.name;\n        this.name = this.calculateRoomName(this.myUserId);\n        this.normalizedName = normalize(this.name);\n        this.summary = new RoomSummary(this.roomId, {\n            title: this.name,\n        });\n\n        if (oldName !== this.name) {\n            this.emit(RoomEvent.Name, this);\n        }\n    }\n\n    /**\n     * Update the room-tag event for the room.  The previous one is overwritten.\n     * @param event - the m.tag event\n     */\n    public addTags(event: MatrixEvent): void {\n        // event content looks like:\n        // content: {\n        //    tags: {\n        //       $tagName: { $metadata: $value },\n        //       $tagName: { $metadata: $value },\n        //    }\n        // }\n\n        // XXX: do we need to deep copy here?\n        this.tags = event.getContent().tags || {};\n\n        // XXX: we could do a deep-comparison to see if the tags have really\n        // changed - but do we want to bother?\n        this.emit(RoomEvent.Tags, event, this);\n    }\n\n    /**\n     * Update the account_data events for this room, overwriting events of the same type.\n     * @param events - an array of account_data events to add\n     */\n    public addAccountData(events: MatrixEvent[]): void {\n        for (const event of events) {\n            if (event.getType() === \"m.tag\") {\n                this.addTags(event);\n            }\n            const eventType = event.getType();\n            const lastEvent = this.accountData.get(eventType);\n            this.accountData.set(eventType, event);\n            this.emit(RoomEvent.AccountData, event, this, lastEvent);\n        }\n    }\n\n    /**\n     * Access account_data event of given event type for this room\n     * @param type - the type of account_data event to be accessed\n     * @returns the account_data event in question\n     */\n    public getAccountData(type: EventType | string): MatrixEvent | undefined {\n        return this.accountData.get(type);\n    }\n\n    /**\n     * Get an iterator of currently active sticky events.\n     */\n    // eslint-disable-next-line\n    public _unstable_getStickyEvents(): ReturnType<RoomStickyEventsStore[\"getStickyEvents\"]> {\n        return this.stickyEvents.getStickyEvents();\n    }\n\n    /**\n     * Get a sticky event that match the given `type`, `sender`, and `stickyKey`\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @param stickyKey The sticky key used by the event.\n     * @returns A matching active sticky event, or undefined.\n     */\n    // eslint-disable-next-line\n    public _unstable_getKeyedStickyEvent(\n        sender: string,\n        type: string,\n        stickyKey: string,\n    ): ReturnType<RoomStickyEventsStore[\"getKeyedStickyEvent\"]> {\n        return this.stickyEvents.getKeyedStickyEvent(sender, type, stickyKey);\n    }\n\n    /**\n     * Get active sticky events without a sticky key that match the given `type` and `sender`.\n     * @param type The event `type`.\n     * @param sender The sender of the sticky event.\n     * @returns An array of matching sticky events.\n     */\n    // eslint-disable-next-line\n    public _unstable_getUnkeyedStickyEvent(\n        sender: string,\n        type: string,\n    ): ReturnType<RoomStickyEventsStore[\"getUnkeyedStickyEvent\"]> {\n        return this.stickyEvents.getUnkeyedStickyEvent(sender, type);\n    }\n\n    /**\n     * Add a series of sticky events, emitting `RoomEvent.StickyEvents` if any\n     * changes were made.\n     * @param events A set of new sticky events.\n     * @internal\n     */\n    // eslint-disable-next-line\n    public _unstable_addStickyEvents(events: MatrixEvent[]): ReturnType<RoomStickyEventsStore[\"addStickyEvents\"]> {\n        return this.stickyEvents.addStickyEvents(events);\n    }\n\n    /**\n     * Returns whether the syncing user has permission to send a message in the room\n     * @returns true if the user should be permitted to send\n     *                   message events into the room.\n     */\n    public maySendMessage(): boolean {\n        return (\n            this.getMyMembership() === KnownMembership.Join &&\n            (this.hasEncryptionStateEvent()\n                ? this.currentState.maySendEvent(EventType.RoomMessageEncrypted, this.myUserId)\n                : this.currentState.maySendEvent(EventType.RoomMessage, this.myUserId))\n        );\n    }\n\n    /**\n     * Returns whether the given user has permissions to issue an invite for this room.\n     * @param userId - the ID of the Matrix user to check permissions for\n     * @returns true if the user should be permitted to issue invites for this room.\n     */\n    public canInvite(userId: string): boolean {\n        let canInvite = this.getMyMembership() === KnownMembership.Join;\n        const powerLevelsEvent = this.currentState.getStateEvents(EventType.RoomPowerLevels, \"\");\n        const powerLevels = powerLevelsEvent && powerLevelsEvent.getContent();\n        const me = this.getMember(userId);\n        if (powerLevels && me && powerLevels.invite > me.powerLevel) {\n            canInvite = false;\n        }\n        return canInvite;\n    }\n\n    /**\n     * Returns the join rule based on the m.room.join_rule state event, defaulting to `invite`.\n     * @returns the join_rule applied to this room\n     */\n    public getJoinRule(): JoinRule {\n        return this.currentState.getJoinRule();\n    }\n\n    /**\n     * Returns the history visibility based on the m.room.history_visibility state event, defaulting to `shared`.\n     * @returns the history_visibility applied to this room\n     */\n    public getHistoryVisibility(): HistoryVisibility {\n        return this.currentState.getHistoryVisibility();\n    }\n\n    /**\n     * Returns the history visibility based on the m.room.history_visibility state event, defaulting to `shared`.\n     * @returns the history_visibility applied to this room\n     */\n    public getGuestAccess(): GuestAccess {\n        return this.currentState.getGuestAccess();\n    }\n\n    /**\n     * Returns the type of the room from the `m.room.create` event content or undefined if none is set\n     * @returns the type of the room.\n     */\n    public getType(): RoomType | string | undefined {\n        const createEvent = this.currentState.getStateEvents(EventType.RoomCreate, \"\");\n        if (!createEvent) {\n            if (!this.getTypeWarning) {\n                logger.warn(\"[getType] Room \" + this.roomId + \" does not have an m.room.create event\");\n                this.getTypeWarning = true;\n            }\n            return undefined;\n        }\n        return createEvent.getContent()[RoomCreateTypeField];\n    }\n\n    /**\n     * Returns whether the room is a space-room as defined by MSC1772.\n     * @returns true if the room's type is RoomType.Space\n     */\n    public isSpaceRoom(): boolean {\n        return this.getType() === RoomType.Space;\n    }\n\n    /**\n     * Returns whether the room is a call-room as defined by MSC3417.\n     * @returns true if the room's type is RoomType.UnstableCall\n     */\n    public isCallRoom(): boolean {\n        return this.getType() === RoomType.UnstableCall;\n    }\n\n    /**\n     * Returns whether the room is a video room.\n     * @returns true if the room's type is RoomType.ElementVideo\n     */\n    public isElementVideoRoom(): boolean {\n        return this.getType() === RoomType.ElementVideo;\n    }\n\n    /**\n     * Find the predecessor of this room.\n     *\n     * @param msc3946ProcessDynamicPredecessor - if true, look for an\n     * m.room.predecessor state event and use it if found (MSC3946).\n     * @returns null if this room has no predecessor. Otherwise, returns\n     * the roomId, last eventId and viaServers of the predecessor room.\n     *\n     * If msc3946ProcessDynamicPredecessor is true, use m.predecessor events\n     * as well as m.room.create events to find predecessors.\n     *\n     * Note: if an m.predecessor event is used, eventId may be undefined\n     * since last_known_event_id is optional.\n     *\n     * Note: viaServers may be undefined, and will definitely be undefined if\n     * this predecessor comes from a RoomCreate event (rather than a\n     * RoomPredecessor, which has the optional via_servers property).\n     */\n    public findPredecessor(\n        msc3946ProcessDynamicPredecessor = false,\n    ): { roomId: string; eventId?: string; viaServers?: string[] } | null {\n        const currentState = this.getLiveTimeline().getState(EventTimeline.FORWARDS);\n        if (!currentState) {\n            return null;\n        }\n        return currentState.findPredecessor(msc3946ProcessDynamicPredecessor);\n    }\n\n    private roomNameGenerator(state: RoomNameState): string {\n        if (this.client.roomNameGenerator) {\n            const name = this.client.roomNameGenerator(this.roomId, state);\n            if (name !== null) {\n                return name;\n            }\n        }\n\n        switch (state.type) {\n            case RoomNameType.Actual:\n                return state.name;\n            case RoomNameType.Generated:\n                switch (state.subtype) {\n                    case \"Inviting\":\n                        return `Inviting ${memberNamesToRoomName(state.names, state.count)}`;\n                    default:\n                        return memberNamesToRoomName(state.names, state.count);\n                }\n            case RoomNameType.EmptyRoom:\n                if (state.oldName) {\n                    return `Empty room (was ${state.oldName})`;\n                } else {\n                    return \"Empty room\";\n                }\n        }\n    }\n\n    /**\n     * This is an internal method. Calculates the name of the room from the current\n     * room state.\n     * @param userId - The client's user ID. Used to filter room members\n     * correctly.\n     * @param ignoreRoomNameEvent - Return the implicit room name that we'd see if there\n     * was no m.room.name event.\n     * @returns The calculated room name.\n     */\n    private calculateRoomName(userId: string, ignoreRoomNameEvent = false): string {\n        if (!ignoreRoomNameEvent) {\n            const name = this.currentState.getStateEvents(EventType.RoomName, \"\")?.getContent().name;\n            if (name && typeof name === \"string\") {\n                return this.roomNameGenerator({\n                    type: RoomNameType.Actual,\n                    name,\n                });\n            }\n        }\n\n        const alias = this.getCanonicalAlias();\n        if (alias) {\n            return this.roomNameGenerator({\n                type: RoomNameType.Actual,\n                name: alias,\n            });\n        }\n\n        const joinedMemberCount = this.currentState.getJoinedMemberCount();\n        const invitedMemberCount = this.currentState.getInvitedMemberCount();\n        // -1 because these numbers include the syncing user\n        let inviteJoinCount = joinedMemberCount + invitedMemberCount - 1;\n\n        // get service members (e.g. helper bots) for exclusion\n        const excludedUserIds = this.getFunctionalMembers();\n\n        // get members from heroes that are NOT ourselves\n        let otherNames: string[] = [];\n        if (this.heroes) {\n            // if we have heroes, use those as the names\n            this.heroes.forEach((hero) => {\n                // filter service members\n                if (excludedUserIds.includes(hero.userId)) {\n                    inviteJoinCount--;\n                    return;\n                }\n                // If the hero has a display name, use that.\n                // Otherwise, look their user ID up in the membership and use\n                // the name from there, or the user ID as a last resort.\n                if (hero.displayName) {\n                    otherNames.push(hero.displayName);\n                } else {\n                    const member = this.getMember(hero.userId);\n                    otherNames.push(member ? member.name : hero.userId);\n                }\n            });\n        } else {\n            let otherMembers = this.currentState.getMembers().filter((m) => {\n                return (\n                    m.userId !== userId &&\n                    (m.membership === KnownMembership.Invite || m.membership === KnownMembership.Join)\n                );\n            });\n            otherMembers = otherMembers.filter(({ userId }) => {\n                // filter service members\n                if (excludedUserIds.includes(userId)) {\n                    inviteJoinCount--;\n                    return false;\n                }\n                return true;\n            });\n            // make sure members have stable order\n            const collator = new Intl.Collator();\n            otherMembers.sort((a, b) => collator.compare(a.userId, b.userId));\n            // only 5 first members, immitate summaryHeroes\n            otherMembers = otherMembers.slice(0, 5);\n            otherNames = otherMembers.map((m) => m.name);\n        }\n\n        if (inviteJoinCount) {\n            return this.roomNameGenerator({\n                type: RoomNameType.Generated,\n                names: otherNames,\n                count: inviteJoinCount,\n            });\n        }\n\n        const myMembership = this.getMyMembership();\n        // if I have created a room and invited people through\n        // 3rd party invites\n        if (myMembership == KnownMembership.Join) {\n            const thirdPartyInvites = this.currentState.getStateEvents(EventType.RoomThirdPartyInvite);\n\n            if (thirdPartyInvites?.length) {\n                const thirdPartyNames = thirdPartyInvites.map((i) => {\n                    return i.getContent().display_name;\n                });\n\n                return this.roomNameGenerator({\n                    type: RoomNameType.Generated,\n                    subtype: \"Inviting\",\n                    names: thirdPartyNames,\n                    count: thirdPartyNames.length + 1,\n                });\n            }\n        }\n\n        // let's try to figure out who was here before\n        let leftNames = otherNames;\n        // if we didn't have heroes, try finding them in the room state\n        if (!leftNames.length) {\n            leftNames = this.currentState\n                .getMembers()\n                .filter((m) => {\n                    return (\n                        m.userId !== userId &&\n                        m.membership !== KnownMembership.Invite &&\n                        m.membership !== KnownMembership.Join\n                    );\n                })\n                .map((m) => m.name);\n        }\n\n        let oldName: string | undefined;\n        if (leftNames.length) {\n            oldName = this.roomNameGenerator({\n                type: RoomNameType.Generated,\n                names: leftNames,\n                count: leftNames.length + 1,\n            });\n        }\n\n        return this.roomNameGenerator({\n            type: RoomNameType.EmptyRoom,\n            oldName,\n        });\n    }\n\n    /**\n     * When we receive a new visibility change event:\n     *\n     * - store this visibility change alongside the timeline, in case we\n     *   later need to apply it to an event that we haven't received yet;\n     * - if we have already received the event whose visibility has changed,\n     *   patch it to reflect the visibility change and inform listeners.\n     */\n    private applyNewVisibilityEvent(event: MatrixEvent): void {\n        const visibilityChange = event.asVisibilityChange();\n        if (!visibilityChange) {\n            // The event is ill-formed.\n            return;\n        }\n\n        // Ignore visibility change events that are not emitted by moderators.\n        const userId = event.getSender();\n        if (!userId) {\n            return;\n        }\n        const isPowerSufficient =\n            (EVENT_VISIBILITY_CHANGE_TYPE.name &&\n                this.currentState.maySendStateEvent(EVENT_VISIBILITY_CHANGE_TYPE.name, userId)) ||\n            (EVENT_VISIBILITY_CHANGE_TYPE.altName &&\n                this.currentState.maySendStateEvent(EVENT_VISIBILITY_CHANGE_TYPE.altName, userId));\n        if (!isPowerSufficient) {\n            // Powerlevel is insufficient.\n            return;\n        }\n\n        // Record this change in visibility.\n        // If the event is not in our timeline and we only receive it later,\n        // we may need to apply the visibility change at a later date.\n\n        const visibilityEventsOnOriginalEvent = this.visibilityEvents.get(visibilityChange.eventId);\n        if (visibilityEventsOnOriginalEvent) {\n            // It would be tempting to simply erase the latest visibility change\n            // but we need to record all of the changes in case the latest change\n            // is ever redacted.\n            //\n            // In practice, linear scans through `visibilityEvents` should be fast.\n            // However, to protect against a potential DoS attack, we limit the\n            // number of iterations in this loop.\n            let index = visibilityEventsOnOriginalEvent.length - 1;\n            const min = Math.max(\n                0,\n                visibilityEventsOnOriginalEvent.length - MAX_NUMBER_OF_VISIBILITY_EVENTS_TO_SCAN_THROUGH,\n            );\n            for (; index >= min; --index) {\n                const target = visibilityEventsOnOriginalEvent[index];\n                if (target.getTs() < event.getTs()) {\n                    break;\n                }\n            }\n            if (index === -1) {\n                visibilityEventsOnOriginalEvent.unshift(event);\n            } else {\n                visibilityEventsOnOriginalEvent.splice(index + 1, 0, event);\n            }\n        } else {\n            this.visibilityEvents.set(visibilityChange.eventId, [event]);\n        }\n\n        // Finally, let's check if the event is already in our timeline.\n        // If so, we need to patch it and inform listeners.\n\n        const originalEvent = this.findEventById(visibilityChange.eventId);\n        if (!originalEvent) {\n            return;\n        }\n        originalEvent.applyVisibilityEvent(visibilityChange);\n    }\n\n    private redactVisibilityChangeEvent(event: MatrixEvent): void {\n        // Sanity checks.\n        if (!event.isVisibilityEvent) {\n            throw new Error(\"expected a visibility change event\");\n        }\n        const relation = event.getRelation();\n        const originalEventId = relation?.event_id;\n        const visibilityEventsOnOriginalEvent = this.visibilityEvents.get(originalEventId!);\n        if (!visibilityEventsOnOriginalEvent) {\n            // No visibility changes on the original event.\n            // In particular, this change event was not recorded,\n            // most likely because it was ill-formed.\n            return;\n        }\n        const index = visibilityEventsOnOriginalEvent.findIndex((change) => change.getId() === event.getId());\n        if (index === -1) {\n            // This change event was not recorded, most likely because\n            // it was ill-formed.\n            return;\n        }\n        // Remove visibility change.\n        visibilityEventsOnOriginalEvent.splice(index, 1);\n\n        // If we removed the latest visibility change event, propagate changes.\n        if (index === visibilityEventsOnOriginalEvent.length) {\n            const originalEvent = this.findEventById(originalEventId!);\n            if (!originalEvent) {\n                return;\n            }\n            if (index === 0) {\n                // We have just removed the only visibility change event.\n                this.visibilityEvents.delete(originalEventId!);\n                originalEvent.applyVisibilityEvent();\n            } else {\n                const newEvent = visibilityEventsOnOriginalEvent[visibilityEventsOnOriginalEvent.length - 1];\n                const newVisibility = newEvent.asVisibilityChange();\n                if (!newVisibility) {\n                    // Event is ill-formed.\n                    // This breaks our invariant.\n                    throw new Error(\"at this stage, visibility changes should be well-formed\");\n                }\n                originalEvent.applyVisibilityEvent(newVisibility);\n            }\n        }\n    }\n\n    /**\n     * When we receive an event whose visibility has been altered by\n     * a (more recent) visibility change event, patch the event in\n     * place so that clients now not to display it.\n     *\n     * @param event - Any matrix event. If this event has at least one a\n     * pending visibility change event, apply the latest visibility\n     * change event.\n     */\n    private applyPendingVisibilityEvents(event: MatrixEvent): void {\n        const visibilityEvents = this.visibilityEvents.get(event.getId()!);\n        if (!visibilityEvents || visibilityEvents.length == 0) {\n            // No pending visibility change in store.\n            return;\n        }\n        const visibilityEvent = visibilityEvents[visibilityEvents.length - 1];\n        const visibilityChange = visibilityEvent.asVisibilityChange();\n        if (!visibilityChange) {\n            return;\n        }\n        if (visibilityChange.visible) {\n            // Events are visible by default, no need to apply a visibility change.\n            // Note that we need to keep the visibility changes in `visibilityEvents`,\n            // in case we later fetch an older visibility change event that is superseded\n            // by `visibilityChange`.\n        }\n        if (visibilityEvent.getTs() < event.getTs()) {\n            // Something is wrong, the visibility change cannot happen before the\n            // event. Presumably an ill-formed event.\n            return;\n        }\n        event.applyVisibilityEvent(visibilityChange);\n    }\n\n    /**\n     * Find when a client has gained thread capabilities by inspecting the oldest\n     * threaded receipt\n     * @returns the timestamp of the oldest threaded receipt\n     */\n    public getOldestThreadedReceiptTs(): number {\n        return this.oldestThreadedReceiptTs;\n    }\n\n    /**\n     * Determines if the given user has read a particular event ID with the known\n     * history of the room. This is not a definitive check as it relies only on\n     * what is available to the room at the time of execution.\n     *\n     * @param userId - The user ID to check the read state of.\n     * @param eventId - The event ID to check if the user read.\n     * @returns true if the user has read the event, false otherwise.\n     */\n    public hasUserReadEvent(userId: string, eventId: string): boolean {\n        return this.roomReceipts.hasUserReadEvent(userId, eventId);\n    }\n\n    /**\n     * Returns the most recent unthreaded receipt for a given user\n     * @param userId - the MxID of the User\n     * @returns an unthreaded Receipt. Can be undefined if receipts have been disabled\n     * or a user chooses to use private read receipts (or we have simply not received\n     * a receipt from this user yet).\n     */\n    public getLastUnthreadedReceiptFor(userId: string): Receipt | undefined {\n        return this.unthreadedReceipts.get(userId);\n    }\n\n    /**\n     * This issue should also be addressed on synapse's side and is tracked as part\n     * of https://github.com/matrix-org/synapse/issues/14837\n     *\n     *\n     * We consider a room  fully read if the current user has sent\n     * the last event in the live timeline of that context and if the read receipt\n     * we have on record matches.\n     * This also detects all unread threads and applies the same logic to those\n     * contexts\n     */\n    public fixupNotifications(userId: string): void {\n        super.fixupNotifications(userId);\n\n        const unreadThreads = this.getThreads().filter(\n            (thread) => this.getThreadUnreadNotificationCount(thread.id, NotificationCountType.Total) > 0,\n        );\n\n        for (const thread of unreadThreads) {\n            thread.fixupNotifications(userId);\n        }\n    }\n\n    /**\n     * Determine the order of two events in this room.\n     *\n     * In principle this should use the same order as the server, but in practice\n     * this is difficult for events that were not received over the Sync API. See\n     * MSC4033 for details.\n     *\n     * This implementation leans on the order of events within their timelines, and\n     * falls back to comparing event timestamps when they are in different\n     * timelines.\n     *\n     * See https://github.com/matrix-org/matrix-js-sdk/issues/3325 for where we are\n     * tracking the work to fix this.\n     *\n     * @param leftEventId - the id of the first event\n     * @param rightEventId - the id of the second event\n\n     * @returns -1 if left \\< right, 1 if left \\> right, 0 if left == right, null if\n     *          we can't tell (because we can't find the events).\n     */\n    public compareEventOrdering(leftEventId: string, rightEventId: string): number | null {\n        return compareEventOrdering(this, leftEventId, rightEventId);\n    }\n\n    /**\n     * Return true if this room has an `m.room.encryption` state event.\n     *\n     * If this returns `true`, events sent to this room should be encrypted (and `MatrixClient.sendEvent` and friends\n     * will encrypt outgoing events).\n     */\n    public hasEncryptionStateEvent(): boolean {\n        return Boolean(\n            this.getLiveTimeline().getState(EventTimeline.FORWARDS)?.getStateEvents(EventType.RoomEncryption, \"\"),\n        );\n    }\n}\n\n// a map from current event status to a list of allowed next statuses\nconst ALLOWED_TRANSITIONS: Record<EventStatus, EventStatus[]> = {\n    [EventStatus.ENCRYPTING]: [EventStatus.SENDING, EventStatus.NOT_SENT, EventStatus.CANCELLED],\n    [EventStatus.SENDING]: [EventStatus.ENCRYPTING, EventStatus.QUEUED, EventStatus.NOT_SENT, EventStatus.SENT],\n    [EventStatus.QUEUED]: [EventStatus.SENDING, EventStatus.NOT_SENT, EventStatus.CANCELLED],\n    [EventStatus.SENT]: [],\n    [EventStatus.NOT_SENT]: [EventStatus.SENDING, EventStatus.QUEUED, EventStatus.CANCELLED],\n    [EventStatus.CANCELLED]: [],\n};\n\nexport enum RoomNameType {\n    EmptyRoom,\n    Generated,\n    Actual,\n}\n\nexport interface EmptyRoomNameState {\n    type: RoomNameType.EmptyRoom;\n    oldName?: string;\n}\n\nexport interface GeneratedRoomNameState {\n    type: RoomNameType.Generated;\n    subtype?: \"Inviting\";\n    names: string[];\n    count: number;\n}\n\nexport interface ActualRoomNameState {\n    type: RoomNameType.Actual;\n    name: string;\n}\n\nexport type RoomNameState = EmptyRoomNameState | GeneratedRoomNameState | ActualRoomNameState;\n\n// Can be overriden by IMatrixClientCreateOpts::memberNamesToRoomNameFn\nfunction memberNamesToRoomName(names: string[], count: number): string {\n    const countWithoutMe = count - 1;\n    if (!names.length) {\n        return \"Empty room\";\n    } else if (names.length === 1 && countWithoutMe <= 1) {\n        return names[0];\n    } else if (names.length === 2 && countWithoutMe <= 2) {\n        return `${names[0]} and ${names[1]}`;\n    } else {\n        const plural = countWithoutMe > 1;\n        if (plural) {\n            return `${names[0]} and ${countWithoutMe} others`;\n        } else {\n            return `${names[0]} and 1 other`;\n        }\n    }\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EventContext } from \"./event-context.ts\";\nimport { type EventMapper } from \"../event-mapper.ts\";\nimport { type IResultContext, type ISearchResult } from \"../@types/search.ts\";\n\nexport class SearchResult {\n    /**\n     * Create a SearchResponse from the response to /search\n     */\n\n    public static fromJson(jsonObj: ISearchResult, eventMapper: EventMapper): SearchResult {\n        const jsonContext = jsonObj.context || ({} as IResultContext);\n        let eventsBefore = (jsonContext.events_before || []).map(eventMapper);\n        let eventsAfter = (jsonContext.events_after || []).map(eventMapper);\n\n        const context = new EventContext(eventMapper(jsonObj.result));\n\n        // Filter out any contextual events which do not correspond to the same timeline (thread or room)\n        const threadRootId = context.ourEvent.threadRootId;\n        eventsBefore = eventsBefore.filter((e) => e.threadRootId === threadRootId);\n        eventsAfter = eventsAfter.filter((e) => e.threadRootId === threadRootId);\n\n        context.setPaginateToken(jsonContext.start, true);\n        context.addEvents(eventsBefore, true);\n        context.addEvents(eventsAfter, false);\n        context.setPaginateToken(jsonContext.end, false);\n\n        return new SearchResult(jsonObj.rank, context);\n    }\n\n    /**\n     * Construct a new SearchResult\n     *\n     * @param rank -   where this SearchResult ranks in the results\n     * @param context -  the matching event and its\n     *    context\n     */\n    public constructor(\n        public readonly rank: number,\n        public readonly context: EventContext,\n    ) {}\n}\n","/*\nCopyright 2021 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixClient, PendingEventOrdering } from \"../client.ts\";\nimport { TypedReEmitter } from \"../ReEmitter.ts\";\nimport { RelationType } from \"../@types/event.ts\";\nimport { type IThreadBundledRelationship, MatrixEvent, MatrixEventEvent } from \"./event.ts\";\nimport { Direction, EventTimeline } from \"./event-timeline.ts\";\nimport { EventTimelineSet, type EventTimelineSetHandlerMap } from \"./event-timeline-set.ts\";\nimport { type NotificationCountType, type Room, RoomEvent } from \"./room.ts\";\nimport { type RoomState } from \"./room-state.ts\";\nimport { ServerControlledNamespacedValue } from \"../NamespacedValue.ts\";\nimport { logger } from \"../logger.ts\";\nimport { ReadReceipt } from \"./read-receipt.ts\";\nimport { type CachedReceiptStructure, type Receipt, ReceiptType } from \"../@types/read_receipts.ts\";\nimport { Feature, ServerSupport } from \"../feature.ts\";\n\nexport enum ThreadEvent {\n    New = \"Thread.new\",\n    Update = \"Thread.update\",\n    NewReply = \"Thread.newReply\",\n    ViewThread = \"Thread.viewThread\",\n    Delete = \"Thread.delete\",\n}\n\nexport type ThreadEmittedEvents = Exclude<ThreadEvent, ThreadEvent.New> | RoomEvent.Timeline | RoomEvent.TimelineReset;\n\nexport type ThreadEventHandlerMap = {\n    [ThreadEvent.Update]: (thread: Thread) => void;\n    [ThreadEvent.NewReply]: (thread: Thread, event: MatrixEvent) => void;\n    [ThreadEvent.ViewThread]: () => void;\n    [ThreadEvent.Delete]: (thread: Thread) => void;\n} & EventTimelineSetHandlerMap;\n\ninterface IThreadOpts {\n    room: Room;\n    client: MatrixClient;\n    pendingEventOrdering?: PendingEventOrdering;\n    receipts?: CachedReceiptStructure[];\n}\n\nexport enum FeatureSupport {\n    None = 0,\n    Experimental = 1,\n    Stable = 2,\n}\n\nexport function determineFeatureSupport(stable: boolean, unstable: boolean): FeatureSupport {\n    if (stable) {\n        return FeatureSupport.Stable;\n    } else if (unstable) {\n        return FeatureSupport.Experimental;\n    } else {\n        return FeatureSupport.None;\n    }\n}\n\nexport class Thread extends ReadReceipt<ThreadEmittedEvents, ThreadEventHandlerMap> {\n    public static hasServerSideSupport = FeatureSupport.None;\n    public static hasServerSideListSupport = FeatureSupport.None;\n    public static hasServerSideFwdPaginationSupport = FeatureSupport.None;\n\n    /**\n     * A reference to all the events ID at the bottom of the threads\n     */\n    public readonly timelineSet: EventTimelineSet;\n\n    private _currentUserParticipated = false;\n\n    private reEmitter: TypedReEmitter<ThreadEmittedEvents, ThreadEventHandlerMap>;\n\n    /**\n     * The last event in this thread, if we don't yet have this in the timeline.\n     *\n     * When we run {@link processRootEvent} (which I think happens during the\n     * setting-up of the thread), we set this to the event pointed to by the\n     * server in `latest_event` [1] that came through with the thread root.\n     *\n     * [1]: https://spec.matrix.org/v1.8/client-server-api/#server-side-aggregation-of-mthread-relationships\n     *\n     * Later, when we have populated the timeline, this is set to undefined, so\n     * that methods like {@link replyToEvent} fall through to use lastReply,\n     * which looks in the timeline for the latest event that is a \"thread reply\"\n     * i.e. directly refers to the thread root with an m.thread relation.\n     *\n     * So it looks like this is only really relevant when initialEventsFetched\n     * is false, because as soon as the initial events have been fetched, we\n     * should have a proper chunk of timeline from the pagination fetch.\n     *\n     * If all replies in this thread are redacted, this is set to the root\n     * event. I'm not clear what the meaning of this is, since usually after the\n     * initial events have been fetched, lastEvent should be undefined.\n     * In fact, the whole usage inside onRedaction looks suspect - it may be\n     * that we were thinking lastEvent always refers to the actual last event,\n     * but it only does so before initialEventsFetched becomes true.\n     *\n     * The usage of lastEvent inside {@link onEcho} looks suspicious, since I'd\n     * think we probably mean {@link replyToEvent} there - we are trying not to\n     * echo a duplicate event, and we probably want that behaviour even after\n     * initialEventsFetched has become true.\n     *\n     * -- andyb\n     */\n    private lastEvent: MatrixEvent | undefined;\n\n    private replyCount = 0;\n    private lastPendingEvent: MatrixEvent | undefined;\n    private pendingReplyCount = 0;\n\n    public readonly room: Room;\n    public readonly client: MatrixClient;\n    private readonly pendingEventOrdering: PendingEventOrdering;\n    private processRootEventPromise?: Promise<void>;\n\n    /**\n     * Whether or not we need to fetch the initial set of events for the thread. We can\n     * only do this if the server has support for it, so if it doesn't we just pretend\n     * that we've already fetched them.\n     */\n    public initialEventsFetched = !Thread.hasServerSideSupport;\n    private initalEventFetchProm: Promise<boolean> | undefined;\n\n    /**\n     * An array of events to add to the timeline once the thread has been initialised\n     * with server suppport.\n     */\n    public replayEvents: MatrixEvent[] | null = [];\n\n    public constructor(\n        public readonly id: string,\n        public rootEvent: MatrixEvent | undefined,\n        opts: IThreadOpts,\n    ) {\n        super();\n\n        // each Event in the thread adds a reemitter, so we could hit the listener limit.\n        this.setMaxListeners(1000);\n\n        if (!opts?.room) {\n            // Logging/debugging for https://github.com/vector-im/element-web/issues/22141\n            // Hope is that we end up with a more obvious stack trace.\n            throw new Error(\"element-web#22141: A thread requires a room in order to function\");\n        }\n\n        this.room = opts.room;\n        this.client = opts.client;\n        this.pendingEventOrdering = opts.pendingEventOrdering ?? PendingEventOrdering.Chronological;\n        this.timelineSet = new EventTimelineSet(\n            this.room,\n            {\n                timelineSupport: true,\n                pendingEvents: true,\n            },\n            this.client,\n            this,\n        );\n        this.reEmitter = new TypedReEmitter(this);\n\n        this.reEmitter.reEmit(this.timelineSet, [RoomEvent.Timeline, RoomEvent.TimelineReset]);\n\n        this.room.on(MatrixEventEvent.BeforeRedaction, this.onBeforeRedaction);\n        this.room.on(RoomEvent.Redaction, this.onRedaction);\n        this.room.on(RoomEvent.LocalEchoUpdated, this.onLocalEcho);\n        this.room.on(RoomEvent.TimelineReset, this.onTimelineReset);\n        this.timelineSet.on(RoomEvent.Timeline, this.onTimelineEvent);\n\n        this.processReceipts(opts.receipts);\n\n        // even if this thread is thought to be originating from this client, we initialise it as we may be in a\n        // gappy sync and a thread around this event may already exist.\n        this.updateThreadMetadata();\n        this.setEventMetadata(this.rootEvent);\n    }\n\n    private onTimelineReset = async (): Promise<void> => {\n        // We hit a gappy sync, ask the server for an update\n        await this.processRootEventPromise;\n        this.processRootEventPromise = undefined;\n    };\n\n    private async fetchRootEvent(): Promise<void> {\n        // Always fetch the root event, even if we already have it, so we can get the latest\n        // state (via unsigned).\n        try {\n            const eventData = await this.client.fetchRoomEvent(this.roomId, this.id);\n            const mapper = this.client.getEventMapper();\n            this.rootEvent = mapper(eventData); // will merge with existing event object if such is known\n        } catch (e) {\n            logger.error(\"Failed to fetch thread root to construct thread with\", e);\n        }\n        await this.processEvent(this.rootEvent);\n    }\n\n    public static setServerSideSupport(status: FeatureSupport): void {\n        Thread.hasServerSideSupport = status;\n        // XXX: This global latching behaviour is really unexpected and means that you can't undo when moving to a server without support\n        if (status !== FeatureSupport.Stable) {\n            FILTER_RELATED_BY_SENDERS.setPreferUnstable(true);\n            FILTER_RELATED_BY_REL_TYPES.setPreferUnstable(true);\n            THREAD_RELATION_TYPE.setPreferUnstable(true);\n        }\n    }\n\n    public static setServerSideListSupport(status: FeatureSupport): void {\n        Thread.hasServerSideListSupport = status;\n    }\n\n    public static setServerSideFwdPaginationSupport(status: FeatureSupport): void {\n        Thread.hasServerSideFwdPaginationSupport = status;\n    }\n\n    private onBeforeRedaction = (event: MatrixEvent, redaction: MatrixEvent): void => {\n        if (\n            event?.isRelation(THREAD_RELATION_TYPE.name) &&\n            this.room.eventShouldLiveIn(event).threadId === this.id &&\n            event.getId() !== this.id && // the root event isn't counted in the length so ignore this redaction\n            !redaction.status // only respect it when it succeeds\n        ) {\n            this.replyCount--;\n            this.updatePendingReplyCount();\n            this.emit(ThreadEvent.Update, this);\n        }\n    };\n\n    private onRedaction = async (event: MatrixEvent, room: Room, threadRootId?: string): Promise<void> => {\n        if (threadRootId !== this.id) return; // ignore redactions for other timelines\n        if (this.replyCount <= 0) {\n            for (const threadEvent of this.timeline) {\n                this.clearEventMetadata(threadEvent);\n            }\n            this.lastEvent = this.rootEvent;\n            this._currentUserParticipated = false;\n            this.emit(ThreadEvent.Delete, this);\n        } else {\n            if (this.lastEvent?.getId() === event.getAssociatedId()) {\n                // XXX: If our last event got redacted we query the server for the last event once again\n                await this.processRootEventPromise;\n                this.processRootEventPromise = undefined;\n            }\n            await this.updateThreadMetadata();\n        }\n    };\n\n    private onTimelineEvent = (\n        event: MatrixEvent,\n        room: Room | undefined,\n        toStartOfTimeline: boolean | undefined,\n    ): void => {\n        // Add a synthesized receipt when paginating forward in the timeline\n        if (!toStartOfTimeline) {\n            const sender = event.getSender();\n            if (sender && room && this.shouldSendLocalEchoReceipt(sender, event)) {\n                room.addLocalEchoReceipt(sender, event, ReceiptType.Read);\n            }\n            if (event.getId() !== this.id && event.isRelation(THREAD_RELATION_TYPE.name)) {\n                this.replyCount++;\n            }\n        }\n        this.onEcho(event, toStartOfTimeline ?? false);\n    };\n\n    private shouldSendLocalEchoReceipt(sender: string, event: MatrixEvent): boolean {\n        const recursionSupport = this.client.canSupport.get(Feature.RelationsRecursion) ?? ServerSupport.Unsupported;\n\n        if (recursionSupport === ServerSupport.Unsupported) {\n            // Normally we add a local receipt, but if we don't have\n            // recursion support, then events may arrive out of order, so we\n            // only create a receipt if it's after our existing receipt.\n            const oldReceiptEventId = this.getReadReceiptForUserId(sender)?.eventId;\n            if (oldReceiptEventId) {\n                const receiptEvent = this.findEventById(oldReceiptEventId);\n                if (receiptEvent && receiptEvent.getTs() > event.getTs()) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private onLocalEcho = (event: MatrixEvent): void => {\n        this.onEcho(event, false);\n    };\n\n    private onEcho = async (event: MatrixEvent, toStartOfTimeline: boolean): Promise<void> => {\n        if (event.threadRootId !== this.id) return; // ignore echoes for other timelines\n        if (this.lastEvent === event) return; // ignore duplicate events\n        await this.updateThreadMetadata();\n        if (!event.isRelation(THREAD_RELATION_TYPE.name)) return; // don't send a new reply event for reactions or edits\n        if (toStartOfTimeline) return; // ignore messages added to the start of the timeline\n        // Clear the lastEvent and instead start tracking locally using lastReply\n        this.lastEvent = undefined;\n        this.emit(ThreadEvent.NewReply, this, event);\n    };\n\n    public get roomState(): RoomState {\n        return this.room.getLiveTimeline().getState(EventTimeline.FORWARDS)!;\n    }\n\n    private addEventToTimeline(event: MatrixEvent, toStartOfTimeline: boolean): void {\n        if (!this.findEventById(event.getId()!)) {\n            this.timelineSet.addEventToTimeline(event, this.liveTimeline, {\n                toStartOfTimeline,\n                fromCache: false,\n                roomState: this.roomState,\n                addToState: false,\n            });\n        }\n    }\n\n    /**\n     * TEMPORARY. Only call this when MSC3981 is not available, and we have some\n     * late-arriving events to insert, because we recursively found them as part\n     * of populating a thread. When we have MSC3981 we won't need it, because\n     * they will all be supplied by the homeserver in one request, and they will\n     * already be in the right order in that response.\n     * This is a copy of addEventToTimeline above, modified to call\n     * insertEventIntoTimeline so this event is inserted into our best guess of\n     * the right place based on timestamp. (We should be using Sync Order but we\n     * don't have it.)\n     *\n     * @internal\n     */\n    public insertEventIntoTimeline(event: MatrixEvent): void {\n        const eventId = event.getId();\n        if (!eventId) {\n            return;\n        }\n        // If the event is already in this thread, bail out\n        if (this.findEventById(eventId)) {\n            return;\n        }\n        this.timelineSet.insertEventIntoTimeline(event, this.liveTimeline, this.roomState, false);\n    }\n\n    public addEvents(events: MatrixEvent[], toStartOfTimeline: boolean): void {\n        events.forEach((ev) => this.addEvent(ev, toStartOfTimeline, false));\n        this.updateThreadMetadata();\n    }\n\n    /**\n     * Add an event to the thread and updates\n     * the tail/root references if needed\n     * Will fire \"Thread.update\"\n     * @param event - The event to add\n     * @param toStartOfTimeline - whether the event is being added\n     * to the start (and not the end) of the timeline.\n     * @param emit - whether to emit the Update event if the thread was updated or not.\n     */\n    public addEvent(event: MatrixEvent, toStartOfTimeline: boolean, emit = true): void {\n        // Modify this event to point at our room's state, and mark its thread\n        // as this.\n        this.setEventMetadata(event);\n\n        // Decide whether this event is going to be added at the end of the timeline.\n        const lastReply = this.lastReply();\n        const isNewestReply = !lastReply || event.localTimestamp >= lastReply!.localTimestamp;\n\n        if (!Thread.hasServerSideSupport) {\n            // When there's no server-side support, just add it to the end of the timeline.\n            this.addEventToTimeline(event, toStartOfTimeline);\n            this.client.decryptEventIfNeeded(event);\n        } else if (event.isRelation(RelationType.Annotation) || event.isRelation(RelationType.Replace)) {\n            this.addRelatedThreadEvent(event, toStartOfTimeline);\n            return;\n        } else if (!toStartOfTimeline && isNewestReply) {\n            // When we've asked for the event to be added to the end,\n            // and this event belongs at the end, add it.\n            this.addEventToTimeline(event, false);\n            this.fetchEditsWhereNeeded(event);\n        } else {\n            // Otherwise, we should add it, but we suspect it is out of order.\n            // This may be because we've just created the thread object and are\n            // still fetching events, in which case add it where we think is sensible\n            // and it will be removed and replaced with the events from the pagination\n            // request once that completes.\n            if (toStartOfTimeline) {\n                // If we're adding at the start of the timeline, it doesn't\n                // matter that it's out of order.\n                this.addEventToTimeline(event, toStartOfTimeline);\n            } else {\n                // We think this event might be out of order, because isNewestReply\n                // is false (otherwise we would have gone into the earlier if\n                // clause), so try to insert it in the right place based on\n                // timestamp.\n                this.insertEventIntoTimeline(event);\n            }\n        }\n\n        if (\n            event.getId() !== this.id &&\n            event.isRelation(THREAD_RELATION_TYPE.name) &&\n            !toStartOfTimeline &&\n            isNewestReply\n        ) {\n            // Clear the last event as we have the latest end of the timeline\n            this.lastEvent = undefined;\n        }\n\n        if (emit) {\n            this.emit(ThreadEvent.NewReply, this, event);\n            this.updateThreadMetadata();\n        }\n    }\n\n    private addRelatedThreadEvent(event: MatrixEvent, toStartOfTimeline: boolean): void {\n        // If this event is not a direct member of the thread, but is a\n        // reference to something that is, then we have two cases:\n\n        if (!this.initialEventsFetched) {\n            // Case 1: we haven't yet fetched events from the server. In\n            // this case, when we do, the events we get back might only be\n            // the first-order ones, so this event (which is second-order -\n            // a reference to something directly in the thread) needs to be\n            // kept so we can replay it when the first-order ones turn up.\n\n            /**\n             * A thread can be fully discovered via a single sync response\n             * And when that's the case we still ask the server to do an initialisation\n             * as it's the safest to ensure we have everything.\n             * However when we are in that scenario we might loose annotation or edits\n             *\n             * This fix keeps a reference to those events and replay them once the thread\n             * has been initialised properly.\n             */\n            this.replayEvents?.push(event);\n\n            // For annotations (reactions), aggregate immediately (pre-init) to keep\n            // reaction counts/summary visible while the thread is still initialising.\n            // Only aggregate as child: parent aggregation is unnecessary here.\n            if (event.isRelation(RelationType.Annotation)) {\n                this.timelineSet.relations?.aggregateChildEvent(event, this.timelineSet);\n            }\n        } else {\n            // Case 2: this is happening later, and we have a timeline. In\n            // this case, these events might be out-of order.\n            //\n            // Specifically, if the server doesn't support recursion, so we\n            // only get these events through sync, they might be coming\n            // later than the first-order ones, so we insert them based on\n            // timestamp (despite the problems with this documented in\n            // #3325).\n            //\n            // If the server does support recursion, we should have got all\n            // the interspersed events from the server when we fetched the\n            // initial events, so if they are coming via sync they should be\n            // the latest ones, so we can add them as normal.\n            //\n            // (Note that both insertEventIntoTimeline and addEventToTimeline\n            // do nothing if we have seen this event before.)\n\n            const recursionSupport =\n                this.client.canSupport.get(Feature.RelationsRecursion) ?? ServerSupport.Unsupported;\n\n            if (recursionSupport === ServerSupport.Unsupported) {\n                this.insertEventIntoTimeline(event);\n            } else {\n                this.addEventToTimeline(event, toStartOfTimeline);\n            }\n            // Aggregation is handled by EventTimelineSet when inserting/adding.\n        }\n    }\n\n    public async processEvent(event: MatrixEvent | null | undefined): Promise<void> {\n        if (event) {\n            this.setEventMetadata(event);\n            await this.fetchEditsWhereNeeded(event);\n        }\n    }\n\n    /**\n     * Processes the receipts that were caught during initial sync\n     * When clients become aware of a thread, they try to retrieve those read receipts\n     * and apply them to the current thread\n     * @param receipts - A collection of the receipts cached from initial sync\n     */\n    private processReceipts(receipts: CachedReceiptStructure[] = []): void {\n        for (const { eventId, receiptType, userId, receipt, synthetic } of receipts) {\n            this.addReceiptToStructure(eventId, receiptType as ReceiptType, userId, receipt, synthetic);\n        }\n    }\n\n    private getRootEventBundledRelationship(rootEvent = this.rootEvent): IThreadBundledRelationship | undefined {\n        return rootEvent?.getServerAggregatedRelation<IThreadBundledRelationship>(THREAD_RELATION_TYPE.name);\n    }\n\n    private async processRootEvent(): Promise<void> {\n        const bundledRelationship = this.getRootEventBundledRelationship();\n        if (Thread.hasServerSideSupport && bundledRelationship) {\n            this.replyCount = bundledRelationship.count;\n            this._currentUserParticipated = !!bundledRelationship.current_user_participated;\n\n            const mapper = this.client.getEventMapper();\n            // re-insert roomId\n            this.lastEvent = mapper({\n                ...bundledRelationship.latest_event,\n                room_id: this.roomId,\n            });\n            this.updatePendingReplyCount();\n            await this.processEvent(this.lastEvent);\n        }\n    }\n\n    private updatePendingReplyCount(): void {\n        const unfilteredPendingEvents =\n            this.pendingEventOrdering === PendingEventOrdering.Detached ? this.room.getPendingEvents() : this.events;\n        const pendingEvents = unfilteredPendingEvents.filter(\n            (ev) =>\n                ev.threadRootId === this.id &&\n                ev.isRelation(THREAD_RELATION_TYPE.name) &&\n                ev.status !== null &&\n                ev.getId() !== this.lastEvent?.getId(),\n        );\n        this.lastPendingEvent = pendingEvents.length ? pendingEvents[pendingEvents.length - 1] : undefined;\n        this.pendingReplyCount = pendingEvents.length;\n    }\n\n    /**\n     * Reset the live timeline of all timelineSets, and start new ones.\n     *\n     * <p>This is used when /sync returns a 'limited' timeline. 'Limited' means that there's a gap between the messages\n     * /sync returned, and the last known message in our timeline. In such a case, our live timeline isn't live anymore\n     * and has to be replaced by a new one. To make sure we can continue paginating our timelines correctly, we have to\n     * set new pagination tokens on the old and the new timeline.\n     *\n     * @param backPaginationToken -   token for back-paginating the new timeline\n     * @param forwardPaginationToken - token for forward-paginating the old live timeline,\n     * if absent or null, all timelines are reset, removing old ones (including the previous live\n     * timeline which would otherwise be unable to paginate forwards without this token).\n     * Removing just the old live timeline whilst preserving previous ones is not supported.\n     */\n    public async resetLiveTimeline(\n        backPaginationToken?: string | null,\n        forwardPaginationToken?: string | null,\n    ): Promise<void> {\n        const oldLive = this.liveTimeline;\n        this.timelineSet.resetLiveTimeline(backPaginationToken ?? undefined, forwardPaginationToken ?? undefined);\n        const newLive = this.liveTimeline;\n\n        // FIXME: Remove the following as soon as https://github.com/matrix-org/synapse/issues/14830 is resolved.\n        //\n        // The pagination API for thread timelines currently can't handle the type of pagination tokens returned by sync\n        //\n        // To make this work anyway, we'll have to transform them into one of the types that the API can handle.\n        // One option is passing the tokens to /messages, which can handle sync tokens, and returns the right format.\n        // /messages does not return new tokens on requests with a limit of 0.\n        // This means our timelines might overlap a slight bit, but that's not an issue, as we deduplicate messages\n        // anyway.\n\n        let newBackward: string | undefined;\n        let oldForward: string | undefined;\n        if (backPaginationToken) {\n            const res = await this.client.createMessagesRequest(this.roomId, backPaginationToken, 1, Direction.Forward);\n            newBackward = res.end;\n        }\n        if (forwardPaginationToken) {\n            const res = await this.client.createMessagesRequest(\n                this.roomId,\n                forwardPaginationToken,\n                1,\n                Direction.Backward,\n            );\n            oldForward = res.start;\n        }\n        // Only replace the token if we don't have paginated away from this position already. This situation doesn't\n        // occur today, but if the above issue is resolved, we'd have to go down this path.\n        if (forwardPaginationToken && oldLive.getPaginationToken(Direction.Forward) === forwardPaginationToken) {\n            oldLive.setPaginationToken(oldForward ?? null, Direction.Forward);\n        }\n        if (backPaginationToken && newLive.getPaginationToken(Direction.Backward) === backPaginationToken) {\n            newLive.setPaginationToken(newBackward ?? null, Direction.Backward);\n        }\n    }\n\n    private async updateThreadFromRootEvent(): Promise<void> {\n        if (Thread.hasServerSideSupport) {\n            // Ensure we show *something* as soon as possible, we'll update it as soon as we get better data, but we\n            // don't want the thread preview to be empty if we can avoid it\n            if (!this.initialEventsFetched && !this.lastEvent) {\n                await this.processRootEvent();\n            }\n            await this.fetchRootEvent();\n        }\n        await this.processRootEvent();\n    }\n\n    private async updateThreadMetadata(): Promise<void> {\n        this.updatePendingReplyCount();\n\n        if (!this.processRootEventPromise) {\n            // We only want to do this once otherwise we end up rolling back to the last unsigned summary we have for the thread\n            this.processRootEventPromise = this.updateThreadFromRootEvent();\n        }\n        await this.processRootEventPromise;\n\n        if (!this.initialEventsFetched) {\n            if (this.initalEventFetchProm) {\n                await this.initalEventFetchProm;\n            } else {\n                // fetch initial events to allow proper pagination\n                try {\n                    // clear out any events that were added before the pagination request\n                    // completed (eg. from sync). They'll be replaced by those from the pagination.\n                    // Really, we should do this after the pagination request completes, but\n                    // paginateEventTimeline does the request and adds the events in one go, so\n                    // this would need a refactor in order to do. It's therefore possible there's\n                    // a remaining race where an event comes in while the pagination request is\n                    // happening.\n                    this.timelineSet.resetLiveTimeline();\n                    // if the thread has regular events, this will just load the last reply.\n                    // if the thread is newly created, this will load the root event.\n                    if (this.replyCount === 0 && this.rootEvent) {\n                        this.timelineSet.addEventsToTimeline([this.rootEvent], true, false, this.liveTimeline, null);\n                        this.liveTimeline.setPaginationToken(null, Direction.Backward);\n                    } else {\n                        this.initalEventFetchProm = this.client.paginateEventTimeline(this.liveTimeline, {\n                            backwards: true,\n                        });\n                        await this.initalEventFetchProm;\n                    }\n                    // We have now fetched the initial events, so set the flag. We need to do this before\n                    // we actually add the events, so `this.addEvents` knows that it can now safely add\n                    // them rather than buffer them in the pending event list. The main thing is that this\n                    // must remain false while the async fetch happens, so we don't try to add events before\n                    // the pagination has finished. The important thing is that we're not await-ing anything\n                    // else between setting this and adding events, so no races.\n                    this.initialEventsFetched = true;\n                    for (const event of this.replayEvents!) {\n                        this.addEvent(event, false);\n                    }\n                    this.replayEvents = null;\n                    // just to make sure that, if we've created a timeline window for this thread before the thread itself\n                    // existed (e.g. when creating a new thread), we'll make sure the panel is force refreshed correctly.\n                    this.emit(RoomEvent.TimelineReset, this.room, this.timelineSet, true);\n                } catch (e) {\n                    logger.error(\"Failed to load start of newly created thread: \", e);\n                    this.initialEventsFetched = false;\n                }\n            }\n        }\n\n        this.emit(ThreadEvent.Update, this);\n    }\n\n    // XXX: Workaround for https://github.com/matrix-org/matrix-spec-proposals/pull/2676/files#r827240084\n    private async fetchEditsWhereNeeded(...events: MatrixEvent[]): Promise<unknown> {\n        const recursionSupport = this.client.canSupport.get(Feature.RelationsRecursion) ?? ServerSupport.Unsupported;\n        if (recursionSupport === ServerSupport.Unsupported) {\n            return Promise.all(\n                events.filter(isAnEncryptedThreadMessage).map(async (event: MatrixEvent) => {\n                    try {\n                        const relations = await this.client.relations(\n                            this.roomId,\n                            event.getId()!,\n                            RelationType.Replace,\n                            event.getType(),\n                            {\n                                limit: 1,\n                            },\n                        );\n                        if (relations.events.length) {\n                            const editEvent = relations.events[0];\n                            event.makeReplaced(editEvent);\n                            this.insertEventIntoTimeline(editEvent);\n                        }\n                    } catch (e) {\n                        logger.error(\"Failed to load edits for encrypted thread event\", e);\n                    }\n                }),\n            );\n        }\n    }\n\n    public setEventMetadata(event: MatrixEvent | null | undefined): void {\n        if (event) {\n            EventTimeline.setEventMetadata(event, this.roomState, false);\n            event.setThread(this);\n        }\n    }\n\n    public clearEventMetadata(event: MatrixEvent | null | undefined): void {\n        if (event) {\n            event.setThread(undefined);\n            delete event.event?.unsigned?.[\"m.relations\"]?.[THREAD_RELATION_TYPE.name];\n        }\n    }\n\n    /**\n     * Finds an event by ID in the current thread\n     */\n    public findEventById(eventId: string): MatrixEvent | undefined {\n        return this.timelineSet.findEventById(eventId);\n    }\n\n    /**\n     * Return last reply to the thread, if known.\n     */\n    public lastReply(\n        matches: (ev: MatrixEvent) => boolean = (ev): boolean => ev.isRelation(THREAD_RELATION_TYPE.name),\n    ): MatrixEvent | null {\n        for (let i = this.timeline.length - 1; i >= 0; i--) {\n            const event = this.timeline[i];\n            if (matches(event)) {\n                return event;\n            }\n        }\n        return null;\n    }\n\n    public get roomId(): string {\n        return this.room.roomId;\n    }\n\n    /**\n     * The number of messages in the thread\n     * Only count rel_type=m.thread as we want to\n     * exclude annotations from that number\n     */\n    public get length(): number {\n        return this.replyCount + this.pendingReplyCount;\n    }\n\n    /**\n     * A getter for the last event of the thread.\n     * This might be a synthesized event, if so, it will not emit any events to listeners.\n     */\n    public get replyToEvent(): MatrixEvent | null {\n        return this.lastPendingEvent ?? this.lastEvent ?? this.lastReply();\n    }\n\n    /**\n     * The live event timeline for this thread.\n     * @deprecated Present for backwards compatibility.\n     *             Use this.events instead\n     * @returns The live event timeline for this thread.\n     */\n    public get timeline(): MatrixEvent[] {\n        return this.events;\n    }\n\n    public get events(): MatrixEvent[] {\n        return this.liveTimeline.getEvents();\n    }\n\n    public has(eventId: string): boolean {\n        return this.timelineSet.findEventById(eventId) instanceof MatrixEvent;\n    }\n\n    public get hasCurrentUserParticipated(): boolean {\n        return this._currentUserParticipated;\n    }\n\n    public get liveTimeline(): EventTimeline {\n        return this.timelineSet.getLiveTimeline();\n    }\n\n    public getUnfilteredTimelineSet(): EventTimelineSet {\n        return this.timelineSet;\n    }\n\n    public addReceipt(event: MatrixEvent, synthetic: boolean): void {\n        throw new Error(\"Unsupported function on the thread model\");\n    }\n\n    /**\n     * Get the ID of the event that a given user has read up to within this thread,\n     * or null if we have received no read receipt (at all) from them.\n     * @param userId - The user ID to get read receipt event ID for\n     * @param ignoreSynthesized - If true, return only receipts that have been\n     *                            sent by the server, not implicit ones generated\n     *                            by the JS SDK.\n     * @returns ID of the latest event that the given user has read, or null.\n     */\n    public getEventReadUpTo(userId: string, ignoreSynthesized?: boolean): string | null {\n        // TODO: we think the implementation here is not right. Here is a sketch\n        // of the right answer:\n        //\n        // for event in timeline.events.reversed():\n        //     if room.hasUserReadEvent(event):\n        //         return event\n        // return null\n        //\n        // If this is too slow, we might be able to improve it by trying walking\n        // forward from the threaded receipt in this thread. We could alternate\n        // between backwards-from-front and forwards-from-threaded-receipt to\n        // improve our chances of hitting the right answer sooner.\n        //\n        // Either way, it's still fundamentally slow because we have to walk\n        // events.\n        //\n        // We also might just want to limit the time we spend on this by giving\n        // up after, say, 100 events.\n        //\n        // --- andyb\n\n        const isCurrentUser = userId === this.client.getUserId();\n        const lastReply = this.timeline[this.timeline.length - 1];\n        if (isCurrentUser && lastReply) {\n            // If the last activity in a thread is prior to the first threaded read receipt\n            // sent in the room (suggesting that it was sent before the user started\n            // using a client that supported threaded read receipts), we want to\n            // consider this thread as read.\n            const beforeFirstThreadedReceipt = lastReply.getTs() < this.room.getOldestThreadedReceiptTs();\n            const lastReplyId = lastReply.getId();\n            // Some unsent events do not have an ID, we do not want to consider them read\n            if (beforeFirstThreadedReceipt && lastReplyId) {\n                return lastReplyId;\n            }\n        }\n\n        const readUpToId = super.getEventReadUpTo(userId, ignoreSynthesized);\n\n        // Check whether the unthreaded read receipt for that user is more recent\n        // than the read receipt inside that thread.\n        if (lastReply) {\n            const unthreadedReceipt = this.room.getLastUnthreadedReceiptFor(userId);\n            if (!unthreadedReceipt) {\n                return readUpToId;\n            }\n\n            for (let i = this.timeline?.length - 1; i >= 0; --i) {\n                const ev = this.timeline[i];\n                // If we encounter the `readUpToId` we do not need to look further\n                // there is no \"more recent\" unthreaded read receipt\n                if (ev.getId() === readUpToId) return readUpToId;\n\n                // Inspecting events from most recent to oldest, we're checking\n                // whether an unthreaded read receipt is more recent that the current event.\n                // We usually prefer relying on the order of the DAG but in this scenario\n                // it is not possible and we have to rely on timestamp\n                if (ev.getTs() < unthreadedReceipt.ts) return ev.getId() ?? readUpToId;\n            }\n        }\n\n        return readUpToId;\n    }\n\n    /**\n     * Determine if the given user has read a particular event.\n     *\n     * It is invalid to call this method with an event that is not part of this thread.\n     *\n     * This is not a definitive check as it only checks the events that have been\n     * loaded client-side at the time of execution.\n     * @param userId - The user ID to check the read state of.\n     * @param eventId - The event ID to check if the user read.\n     * @returns True if the user has read the event, false otherwise.\n     */\n    public hasUserReadEvent(userId: string, eventId: string): boolean {\n        if (userId === this.client.getUserId()) {\n            // Consider an event read if it's part of a thread that is before the\n            // first threaded receipt sent in that room. It is likely that it is\n            // part of a thread that was created before MSC3771 was implemented.\n            // Or before the last unthreaded receipt for the logged in user\n            const beforeFirstThreadedReceipt =\n                (this.lastReply()?.getTs() ?? 0) < this.room.getOldestThreadedReceiptTs();\n            const unthreadedReceiptTs = this.room.getLastUnthreadedReceiptFor(userId)?.ts ?? 0;\n            const beforeLastUnthreadedReceipt = (this?.lastReply()?.getTs() ?? 0) < unthreadedReceiptTs;\n            if (beforeFirstThreadedReceipt || beforeLastUnthreadedReceipt) {\n                return true;\n            }\n        }\n\n        return this.room.hasUserReadEvent(userId, eventId);\n    }\n\n    public setUnread(type: NotificationCountType, count: number): void {\n        return this.room.setThreadUnreadNotificationCount(this.id, type, count);\n    }\n\n    /**\n     * Returns the most recent unthreaded receipt for a given user\n     * @param userId - the MxID of the User\n     * @returns an unthreaded Receipt. Can be undefined if receipts have been disabled\n     * or a user chooses to use private read receipts (or we have simply not received\n     * a receipt from this user yet).\n     */\n    public getLastUnthreadedReceiptFor(userId: string): Receipt | undefined {\n        return this.room.getLastUnthreadedReceiptFor(userId);\n    }\n}\n\n/**\n * Decide whether an event deserves to have its potential edits fetched.\n *\n * @returns true if this event is encrypted and is a message that is part of a\n * thread - either inside it, or a root.\n */\nfunction isAnEncryptedThreadMessage(event: MatrixEvent): boolean {\n    return event.isEncrypted() && (event.isRelation(THREAD_RELATION_TYPE.name) || event.isThreadRoot);\n}\n\nexport const FILTER_RELATED_BY_SENDERS = new ServerControlledNamespacedValue(\n    \"related_by_senders\",\n    \"io.element.relation_senders\",\n);\nexport const FILTER_RELATED_BY_REL_TYPES = new ServerControlledNamespacedValue(\n    \"related_by_rel_types\",\n    \"io.element.relation_types\",\n);\nexport const THREAD_RELATION_TYPE = new ServerControlledNamespacedValue(\"m.thread\", \"io.element.thread\");\n\nexport enum ThreadFilterType {\n    \"My\",\n    \"All\",\n}\n\nexport function threadFilterTypeToFilter(type: ThreadFilterType | null): \"all\" | \"participated\" {\n    switch (type) {\n        case ThreadFilterType.My:\n            return \"participated\";\n        default:\n            return \"all\";\n    }\n}\n","/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n// eslint-disable-next-line no-restricted-imports\nimport { EventEmitter } from \"events\";\n\n/** Events emitted by EventEmitter itself */\nexport enum EventEmitterEvents {\n    NewListener = \"newListener\",\n    RemoveListener = \"removeListener\",\n    Error = \"error\",\n}\n\ntype AnyListener = (...args: any) => any;\n\n/** Base class for types mapping from event name to the type of listeners to that event */\nexport type ListenerMap<E extends string> = { [eventName in E]: AnyListener };\n\ntype EventEmitterEventListener = (eventName: string, listener: AnyListener) => void;\ntype EventEmitterErrorListener = (error: Error) => void;\n\n/**\n * The expected type of a listener function for a particular event.\n *\n * Type parameters:\n *   * `E` - List of all events emitted by the `TypedEventEmitter`. Normally an enum type.\n *   * `A` - A type providing mappings from event names to listener types.\n *   * `T` - The name of the actual event that this listener is for. Normally one of the types in `E` or\n *           {@link EventEmitterEvents}.\n */\nexport type Listener<E extends string, A extends ListenerMap<E>, T extends E | EventEmitterEvents> = T extends E\n    ? A[T]\n    : T extends EventEmitterEvents\n      ? EventEmitterErrorListener\n      : EventEmitterEventListener;\n\n/**\n * Typed Event Emitter class which can act as a Base Model for all our model\n * and communication events.\n * This makes it much easier for us to distinguish between events, as we now need\n * to properly type this, so that our events are not stringly-based and prone\n * to silly typos.\n *\n * Type parameters:\n *  * `Events` - List of all events emitted by this `TypedEventEmitter`. Normally an enum type.\n *  * `Arguments` - A {@link ListenerMap} type providing mappings from event names to listener types.\n *  * `SuperclassArguments` - TODO: not really sure. Alternative listener mappings, I think? But only honoured for `.emit`?\n */\nexport class TypedEventEmitter<\n    Events extends string,\n    Arguments extends ListenerMap<Events>,\n    SuperclassArguments extends ListenerMap<any> = Arguments,\n> extends EventEmitter {\n    /**\n     * Alias for {@link on}.\n     */\n    public addListener<T extends Events | EventEmitterEvents>(\n        event: T,\n        listener: Listener<Events, Arguments, T>,\n    ): this {\n        return super.addListener(event, listener);\n    }\n\n    /**\n     * Synchronously calls each of the listeners registered for the event named\n     * `event`, in the order they were registered, passing the supplied arguments\n     * to each.\n     *\n     * @param event - The name of the event to emit\n     * @param args - Arguments to pass to the listener\n     * @returns `true` if the event had listeners, `false` otherwise.\n     */\n    public emit<T extends Events>(event: T, ...args: Parameters<SuperclassArguments[T]>): boolean;\n    public emit<T extends Events>(event: T, ...args: Parameters<Arguments[T]>): boolean;\n    public emit<T extends Events>(event: T, ...args: any[]): boolean {\n        return super.emit(event, ...args);\n    }\n\n    /**\n     * Similar to `emit` but calls all listeners within a `Promise.all` and returns the promise chain\n     * @param event - The name of the event to emit\n     * @param args - Arguments to pass to the listener\n     * @returns `true` if the event had listeners, `false` otherwise.\n     */\n    public async emitPromised<T extends Events>(\n        event: T,\n        ...args: Parameters<SuperclassArguments[T]>\n    ): Promise<boolean>;\n    public async emitPromised<T extends Events>(event: T, ...args: Parameters<Arguments[T]>): Promise<boolean>;\n    public async emitPromised<T extends Events>(event: T, ...args: any[]): Promise<boolean> {\n        const listeners = this.listeners(event);\n        return Promise.allSettled(listeners.map((l) => l(...args))).then(() => {\n            return listeners.length > 0;\n        });\n    }\n\n    /**\n     * Returns the number of listeners listening to the event named `event`.\n     *\n     * @param event - The name of the event being listened for\n     */\n    public listenerCount(event: Events | EventEmitterEvents): number {\n        return super.listenerCount(event);\n    }\n\n    /**\n     * Returns a copy of the array of listeners for the event named `event`.\n     */\n    public listeners(event: Events | EventEmitterEvents): ReturnType<EventEmitter[\"listeners\"]> {\n        return super.listeners(event);\n    }\n\n    /**\n     * Alias for {@link removeListener}\n     */\n    public off<T extends Events | EventEmitterEvents>(event: T, listener: Listener<Events, Arguments, T>): this {\n        return super.off(event, listener);\n    }\n\n    /**\n     * Adds the `listener` function to the end of the listeners array for the\n     * event named `event`.\n     *\n     * No checks are made to see if the `listener` has already been added. Multiple calls\n     * passing the same combination of `event` and `listener` will result in the `listener`\n     * being added, and called, multiple times.\n     *\n     * By default, event listeners are invoked in the order they are added. The\n     * {@link prependListener} method can be used as an alternative to add the\n     * event listener to the beginning of the listeners array.\n     *\n     * @param event - The name of the event.\n     * @param listener - The callback function\n     *\n     * @returns a reference to the `EventEmitter`, so that calls can be chained.\n     */\n    public on<T extends Events | EventEmitterEvents>(event: T, listener: Listener<Events, Arguments, T>): this {\n        return super.on(event, listener);\n    }\n\n    /**\n     * Adds a **one-time** `listener` function for the event named `event`. The\n     * next time `event` is triggered, this listener is removed and then invoked.\n     *\n     * Returns a reference to the `EventEmitter`, so that calls can be chained.\n     *\n     * By default, event listeners are invoked in the order they are added.\n     * The {@link prependOnceListener} method can be used as an alternative to add the\n     * event listener to the beginning of the listeners array.\n     *\n     * @param event - The name of the event.\n     * @param listener - The callback function\n     *\n     * @returns a reference to the `EventEmitter`, so that calls can be chained.\n     */\n    public once<T extends Events | EventEmitterEvents>(event: T, listener: Listener<Events, Arguments, T>): this {\n        return super.once(event, listener);\n    }\n\n    /**\n     * Adds the `listener` function to the _beginning_ of the listeners array for the\n     * event named `event`.\n     *\n     * No checks are made to see if the `listener` has already been added. Multiple calls\n     * passing the same combination of `event` and `listener` will result in the `listener`\n     * being added, and called, multiple times.\n     *\n     * @param event - The name of the event.\n     * @param listener - The callback function\n     *\n     * @returns a reference to the `EventEmitter`, so that calls can be chained.\n     */\n    public prependListener<T extends Events | EventEmitterEvents>(\n        event: T,\n        listener: Listener<Events, Arguments, T>,\n    ): this {\n        return super.prependListener(event, listener);\n    }\n\n    /**\n     * Adds a **one-time**`listener` function for the event named `event` to the _beginning_ of the listeners array.\n     * The next time `event` is triggered, this listener is removed, and then invoked.\n     *\n     * @param event - The name of the event.\n     * @param listener - The callback function\n     *\n     * @returns a reference to the `EventEmitter`, so that calls can be chained.\n     */\n    public prependOnceListener<T extends Events | EventEmitterEvents>(\n        event: T,\n        listener: Listener<Events, Arguments, T>,\n    ): this {\n        return super.prependOnceListener(event, listener);\n    }\n\n    /**\n     * Removes all listeners, or those of the specified `event`.\n     *\n     * It is bad practice to remove listeners added elsewhere in the code,\n     * particularly when the `EventEmitter` instance was created by some other\n     * component or module (e.g. sockets or file streams).\n     *\n     * @param event - The name of the event. If undefined, all listeners everywhere are removed.\n     * @returns a reference to the `EventEmitter`, so that calls can be chained.\n     */\n    public removeAllListeners(event?: Events | EventEmitterEvents): this {\n        // EventEmitter::removeAllListeners uses `arguments.length` to determine undefined case\n        if (event === undefined) {\n            return super.removeAllListeners();\n        }\n        return super.removeAllListeners(event);\n    }\n\n    /**\n     * Removes the specified `listener` from the listener array for the event named `event`.\n     *\n     * @returns a reference to the `EventEmitter`, so that calls can be chained.\n     */\n    public removeListener<T extends Events | EventEmitterEvents>(\n        event: T,\n        listener: Listener<Events, Arguments, T>,\n    ): this {\n        return super.removeListener(event, listener);\n    }\n\n    /**\n     * Returns a copy of the array of listeners for the event named `eventName`,\n     * including any wrappers (such as those created by `.once()`).\n     */\n    public rawListeners(event: Events | EventEmitterEvents): ReturnType<EventEmitter[\"rawListeners\"]> {\n        return super.rawListeners(event);\n    }\n}\n","/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type MatrixClient } from \"../matrix.ts\";\nimport { type MatrixEvent } from \"./event.ts\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.ts\";\n\nexport enum UserEvent {\n    DisplayName = \"User.displayName\",\n    AvatarUrl = \"User.avatarUrl\",\n    Presence = \"User.presence\",\n    CurrentlyActive = \"User.currentlyActive\",\n    LastPresenceTs = \"User.lastPresenceTs\",\n}\n\nexport type UserEventHandlerMap = {\n    /**\n     * Fires whenever any user's display name changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param user - The user whose User.displayName changed.\n     * @example\n     * ```\n     * matrixClient.on(\"User.displayName\", function(event, user){\n     *   var newName = user.displayName;\n     * });\n     * ```\n     */\n    [UserEvent.DisplayName]: (event: MatrixEvent | undefined, user: User) => void;\n    /**\n     * Fires whenever any user's avatar URL changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param user - The user whose User.avatarUrl changed.\n     * @example\n     * ```\n     * matrixClient.on(\"User.avatarUrl\", function(event, user){\n     *   var newUrl = user.avatarUrl;\n     * });\n     * ```\n     */\n    [UserEvent.AvatarUrl]: (event: MatrixEvent | undefined, user: User) => void;\n    /**\n     * Fires whenever any user's presence changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param user - The user whose User.presence changed.\n     * @example\n     * ```\n     * matrixClient.on(\"User.presence\", function(event, user){\n     *   var newPresence = user.presence;\n     * });\n     * ```\n     */\n    [UserEvent.Presence]: (event: MatrixEvent | undefined, user: User) => void;\n    /**\n     * Fires whenever any user's currentlyActive changes.\n     * @param event - The matrix event which caused this event to fire.\n     * @param user - The user whose User.currentlyActive changed.\n     * @example\n     * ```\n     * matrixClient.on(\"User.currentlyActive\", function(event, user){\n     *   var newCurrentlyActive = user.currentlyActive;\n     * });\n     * ```\n     */\n    [UserEvent.CurrentlyActive]: (event: MatrixEvent | undefined, user: User) => void;\n    /**\n     * Fires whenever any user's lastPresenceTs changes,\n     * ie. whenever any presence event is received for a user.\n     * @param event - The matrix event which caused this event to fire.\n     * @param user - The user whose User.lastPresenceTs changed.\n     * @example\n     * ```\n     * matrixClient.on(\"User.lastPresenceTs\", function(event, user){\n     *   var newlastPresenceTs = user.lastPresenceTs;\n     * });\n     * ```\n     */\n    [UserEvent.LastPresenceTs]: (event: MatrixEvent | undefined, user: User) => void;\n};\n\nexport class User extends TypedEventEmitter<UserEvent, UserEventHandlerMap> {\n    private modified = -1;\n\n    /**\n     * The 'displayname' of the user if known.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public displayName?: string;\n    public rawDisplayName?: string;\n    /**\n     * The 'avatar_url' of the user if known.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public avatarUrl?: string;\n    /**\n     * The presence status message if known.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public presenceStatusMsg?: string;\n    /**\n     * The presence enum if known.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public presence = \"offline\";\n    /**\n     * Timestamp (ms since the epoch) for when we last received presence data for this user.\n     * We can subtract lastActiveAgo from this to approximate an absolute value for when a user was last active.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public lastActiveAgo = 0;\n    /**\n     * The time elapsed in ms since the user interacted proactively with the server,\n     * or we saw a message from the user\n     * @privateRemarks\n     * Should be read-only\n     */\n    public lastPresenceTs = 0;\n    /**\n     * Whether we should consider lastActiveAgo to be an approximation\n     * and that the user should be seen as active 'now'\n     * @privateRemarks\n     * Should be read-only\n     */\n    public currentlyActive = false;\n    /**\n     * The events describing this user.\n     * @privateRemarks\n     * Should be read-only\n     */\n    public events: {\n        /** The m.presence event for this user. */\n        presence?: MatrixEvent;\n        profile?: MatrixEvent;\n    } = {};\n\n    /**\n     * Construct a new User. A User must have an ID and can optionally have extra information associated with it.\n     * @param userId - Required. The ID of this user.\n     * @deprecated use `User.createUser`\n     */\n    public constructor(public readonly userId: string) {\n        super();\n        this.displayName = userId;\n        this.rawDisplayName = userId;\n        this.updateModifiedTime();\n    }\n\n    /**\n     * Construct a new User whose events will also emit on MatrixClient.\n     * A User must have an ID and can optionally have extra information associated with it.\n     * @param userId - Required. The ID of this user.\n     * @param client - An instance of MatrixClient object\n     * @returns User object with reEmitter setup on client\n     */\n    public static createUser(userId: string, client: MatrixClient): User {\n        const user = new User(userId);\n        client.reEmitter.reEmit(user, [\n            UserEvent.AvatarUrl,\n            UserEvent.DisplayName,\n            UserEvent.Presence,\n            UserEvent.CurrentlyActive,\n            UserEvent.LastPresenceTs,\n        ]);\n        return user;\n    }\n\n    /**\n     * Update this User with the given presence event. May fire \"User.presence\",\n     * \"User.avatarUrl\" and/or \"User.displayName\" if this event updates this user's\n     * properties.\n     * @param event - The `m.presence` event.\n     *\n     * @remarks\n     * Fires {@link UserEvent.Presence}\n     * Fires {@link UserEvent.DisplayName}\n     * Fires {@link UserEvent.AvatarUrl}\n     */\n    public setPresenceEvent(event: MatrixEvent): void {\n        if (event.getType() !== \"m.presence\") {\n            return;\n        }\n        const firstFire = this.events.presence === null;\n        this.events.presence = event;\n\n        const eventsToFire: UserEvent[] = [];\n        if (event.getContent().presence !== this.presence || firstFire) {\n            eventsToFire.push(UserEvent.Presence);\n        }\n        if (event.getContent().avatar_url && event.getContent().avatar_url !== this.avatarUrl) {\n            eventsToFire.push(UserEvent.AvatarUrl);\n        }\n        if (event.getContent().displayname && event.getContent().displayname !== this.displayName) {\n            eventsToFire.push(UserEvent.DisplayName);\n        }\n        if (\n            event.getContent().currently_active !== undefined &&\n            event.getContent().currently_active !== this.currentlyActive\n        ) {\n            eventsToFire.push(UserEvent.CurrentlyActive);\n        }\n\n        this.presence = event.getContent().presence;\n        eventsToFire.push(UserEvent.LastPresenceTs);\n\n        if (event.getContent().status_msg) {\n            this.presenceStatusMsg = event.getContent().status_msg;\n        }\n        if (event.getContent().displayname) {\n            this.displayName = event.getContent().displayname;\n        }\n        if (event.getContent().avatar_url) {\n            this.avatarUrl = event.getContent().avatar_url;\n        }\n        this.lastActiveAgo = event.getContent().last_active_ago;\n        this.lastPresenceTs = Date.now();\n        this.currentlyActive = event.getContent().currently_active;\n\n        this.updateModifiedTime();\n\n        for (const eventToFire of eventsToFire) {\n            this.emit(eventToFire, event, this);\n        }\n    }\n\n    /**\n     * Manually set this user's display name. No event is emitted in response to this\n     * as there is no underlying MatrixEvent to emit with.\n     * @param name - The new display name.\n     */\n    public setDisplayName(name: string): void {\n        const oldName = this.displayName;\n        this.displayName = name;\n        if (name !== oldName) {\n            this.updateModifiedTime();\n        }\n    }\n\n    /**\n     * Manually set this user's non-disambiguated display name. No event is emitted\n     * in response to this as there is no underlying MatrixEvent to emit with.\n     * @param name - The new display name.\n     */\n    public setRawDisplayName(name?: string): void {\n        this.rawDisplayName = name;\n    }\n\n    /**\n     * Manually set this user's avatar URL. No event is emitted in response to this\n     * as there is no underlying MatrixEvent to emit with.\n     * @param url - The new avatar URL.\n     */\n    public setAvatarUrl(url?: string): void {\n        const oldUrl = this.avatarUrl;\n        this.avatarUrl = url;\n        if (url !== oldUrl) {\n            this.updateModifiedTime();\n        }\n    }\n\n    /**\n     * Update the last modified time to the current time.\n     */\n    private updateModifiedTime(): void {\n        this.modified = Date.now();\n    }\n\n    /**\n     * Get the timestamp when this User was last updated. This timestamp is\n     * updated when this User receives a new Presence event which has updated a\n     * property on this object. It is updated <i>before</i> firing events.\n     * @returns The timestamp\n     */\n    public getLastModifiedTime(): number {\n        return this.modified;\n    }\n\n    /**\n     * Get the absolute timestamp when this User was last known active on the server.\n     * It is *NOT* accurate if this.currentlyActive is true.\n     * @returns The timestamp\n     */\n    public getLastActiveTs(): number {\n        return this.lastPresenceTs - this.lastActiveAgo;\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type OidcClientConfig } from \"./index.ts\";\nimport { OidcError } from \"./error.ts\";\nimport { Method } from \"../http-api/index.ts\";\nimport { logger } from \"../logger.ts\";\nimport { type NonEmptyArray } from \"../@types/common.ts\";\n\n/**\n * Client metadata passed to registration endpoint\n */\nexport type OidcRegistrationClientMetadata = {\n    clientName: OidcRegistrationRequestBody[\"client_name\"];\n    clientUri: OidcRegistrationRequestBody[\"client_uri\"];\n    logoUri?: OidcRegistrationRequestBody[\"logo_uri\"];\n    applicationType: OidcRegistrationRequestBody[\"application_type\"];\n    redirectUris: OidcRegistrationRequestBody[\"redirect_uris\"];\n    contacts: OidcRegistrationRequestBody[\"contacts\"];\n    tosUri: OidcRegistrationRequestBody[\"tos_uri\"];\n    policyUri: OidcRegistrationRequestBody[\"policy_uri\"];\n};\n\n/**\n * Request body for dynamic registration as defined by https://github.com/matrix-org/matrix-spec-proposals/pull/2966\n */\ninterface OidcRegistrationRequestBody {\n    client_name?: string;\n    client_uri: string;\n    logo_uri?: string;\n    contacts?: string[];\n    tos_uri?: string;\n    policy_uri?: string;\n    redirect_uris?: NonEmptyArray<string>;\n    response_types?: NonEmptyArray<string>;\n    grant_types?: NonEmptyArray<string>;\n    id_token_signed_response_alg?: string;\n    token_endpoint_auth_method: string;\n    application_type: \"web\" | \"native\";\n}\n\n/**\n * The OAuth 2.0 grant types that are defined for Matrix in https://spec.matrix.org/v1.17/client-server-api/#grant-types\n */\nexport enum OAuthGrantType {\n    /**\n     * See https://spec.matrix.org/v1.17/client-server-api/#authorization-code-grant\n     */\n    AuthorizationCode = \"authorization_code\",\n    /**\n     * https://spec.matrix.org/v1.17/client-server-api/#refresh-token-grant\n     */\n    RefreshToken = \"refresh_token\",\n    /**\n     * The OAuth 2.0 Device Authorization Grant type identifier as per\n     * https://www.rfc-editor.org/rfc/rfc8628.html#section-7.2 from\n     * [MSC4341](https://github.com/matrix-org/matrix-spec-proposals/pull/4341).\n     *\n     * @experimental Note that this is UNSTABLE and may have breaking changes without notice.\n     */\n    DeviceAuthorization = \"urn:ietf:params:oauth:grant-type:device_code\",\n}\n\n/**\n * The name \"scope\" is a misnomer here as it is actually a \"grant type\".\n *\n * @deprecated use `OAuthGrantType.DeviceAuthorization` instead\n */\nexport const DEVICE_CODE_SCOPE: string = OAuthGrantType.DeviceAuthorization;\n\n// Check that URIs have a common base, as per the MSC2966 definition\nconst urlHasCommonBase = (base: URL, urlStr?: string): boolean => {\n    if (!urlStr) return false;\n    const url = new URL(urlStr);\n    if (url.protocol !== base.protocol) return false;\n    if (url.hostname !== base.hostname && !url.hostname.endsWith(`.${base.hostname}`)) return false;\n    return true;\n};\n\n/**\n * Attempts dynamic registration against the configured registration endpoint.\n * Will ignore any URIs that do not use client_uri as a common base as per the spec.\n * @param delegatedAuthConfig - Auth config from {@link discoverAndValidateOIDCIssuerWellKnown}\n * @param clientMetadata - The metadata for the client which to register\n * @returns Promise<string> resolved with registered clientId\n * @throws when registration is not supported, on failed request or invalid response\n */\nexport const registerOidcClient = async (\n    delegatedAuthConfig: OidcClientConfig,\n    clientMetadata: OidcRegistrationClientMetadata,\n): Promise<string> => {\n    if (!delegatedAuthConfig.registration_endpoint) {\n        throw new Error(OidcError.DynamicRegistrationNotSupported);\n    }\n\n    const grantTypes: NonEmptyArray<string> = [OAuthGrantType.AuthorizationCode, OAuthGrantType.RefreshToken];\n    if (grantTypes.some((scope) => !delegatedAuthConfig.grant_types_supported.includes(scope))) {\n        throw new Error(OidcError.DynamicRegistrationNotSupported);\n    }\n\n    const commonBase = new URL(clientMetadata.clientUri);\n\n    // https://openid.net/specs/openid-connect-registration-1_0.html\n    const metadata: OidcRegistrationRequestBody = {\n        client_name: clientMetadata.clientName,\n        client_uri: clientMetadata.clientUri,\n        response_types: [\"code\"],\n        grant_types: grantTypes,\n        redirect_uris: clientMetadata.redirectUris,\n        id_token_signed_response_alg: \"RS256\",\n        token_endpoint_auth_method: \"none\",\n        application_type: clientMetadata.applicationType,\n        contacts: clientMetadata.contacts,\n        logo_uri: urlHasCommonBase(commonBase, clientMetadata.logoUri) ? clientMetadata.logoUri : undefined,\n        policy_uri: urlHasCommonBase(commonBase, clientMetadata.policyUri) ? clientMetadata.policyUri : undefined,\n        tos_uri: urlHasCommonBase(commonBase, clientMetadata.tosUri) ? clientMetadata.tosUri : undefined,\n    };\n\n    const headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n    };\n\n    try {\n        const response = await fetch(delegatedAuthConfig.registration_endpoint, {\n            method: Method.Post,\n            headers,\n            body: JSON.stringify(metadata),\n        });\n\n        if (response.status >= 400) {\n            throw new Error(OidcError.DynamicRegistrationFailed);\n        }\n\n        const body = await response.json();\n        const clientId = body[\"client_id\"];\n        if (!clientId || typeof clientId !== \"string\") {\n            throw new Error(OidcError.DynamicRegistrationInvalid);\n        }\n\n        return clientId;\n    } catch (error) {\n        if (Object.values(OidcError).includes((error as Error).message as OidcError)) {\n            throw error;\n        } else {\n            logger.error(\"Dynamic registration request failed\", error);\n            throw new Error(OidcError.DynamicRegistrationFailed);\n        }\n    }\n};\n","export class InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nexport function jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { jwtDecode } from \"jwt-decode\";\nimport { type IdTokenClaims, type OidcMetadata, type SigninResponse } from \"oidc-client-ts\";\n\nimport { logger } from \"../logger.ts\";\nimport { OidcError } from \"./error.ts\";\nimport { OAuthGrantType } from \"./index.ts\";\n\n/**\n * Metadata from OAuth 2.0 client authentication API as per\n * https://spec.matrix.org/v1.17/client-server-api/#get_matrixclientv1auth_metadata\n * With validated properties required in type\n */\nexport type ValidatedAuthMetadata = Partial<OidcMetadata> &\n    Pick<\n        // These values are from [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414#section-2)\n        // so we can reuse the OidcMetadata definitions from oidc-client-ts\n        OidcMetadata,\n        | \"issuer\"\n        | \"authorization_endpoint\"\n        | \"token_endpoint\"\n        | \"revocation_endpoint\"\n        | \"response_types_supported\"\n        | \"grant_types_supported\"\n        | \"code_challenge_methods_supported\"\n    > & {\n        // These values aren't part of RFC8414 so we add them here\n        // Account management fields from stable MSC4191:\n        account_management_uri?: string;\n        account_management_actions_supported?: string[];\n        // Value from [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html):\n        prompt_values_supported?: string[];\n        // Experimental MSC4341 value from [RFC8628](https://datatracker.ietf.org/doc/html/rfc8628#section-4):\n        device_authorization_endpoint?: string;\n    };\n\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\n    !!value && typeof value === \"object\" && !Array.isArray(value);\nconst requiredStringProperty = (wellKnown: Record<string, unknown>, key: string): boolean => {\n    if (!wellKnown[key] || !optionalStringProperty(wellKnown, key)) {\n        logger.error(`Missing or invalid property: ${key}`);\n        return false;\n    }\n    return true;\n};\nconst optionalStringProperty = (wellKnown: Record<string, unknown>, key: string): boolean => {\n    if (!!wellKnown[key] && typeof wellKnown[key] !== \"string\") {\n        logger.error(`Invalid property: ${key}`);\n        return false;\n    }\n    return true;\n};\nconst optionalStringArrayProperty = (wellKnown: Record<string, unknown>, key: string): boolean => {\n    if (\n        !!wellKnown[key] &&\n        (!Array.isArray(wellKnown[key]) || !(<unknown[]>wellKnown[key]).every((v) => typeof v === \"string\"))\n    ) {\n        logger.error(`Invalid property: ${key}`);\n        return false;\n    }\n    return true;\n};\nconst requiredArrayValue = (wellKnown: Record<string, unknown>, key: string, value: any): boolean => {\n    const array = wellKnown[key];\n    if (!array || !Array.isArray(array) || !array.includes(value)) {\n        logger.error(`Invalid property: ${key}. ${value} is required.`);\n        return false;\n    }\n    return true;\n};\n\n/**\n * Validates OAuth 2.0 auth metadata as defined by\n * https://spec.matrix.org/v1.17/client-server-api/#get_matrixclientv1auth_metadata\n * is compatible with Element's OAuth/OIDC flow\n * @param authMetadata - json object\n * @returns valid issuer config\n * @throws Error - when issuer config is not found or is invalid\n */\nexport const validateAuthMetadata = (authMetadata: unknown): ValidatedAuthMetadata => {\n    if (!isRecord(authMetadata)) {\n        logger.error(\"Issuer configuration not found or malformed\");\n        throw new Error(OidcError.OpSupport);\n    }\n\n    const isInvalid = [\n        requiredStringProperty(authMetadata, \"issuer\"),\n        requiredStringProperty(authMetadata, \"authorization_endpoint\"),\n        requiredStringProperty(authMetadata, \"token_endpoint\"),\n        requiredStringProperty(authMetadata, \"revocation_endpoint\"),\n        optionalStringProperty(authMetadata, \"registration_endpoint\"),\n        optionalStringProperty(authMetadata, \"account_management_uri\"),\n        optionalStringProperty(authMetadata, \"device_authorization_endpoint\"),\n        optionalStringArrayProperty(authMetadata, \"account_management_actions_supported\"),\n        requiredArrayValue(authMetadata, \"response_types_supported\", \"code\"),\n        requiredArrayValue(authMetadata, \"grant_types_supported\", OAuthGrantType.AuthorizationCode),\n        requiredArrayValue(authMetadata, \"code_challenge_methods_supported\", \"S256\"),\n        optionalStringArrayProperty(authMetadata, \"prompt_values_supported\"),\n    ].some((isValid) => !isValid);\n\n    if (!isInvalid) {\n        return authMetadata as ValidatedAuthMetadata;\n    }\n\n    logger.error(\"Issuer configuration not valid\");\n    throw new Error(OidcError.OpSupport);\n};\n\nexport const decodeIdToken = (token: string): IdTokenClaims => {\n    try {\n        return jwtDecode<IdTokenClaims>(token);\n    } catch (error) {\n        logger.error(\"Could not decode id_token\", error);\n        throw error;\n    }\n};\n\n/**\n * Validate idToken\n * https://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n * @param idToken - id token from token endpoint\n * @param issuer - issuer for the OP as found during discovery\n * @param clientId - this client's id as registered with the OP\n * @param nonce - nonce used in the authentication request\n * @throws when id token is invalid\n */\nexport const validateIdToken = (\n    idToken: string | undefined,\n    issuer: string,\n    clientId: string,\n    nonce: string | undefined,\n): void => {\n    try {\n        if (!idToken) {\n            throw new Error(\"No ID token\");\n        }\n        const claims = decodeIdToken(idToken);\n\n        // The Issuer Identifier for the OpenID Provider MUST exactly match the value of the iss (issuer) Claim.\n        if (claims.iss !== issuer) {\n            throw new Error(\"Invalid issuer\");\n        }\n        /**\n         * The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified by the iss (issuer) Claim as an audience.\n         * The aud (audience) Claim MAY contain an array with more than one element.\n         * The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences not trusted by the Client.\n         * EW: Don't accept tokens with other untrusted audiences\n         * */\n        const sanitisedAuds = typeof claims.aud === \"string\" ? [claims.aud] : claims.aud;\n        if (!sanitisedAuds.includes(clientId)) {\n            throw new Error(\"Invalid audience\");\n        }\n\n        /**\n         * If a nonce value was sent in the Authentication Request, a nonce Claim MUST be present and its value checked\n         * to verify that it is the same value as the one that was sent in the Authentication Request.\n         */\n        if (nonce !== undefined && claims.nonce !== nonce) {\n            throw new Error(\"Invalid nonce\");\n        }\n\n        /**\n         * The current time MUST be before the time represented by the exp Claim.\n         *  exp is an epoch timestamp in seconds\n         * */\n        if (!claims.exp || Date.now() > claims.exp * 1000) {\n            throw new Error(\"Invalid expiry\");\n        }\n    } catch (error) {\n        logger.error(\"Invalid ID token\", error);\n        throw new Error(OidcError.InvalidIdToken);\n    }\n};\n\n/**\n * State we ask OidcClient to store when starting oidc authorization flow (in `generateOidcAuthorizationUrl`)\n * so that we can access it on return from the OP and complete login\n */\nexport type UserState = {\n    /**\n     * Remember which server we were trying to login to\n     */\n    homeserverUrl: string;\n    identityServerUrl?: string;\n    /**\n     * Used to validate id token\n     */\n    nonce: string;\n};\n/**\n * Validate stored user state exists and is valid\n * @param userState - userState returned by oidcClient.processSigninResponse\n * @throws when userState is invalid\n */\nexport function validateStoredUserState(userState: unknown): asserts userState is UserState {\n    if (!isRecord(userState)) {\n        logger.error(\"Stored user state not found\");\n        throw new Error(OidcError.MissingOrInvalidStoredState);\n    }\n    const isInvalid = [\n        requiredStringProperty(userState, \"homeserverUrl\"),\n        requiredStringProperty(userState, \"nonce\"),\n        optionalStringProperty(userState, \"identityServerUrl\"),\n    ].some((isValid) => !isValid);\n\n    if (isInvalid) {\n        throw new Error(OidcError.MissingOrInvalidStoredState);\n    }\n}\n\n/**\n * The expected response type from the token endpoint during authorization code flow\n * Normalized to always use capitalized 'Bearer' for token_type\n *\n * See https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.4,\n * https://openid.net/specs/openid-connect-basic-1_0.html#TokenOK.\n */\nexport type BearerTokenResponse = {\n    token_type: \"Bearer\";\n    access_token: string;\n    scope: string;\n    refresh_token?: string;\n    expires_in?: number;\n    // from oidc-client-ts\n    expires_at?: number;\n    id_token: string;\n};\n\n/**\n * Make required properties required in type\n */\ntype ValidSignInResponse = SigninResponse &\n    BearerTokenResponse & {\n        token_type: \"Bearer\" | \"bearer\";\n    };\n\nconst isValidBearerTokenResponse = (response: unknown): response is ValidSignInResponse =>\n    isRecord(response) &&\n    requiredStringProperty(response, \"token_type\") &&\n    // token_type is case insensitive, some OPs return `token_type: \"bearer\"`\n    (response[\"token_type\"] as string).toLowerCase() === \"bearer\" &&\n    requiredStringProperty(response, \"access_token\") &&\n    requiredStringProperty(response, \"refresh_token\") &&\n    (!(\"expires_in\" in response) || typeof response[\"expires_in\"] === \"number\");\n\nexport function validateBearerTokenResponse(response: unknown): asserts response is ValidSignInResponse {\n    if (!isValidBearerTokenResponse(response)) {\n        throw new Error(OidcError.InvalidBearerTokenResponse);\n    }\n}\n","/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { encodeUnpaddedBase64Url } from \"./base64.ts\";\n\n/**\n * String representing the lowercase latin alphabet for use in {@link secureRandomStringFrom}\n * (can be combined with other such exports or other characters by appending strings)\n */\nexport const LOWERCASE = \"abcdefghijklmnopqrstuvwxyz\";\n\n/**\n * String representing the uppercase latin alphabet for use in secureRandomStringFrom\n * (can be combined with other such exports or other characters by appending strings)\n */\nexport const UPPERCASE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n/**\n * String representing the arabic numerals for use in secureRandomStringFrom\n * (can be combined with other such exports or other characters by appending strings)\n */\nexport const DIGITS = \"0123456789\";\n\nexport function secureRandomBase64Url(len: number): string {\n    const key = new Uint8Array(len);\n    globalThis.crypto.getRandomValues(key);\n\n    return encodeUnpaddedBase64Url(key);\n}\n\n/**\n * Generates a random string of uppercase and lowercase letters plus digits using a\n * cryptographically secure random number generator.\n * @param len The length of the string to generate\n * @returns Random string of uppercase and lowercase letters plus digits of length `len`\n */\nexport function secureRandomString(len: number): string {\n    return secureRandomStringFrom(len, UPPERCASE + LOWERCASE + DIGITS);\n}\n\n/**\n * Generate a cryptographically secure random string using characters given.\n *\n * @param len - The length of the string to generate (must be positive and less than 32768).\n * @param chars - The characters to use in the random string (between 2 and 256 characters long).\n * @returns Random string of characters of length `len`.\n */\nexport function secureRandomStringFrom(len: number, chars: string): string {\n    // This is intended for latin strings so 256 possibilities should be more than enough and\n    // means we can use random bytes, minimising the amount of entropy we need to ask for.\n    if (chars.length < 2 || chars.length > 256) {\n        throw new Error(\"Character set must be between 2 and 256 characters long\");\n    }\n\n    if (len < 1 || len > 32768) {\n        throw new Error(\"Requested random string length must be between 1 and 32768\");\n    }\n\n    // We'll generate random unsigned bytes, so get the largest number less than 256 that is a multiple\n    // of the length of the character set: We'll need to discard any random values that are larger than\n    // this as we can't possibly map them onto the character set while keeping each character equally\n    // likely to be chosen (minus 1 to convert to indices in a string). (Essentially, we're using a d8\n    // to choose between 7 possibilities and re-rolling on an 8, keeping all 7 outcomes equally likely.)\n    // Our random values must be strictly less than this\n    const randomValueCutoff = 256 - (256 % chars.length);\n\n    // Grab 30% more entropy than we need. This should be enough that we can discard the values that are\n    // too high without having to go back and grab more unless we're super unlucky.\n    const entropyBuffer = new Uint8Array(Math.floor(len * 1.3));\n    // Mark all of this buffer as used to start with (we haven't populated it with entropy yet) so it will\n    // be filled on the first iteration.\n    let entropyBufferPos = entropyBuffer.length;\n\n    const result = [];\n    while (result.length < len) {\n        if (entropyBufferPos === entropyBuffer.length) {\n            globalThis.crypto.getRandomValues(entropyBuffer);\n            entropyBufferPos = 0;\n        }\n\n        const randomByte = entropyBuffer[entropyBufferPos++];\n\n        if (randomByte < randomValueCutoff) {\n            result.push(chars[randomByte % chars.length]);\n        }\n    }\n\n    return result.join(\"\");\n}\n","/*\nCopyright 2021-2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Implementation of server-side secret storage\n *\n * @see https://spec.matrix.org/v1.6/client-server-api/#storage\n */\n\nimport { type TypedEventEmitter } from \"./models/typed-event-emitter.ts\";\nimport { ClientEvent, type ClientEventHandlerMap } from \"./client.ts\";\nimport { type MatrixEvent } from \"./models/event.ts\";\nimport { secureRandomString } from \"./randomstring.ts\";\nimport { logger } from \"./logger.ts\";\nimport encryptAESSecretStorageItem from \"./utils/encryptAESSecretStorageItem.ts\";\nimport decryptAESSecretStorageItem from \"./utils/decryptAESSecretStorageItem.ts\";\nimport { type AESEncryptedSecretStoragePayload } from \"./@types/AESEncryptedSecretStoragePayload.ts\";\nimport { type AccountDataEvents, type SecretStorageAccountDataEvents } from \"./@types/event.ts\";\nimport { type EmptyObject } from \"./@types/common.ts\";\n\nexport const SECRET_STORAGE_ALGORITHM_V1_AES = \"m.secret_storage.v1.aes-hmac-sha2\";\n\n/**\n * Common base interface for Secret Storage Keys.\n *\n * The common properties for all encryption keys used in server-side secret storage.\n *\n * @see https://spec.matrix.org/v1.6/client-server-api/#key-storage\n */\nexport interface SecretStorageKeyDescriptionCommon {\n    /** A human-readable name for this key. */\n    // XXX: according to the spec, this is optional\n    name: string;\n\n    /** The encryption algorithm used with this key. */\n    algorithm: string;\n\n    /** Information for deriving this key from a passphrase. */\n    // XXX: according to the spec, this is optional\n    passphrase: PassphraseInfo;\n}\n\n/**\n * Properties for a SSSS key using the `m.secret_storage.v1.aes-hmac-sha2` algorithm.\n *\n * Corresponds to `AesHmacSha2KeyDescription` in the specification.\n *\n * @see https://spec.matrix.org/v1.6/client-server-api/#msecret_storagev1aes-hmac-sha2\n */\nexport interface SecretStorageKeyDescriptionAesV1 extends SecretStorageKeyDescriptionCommon {\n    // XXX: strictly speaking, we should be able to enforce the algorithm here. But\n    //   this interface ends up being incorrectly used where other algorithms are in use (notably\n    //   in device-dehydration support), and unpicking that is too much like hard work\n    //   at the moment.\n    // algorithm: \"m.secret_storage.v1.aes-hmac-sha2\";\n\n    /** The 16-byte AES initialization vector, encoded as base64. */\n    iv: string;\n\n    /** The MAC of the result of encrypting 32 bytes of 0, encoded as base64. */\n    mac: string;\n}\n\n/**\n * Union type for secret storage keys.\n *\n * For now, this is only {@link SecretStorageKeyDescriptionAesV1}, but other interfaces may be added in future.\n */\nexport type SecretStorageKeyDescription = SecretStorageKeyDescriptionAesV1;\n\n/**\n * Information on how to generate the key from a passphrase.\n *\n * @see https://spec.matrix.org/v1.6/client-server-api/#deriving-keys-from-passphrases\n */\nexport interface PassphraseInfo {\n    /** The algorithm to be used to derive the key. */\n    algorithm: \"m.pbkdf2\";\n\n    /** The number of PBKDF2 iterations to use. */\n    iterations: number;\n\n    /** The salt to be used for PBKDF2. */\n    salt: string;\n\n    /** The number of bits to generate. Defaults to 256. */\n    bits?: number;\n}\n\n/**\n * Options for {@link ServerSideSecretStorageImpl#addKey}.\n */\nexport interface AddSecretStorageKeyOpts {\n    /** Information for deriving the key from a passphrase if any. */\n    passphrase?: PassphraseInfo;\n    /** Optional name of the key. */\n    name?: string;\n    /** The private key. Will be used to generate the key check values in the key info; it will not be stored on the server */\n    key: Uint8Array<ArrayBuffer>;\n}\n\n/**\n * Return type for {@link ServerSideSecretStorageImpl#getKey}.\n */\nexport type SecretStorageKeyTuple = [keyId: string, keyInfo: SecretStorageKeyDescription];\n\n/**\n * Return type for {@link ServerSideSecretStorageImpl#addKey}.\n */\nexport type SecretStorageKeyObject = {\n    /** The ID of the key */\n    keyId: string;\n    /**  details about the key */\n    keyInfo: SecretStorageKeyDescription;\n};\n\n/** Interface for managing account data on the server.\n *\n * A subset of {@link MatrixClient}.\n */\nexport interface AccountDataClient extends TypedEventEmitter<ClientEvent.AccountData, ClientEventHandlerMap> {\n    /**\n     * Get account data event of given type for the current user. This variant\n     * gets account data directly from the homeserver if the local store is not\n     * ready, which can be useful very early in startup before the initial sync.\n     *\n     * @param eventType - The type of account data\n     * @returns The contents of the given account data event, or `null` if the event is not found\n     */\n    getAccountDataFromServer: <K extends keyof AccountDataEvents>(eventType: K) => Promise<AccountDataEvents[K] | null>;\n\n    /**\n     * Set account data event for the current user, with retries\n     *\n     * @param eventType - The type of account data\n     * @param content - the content object to be set\n     * @returns an empty object\n     */\n    setAccountData: <K extends keyof AccountDataEvents>(\n        eventType: K,\n        content: AccountDataEvents[K] | Record<string, never>,\n    ) => Promise<EmptyObject>;\n}\n\n/**\n *  Application callbacks for use with {@link SecretStorage.ServerSideSecretStorageImpl}\n */\nexport interface SecretStorageCallbacks {\n    /**\n     * Called to retrieve a secret storage encryption key\n     *\n     * Before a secret can be stored in server-side storage, it must be encrypted with one or more\n     * keys. Similarly, after it has been retrieved from storage, it must be decrypted with one of\n     * the keys it was encrypted with. These encryption keys are known as \"secret storage keys\".\n     *\n     * Descriptions of the secret storage keys are also stored in server-side storage, per the\n     * [matrix specification](https://spec.matrix.org/v1.6/client-server-api/#key-storage), so\n     * before a key can be used in this way, it must have been stored on the server. This is\n     * done via {@link ServerSideSecretStorage#addKey}.\n     *\n     * Obviously the keys themselves are not stored server-side, so the js-sdk calls this callback\n     * in order to retrieve a secret storage key from the application.\n     *\n     * @param keys - An options object, containing only the property `keys`.\n     *\n     * @param name - the name of the *secret* (NB: not the encryption key) being stored or retrieved.\n     *    This is the \"event type\" stored in account data.\n     *\n     * @returns a pair [`keyId`, `privateKey`], where `keyId` is one of the keys from the `keys` parameter,\n     *    and `privateKey` is the raw private encryption key, as appropriate for the encryption algorithm.\n     *    (For `m.secret_storage.v1.aes-hmac-sha2`, it is the input to an HKDF as defined in the\n     *    [specification](https://spec.matrix.org/v1.6/client-server-api/#msecret_storagev1aes-hmac-sha2).)\n     *\n     *    Alternatively, if none of the keys are known, may return `null`  in which case the original\n     *    storage/retrieval operation will fail with an exception.\n     */\n    getSecretStorageKey?: (\n        keys: {\n            /**\n             * details of the secret storage keys required: a map from the key ID\n             * (excluding the `m.secret_storage.key.` prefix) to details of the key.\n             *\n             * When storing a secret, `keys` will contain exactly one entry; this method will be called\n             * once for each secret storage key to be used for encryption.\n             *\n             * For secret retrieval, `keys` may contain several entries, and the application can return\n             * any one of the requested keys.\n             */\n            keys: Record<string, SecretStorageKeyDescription>;\n        },\n        name: string,\n    ) => Promise<[string, Uint8Array<ArrayBuffer>] | null>;\n}\n\n/**\n * Account Data event types which can store secret-storage-encrypted information.\n */\nexport type SecretStorageKey = keyof SecretStorageAccountDataEvents;\n\n/**\n * Account Data event content type for storing secret-storage-encrypted information.\n *\n * See https://spec.matrix.org/v1.13/client-server-api/#msecret_storagev1aes-hmac-sha2-1\n */\nexport interface SecretInfo {\n    encrypted: {\n        [keyId: string]: AESEncryptedSecretStoragePayload;\n    };\n}\n\ninterface Decryptors {\n    encrypt: (plaintext: string) => Promise<AESEncryptedSecretStoragePayload>;\n    decrypt: (ciphertext: AESEncryptedSecretStoragePayload) => Promise<string>;\n}\n\n/**\n * Interface provided by SecretStorage implementations\n *\n * Normally this will just be an {@link ServerSideSecretStorageImpl}, but for backwards\n * compatibility some methods allow other implementations.\n */\nexport interface ServerSideSecretStorage {\n    /**\n     * Add a key for encrypting secrets.\n     *\n     * @param algorithm - the algorithm used by the key.\n     * @param opts - the options for the algorithm.  The properties used\n     *     depend on the algorithm given.\n     * @param keyId - the ID of the key.  If not given, a random\n     *     ID will be generated.\n     *\n     * @returns details about the key.\n     */\n    addKey(algorithm: string, opts: AddSecretStorageKeyOpts, keyId?: string): Promise<SecretStorageKeyObject>;\n\n    /**\n     * Get the key information for a given ID.\n     *\n     * @param keyId - The ID of the key to check\n     *     for. Defaults to the default key ID if not provided.\n     * @returns If the key was found, the return value is an array of\n     *     the form [keyId, keyInfo].  Otherwise, null is returned.\n     *     XXX: why is this an array when addKey returns an object?\n     */\n    getKey(keyId?: string | null): Promise<SecretStorageKeyTuple | null>;\n\n    /**\n     * Check whether we have a key with a given ID.\n     *\n     * @param keyId - The ID of the key to check\n     *     for. Defaults to the default key ID if not provided.\n     * @returns Whether we have the key.\n     */\n    hasKey(keyId?: string): Promise<boolean>;\n\n    /**\n     * Check whether a key matches what we expect based on the key info\n     *\n     * @param key - the key to check\n     * @param info - the key info\n     *\n     * @returns whether or not the key matches\n     */\n    checkKey(key: Uint8Array, info: SecretStorageKeyDescriptionAesV1): Promise<boolean>;\n\n    /**\n     * Store an encrypted secret on the server.\n     *\n     * Details of the encryption keys to be used must previously have been stored in account data\n     * (for example, via {@link ServerSideSecretStorageImpl#addKey}. {@link SecretStorageCallbacks#getSecretStorageKey} will be called to obtain a secret storage\n     * key to decrypt the secret.\n     *\n     * If the secret is `null`, the secret value in the account data will be set to an empty object.\n     * This is considered as \"removing\" the secret.\n     *\n     * @param name - The name of the secret - i.e., the \"event type\" to be stored in the account data\n     * @param secret - The secret contents.\n     * @param keys - The IDs of the keys to use to encrypt the secret, or null/undefined to use the default key\n     *     (will throw if no default key is set).\n     */\n    store(name: string, secret: string | null, keys?: string[] | null): Promise<void>;\n\n    /**\n     * Get a secret from storage, and decrypt it.\n     *\n     * @param name - the name of the secret - i.e., the \"event type\" stored in the account data\n     *\n     * @returns the decrypted contents of the secret, or \"undefined\" if `name` is not found in\n     *    the user's account data.\n     */\n    get(name: string): Promise<string | undefined>;\n\n    /**\n     * Check if a secret is stored on the server.\n     *\n     * @param name - the name of the secret\n     *\n     * @returns map of key name to key info the secret is encrypted\n     *     with, or null if it is not present or not encrypted with a trusted\n     *     key\n     */\n    isStored(name: SecretStorageKey): Promise<Record<string, SecretStorageKeyDescriptionAesV1> | null>;\n\n    /**\n     * Get the current default key ID for encrypting secrets.\n     *\n     * @returns The default key ID or null if no default key ID is set\n     */\n    getDefaultKeyId(): Promise<string | null>;\n\n    /**\n     * Set the default key ID for encrypting secrets.\n     *\n     * If keyId is `null`, the default key id value in the account data will be set to an empty object.\n     * This is considered as \"disabling\" the default key.\n     *\n     * @param keyId - The new default key ID\n     */\n    setDefaultKeyId(keyId: string | null): Promise<void>;\n}\n\n/**\n * Implementation of Server-side secret storage.\n *\n * Secret *sharing* is *not* implemented here: this class is strictly about the storage component of\n * SSSS.\n *\n * @see https://spec.matrix.org/v1.6/client-server-api/#storage\n */\nexport class ServerSideSecretStorageImpl implements ServerSideSecretStorage {\n    /**\n     * Construct a new `SecretStorage`.\n     *\n     * Normally, it is unnecessary to call this directly, since MatrixClient automatically constructs one.\n     * However, it may be useful to construct a new `SecretStorage`, if custom `callbacks` are required, for example.\n     *\n     * @param accountDataAdapter - interface for fetching and setting account data on the server. Normally an instance\n     *   of {@link MatrixClient}.\n     * @param callbacks - application level callbacks for retrieving secret keys\n     */\n    public constructor(\n        private readonly accountDataAdapter: AccountDataClient,\n        private readonly callbacks: SecretStorageCallbacks,\n    ) {}\n\n    /**\n     * Get the current default key ID for encrypting secrets.\n     *\n     * @returns The default key ID or null if no default key ID is set\n     */\n    public async getDefaultKeyId(): Promise<string | null> {\n        const defaultKey = await this.accountDataAdapter.getAccountDataFromServer(\"m.secret_storage.default_key\");\n        if (!defaultKey) return null;\n        return defaultKey.key ?? null;\n    }\n\n    /**\n     * Implementation of {@link ServerSideSecretStorage#setDefaultKeyId}.\n     */\n    public setDefaultKeyId(keyId: string | null): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            const listener = (ev: MatrixEvent): void => {\n                if (ev.getType() !== \"m.secret_storage.default_key\") {\n                    //  Different account data item\n                    return;\n                }\n\n                // If keyId === null, the content should be an empty object.\n                // Otherwise, the `key` in the content object should match keyId.\n                const content = ev.getContent();\n                const isSameKey = keyId === null ? Object.keys(content).length === 0 : content.key === keyId;\n                if (isSameKey) {\n                    this.accountDataAdapter.removeListener(ClientEvent.AccountData, listener);\n                    resolve();\n                }\n            };\n            this.accountDataAdapter.on(ClientEvent.AccountData, listener);\n\n            // The spec [1] says that the value of the account data entry should be an object with a `key` property.\n            // It doesn't specify how to delete the default key; we do it by setting the account data to an empty object.\n            //\n            // [1]: https://spec.matrix.org/v1.13/client-server-api/#key-storage\n            const newValue: Record<string, never> | { key: string } = keyId === null ? {} : { key: keyId };\n            this.accountDataAdapter.setAccountData(\"m.secret_storage.default_key\", newValue).catch((e) => {\n                this.accountDataAdapter.removeListener(ClientEvent.AccountData, listener);\n                reject(e);\n            });\n        });\n    }\n\n    /**\n     * Add a key for encrypting secrets.\n     *\n     * @param algorithm - the algorithm used by the key.\n     * @param opts - the options for the algorithm.  The properties used\n     *     depend on the algorithm given.\n     * @param keyId - the ID of the key.  If not given, a random\n     *     ID will be generated.\n     *\n     * @returns An object with:\n     *     keyId: the ID of the key\n     *     keyInfo: details about the key (iv, mac, passphrase)\n     */\n    public async addKey(\n        algorithm: string,\n        opts: AddSecretStorageKeyOpts,\n        keyId?: string,\n    ): Promise<SecretStorageKeyObject> {\n        if (algorithm !== SECRET_STORAGE_ALGORITHM_V1_AES) {\n            throw new Error(`Unknown key algorithm ${algorithm}`);\n        }\n\n        const keyInfo = { algorithm } as SecretStorageKeyDescriptionAesV1;\n\n        if (opts.name) {\n            keyInfo.name = opts.name;\n        }\n\n        if (opts.passphrase) {\n            keyInfo.passphrase = opts.passphrase;\n        }\n\n        const { iv, mac } = await calculateKeyCheck(opts.key);\n        keyInfo.iv = iv;\n        keyInfo.mac = mac;\n\n        // Create a unique key id. XXX: this is racey.\n        if (!keyId) {\n            do {\n                keyId = secureRandomString(32);\n            } while (await this.accountDataAdapter.getAccountDataFromServer(`m.secret_storage.key.${keyId}`));\n        }\n\n        await this.accountDataAdapter.setAccountData(`m.secret_storage.key.${keyId}`, keyInfo);\n\n        return {\n            keyId,\n            keyInfo,\n        };\n    }\n\n    /**\n     * Get the key information for a given ID.\n     *\n     * @param keyId - The ID of the key to check\n     *     for. Defaults to the default key ID if not provided.\n     * @returns If the key was found, the return value is an array of\n     *     the form [keyId, keyInfo].  Otherwise, null is returned.\n     *     XXX: why is this an array when addKey returns an object?\n     */\n    public async getKey(keyId?: string | null): Promise<SecretStorageKeyTuple | null> {\n        if (!keyId) {\n            keyId = await this.getDefaultKeyId();\n        }\n        if (!keyId) {\n            return null;\n        }\n\n        const keyInfo = await this.accountDataAdapter.getAccountDataFromServer(`m.secret_storage.key.${keyId}`);\n        return keyInfo ? [keyId, keyInfo] : null;\n    }\n\n    /**\n     * Check whether we have a key with a given ID.\n     *\n     * @param keyId - The ID of the key to check\n     *     for. Defaults to the default key ID if not provided.\n     * @returns Whether we have the key.\n     */\n    public async hasKey(keyId?: string): Promise<boolean> {\n        const key = await this.getKey(keyId);\n        return Boolean(key);\n    }\n\n    /**\n     * Check whether a key matches what we expect based on the key info\n     *\n     * @param key - the key to check\n     * @param info - the key info\n     *\n     * @returns whether or not the key matches\n     */\n    public async checkKey(key: Uint8Array<ArrayBuffer>, info: SecretStorageKeyDescriptionAesV1): Promise<boolean> {\n        if (info.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n            if (info.mac) {\n                const { mac } = await calculateKeyCheck(key, info.iv);\n                return trimTrailingEquals(info.mac) === trimTrailingEquals(mac);\n            } else {\n                // if we have no information, we have to assume the key is right\n                return true;\n            }\n        } else {\n            throw new Error(\"Unknown algorithm\");\n        }\n    }\n\n    /**\n     * Implementation of {@link ServerSideSecretStorage#store}.\n     */\n    public async store(name: SecretStorageKey, secret: string | null, keys?: string[] | null): Promise<void> {\n        if (secret === null) {\n            // remove secret\n            await this.accountDataAdapter.setAccountData(name, {});\n            return;\n        }\n\n        const encrypted: Record<string, AESEncryptedSecretStoragePayload> = {};\n\n        if (!keys) {\n            const defaultKeyId = await this.getDefaultKeyId();\n            if (!defaultKeyId) {\n                throw new Error(\"No keys specified and no default key present\");\n            }\n            keys = [defaultKeyId];\n        }\n\n        if (keys.length === 0) {\n            throw new Error(\"Zero keys given to encrypt with!\");\n        }\n\n        for (const keyId of keys) {\n            // get key information from key storage\n            const keyInfo = await this.accountDataAdapter.getAccountDataFromServer(`m.secret_storage.key.${keyId}`);\n            if (!keyInfo) {\n                throw new Error(\"Unknown key: \" + keyId);\n            }\n\n            // encrypt secret, based on the algorithm\n            if (keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n                const keys = { [keyId]: keyInfo };\n                const [, encryption] = await this.getSecretStorageKey(keys, name);\n                encrypted[keyId] = await encryption.encrypt(secret);\n            } else {\n                logger.warn(\"unknown algorithm for secret storage key \" + keyId + \": \" + keyInfo.algorithm);\n                // do nothing if we don't understand the encryption algorithm\n            }\n        }\n\n        // save encrypted secret\n        await this.accountDataAdapter.setAccountData(name, { encrypted });\n    }\n\n    /**\n     * Get a secret from storage, and decrypt it.\n     *\n     * {@link SecretStorageCallbacks#getSecretStorageKey} will be called to obtain a secret storage\n     * key to decrypt the secret.\n     *\n     * @param name - the name of the secret - i.e., the \"event type\" stored in the account data\n     *\n     * @returns the decrypted contents of the secret, or \"undefined\" if `name` is not found in\n     *    the user's account data.\n     */\n    public async get(name: SecretStorageKey): Promise<string | undefined> {\n        const secretInfo = await this.accountDataAdapter.getAccountDataFromServer(name);\n        if (!secretInfo) {\n            return;\n        }\n        if (!secretInfo.encrypted) {\n            throw new Error(\"Content is not encrypted!\");\n        }\n\n        // get possible keys to decrypt\n        const keys: Record<string, SecretStorageKeyDescriptionAesV1> = {};\n        for (const keyId of Object.keys(secretInfo.encrypted)) {\n            // get key information from key storage\n            const keyInfo = await this.accountDataAdapter.getAccountDataFromServer(`m.secret_storage.key.${keyId}`);\n            const encInfo = secretInfo.encrypted[keyId];\n            // only use keys we understand the encryption algorithm of\n            if (keyInfo?.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n                if (encInfo.iv && encInfo.ciphertext && encInfo.mac) {\n                    keys[keyId] = keyInfo;\n                }\n            }\n        }\n\n        if (Object.keys(keys).length === 0) {\n            throw new Error(\n                `Could not decrypt ${name} because none of ` +\n                    `the keys it is encrypted with are for a supported algorithm`,\n            );\n        }\n\n        // fetch private key from app\n        const [keyId, decryption] = await this.getSecretStorageKey(keys, name);\n        const encInfo = secretInfo.encrypted[keyId];\n\n        return decryption.decrypt(encInfo);\n    }\n\n    /**\n     * Check if a secret is stored on the server.\n     *\n     * @param name - the name of the secret\n     *\n     * @returns map of key name to key info the secret is encrypted\n     *     with, or null if it is not present or not encrypted with a trusted\n     *     key\n     */\n    public async isStored(name: SecretStorageKey): Promise<Record<string, SecretStorageKeyDescriptionAesV1> | null> {\n        // check if secret exists\n        const secretInfo = await this.accountDataAdapter.getAccountDataFromServer(name);\n        if (!secretInfo?.encrypted) return null;\n\n        const ret: Record<string, SecretStorageKeyDescriptionAesV1> = {};\n\n        // filter secret encryption keys with supported algorithm\n        for (const keyId of Object.keys(secretInfo.encrypted)) {\n            // get key information from key storage\n            const keyInfo = await this.accountDataAdapter.getAccountDataFromServer(`m.secret_storage.key.${keyId}`);\n            if (!keyInfo) continue;\n            const encInfo = secretInfo.encrypted[keyId];\n\n            // only use keys we understand the encryption algorithm of\n            if (keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n                if (encInfo.iv && encInfo.ciphertext && encInfo.mac) {\n                    ret[keyId] = keyInfo;\n                }\n            }\n        }\n        return Object.keys(ret).length ? ret : null;\n    }\n\n    private async getSecretStorageKey(\n        keys: Record<string, SecretStorageKeyDescriptionAesV1>,\n        name: string,\n    ): Promise<[string, Decryptors]> {\n        if (!this.callbacks.getSecretStorageKey) {\n            throw new Error(\"No getSecretStorageKey callback supplied\");\n        }\n\n        const returned = await this.callbacks.getSecretStorageKey({ keys }, name);\n\n        if (!returned) {\n            throw new Error(\"getSecretStorageKey callback returned falsey\");\n        }\n        if (returned.length < 2) {\n            throw new Error(\"getSecretStorageKey callback returned invalid data\");\n        }\n\n        const [keyId, privateKey] = returned;\n        if (!keys[keyId]) {\n            throw new Error(\"App returned unknown key from getSecretStorageKey!\");\n        }\n\n        if (keys[keyId].algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {\n            const decryption = {\n                encrypt: function (secret: string): Promise<AESEncryptedSecretStoragePayload> {\n                    return encryptAESSecretStorageItem(secret, privateKey, name);\n                },\n                decrypt: function (encInfo: AESEncryptedSecretStoragePayload): Promise<string> {\n                    return decryptAESSecretStorageItem(encInfo, privateKey, name);\n                },\n            };\n            return [keyId, decryption];\n        } else {\n            throw new Error(\"Unknown key type: \" + keys[keyId].algorithm);\n        }\n    }\n}\n\n/** trim trailing instances of '=' from a string\n *\n * @internal\n *\n * @param input - input string\n */\nexport function trimTrailingEquals(input: string): string {\n    // according to Sonar and CodeQL, a regex such as /=+$/ is superlinear.\n    // Not sure I believe it, but it's easy enough to work around.\n\n    // find the number of characters before the trailing =\n    let i = input.length;\n    while (i >= 1 && input.charCodeAt(i - 1) == 0x3d) i--;\n\n    // trim to the calculated length\n    if (i < input.length) {\n        return input.substring(0, i);\n    } else {\n        return input;\n    }\n}\n\n// string of zeroes, for calculating the key check\nconst ZERO_STR = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Calculate the MAC for checking the key.\n * See https://spec.matrix.org/v1.11/client-server-api/#msecret_storagev1aes-hmac-sha2, steps 3 and 4.\n *\n * @param key - the key to use\n * @param iv - The initialization vector as a base64-encoded string.\n *     If omitted, a random initialization vector will be created.\n * @returns An object that contains, `mac` and `iv` properties.\n */\nexport function calculateKeyCheck(\n    key: Uint8Array<ArrayBuffer>,\n    iv?: string,\n): Promise<AESEncryptedSecretStoragePayload> {\n    return encryptAESSecretStorageItem(ZERO_STR, key, \"\", iv);\n}\n","/*\nCopyright 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IHttpOpts, type MatrixHttpApi, Method } from \"./http-api/index.ts\";\nimport { type Logger } from \"./logger.ts\";\n\n// How often we update the server capabilities.\n// 6 hours - an arbitrary value, but they should change very infrequently.\nconst CAPABILITIES_CACHE_MS = 6 * 60 * 60 * 1000;\n\n// How long we want before retrying if we couldn't fetch\nconst CAPABILITIES_RETRY_MS = 30 * 1000;\n\nexport interface ICapability {\n    enabled: boolean;\n}\n\nexport interface IChangePasswordCapability extends ICapability {}\n\nexport interface IThreadsCapability extends ICapability {}\n\nexport interface IGetLoginTokenCapability extends ICapability {}\n\nexport interface ISetDisplayNameCapability extends ICapability {}\n\nexport interface ISetAvatarUrlCapability extends ICapability {}\n\nexport interface IProfileFieldsCapability extends ICapability {}\n\nexport enum RoomVersionStability {\n    Stable = \"stable\",\n    Unstable = \"unstable\",\n}\n\nexport interface IRoomVersionsCapability {\n    default: string;\n    available: Record<string, RoomVersionStability>;\n}\n\n/**\n * A representation of the capabilities advertised by a homeserver as defined by\n * [Capabilities negotiation](https://spec.matrix.org/v1.6/client-server-api/#get_matrixclientv3capabilities).\n */\nexport interface Capabilities {\n    [key: string]: any;\n    \"m.change_password\"?: IChangePasswordCapability;\n    \"m.room_versions\"?: IRoomVersionsCapability;\n    \"io.element.thread\"?: IThreadsCapability;\n    \"m.get_login_token\"?: IGetLoginTokenCapability;\n    \"org.matrix.msc3882.get_login_token\"?: IGetLoginTokenCapability;\n    \"m.set_displayname\"?: ISetDisplayNameCapability;\n    \"m.set_avatar_url\"?: ISetAvatarUrlCapability;\n    \"uk.tcpip.msc4133.profile_fields\"?: IProfileFieldsCapability;\n    /**\n     * Since Matrix v1.16\n     */\n    \"m.profile_fields\"?: IProfileFieldsCapability;\n}\n\ntype CapabilitiesResponse = {\n    capabilities: Capabilities;\n};\n\n/**\n * Manages storing and periodically refreshing the server capabilities.\n */\nexport class ServerCapabilities {\n    private capabilities?: Capabilities;\n    private retryTimeout?: ReturnType<typeof setTimeout>;\n    private refreshTimeout?: ReturnType<typeof setInterval>;\n\n    public constructor(\n        private readonly logger: Logger,\n        private readonly http: MatrixHttpApi<IHttpOpts & { onlyData: true }>,\n    ) {}\n\n    /**\n     * Starts periodically fetching the server capabilities.\n     */\n    public start(): void {\n        this.poll().then();\n    }\n\n    /**\n     * Stops the service\n     */\n    public stop(): void {\n        this.clearTimeouts();\n    }\n\n    /**\n     * Returns the cached capabilities, or undefined if none are cached.\n     * @returns the current capabilities, if any.\n     */\n    public getCachedCapabilities(): Capabilities | undefined {\n        return this.capabilities;\n    }\n\n    /**\n     * Fetches the latest server capabilities from the homeserver and returns them, or rejects\n     * on failure.\n     */\n    public fetchCapabilities = async (): Promise<Capabilities> => {\n        const resp = await this.http.authedRequest<CapabilitiesResponse>(Method.Get, \"/capabilities\");\n        this.capabilities = resp[\"capabilities\"];\n        return this.capabilities;\n    };\n\n    private poll = async (): Promise<void> => {\n        try {\n            await this.fetchCapabilities();\n            this.clearTimeouts();\n            this.refreshTimeout = setTimeout(this.poll, CAPABILITIES_CACHE_MS);\n            this.logger.debug(\"Fetched new server capabilities\");\n        } catch (e) {\n            this.clearTimeouts();\n            const howLong = Math.floor(CAPABILITIES_RETRY_MS + Math.random() * 5000);\n            this.retryTimeout = setTimeout(this.poll, howLong);\n            this.logger.warn(`Failed to refresh capabilities: retrying in ${howLong}ms`, e);\n        }\n    };\n\n    private clearTimeouts(): void {\n        if (this.refreshTimeout) {\n            clearInterval(this.refreshTimeout);\n            this.refreshTimeout = undefined;\n        }\n        if (this.retryTimeout) {\n            clearTimeout(this.retryTimeout);\n            this.retryTimeout = undefined;\n        }\n    }\n}\n","/*\nCopyright 2019 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport enum SERVICE_TYPES {\n    IS = \"SERVICE_TYPE_IS\", // An identity server\n    IM = \"SERVICE_TYPE_IM\", // An integration manager\n}\n","/*\nCopyright 2022-2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { logger } from \"./logger.ts\";\nimport { type MatrixClient } from \"./client.ts\";\nimport { type IRoomEvent, type IStateEvent } from \"./sync-accumulator.ts\";\nimport { TypedEventEmitter } from \"./models/typed-event-emitter.ts\";\nimport { sleep } from \"./utils.ts\";\nimport { type HTTPError } from \"./http-api/index.ts\";\n\n// /sync requests allow you to set a timeout= but the request may continue\n// beyond that and wedge forever, so we need to track how long we are willing\n// to keep open the connection. This constant is *ADDED* to the timeout= value\n// to determine the max time we're willing to wait.\nconst BUFFER_PERIOD_MS = 10 * 1000;\n\nexport const MSC3575_WILDCARD = \"*\";\nexport const MSC3575_STATE_KEY_ME = \"$ME\";\nexport const MSC3575_STATE_KEY_LAZY = \"$LAZY\";\n\n/**\n * Represents a subscription to a room or set of rooms. Controls which events are returned.\n */\nexport interface MSC3575RoomSubscription {\n    required_state?: string[][];\n    timeline_limit?: number;\n    include_old_rooms?: MSC3575RoomSubscription;\n}\n\n/**\n * Controls which rooms are returned in a given list.\n */\nexport interface MSC3575Filter {\n    is_dm?: boolean;\n    is_encrypted?: boolean;\n    is_invite?: boolean;\n    room_name_like?: string;\n    room_types?: string[];\n    not_room_types?: string[];\n    spaces?: string[];\n    tags?: string[];\n    not_tags?: string[];\n}\n\n/**\n * Represents a list subscription.\n */\nexport interface MSC3575List extends MSC3575RoomSubscription {\n    ranges: number[][];\n    sort?: string[];\n    filters?: MSC3575Filter;\n    slow_get_all_rooms?: boolean;\n}\n\n/**\n * A complete Sliding Sync request.\n */\nexport interface MSC3575SlidingSyncRequest {\n    // json body params\n    lists?: Record<string, MSC3575List>;\n    unsubscribe_rooms?: string[];\n    room_subscriptions?: Record<string, MSC3575RoomSubscription>;\n    extensions?: object;\n    txn_id?: string;\n\n    // query params\n    pos?: string;\n    timeout?: number;\n    clientTimeout?: number;\n}\n\n/**\n * New format of hero introduced in MSC4186 with display name and avatar URL\n * in addition to just user_id (as it is on the wire, with underscores)\n * as opposed to Hero in room-summary.ts which has fields in camelCase\n * (and also a flag to note what format the hero came from).\n */\nexport interface MSC4186Hero {\n    user_id: string;\n    displayname?: string;\n    avatar_url?: string;\n}\n\nexport interface MSC3575RoomData {\n    name: string;\n    required_state: IStateEvent[];\n    timeline: (IRoomEvent | IStateEvent)[];\n    heroes?: MSC4186Hero[];\n    notification_count?: number;\n    highlight_count?: number;\n    joined_count?: number;\n    invited_count?: number;\n    invite_state?: IStateEvent[];\n    initial?: boolean;\n    limited?: boolean;\n    is_dm?: boolean;\n    prev_batch?: string;\n    num_live?: number;\n    bump_stamp?: number;\n}\n\ninterface ListResponse {\n    count: number;\n}\n\n/**\n * A complete Sliding Sync response\n */\nexport interface MSC3575SlidingSyncResponse {\n    pos: string;\n    txn_id?: string;\n    lists: Record<string, ListResponse>;\n    rooms: Record<string, MSC3575RoomData>;\n    extensions: Record<string, object>;\n}\n\nexport enum SlidingSyncState {\n    /**\n     * Fired by SlidingSyncEvent.Lifecycle event immediately before processing the response.\n     */\n    RequestFinished = \"FINISHED\",\n    /**\n     * Fired by SlidingSyncEvent.Lifecycle event immediately after all room data listeners have been\n     * invoked, but before list listeners.\n     */\n    Complete = \"COMPLETE\",\n}\n\n/**\n * Internal Class. SlidingList represents a single list in sliding sync. The list can have filters,\n * multiple sliding windows, and maintains the index-\\>room_id mapping.\n */\nclass SlidingList {\n    private list!: MSC3575List;\n    private isModified?: boolean;\n\n    // returned data\n    public joinedCount = 0;\n\n    /**\n     * Construct a new sliding list.\n     * @param list - The range, sort and filter values to use for this list.\n     */\n    public constructor(list: MSC3575List) {\n        this.replaceList(list);\n    }\n\n    /**\n     * Mark this list as modified or not. Modified lists will return sticky params with calls to getList.\n     * This is useful for the first time the list is sent, or if the list has changed in some way.\n     * @param modified - True to mark this list as modified so all sticky parameters will be re-sent.\n     */\n    public setModified(modified: boolean): void {\n        this.isModified = modified;\n    }\n\n    /**\n     * Update the list range for this list. Does not affect modified status as list ranges are non-sticky.\n     * @param newRanges - The new ranges for the list\n     */\n    public updateListRange(newRanges: number[][]): void {\n        this.list.ranges = JSON.parse(JSON.stringify(newRanges));\n    }\n\n    /**\n     * Replace list parameters. All fields will be replaced with the new list parameters.\n     * @param list - The new list parameters\n     */\n    public replaceList(list: MSC3575List): void {\n        list.filters = list.filters ?? {};\n        list.ranges = list.ranges ?? [];\n        this.list = JSON.parse(JSON.stringify(list));\n        this.isModified = true;\n\n        // reset values as the join count may be very different (if filters changed) including the rooms\n        // (e.g. sort orders or sliding window ranges changed)\n\n        // the total number of joined rooms according to the server, always >= len(roomIndexToRoomId)\n        this.joinedCount = 0;\n    }\n\n    /**\n     * Return a copy of the list suitable for a request body.\n     * @param forceIncludeAllParams - True to forcibly include all params even if the list\n     * hasn't been modified. Callers may want to do this if they are modifying the list prior to calling\n     * updateList.\n     */\n    public getList(forceIncludeAllParams: boolean): MSC3575List {\n        let list = {\n            ranges: JSON.parse(JSON.stringify(this.list.ranges)),\n        };\n        if (this.isModified || forceIncludeAllParams) {\n            list = JSON.parse(JSON.stringify(this.list));\n        }\n        return list;\n    }\n}\n\n/**\n * When onResponse extensions should be invoked: before or after processing the main response.\n */\nexport enum ExtensionState {\n    // Call onResponse before processing the response body. This is useful when your extension is\n    // preparing the ground for the response body e.g. processing to-device messages before the\n    // encrypted event arrives.\n    PreProcess = \"ExtState.PreProcess\",\n    // Call onResponse after processing the response body. This is useful when your extension is\n    // decorating data from the client, and you rely on MatrixClient.getRoom returning the Room object\n    // e.g. room account data.\n    PostProcess = \"ExtState.PostProcess\",\n}\n\n/**\n * An interface that must be satisfied to register extensions\n */\nexport interface Extension<Req extends object, Res extends object> {\n    /**\n     * The extension name to go under 'extensions' in the request body.\n     * @returns The JSON key.\n     */\n    name(): string;\n    /**\n     * A function which is called when the request JSON is being formed.\n     * Returns the data to insert under this key.\n     * @param isInitial - True when this is part of the initial request.\n     * @returns The request JSON to send.\n     */\n    onRequest(isInitial: boolean): Promise<Req>;\n    /**\n     * A function which is called when there is response JSON under this extension.\n     * @param data - The response JSON under the extension name.\n     */\n    onResponse(data: Res): Promise<void>;\n    /**\n     * Controls when onResponse should be called.\n     * @returns The state when it should be called.\n     */\n    when(): ExtensionState;\n}\n\n/**\n * Events which can be fired by the SlidingSync class. These are designed to provide different levels\n * of information when processing sync responses.\n *  - RoomData: concerns rooms, useful for SlidingSyncSdk to update its knowledge of rooms.\n *  - Lifecycle: concerns callbacks at various well-defined points in the sync process.\n * Specifically, the order of event invocation is:\n *  - Lifecycle (state=RequestFinished)\n *  - RoomData (N times)\n *  - Lifecycle (state=Complete)\n */\nexport enum SlidingSyncEvent {\n    /**\n     * This event fires when there are updates for a room. Fired as and when rooms are encountered\n     * in the response.\n     */\n    RoomData = \"SlidingSync.RoomData\",\n    /**\n     * This event fires at various points in the /sync loop lifecycle.\n     *  - SlidingSyncState.RequestFinished: Fires after we receive a valid response but before the\n     * response has been processed. Perform any pre-process steps here. If there was a problem syncing,\n     * `err` will be set (e.g network errors).\n     *  - SlidingSyncState.Complete: Fires after the response has been processed.\n     */\n    Lifecycle = \"SlidingSync.Lifecycle\",\n}\n\nexport type SlidingSyncEventHandlerMap = {\n    [SlidingSyncEvent.RoomData]: (roomId: string, roomData: MSC3575RoomData) => Promise<void> | void;\n    [SlidingSyncEvent.Lifecycle]: (\n        state: SlidingSyncState,\n        resp: MSC3575SlidingSyncResponse | null,\n        err?: Error,\n    ) => void;\n};\n\n/**\n * SlidingSync is a high-level data structure which controls the majority of sliding sync.\n * It has no hooks into JS SDK except for needing a MatrixClient to perform the HTTP request.\n * This means this class (and everything it uses) can be used in isolation from JS SDK if needed.\n * To hook this up with the JS SDK, you need to use SlidingSyncSdk.\n */\nexport class SlidingSync extends TypedEventEmitter<SlidingSyncEvent, SlidingSyncEventHandlerMap> {\n    private lists: Map<string, SlidingList>;\n    private listModifiedCount = 0;\n    private terminated = false;\n    // flag set when resend() is called because we cannot rely on detecting AbortError in JS SDK :(\n    private needsResend = false;\n    // map of extension name to req/resp handler\n    private extensions: Record<string, Extension<any, any>> = {};\n\n    private desiredRoomSubscriptions = new Set<string>(); // the *desired* room subscriptions\n    private confirmedRoomSubscriptions = new Set<string>();\n\n    // map of custom subscription name to the subscription\n    private customSubscriptions: Map<string, MSC3575RoomSubscription> = new Map();\n    // map of room ID to custom subscription name\n    private roomIdToCustomSubscription: Map<string, string> = new Map();\n\n    private pendingReq?: Promise<MSC3575SlidingSyncResponse>;\n    private abortController?: AbortController;\n\n    /**\n     * Create a new sliding sync instance\n     * @param proxyBaseUrl - The base URL of the sliding sync proxy\n     * @param lists - The lists to use for sliding sync.\n     * @param roomSubscriptionInfo - The params to use for room subscriptions.\n     * @param client - The client to use for /sync calls.\n     * @param timeoutMS - The number of milliseconds to wait for a response.\n     */\n    public constructor(\n        private readonly proxyBaseUrl: string,\n        lists: Map<string, MSC3575List>,\n        private roomSubscriptionInfo: MSC3575RoomSubscription,\n        private readonly client: MatrixClient,\n        private readonly timeoutMS: number,\n    ) {\n        super();\n        this.lists = new Map<string, SlidingList>();\n        lists.forEach((list, key) => {\n            this.lists.set(key, new SlidingList(list));\n        });\n    }\n\n    /**\n     * Add a custom room subscription, referred to by an arbitrary name. If a subscription with this\n     * name already exists, it is replaced. No requests are sent by calling this method.\n     * @param name - The name of the subscription. Only used to reference this subscription in\n     * useCustomSubscription.\n     * @param sub - The subscription information.\n     */\n    public addCustomSubscription(name: string, sub: MSC3575RoomSubscription): void {\n        if (this.customSubscriptions.has(name)) {\n            logger.warn(`addCustomSubscription: ${name} already exists as a custom subscription, ignoring.`);\n            return;\n        }\n        this.customSubscriptions.set(name, sub);\n    }\n\n    /**\n     * Use a custom subscription previously added via addCustomSubscription. No requests are sent\n     * by calling this method. Use modifyRoomSubscriptions to resend subscription information.\n     * @param roomId - The room to use the subscription in.\n     * @param name - The name of the subscription. If this name is unknown, the default subscription\n     * will be used.\n     */\n    public useCustomSubscription(roomId: string, name: string): void {\n        // We already know about this custom subscription, as it is immutable,\n        // we don't need to unconfirm the subscription.\n        if (this.roomIdToCustomSubscription.get(roomId) === name) {\n            return;\n        }\n        this.roomIdToCustomSubscription.set(roomId, name);\n        // unconfirm this subscription so a resend() will send it up afresh.\n        this.confirmedRoomSubscriptions.delete(roomId);\n    }\n\n    /**\n     * Get the room index data for a list.\n     * @param key - The list key\n     * @returns The list data which contains the rooms in this list\n     */\n    public getListData(key: string): { joinedCount: number } | null {\n        const data = this.lists.get(key);\n        if (!data) {\n            return null;\n        }\n        return {\n            joinedCount: data.joinedCount,\n        };\n    }\n\n    /**\n     * Get the full request list parameters for a list index. This function is provided for callers to use\n     * in conjunction with setList to update fields on an existing list.\n     * @param key - The list key to get the params for.\n     * @returns A copy of the list params or undefined.\n     */\n    public getListParams(key: string): MSC3575List | null {\n        const params = this.lists.get(key);\n        if (!params) {\n            return null;\n        }\n        return params.getList(true);\n    }\n\n    /**\n     * Set new ranges for an existing list. Calling this function when _only_ the ranges have changed\n     * is more efficient than calling setList(index,list) as this function won't resend sticky params,\n     * whereas setList always will.\n     * @param key - The list key to modify\n     * @param ranges - The new ranges to apply.\n     * @returns A promise which resolves to the transaction ID when it has been received down sync\n     * (or rejects with the transaction ID if the action was not applied e.g the request was cancelled\n     * immediately after sending, in which case the action will be applied in the subsequent request)\n     */\n    public setListRanges(key: string, ranges: number[][]): void {\n        const list = this.lists.get(key);\n        if (!list) {\n            throw new Error(\"no list with key \" + key);\n        }\n        list.updateListRange(ranges);\n        this.resend();\n    }\n\n    /**\n     * Add or replace a list. Calling this function will interrupt the /sync request to resend new\n     * lists.\n     * @param key - The key to modify\n     * @param list - The new list parameters.\n     * @returns A promise which resolves to the transaction ID when it has been received down sync\n     * (or rejects with the transaction ID if the action was not applied e.g the request was cancelled\n     * immediately after sending, in which case the action will be applied in the subsequent request)\n     */\n    public setList(key: string, list: MSC3575List): void {\n        const existingList = this.lists.get(key);\n        if (existingList) {\n            existingList.replaceList(list);\n            this.lists.set(key, existingList);\n        } else {\n            this.lists.set(key, new SlidingList(list));\n        }\n        this.listModifiedCount += 1;\n        this.resend();\n    }\n\n    /**\n     * Get the room subscriptions for the sync API.\n     * @returns A copy of the desired room subscriptions.\n     */\n    public getRoomSubscriptions(): Set<string> {\n        return new Set(Array.from(this.desiredRoomSubscriptions));\n    }\n\n    /**\n     * Modify the room subscriptions for the sync API. Calling this function will interrupt the\n     * /sync request to resend new subscriptions. If the /sync stream has not started, this will\n     * prepare the room subscriptions for when start() is called.\n     * @param s - The new desired room subscriptions.\n     */\n    public modifyRoomSubscriptions(s: Set<string>): void {\n        this.desiredRoomSubscriptions = s;\n        this.resend();\n    }\n\n    /**\n     * Modify which events to retrieve for room subscriptions. Invalidates all room subscriptions\n     * such that they will be sent up afresh.\n     * @param rs - The new room subscription fields to fetch.\n     */\n    public modifyRoomSubscriptionInfo(rs: MSC3575RoomSubscription): void {\n        this.roomSubscriptionInfo = rs;\n        this.confirmedRoomSubscriptions = new Set<string>();\n        this.resend();\n    }\n\n    /**\n     * Register an extension to send with the /sync request.\n     * @param ext - The extension to register.\n     */\n    public registerExtension(ext: Extension<any, any>): void {\n        if (this.extensions[ext.name()]) {\n            throw new Error(`registerExtension: ${ext.name()} already exists as an extension`);\n        }\n        this.extensions[ext.name()] = ext;\n    }\n\n    private async getExtensionRequest(isInitial: boolean): Promise<Record<string, object | undefined>> {\n        const ext: Record<string, object | undefined> = {};\n        for (const extName in this.extensions) {\n            ext[extName] = await this.extensions[extName].onRequest(isInitial);\n        }\n        return ext;\n    }\n\n    private async onPreExtensionsResponse(ext: Record<string, object>): Promise<void> {\n        await Promise.all(\n            Object.keys(ext).map(async (extName) => {\n                if (this.extensions[extName].when() == ExtensionState.PreProcess) {\n                    await this.extensions[extName].onResponse(ext[extName]);\n                }\n            }),\n        );\n    }\n\n    private async onPostExtensionsResponse(ext: Record<string, object>): Promise<void> {\n        await Promise.all(\n            Object.keys(ext).map(async (extName) => {\n                if (this.extensions[extName].when() == ExtensionState.PostProcess) {\n                    await this.extensions[extName].onResponse(ext[extName]);\n                }\n            }),\n        );\n    }\n\n    /**\n     * Invoke all attached room data listeners.\n     * @param roomId - The room which received some data.\n     * @param roomData - The raw sliding sync response JSON.\n     */\n    private async invokeRoomDataListeners(roomId: string, roomData: MSC3575RoomData): Promise<void> {\n        if (!roomData.required_state) {\n            roomData.required_state = [];\n        }\n        if (!roomData.timeline) {\n            roomData.timeline = [];\n        }\n        await this.emitPromised(SlidingSyncEvent.RoomData, roomId, roomData);\n    }\n\n    /**\n     * Invoke all attached lifecycle listeners.\n     * @param state - The Lifecycle state\n     * @param resp - The raw sync response JSON\n     * @param err - Any error that occurred when making the request e.g. network errors.\n     */\n    private invokeLifecycleListeners(\n        state: SlidingSyncState,\n        resp: MSC3575SlidingSyncResponse | null,\n        err?: Error,\n    ): void {\n        this.emit(SlidingSyncEvent.Lifecycle, state, resp, err);\n    }\n\n    /**\n     * Resend a Sliding Sync request. Used when something has changed in the request.\n     */\n    public resend(): void {\n        this.needsResend = true;\n        this.abortController?.abort();\n        this.abortController = new AbortController();\n    }\n\n    /**\n     * Stop syncing with the server.\n     */\n    public stop(): void {\n        this.terminated = true;\n        this.abortController?.abort();\n        // remove all listeners so things can be GC'd\n        this.removeAllListeners(SlidingSyncEvent.Lifecycle);\n        this.removeAllListeners(SlidingSyncEvent.RoomData);\n    }\n\n    /**\n     * Re-setup this connection e.g in the event of an expired session.\n     */\n    private resetup(): void {\n        logger.warn(\"SlidingSync: resetting connection info\");\n        // resend sticky params and de-confirm all subscriptions\n        this.lists.forEach((l) => {\n            l.setModified(true);\n        });\n        this.confirmedRoomSubscriptions = new Set<string>(); // leave desired ones alone though!\n        // reset the connection as we might be wedged\n        this.resend();\n    }\n\n    /**\n     * Start syncing with the server. Blocks until stopped.\n     */\n    public async start(): Promise<void> {\n        this.abortController = new AbortController();\n\n        let currentPos: string | undefined;\n        while (!this.terminated) {\n            this.needsResend = false;\n            let resp: MSC3575SlidingSyncResponse | undefined;\n            try {\n                const reqLists: Record<string, MSC3575List> = {};\n                this.lists.forEach((l: SlidingList, key: string) => {\n                    reqLists[key] = l.getList(true);\n                });\n                const reqBody: MSC3575SlidingSyncRequest = {\n                    lists: reqLists,\n                    pos: currentPos,\n                    timeout: this.timeoutMS,\n                    clientTimeout: this.timeoutMS + BUFFER_PERIOD_MS,\n                    extensions: await this.getExtensionRequest(currentPos === undefined),\n                };\n                // check if we are (un)subscribing to a room and modify request this one time for it\n                const newSubscriptions = difference(this.desiredRoomSubscriptions, this.confirmedRoomSubscriptions);\n                const unsubscriptions = difference(this.confirmedRoomSubscriptions, this.desiredRoomSubscriptions);\n                if (unsubscriptions.size > 0) {\n                    reqBody.unsubscribe_rooms = Array.from(unsubscriptions);\n                }\n                if (newSubscriptions.size > 0) {\n                    reqBody.room_subscriptions = {};\n                    for (const roomId of newSubscriptions) {\n                        const customSubName = this.roomIdToCustomSubscription.get(roomId);\n                        let sub = this.roomSubscriptionInfo;\n                        if (customSubName && this.customSubscriptions.has(customSubName)) {\n                            sub = this.customSubscriptions.get(customSubName)!;\n                        }\n                        reqBody.room_subscriptions[roomId] = sub;\n                    }\n                }\n                this.pendingReq = this.client.slidingSync(reqBody, this.proxyBaseUrl, this.abortController.signal);\n                resp = await this.pendingReq;\n                currentPos = resp.pos;\n                // update what we think we're subscribed to.\n                for (const roomId of newSubscriptions) {\n                    this.confirmedRoomSubscriptions.add(roomId);\n                }\n                for (const roomId of unsubscriptions) {\n                    this.confirmedRoomSubscriptions.delete(roomId);\n                }\n                // mark all these lists as having been sent as sticky so we don't keep sending sticky params\n                this.lists.forEach((l) => {\n                    l.setModified(false);\n                });\n                // set default empty values so we don't need to null check\n                resp.lists = resp.lists ?? {};\n                resp.rooms = resp.rooms ?? {};\n                resp.extensions = resp.extensions ?? {};\n                Object.keys(resp.lists).forEach((key: string) => {\n                    const list = this.lists.get(key);\n                    if (!list || !resp) {\n                        return;\n                    }\n                    list.joinedCount = resp.lists[key].count;\n                });\n                this.invokeLifecycleListeners(SlidingSyncState.RequestFinished, resp);\n            } catch (err) {\n                if ((<HTTPError>err).httpStatus) {\n                    this.invokeLifecycleListeners(SlidingSyncState.RequestFinished, null, <Error>err);\n                    if ((<HTTPError>err).httpStatus === 400) {\n                        // session probably expired TODO: assign an errcode\n                        // so drop state and re-request\n                        this.resetup();\n                        currentPos = undefined;\n                        await sleep(50); // in case the 400 was for something else; don't tightloop\n                        continue;\n                    } // else fallthrough to generic error handling\n                } else if (this.needsResend || (<Error>err).name === \"AbortError\") {\n                    continue; // don't sleep as we caused this error by abort()ing the request.\n                }\n                logger.error(err);\n                await sleep(5000);\n            }\n            if (!resp) {\n                continue;\n            }\n            await this.onPreExtensionsResponse(resp.extensions);\n\n            for (const roomId in resp.rooms) {\n                await this.invokeRoomDataListeners(roomId, resp!.rooms[roomId]);\n            }\n\n            this.invokeLifecycleListeners(SlidingSyncState.Complete, resp);\n            await this.onPostExtensionsResponse(resp.extensions);\n        }\n    }\n}\n\nconst difference = (setA: Set<string>, setB: Set<string>): Set<string> => {\n    const diff = new Set(setA);\n    for (const elem of setB) {\n        diff.delete(elem);\n    }\n    return diff;\n};\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type IMinimalEvent } from \"./sync-accumulator.ts\";\nimport { EventType } from \"./@types/event.ts\";\nimport { isSupportedReceiptType, MapWithDefault, recursiveMapToObject } from \"./utils.ts\";\nimport { type IContent } from \"./models/event.ts\";\nimport { type ReceiptContent, type ReceiptType } from \"./@types/read_receipts.ts\";\n\ninterface AccumulatedReceipt {\n    data: IMinimalEvent;\n    type: ReceiptType;\n    eventId: string;\n}\n\n/**\n * Summarises the read receipts within a room. Used by the sync accumulator.\n *\n * Given receipts for users, picks the most recently-received one and provides\n * the results in a new fake receipt event returned from\n * buildAccumulatedReceiptEvent().\n *\n * Handles unthreaded receipts and receipts in each thread separately, so the\n * returned event contains the most recently received unthreaded receipt, and\n * the most recently received receipt in each thread.\n */\nexport class ReceiptAccumulator {\n    /** user_id -\\> most-recently-received unthreaded receipt */\n    private unthreadedReadReceipts: Map<string, AccumulatedReceipt> = new Map();\n\n    /** thread_id -\\> user_id -\\> most-recently-received receipt for this thread */\n    private threadedReadReceipts: MapWithDefault<string, Map<string, AccumulatedReceipt>> = new MapWithDefault(\n        () => new Map(),\n    );\n\n    /**\n     * Provide an unthreaded receipt for this user. Overwrites any other\n     * unthreaded receipt we have for this user.\n     */\n    private setUnthreaded(userId: string, receipt: AccumulatedReceipt): void {\n        this.unthreadedReadReceipts.set(userId, receipt);\n    }\n\n    /**\n     * Provide a receipt for this user in this thread. Overwrites any other\n     * receipt we have for this user in this thread.\n     */\n    private setThreaded(threadId: string, userId: string, receipt: AccumulatedReceipt): void {\n        this.threadedReadReceipts.getOrCreate(threadId).set(userId, receipt);\n    }\n\n    /**\n     * @returns an iterator of pairs of [userId, AccumulatedReceipt] - all the\n     *          most recently-received unthreaded receipts for each user.\n     */\n    private allUnthreaded(): IterableIterator<[string, AccumulatedReceipt]> {\n        return this.unthreadedReadReceipts.entries();\n    }\n\n    /**\n     * @returns an iterator of pairs of [userId, AccumulatedReceipt] - all the\n     *          most recently-received threaded receipts for each user, in all\n     *          threads.\n     */\n    private *allThreaded(): IterableIterator<[string, AccumulatedReceipt]> {\n        for (const receiptsForThread of this.threadedReadReceipts.values()) {\n            for (const e of receiptsForThread.entries()) {\n                yield e;\n            }\n        }\n    }\n\n    /**\n     * Given a list of ephemeral events, find the receipts and store the\n     * relevant ones to be returned later from buildAccumulatedReceiptEvent().\n     */\n    public consumeEphemeralEvents(events: IMinimalEvent[] | undefined): void {\n        events?.forEach((e) => {\n            if (e.type !== EventType.Receipt || !e.content) {\n                // This means we'll drop unknown ephemeral events but that\n                // seems okay.\n                return;\n            }\n\n            // Handle m.receipt events. They clobber based on:\n            //   (user_id, receipt_type)\n            // but they are keyed in the event as:\n            //   content:{ $event_id: { $receipt_type: { $user_id: {json} }}}\n            // so store them in the former so we can accumulate receipt deltas\n            // quickly and efficiently (we expect a lot of them). Fold the\n            // receipt type into the key name since we only have 1 at the\n            // moment (m.read) and nested JSON objects are slower and more\n            // of a hassle to work with. We'll inflate this back out when\n            // getJSON() is called.\n            Object.keys(e.content).forEach((eventId) => {\n                Object.entries<ReceiptContent>(e.content[eventId]).forEach(([key, value]) => {\n                    if (!isSupportedReceiptType(key)) return;\n\n                    for (const userId of Object.keys(value)) {\n                        const data = e.content[eventId][key][userId];\n\n                        const receipt = {\n                            data: e.content[eventId][key][userId],\n                            type: key as ReceiptType,\n                            eventId,\n                        };\n\n                        // In a world that supports threads, read receipts normally have\n                        // a `thread_id` which is either the thread they belong in or\n                        // `MAIN_ROOM_TIMELINE`, so we normally use `setThreaded(...)`\n                        // here. The `MAIN_ROOM_TIMELINE` is just treated as another\n                        // thread.\n                        //\n                        // We still encounter read receipts that are \"unthreaded\"\n                        // (missing the `thread_id` property). These come from clients\n                        // that don't support threads, and from threaded clients that\n                        // are doing a \"Mark room as read\" operation. Unthreaded\n                        // receipts mark everything \"before\" them as read, in all\n                        // threads, where \"before\" means in Sync Order i.e. the order\n                        // the events were received from the homeserver in a sync.\n                        // [Note: we have some bugs where we use timestamp order instead\n                        // of Sync Order, because we don't correctly remember the Sync\n                        // Order. See #3325.]\n                        //\n                        // Calling the wrong method will cause incorrect behavior like\n                        // messages re-appearing as \"new\" when you already read them\n                        // previously.\n                        if (!data.thread_id) {\n                            this.setUnthreaded(userId, receipt);\n                        } else {\n                            this.setThreaded(data.thread_id, userId, receipt);\n                        }\n                    }\n                });\n            });\n        });\n    }\n\n    /**\n     * Build a receipt event that contains all relevant information for this\n     * room, taking the most recently received receipt for each user in an\n     * unthreaded context, and in each thread.\n     */\n    public buildAccumulatedReceiptEvent(roomId: string): IMinimalEvent | null {\n        const receiptEvent: IMinimalEvent = {\n            type: EventType.Receipt,\n            room_id: roomId,\n            content: {\n                // $event_id: { \"m.read\": { $user_id: $json } }\n            } as IContent,\n        };\n\n        const receiptEventContent: MapWithDefault<\n            string,\n            MapWithDefault<ReceiptType, Map<string, object>>\n        > = new MapWithDefault(() => new MapWithDefault(() => new Map()));\n\n        for (const [userId, receiptData] of this.allUnthreaded()) {\n            receiptEventContent\n                .getOrCreate(receiptData.eventId)\n                .getOrCreate(receiptData.type)\n                .set(userId, receiptData.data);\n        }\n\n        for (const [userId, receiptData] of this.allThreaded()) {\n            receiptEventContent\n                .getOrCreate(receiptData.eventId)\n                .getOrCreate(receiptData.type)\n                .set(userId, receiptData.data);\n        }\n\n        receiptEvent.content = recursiveMapToObject(receiptEventContent);\n\n        return receiptEventContent.size > 0 ? receiptEvent : null;\n    }\n}\n","/*\nCopyright 2017 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link SyncAccumulator} for the public class.\n */\n\nimport { logger } from \"./logger.ts\";\nimport { deepCopy } from \"./utils.ts\";\nimport { MAX_STICKY_DURATION_MS, type IContent, type IUnsigned } from \"./models/event.ts\";\nimport { type IRoomSummary } from \"./models/room-summary.ts\";\nimport { type EventType } from \"./@types/event.ts\";\nimport { UNREAD_THREAD_NOTIFICATIONS } from \"./@types/sync.ts\";\nimport { ReceiptAccumulator } from \"./receipt-accumulator.ts\";\nimport { type OlmEncryptionInfo } from \"./crypto-api/index.ts\";\n\ninterface IOpts {\n    /**\n     * The ideal maximum number of timeline entries to keep in the sync response.\n     * This is best-effort, as clients do not always have a back-pagination token for each event,\n     * so it's possible there may be slightly *less* than this value. There will never be more.\n     * This cannot be 0 or else it makes it impossible to scroll back in a room.\n     * Default: 50.\n     */\n    maxTimelineEntries?: number;\n}\n\nexport interface IMinimalEvent {\n    content: IContent;\n    type: EventType | string;\n    room_id?: string;\n    unsigned?: IUnsigned;\n}\n\nexport interface IEphemeral {\n    events: IMinimalEvent[];\n}\n\n/* eslint-disable camelcase */\ninterface UnreadNotificationCounts {\n    highlight_count?: number;\n    notification_count?: number;\n}\n\nexport interface IRoomEvent extends IMinimalEvent {\n    event_id: string;\n    sender: string;\n    origin_server_ts: number;\n}\n\nexport interface IStateEvent extends IRoomEvent {\n    prev_content?: IContent;\n    state_key: string;\n}\n\ninterface IState {\n    events: IStateEvent[];\n}\n\nexport interface ITimeline {\n    events: Array<IRoomEvent | IStateEvent>;\n    limited?: boolean;\n    prev_batch: string | null;\n}\n\ntype StickyEventFields = {\n    msc4354_sticky: { duration_ms: number };\n    content: { msc4354_sticky_key?: string };\n};\n\nexport type IStickyEvent = IRoomEvent & StickyEventFields;\n\nexport type IStickyStateEvent = IStateEvent & StickyEventFields;\n\nexport interface ISticky {\n    events: Array<IStickyEvent | IStickyStateEvent>;\n}\n\nexport interface IJoinedRoom {\n    \"summary\": IRoomSummary;\n    // One of `state` or `state_after` is required.\n    \"state\"?: IState;\n    \"org.matrix.msc4222.state_after\"?: IState; // https://github.com/matrix-org/matrix-spec-proposals/pull/4222\n    \"msc4354_sticky\"?: ISticky; // https://github.com/matrix-org/matrix-spec-proposals/pull/4354\n    \"timeline\": ITimeline;\n    \"ephemeral\": IEphemeral;\n    \"account_data\": IAccountData;\n    \"unread_notifications\": UnreadNotificationCounts;\n    \"unread_thread_notifications\"?: Record<string, UnreadNotificationCounts>;\n    \"org.matrix.msc3773.unread_thread_notifications\"?: Record<string, UnreadNotificationCounts>;\n}\n\nexport interface IStrippedState {\n    content: IContent;\n    state_key: string;\n    type: EventType | string;\n    sender: string;\n}\n\nexport interface IInviteState {\n    events: IStrippedState[];\n}\n\nexport interface IKnockState {\n    events: IStrippedState[];\n}\n\nexport interface IInvitedRoom {\n    invite_state: IInviteState;\n}\n\nexport interface ILeftRoom {\n    // One of `state` or `state_after` is required.\n    \"state\"?: IState;\n    \"org.matrix.msc4222.state_after\"?: IState;\n    \"timeline\": ITimeline;\n    \"account_data\": IAccountData;\n}\n\nexport interface IKnockedRoom {\n    knock_state: IKnockState;\n}\n\nexport interface IRooms {\n    [Category.Join]: Record<string, IJoinedRoom>;\n    [Category.Invite]: Record<string, IInvitedRoom>;\n    [Category.Leave]: Record<string, ILeftRoom>;\n    [Category.Knock]: Record<string, IKnockedRoom>;\n}\n\ninterface IPresence {\n    events: IMinimalEvent[];\n}\n\ninterface IAccountData {\n    events: IMinimalEvent[];\n}\n\n/** A to-device message as received from the sync. */\nexport interface IToDeviceEvent {\n    content: IContent;\n    sender: string;\n    type: string;\n}\n\n/**\n * A (possibly decrypted) to-device message after it has been successfully processed by the sdk.\n *\n * If the message was encrypted, the `encryptionInfo` field will contain the encryption information.\n * If the message was sent in clear, this field will be null.\n *\n * The `message` field contains the message `type`, `content`, and `sender` as if the message was sent in clear.\n */\nexport interface ReceivedToDeviceMessage {\n    /** The message type, content, and sender as if the message was sent in clear. */\n    message: IToDeviceEvent;\n    /**\n     * Information about the encryption of the message.\n     * Will be null if the message was sent in clear\n     */\n    encryptionInfo: OlmEncryptionInfo | null;\n}\n\ninterface IToDevice {\n    events: IToDeviceEvent[];\n}\n\nexport interface IDeviceLists {\n    changed?: string[];\n    left?: string[];\n}\n\nexport interface ISyncResponse {\n    \"next_batch\": string;\n    \"rooms\": IRooms;\n    \"presence\"?: IPresence;\n    \"account_data\": IAccountData;\n    \"to_device\"?: IToDevice;\n    \"device_lists\"?: IDeviceLists;\n    \"device_one_time_keys_count\"?: Record<string, number>;\n\n    \"device_unused_fallback_key_types\"?: string[];\n    \"org.matrix.msc2732.device_unused_fallback_key_types\"?: string[];\n}\n/* eslint-enable camelcase */\n\nexport enum Category {\n    Invite = \"invite\",\n    Leave = \"leave\",\n    Join = \"join\",\n    Knock = \"knock\",\n}\n\ninterface IRoom {\n    _currentState: { [eventType: string]: { [stateKey: string]: IStateEvent } };\n    _timeline: {\n        event: IRoomEvent | IStateEvent;\n        token: string | null;\n    }[];\n    _summary: Partial<IRoomSummary>;\n    _accountData: { [eventType: string]: IMinimalEvent };\n    _unreadNotifications: Partial<UnreadNotificationCounts>;\n    _unreadThreadNotifications?: Record<string, Partial<UnreadNotificationCounts>>;\n    _receipts: ReceiptAccumulator;\n    _stickyEvents: {\n        readonly event: IStickyEvent | IStickyStateEvent;\n        /**\n         * This is the timestamp at which point it is safe to remove this event from the store.\n         * This value is immutable\n         */\n        readonly expiresTs: number;\n    }[];\n}\n\nexport interface ISyncData {\n    nextBatch: string;\n    accountData: IMinimalEvent[];\n    roomsData: IRooms;\n}\n\ntype TaggedEvent = IRoomEvent & { _localTs?: number };\n\nfunction isTaggedEvent(event: IRoomEvent): event is TaggedEvent {\n    return \"_localTs\" in event && event[\"_localTs\"] !== undefined;\n}\n\n/**\n * The purpose of this class is to accumulate /sync responses such that a\n * complete \"initial\" JSON response can be returned which accurately represents\n * the sum total of the /sync responses accumulated to date. It only handles\n * room data: that is, everything under the \"rooms\" top-level key.\n *\n * This class is used when persisting room data so a complete /sync response can\n * be loaded from disk and incremental syncs can be performed on the server,\n * rather than asking the server to do an initial sync on startup.\n */\nexport class SyncAccumulator {\n    private accountData: Record<string, IMinimalEvent> = {}; // $event_type: Object\n    private inviteRooms: Record<string, IInvitedRoom> = {}; // $roomId: { ... sync 'invite' json data ... }\n    private knockRooms: Record<string, IKnockedRoom> = {}; // $roomId: { ... sync 'knock' json data ... }\n    private joinRooms: { [roomId: string]: IRoom } = {};\n    // the /sync token which corresponds to the last time rooms were\n    // accumulated. We remember this so that any caller can obtain a\n    // coherent /sync response and know at what point they should be\n    // streaming from without losing events.\n    private nextBatch: string | null = null;\n\n    public constructor(private readonly opts: IOpts = {}) {\n        this.opts.maxTimelineEntries = this.opts.maxTimelineEntries || 50;\n    }\n\n    public accumulate(syncResponse: ISyncResponse, fromDatabase = false): void {\n        this.accumulateRooms(syncResponse, fromDatabase);\n        this.accumulateAccountData(syncResponse);\n        this.nextBatch = syncResponse.next_batch;\n    }\n\n    private accumulateAccountData(syncResponse: ISyncResponse): void {\n        if (!syncResponse.account_data || !syncResponse.account_data.events) {\n            return;\n        }\n        // Clobbers based on event type.\n        syncResponse.account_data.events.forEach((e) => {\n            this.accountData[e.type] = e;\n        });\n    }\n\n    /**\n     * Accumulate incremental /sync room data.\n     * @param syncResponse - the complete /sync JSON\n     * @param fromDatabase - True if the sync response is one saved to the database\n     */\n    private accumulateRooms(syncResponse: ISyncResponse, fromDatabase = false): void {\n        if (!syncResponse.rooms) {\n            return;\n        }\n        if (syncResponse.rooms.invite) {\n            Object.keys(syncResponse.rooms.invite).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Invite, syncResponse.rooms.invite[roomId], fromDatabase);\n            });\n        }\n        if (syncResponse.rooms.join) {\n            Object.keys(syncResponse.rooms.join).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Join, syncResponse.rooms.join[roomId], fromDatabase);\n            });\n        }\n        if (syncResponse.rooms.leave) {\n            Object.keys(syncResponse.rooms.leave).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Leave, syncResponse.rooms.leave[roomId], fromDatabase);\n            });\n        }\n        if (syncResponse.rooms.knock) {\n            Object.keys(syncResponse.rooms.knock).forEach((roomId) => {\n                this.accumulateRoom(roomId, Category.Knock, syncResponse.rooms.knock[roomId], fromDatabase);\n            });\n        }\n    }\n\n    private accumulateRoom(roomId: string, category: Category.Invite, data: IInvitedRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category.Join, data: IJoinedRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category.Leave, data: ILeftRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category.Knock, data: IKnockedRoom, fromDatabase: boolean): void;\n    private accumulateRoom(roomId: string, category: Category, data: any, fromDatabase = false): void {\n        // Valid /sync state transitions\n        //       +--------+ <======+            1: Accept an invite\n        //   +== | INVITE |        | (5)        2: Leave a room\n        //   |   +--------+ =====+ |            3: Join a public room previously\n        //   |(1)            (4) | |               left (handle as if new room)\n        //   V         (2)       V |            4: Reject an invite\n        // +------+ ========> +--------+         5: Invite to a room previously\n        // | JOIN |    (3)    | LEAVE* |            left (handle as if new room)\n        // +------+ <======== +--------+\n        //\n        // * equivalent to \"no state\"\n        switch (category) {\n            case Category.Invite: // (5)\n                if (this.knockRooms[roomId]) {\n                    // was previously knock, now invite, need to delete knock state\n                    delete this.knockRooms[roomId];\n                }\n                this.accumulateInviteState(roomId, data as IInvitedRoom);\n                break;\n\n            case Category.Knock:\n                this.accumulateKnockState(roomId, data as IKnockedRoom);\n                break;\n\n            case Category.Join:\n                if (this.knockRooms[roomId]) {\n                    // delete knock state on join\n                    delete this.knockRooms[roomId];\n                } else if (this.inviteRooms[roomId]) {\n                    // (1)\n                    // was previously invite, now join. We expect /sync to give\n                    // the entire state and timeline on 'join', so delete previous\n                    // invite state\n                    delete this.inviteRooms[roomId];\n                }\n                // (3)\n                this.accumulateJoinState(roomId, data as IJoinedRoom, fromDatabase);\n                break;\n\n            case Category.Leave:\n                if (this.knockRooms[roomId]) {\n                    // delete knock state on leave\n                    delete this.knockRooms[roomId];\n                } else if (this.inviteRooms[roomId]) {\n                    // (4)\n                    delete this.inviteRooms[roomId];\n                } else {\n                    // (2)\n                    delete this.joinRooms[roomId];\n                }\n                break;\n\n            default:\n                logger.error(\"Unknown cateogory: \", category);\n        }\n    }\n\n    private accumulateInviteState(roomId: string, data: IInvitedRoom): void {\n        if (!data.invite_state || !data.invite_state.events) {\n            // no new data\n            return;\n        }\n        if (!this.inviteRooms[roomId]) {\n            this.inviteRooms[roomId] = {\n                invite_state: data.invite_state,\n            };\n            return;\n        }\n        // accumulate extra keys for invite->invite transitions\n        // clobber based on event type / state key\n        // We expect invite_state to be small, so just loop over the events\n        const currentData = this.inviteRooms[roomId];\n        data.invite_state.events.forEach((e) => {\n            let hasAdded = false;\n            for (let i = 0; i < currentData.invite_state.events.length; i++) {\n                const current = currentData.invite_state.events[i];\n                if (current.type === e.type && current.state_key == e.state_key) {\n                    currentData.invite_state.events[i] = e; // update\n                    hasAdded = true;\n                }\n            }\n            if (!hasAdded) {\n                currentData.invite_state.events.push(e);\n            }\n        });\n    }\n\n    private accumulateKnockState(roomId: string, data: IKnockedRoom): void {\n        if (!data.knock_state || !data.knock_state.events) {\n            // no new data\n            return;\n        }\n        if (!this.knockRooms[roomId]) {\n            this.knockRooms[roomId] = {\n                knock_state: data.knock_state,\n            };\n            return;\n        }\n        // accumulate extra keys\n        // clobber based on event type / state key\n        // We expect knock_state to be small, so just loop over the events\n        const currentData = this.knockRooms[roomId];\n        data.knock_state.events.forEach((e) => {\n            let hasAdded = false;\n            for (let i = 0; i < currentData.knock_state.events.length; i++) {\n                const current = currentData.knock_state.events[i];\n                if (current.type === e.type && current.state_key == e.state_key) {\n                    currentData.knock_state.events[i] = e; // update\n                    hasAdded = true;\n                }\n            }\n            if (!hasAdded) {\n                currentData.knock_state.events.push(e);\n            }\n        });\n    }\n\n    // Accumulate timeline and state events in a room.\n    private accumulateJoinState(roomId: string, data: IJoinedRoom, fromDatabase = false): void {\n        const now = Date.now();\n        // We expect this function to be called a lot (every /sync) so we want\n        // this to be fast. /sync stores events in an array but we often want\n        // to clobber based on type/state_key. Rather than convert arrays to\n        // maps all the time, just keep private maps which contain\n        // the actual current accumulated sync state, and array-ify it when\n        // getJSON() is called.\n\n        // State resolution:\n        // The 'state' key is the delta from the previous sync (or start of time\n        // if no token was supplied), to the START of the timeline. To obtain\n        // the current state, we need to \"roll forward\" state by reading the\n        // timeline. We want to store the current state so we can drop events\n        // out the end of the timeline based on opts.maxTimelineEntries.\n        //\n        //      'state'     'timeline'     current state\n        // |-------x<======================>x\n        //          T   I   M   E\n        //\n        // When getJSON() is called, we 'roll back' the current state by the\n        // number of entries in the timeline to work out what 'state' should be.\n\n        // Back-pagination:\n        // On an initial /sync, the server provides a back-pagination token for\n        // the start of the timeline. When /sync deltas come down, they also\n        // include back-pagination tokens for the start of the timeline. This\n        // means not all events in the timeline have back-pagination tokens, as\n        // it is only the ones at the START of the timeline which have them.\n        // In order for us to have a valid timeline (and back-pagination token\n        // to match), we need to make sure that when we remove old timeline\n        // events, that we roll forward to an event which has a back-pagination\n        // token. This means we can't keep a strict sliding-window based on\n        // opts.maxTimelineEntries, and we may have a few less. We should never\n        // have more though, provided that the /sync limit is less than or equal\n        // to opts.maxTimelineEntries.\n\n        if (!this.joinRooms[roomId]) {\n            // Create truly empty objects so event types of 'hasOwnProperty' and co\n            // don't cause this code to break.\n            this.joinRooms[roomId] = {\n                _currentState: Object.create(null),\n                _timeline: [],\n                _accountData: Object.create(null),\n                _unreadNotifications: {},\n                _unreadThreadNotifications: {},\n                _summary: {},\n                _receipts: new ReceiptAccumulator(),\n                _stickyEvents: [],\n            };\n        }\n        const currentData = this.joinRooms[roomId];\n\n        if (data.account_data && data.account_data.events) {\n            // clobber based on type\n            data.account_data.events.forEach((e) => {\n                currentData._accountData[e.type] = e;\n            });\n        }\n\n        // these probably clobber, spec is unclear.\n        if (data.unread_notifications) {\n            currentData._unreadNotifications = data.unread_notifications;\n        }\n        currentData._unreadThreadNotifications =\n            data[UNREAD_THREAD_NOTIFICATIONS.stable!] ?? data[UNREAD_THREAD_NOTIFICATIONS.unstable!] ?? undefined;\n\n        if (data.summary) {\n            const HEROES_KEY = \"m.heroes\";\n            const INVITED_COUNT_KEY = \"m.invited_member_count\";\n            const JOINED_COUNT_KEY = \"m.joined_member_count\";\n\n            const acc = currentData._summary;\n            const sum = data.summary;\n            acc[HEROES_KEY] = sum[HEROES_KEY] ?? acc[HEROES_KEY];\n            acc[JOINED_COUNT_KEY] = sum[JOINED_COUNT_KEY] ?? acc[JOINED_COUNT_KEY];\n            acc[INVITED_COUNT_KEY] = sum[INVITED_COUNT_KEY] ?? acc[INVITED_COUNT_KEY];\n        }\n\n        // We purposefully do not persist m.typing events.\n        // Technically you could refresh a browser before the timer on a\n        // typing event is up, so it'll look like you aren't typing when\n        // you really still are. However, the alternative is worse. If\n        // we do persist typing events, it will look like people are\n        // typing forever until someone really does start typing (which\n        // will prompt Synapse to send down an actual m.typing event to\n        // clobber the one we persisted).\n\n        // Persist the receipts\n        currentData._receipts.consumeEphemeralEvents(data.ephemeral?.events);\n\n        // if we got a limited sync, we need to remove all timeline entries or else\n        // we will have gaps in the timeline.\n        if (data.timeline && data.timeline.limited) {\n            currentData._timeline = [];\n        }\n\n        // Work out the current state. The deltas need to be applied in the order:\n        // - existing state which didn't come down /sync.\n        // - State events under the 'state' key.\n        // - State events under the 'state_after' key OR state events in the 'timeline' if 'state_after' is not present.\n        data.state?.events?.forEach((e) => {\n            setState(currentData._currentState, e);\n        });\n        data[\"org.matrix.msc4222.state_after\"]?.events?.forEach((e) => {\n            setState(currentData._currentState, e);\n        });\n        data.timeline?.events?.forEach((e, index) => {\n            if (!data[\"org.matrix.msc4222.state_after\"]) {\n                // this nops if 'e' isn't a state event\n                setState(currentData._currentState, e);\n            }\n            // append the event to the timeline. The back-pagination token\n            // corresponds to the first event in the timeline\n            let transformedEvent: TaggedEvent;\n            if (!fromDatabase) {\n                transformedEvent = Object.assign({}, e);\n                if (transformedEvent.unsigned !== undefined) {\n                    transformedEvent.unsigned = Object.assign({}, transformedEvent.unsigned);\n                }\n                const age = e.unsigned?.age;\n                if (age !== undefined) transformedEvent._localTs = Date.now() - age;\n            } else {\n                transformedEvent = e;\n            }\n\n            currentData._timeline.push({\n                event: transformedEvent,\n                token: index === 0 ? (data.timeline.prev_batch ?? null) : null,\n            });\n        });\n\n        // Prune out any events in our stores that have since expired, do this before we\n        // insert new events.\n        currentData._stickyEvents = currentData._stickyEvents.filter(({ expiresTs }) => expiresTs > now);\n\n        // We want this to be fast, so don't worry about duplicate events here. The RoomStickyEventsStore will\n        // process these events into the correct mapped order.\n        if (data.msc4354_sticky?.events) {\n            currentData._stickyEvents = currentData._stickyEvents.concat(\n                data.msc4354_sticky.events.map((event) => {\n                    // If `duration_ms` exceeds the spec limit of a hour, we cap it.\n                    const cappedDuration = Math.min(event.msc4354_sticky.duration_ms, MAX_STICKY_DURATION_MS);\n                    // If `origin_server_ts` claims to have been from the future, we still bound it to now.\n                    const createdTs = Math.min(event.origin_server_ts, now);\n                    return {\n                        event,\n                        expiresTs: cappedDuration + createdTs,\n                    };\n                }),\n            );\n        }\n\n        // attempt to prune the timeline by jumping between events which have\n        // pagination tokens.\n        if (currentData._timeline.length > this.opts.maxTimelineEntries!) {\n            const startIndex = currentData._timeline.length - this.opts.maxTimelineEntries!;\n            for (let i = startIndex; i < currentData._timeline.length; i++) {\n                if (currentData._timeline[i].token) {\n                    // keep all events after this, including this one\n                    currentData._timeline = currentData._timeline.slice(i, currentData._timeline.length);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Return everything under the 'rooms' key from a /sync response which\n     * represents all room data that should be stored. This should be paired\n     * with the sync token which represents the most recent /sync response\n     * provided to accumulate().\n     * @param forDatabase - True to generate a sync to be saved to storage\n     * @returns An object with a \"nextBatch\", \"roomsData\" and \"accountData\"\n     * keys.\n     * The \"nextBatch\" key is a string which represents at what point in the\n     * /sync stream the accumulator reached. This token should be used when\n     * restarting a /sync stream at startup. Failure to do so can lead to missing\n     * events. The \"roomsData\" key is an Object which represents the entire\n     * /sync response from the 'rooms' key onwards. The \"accountData\" key is\n     * a list of raw events which represent global account data.\n     */\n    public getJSON(forDatabase = false): ISyncData {\n        const data: IRooms = {\n            join: {},\n            invite: {},\n            knock: {},\n            // always empty. This is set by /sync when a room was previously\n            // in 'invite' or 'join'. On fresh startup, the client won't know\n            // about any previous room being in 'invite' or 'join' so we can\n            // just omit mentioning it at all, even if it has previously come\n            // down /sync.\n            // The notable exception is when a client is kicked or banned:\n            // we may want to hold onto that room so the client can clearly see\n            // why their room has disappeared. We don't persist it though because\n            // it is unclear *when* we can safely remove the room from the DB.\n            // Instead, we assume that if you're loading from the DB, you've\n            // refreshed the page, which means you've seen the kick/ban already.\n            leave: {},\n        };\n        Object.keys(this.inviteRooms).forEach((roomId) => {\n            data.invite[roomId] = this.inviteRooms[roomId];\n        });\n        Object.keys(this.knockRooms).forEach((roomId) => {\n            data.knock[roomId] = this.knockRooms[roomId];\n        });\n        Object.keys(this.joinRooms).forEach((roomId) => {\n            const roomData = this.joinRooms[roomId];\n            const roomJson: IJoinedRoom & {\n                // We track both `state` and `state_after` for downgrade compatibility\n                \"state\": IState;\n                \"org.matrix.msc4222.state_after\": IState;\n            } = {\n                \"ephemeral\": { events: [] },\n                \"account_data\": { events: [] },\n                \"state\": { events: [] },\n                \"org.matrix.msc4222.state_after\": { events: [] },\n                \"timeline\": {\n                    events: [],\n                    prev_batch: null,\n                },\n                \"unread_notifications\": roomData._unreadNotifications,\n                \"unread_thread_notifications\": roomData._unreadThreadNotifications,\n                \"summary\": roomData._summary as IRoomSummary,\n                \"msc4354_sticky\": roomData._stickyEvents?.length\n                    ? {\n                          events: roomData._stickyEvents.map((e) => e.event),\n                      }\n                    : undefined,\n            };\n            // Add account data\n            Object.keys(roomData._accountData).forEach((evType) => {\n                roomJson.account_data.events.push(roomData._accountData[evType]);\n            });\n\n            const receiptEvent = roomData._receipts.buildAccumulatedReceiptEvent(roomId);\n\n            // add only if we have some receipt data\n            if (receiptEvent) {\n                roomJson.ephemeral.events.push(receiptEvent);\n            }\n\n            // Add timeline data\n            roomData._timeline.forEach((msgData) => {\n                if (!roomJson.timeline.prev_batch) {\n                    // the first event we add to the timeline MUST match up to\n                    // the prev_batch token.\n                    if (!msgData.token) {\n                        return; // this shouldn't happen as we prune constantly.\n                    }\n                    roomJson.timeline.prev_batch = msgData.token;\n                }\n\n                let transformedEvent: (IRoomEvent | IStateEvent) & { _localTs?: number };\n                if (!forDatabase && isTaggedEvent(msgData.event)) {\n                    // This means we have to copy each event, so we can fix it up to\n                    // set a correct 'age' parameter whilst keeping the local timestamp\n                    // on our stored event. If this turns out to be a bottleneck, it could\n                    // be optimised either by doing this in the main process after the data\n                    // has been structured-cloned to go between the worker & main process,\n                    // or special-casing data from saved syncs to read the local timestamp\n                    // directly rather than turning it into age to then immediately be\n                    // transformed back again into a local timestamp.\n                    transformedEvent = Object.assign({}, msgData.event);\n                    if (transformedEvent.unsigned !== undefined) {\n                        transformedEvent.unsigned = Object.assign({}, transformedEvent.unsigned);\n                    }\n                    delete transformedEvent._localTs;\n                    transformedEvent.unsigned = transformedEvent.unsigned || {};\n                    transformedEvent.unsigned.age = Date.now() - msgData.event._localTs!;\n                } else {\n                    transformedEvent = msgData.event;\n                }\n                roomJson.timeline.events.push(transformedEvent);\n            });\n\n            // Add state data: roll back current state to the start of timeline,\n            // by \"reverse clobbering\" from the end of the timeline to the start.\n            // Convert maps back into arrays.\n            const rollBackState = Object.create(null);\n            for (let i = roomJson.timeline.events.length - 1; i >= 0; i--) {\n                const timelineEvent = roomJson.timeline.events[i];\n                if (\n                    (timelineEvent as IStateEvent).state_key === null ||\n                    (timelineEvent as IStateEvent).state_key === undefined\n                ) {\n                    continue; // not a state event\n                }\n                // since we're going back in time, we need to use the previous\n                // state value else we'll break causality. We don't have the\n                // complete previous state event, so we need to create one.\n                const prevStateEvent = deepCopy(timelineEvent);\n                if (prevStateEvent.unsigned) {\n                    if (prevStateEvent.unsigned.prev_content) {\n                        prevStateEvent.content = prevStateEvent.unsigned.prev_content;\n                    }\n                    if (prevStateEvent.unsigned.prev_sender) {\n                        prevStateEvent.sender = prevStateEvent.unsigned.prev_sender;\n                    }\n                }\n                setState(rollBackState, prevStateEvent);\n            }\n            Object.keys(roomData._currentState).forEach((evType) => {\n                Object.keys(roomData._currentState[evType]).forEach((stateKey) => {\n                    let ev = roomData._currentState[evType][stateKey];\n                    // Push to both fields to provide downgrade compatibility in the sync accumulator db\n                    // the code will prefer `state_after` if it is present\n                    roomJson[\"org.matrix.msc4222.state_after\"].events.push(ev);\n                    // Roll the state back to the value at the start of the timeline if it was changed\n                    if (rollBackState[evType] && rollBackState[evType][stateKey]) {\n                        ev = rollBackState[evType][stateKey];\n                    }\n                    roomJson.state.events.push(ev);\n                });\n            });\n            data.join[roomId] = roomJson;\n        });\n\n        // Add account data\n        const accData: IMinimalEvent[] = [];\n        Object.keys(this.accountData).forEach((evType) => {\n            accData.push(this.accountData[evType]);\n        });\n\n        return {\n            nextBatch: this.nextBatch!,\n            roomsData: data,\n            accountData: accData,\n        };\n    }\n\n    public getNextBatchToken(): string {\n        return this.nextBatch!;\n    }\n}\n\nfunction setState(eventMap: Record<string, Record<string, IStateEvent>>, event: IRoomEvent | IStateEvent): void {\n    if ((event as IStateEvent).state_key === null || (event as IStateEvent).state_key === undefined || !event.type) {\n        return;\n    }\n    if (!eventMap[event.type]) {\n        eventMap[event.type] = Object.create(null);\n    }\n    eventMap[event.type][(event as IStateEvent).state_key] = event as IStateEvent;\n}\n","/*\nCopyright 2015 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/*\n * TODO:\n * This class mainly serves to take all the syncing logic out of client.js and\n * into a separate file. It's all very fluid, and this class gut wrenches a lot\n * of MatrixClient props (e.g. http). Given we want to support WebSockets as\n * an alternative syncing API, we may want to have a proper syncing interface\n * for HTTP and WS at some point.\n */\n\nimport type { SyncCryptoCallbacks } from \"./common-crypto/CryptoBackend.ts\";\nimport { User } from \"./models/user.ts\";\nimport { NotificationCountType, Room, RoomEvent } from \"./models/room.ts\";\nimport { deepCopy, noUnsafeEventProps, unsafeProp } from \"./utils.ts\";\nimport { Filter } from \"./filter.ts\";\nimport { EventTimeline } from \"./models/event-timeline.ts\";\nimport { type Logger } from \"./logger.ts\";\nimport {\n    ClientEvent,\n    type IStoredClientOpts,\n    type MatrixClient,\n    PendingEventOrdering,\n    type ResetTimelineCallback,\n} from \"./client.ts\";\nimport {\n    type IEphemeral,\n    type IInvitedRoom,\n    type IInviteState,\n    type IJoinedRoom,\n    type IKnockedRoom,\n    type ILeftRoom,\n    type IMinimalEvent,\n    type IRoomEvent,\n    type IStateEvent,\n    type IStrippedState,\n    type ISyncResponse,\n    type ITimeline,\n    type IToDeviceEvent,\n    type ReceivedToDeviceMessage,\n} from \"./sync-accumulator.ts\";\nimport { MatrixEvent } from \"./models/event.ts\";\nimport { type MatrixError, Method } from \"./http-api/index.ts\";\nimport { type ISavedSync } from \"./store/index.ts\";\nimport { EventType } from \"./@types/event.ts\";\nimport { type IPushRules } from \"./@types/PushRules.ts\";\nimport { type IMarkerFoundOptions, RoomStateEvent } from \"./models/room-state.ts\";\nimport { RoomMemberEvent } from \"./models/room-member.ts\";\nimport { BeaconEvent } from \"./models/beacon.ts\";\nimport { type IEventsResponse } from \"./@types/requests.ts\";\nimport { UNREAD_THREAD_NOTIFICATIONS } from \"./@types/sync.ts\";\nimport { Feature, ServerSupport } from \"./feature.ts\";\nimport { KnownMembership } from \"./@types/membership.ts\";\n\n// /sync requests allow you to set a timeout= but the request may continue\n// beyond that and wedge forever, so we need to track how long we are willing\n// to keep open the connection. This constant is *ADDED* to the timeout= value\n// to determine the max time we're willing to wait.\nconst BUFFER_PERIOD_MS = 80 * 1000;\n\n// Number of consecutive failed syncs that will lead to a syncState of ERROR as opposed\n// to RECONNECTING. This is needed to inform the client of server issues when the\n// keepAlive is successful but the server /sync fails.\nconst FAILED_SYNC_ERROR_THRESHOLD = 3;\n\nexport enum SyncState {\n    /** Emitted after we try to sync more than `FAILED_SYNC_ERROR_THRESHOLD`\n     * times and are still failing. Or when we enounter a hard error like the\n     * token being invalid. */\n    Error = \"ERROR\",\n    /** Emitted after the first sync events are ready (this could even be sync\n     * events from the cache) */\n    Prepared = \"PREPARED\",\n    /** Emitted when the sync loop is no longer running */\n    Stopped = \"STOPPED\",\n    /** Emitted after each sync request happens */\n    Syncing = \"SYNCING\",\n    /** Emitted after a connectivity error and we're ready to start syncing again */\n    Catchup = \"CATCHUP\",\n    /** Emitted for each time we try reconnecting. Will switch to `Error` after\n     * we reach the `FAILED_SYNC_ERROR_THRESHOLD`\n     */\n    Reconnecting = \"RECONNECTING\",\n}\n\n// Room versions where \"insertion\", \"batch\", and \"marker\" events are controlled\n// by power-levels. MSC2716 is supported in existing room versions but they\n// should only have special meaning when the room creator sends them.\nconst MSC2716_ROOM_VERSIONS = [\"org.matrix.msc2716v3\"];\n\nfunction getFilterName(userId: string, suffix?: string): string {\n    // scope this on the user ID because people may login on many accounts\n    // and they all need to be stored!\n    return `FILTER_SYNC_${userId}` + (suffix ? \"_\" + suffix : \"\");\n}\n\n/**\n * Options passed into the constructor of SyncApi by MatrixClient\n */\nexport interface SyncApiOptions {\n    /**\n     * If crypto is enabled on our client, callbacks into the crypto module\n     */\n    cryptoCallbacks?: SyncCryptoCallbacks;\n\n    /**\n     * A function which is called\n     * with a room ID and returns a boolean. It should return 'true' if the SDK can\n     * SAFELY remove events from this room. It may not be safe to remove events if\n     * there are other references to the timelines for this room.\n     */\n    canResetEntireTimeline?: ResetTimelineCallback;\n\n    /** Logger instance to use for writing debug logs. */\n    logger: Logger;\n}\n\ninterface ISyncOptions {\n    filter?: string;\n    hasSyncedBefore?: boolean;\n}\n\nexport interface ISyncStateData {\n    /**\n     * The matrix error if `state=ERROR`.\n     */\n    error?: Error;\n    /**\n     * The 'since' token passed to /sync.\n     *    `null` for the first successful sync since this client was\n     *    started. Only present if `state=PREPARED` or\n     *    `state=SYNCING`.\n     */\n    oldSyncToken?: string;\n    /**\n     * The 'next_batch' result from /sync, which\n     *    will become the 'since' token for the next call to /sync. Only present if\n     *    `state=PREPARED</code> or <code>state=SYNCING`.\n     */\n    nextSyncToken?: string;\n    /**\n     * True if we are working our way through a\n     *    backlog of events after connecting. Only present if `state=SYNCING`.\n     */\n    catchingUp?: boolean;\n    fromCache?: boolean;\n}\n\nexport enum SetPresence {\n    Offline = \"offline\",\n    Online = \"online\",\n    Unavailable = \"unavailable\",\n}\n\ninterface ISyncParams {\n    \"filter\"?: string;\n    \"timeout\": number;\n    \"since\"?: string;\n    // eslint-disable-next-line camelcase\n    \"full_state\"?: boolean;\n    // eslint-disable-next-line camelcase\n    \"set_presence\"?: SetPresence;\n    \"_cacheBuster\"?: string | number; // not part of the API itself\n    \"org.matrix.msc4222.use_state_after\"?: boolean; // https://github.com/matrix-org/matrix-spec-proposals/pull/4222\n}\n\ntype WrappedRoom<T> = T & {\n    room: Room;\n    isBrandNewRoom: boolean;\n};\n\n/** add default settings to an IStoredClientOpts */\nexport function defaultClientOpts(opts?: IStoredClientOpts): IStoredClientOpts {\n    return {\n        initialSyncLimit: 8,\n        resolveInvitesToProfiles: false,\n        pollTimeout: 30 * 1000,\n        pendingEventOrdering: PendingEventOrdering.Chronological,\n        threadSupport: false,\n        ...opts,\n    };\n}\n\nexport function defaultSyncApiOpts(syncOpts: SyncApiOptions): SyncApiOptions {\n    return {\n        canResetEntireTimeline: (_roomId): boolean => false,\n        ...syncOpts,\n    };\n}\n\nexport class SyncApi {\n    private readonly opts: IStoredClientOpts;\n    private readonly syncOpts: SyncApiOptions;\n\n    private _peekRoom: Room | null = null;\n    private currentSyncRequest?: Promise<ISyncResponse>;\n    private abortController?: AbortController;\n    private syncState: SyncState | null = null;\n    private syncStateData?: ISyncStateData; // additional data (eg. error object for failed sync)\n    private catchingUp = false;\n    private running = false;\n    private keepAliveTimer?: ReturnType<typeof setTimeout>;\n    private connectionReturnedResolvers?: PromiseWithResolvers<boolean>;\n    private notifEvents: MatrixEvent[] = []; // accumulator of sync events in the current sync response\n    private failedSyncCount = 0; // Number of consecutive failed /sync requests\n    private storeIsInvalid = false; // flag set if the store needs to be cleared before we can start\n    private presence?: SetPresence;\n\n    /**\n     * Construct an entity which is able to sync with a homeserver.\n     * @param client - The matrix client instance to use.\n     * @param opts - client config options\n     * @param syncOpts - sync-specific options passed by the client\n     * @internal\n     */\n    public constructor(\n        private readonly client: MatrixClient,\n        opts: IStoredClientOpts | undefined,\n        syncOpts: SyncApiOptions,\n    ) {\n        this.opts = defaultClientOpts(opts);\n        this.syncOpts = defaultSyncApiOpts(syncOpts);\n\n        if (client.getNotifTimelineSet()) {\n            client.reEmitter.reEmit(client.getNotifTimelineSet()!, [RoomEvent.Timeline, RoomEvent.TimelineReset]);\n        }\n    }\n\n    public createRoom(roomId: string): Room {\n        const room = _createAndReEmitRoom(this.client, roomId, this.opts);\n\n        room.on(RoomStateEvent.Marker, (markerEvent, markerFoundOptions) => {\n            this.onMarkerStateEvent(room, markerEvent, markerFoundOptions);\n        });\n\n        return room;\n    }\n\n    /** When we see the marker state change in the room, we know there is some\n     * new historical messages imported by MSC2716 `/batch_send` somewhere in\n     * the room and we need to throw away the timeline to make sure the\n     * historical messages are shown when we paginate `/messages` again.\n     * @param room - The room where the marker event was sent\n     * @param markerEvent - The new marker event\n     * @param setStateOptions - When `timelineWasEmpty` is set\n     * as `true`, the given marker event will be ignored\n     */\n    private onMarkerStateEvent(\n        room: Room,\n        markerEvent: MatrixEvent,\n        { timelineWasEmpty }: IMarkerFoundOptions = {},\n    ): void {\n        // We don't need to refresh the timeline if it was empty before the\n        // marker arrived. This could be happen in a variety of cases:\n        //  1. From the initial sync\n        //  2. If it's from the first state we're seeing after joining the room\n        //  3. Or whether it's coming from `syncFromCache`\n        if (timelineWasEmpty) {\n            this.syncOpts.logger.debug(\n                `MarkerState: Ignoring markerEventId=${markerEvent.getId()} in roomId=${room.roomId} ` +\n                    `because the timeline was empty before the marker arrived which means there is nothing to refresh.`,\n            );\n            return;\n        }\n\n        const isValidMsc2716Event =\n            // Check whether the room version directly supports MSC2716, in\n            // which case, \"marker\" events are already auth'ed by\n            // power_levels\n            MSC2716_ROOM_VERSIONS.includes(room.getVersion()) ||\n            // MSC2716 is also supported in all existing room versions but\n            // special meaning should only be given to \"insertion\", \"batch\",\n            // and \"marker\" events when they come from the room creator\n            markerEvent.getSender() === room.getCreator();\n\n        // It would be nice if we could also specifically tell whether the\n        // historical messages actually affected the locally cached client\n        // timeline or not. The problem is we can't see the prev_events of\n        // the base insertion event that the marker was pointing to because\n        // prev_events aren't available in the client API's. In most cases,\n        // the history won't be in people's locally cached timelines in the\n        // client, so we don't need to bother everyone about refreshing\n        // their timeline. This works for a v1 though and there are use\n        // cases like initially bootstrapping your bridged room where people\n        // are likely to encounter the historical messages affecting their\n        // current timeline (think someone signing up for Beeper and\n        // importing their Whatsapp history).\n        if (isValidMsc2716Event) {\n            // Saw new marker event, let's let the clients know they should\n            // refresh the timeline.\n            this.syncOpts.logger.debug(\n                `MarkerState: Timeline needs to be refreshed because ` +\n                    `a new markerEventId=${markerEvent.getId()} was sent in roomId=${room.roomId}`,\n            );\n            room.setTimelineNeedsRefresh(true);\n            room.emit(RoomEvent.HistoryImportedWithinTimeline, markerEvent, room);\n        } else {\n            this.syncOpts.logger.debug(\n                `MarkerState: Ignoring markerEventId=${markerEvent.getId()} in roomId=${room.roomId} because ` +\n                    `MSC2716 is not supported in the room version or for any room version, the marker wasn't sent ` +\n                    `by the room creator.`,\n            );\n        }\n    }\n\n    /**\n     * Sync rooms the user has left.\n     * @returns Resolved when they've been added to the store.\n     */\n    public async syncLeftRooms(): Promise<Room[]> {\n        const client = this.client;\n\n        // grab a filter with limit=1 and include_leave=true\n        const filter = new Filter(this.client.credentials.userId);\n        filter.setTimelineLimit(1);\n        filter.setIncludeLeaveRooms(true);\n\n        const localTimeoutMs = this.opts.pollTimeout! + BUFFER_PERIOD_MS;\n\n        const filterId = await client.getOrCreateFilter(\n            getFilterName(client.credentials.userId!, \"LEFT_ROOMS\"),\n            filter,\n        );\n\n        const qps: ISyncParams = {\n            \"timeout\": 0, // don't want to block since this is a single isolated req\n            \"filter\": filterId,\n            \"org.matrix.msc4222.use_state_after\": true,\n        };\n\n        const data = await client.http.authedRequest<ISyncResponse>(Method.Get, \"/sync\", qps as any, undefined, {\n            localTimeoutMs,\n        });\n\n        let leaveRooms: WrappedRoom<ILeftRoom>[] = [];\n        if (data.rooms?.leave) {\n            leaveRooms = this.mapSyncResponseToRoomArray(data.rooms.leave);\n        }\n\n        const rooms = await Promise.all(\n            leaveRooms.map(async (leaveObj) => {\n                const room = leaveObj.room;\n                if (!leaveObj.isBrandNewRoom) {\n                    // the intention behind syncLeftRooms is to add in rooms which were\n                    // *omitted* from the initial /sync. Rooms the user were joined to\n                    // but then left whilst the app is running will appear in this list\n                    // and we do not want to bother with them since they will have the\n                    // current state already (and may get dupe messages if we add\n                    // yet more timeline events!), so skip them.\n                    // NB: When we persist rooms to localStorage this will be more\n                    //     complicated...\n                    return;\n                }\n                leaveObj.timeline = leaveObj.timeline || {\n                    prev_batch: null,\n                    events: [],\n                };\n\n                // set the back-pagination token. Do this *before* adding any\n                // events so that clients can start back-paginating.\n                room.getLiveTimeline().setPaginationToken(leaveObj.timeline.prev_batch, EventTimeline.BACKWARDS);\n\n                const { timelineEvents } = await this.mapAndInjectRoomEvents(leaveObj);\n\n                room.recalculate();\n                client.store.storeRoom(room);\n                client.emit(ClientEvent.Room, room);\n\n                this.processEventsForNotifs(room, timelineEvents);\n                return room;\n            }),\n        );\n\n        return rooms.filter(Boolean) as Room[];\n    }\n\n    /**\n     * Peek into a room. This will result in the room in question being synced so it\n     * is accessible via getRooms(). Live updates for the room will be provided.\n     * @param roomId - The room ID to peek into.\n     * @param limit - The number of timeline events to initially retrieve.\n     * @returns A promise which resolves once the room has been added to the\n     * store.\n     */\n    public peek(roomId: string, limit: number = 20): Promise<Room> {\n        if (this._peekRoom?.roomId === roomId) {\n            return Promise.resolve(this._peekRoom);\n        }\n\n        const client = this.client;\n        this._peekRoom = this.createRoom(roomId);\n        return this.client.roomInitialSync(roomId, limit).then((response) => {\n            if (this._peekRoom?.roomId !== roomId) {\n                throw new Error(\"Peeking aborted\");\n            }\n\n            // make sure things are init'd\n            response.messages = response.messages || { chunk: [] };\n            response.messages.chunk = response.messages.chunk || [];\n            response.state = response.state || [];\n\n            // FIXME: Mostly duplicated from injectRoomEvents but not entirely\n            // because \"state\" in this API is at the BEGINNING of the chunk\n            const oldStateEvents = deepCopy(response.state).map(client.getEventMapper());\n            const stateEvents = response.state.map(client.getEventMapper());\n            const messages = response.messages.chunk.map(client.getEventMapper());\n\n            // XXX: copypasted from /sync until we kill off this minging v1 API stuff)\n            // handle presence events (User objects)\n            if (Array.isArray(response.presence)) {\n                response.presence.map(client.getEventMapper()).forEach(function (presenceEvent) {\n                    let user = client.store.getUser(presenceEvent.getContent().user_id);\n                    if (user) {\n                        user.setPresenceEvent(presenceEvent);\n                    } else {\n                        user = User.createUser(presenceEvent.getContent().user_id, client);\n                        user.setPresenceEvent(presenceEvent);\n                        client.store.storeUser(user);\n                    }\n                    client.emit(ClientEvent.Event, presenceEvent);\n                });\n            }\n\n            // set the pagination token before adding the events in case people\n            // fire off pagination requests in response to the Room.timeline\n            // events.\n            if (response.messages.start) {\n                this._peekRoom.oldState.paginationToken = response.messages.start;\n            }\n\n            // set the state of the room to as it was after the timeline executes\n            this._peekRoom.oldState.setStateEvents(oldStateEvents);\n            this._peekRoom.currentState.setStateEvents(stateEvents);\n\n            this.resolveInvites(this._peekRoom);\n            this._peekRoom.recalculate();\n\n            // roll backwards to diverge old state. addEventsToTimeline\n            // will overwrite the pagination token, so make sure it overwrites\n            // it with the right thing.\n            this._peekRoom.addEventsToTimeline(\n                messages.reverse(),\n                true,\n                true,\n                this._peekRoom.getLiveTimeline(),\n                response.messages.start,\n            );\n\n            client.store.storeRoom(this._peekRoom);\n            client.emit(ClientEvent.Room, this._peekRoom);\n\n            this.peekPoll(this._peekRoom);\n            return this._peekRoom;\n        });\n    }\n\n    /**\n     * Stop polling for updates in the peeked room. NOPs if there is no room being\n     * peeked.\n     */\n    public stopPeeking(): void {\n        this._peekRoom = null;\n    }\n\n    /**\n     * Do a peek room poll.\n     * @param token - from= token\n     */\n    private peekPoll(peekRoom: Room, token?: string): void {\n        if (this._peekRoom !== peekRoom) {\n            this.syncOpts.logger.debug(\"Stopped peeking in room %s\", peekRoom.roomId);\n            return;\n        }\n\n        // FIXME: gut wrenching; hard-coded timeout values\n        this.client.http\n            .authedRequest<IEventsResponse>(\n                Method.Get,\n                \"/events\",\n                {\n                    room_id: peekRoom.roomId,\n                    timeout: String(30 * 1000),\n                    from: token,\n                },\n                undefined,\n                {\n                    localTimeoutMs: 50 * 1000,\n                    abortSignal: this.abortController?.signal,\n                },\n            )\n            .then(\n                async (res) => {\n                    if (this._peekRoom !== peekRoom) {\n                        this.syncOpts.logger.debug(\"Stopped peeking in room %s\", peekRoom.roomId);\n                        return;\n                    }\n                    // We have a problem that we get presence both from /events and /sync\n                    // however, /sync only returns presence for users in rooms\n                    // you're actually joined to.\n                    // in order to be sure to get presence for all of the users in the\n                    // peeked room, we handle presence explicitly here. This may result\n                    // in duplicate presence events firing for some users, which is a\n                    // performance drain, but such is life.\n                    // XXX: copypasted from /sync until we can kill this minging v1 stuff.\n\n                    res.chunk\n                        .filter(function (e) {\n                            return e.type === \"m.presence\";\n                        })\n                        .map(this.client.getEventMapper())\n                        .forEach((presenceEvent) => {\n                            let user = this.client.store.getUser(presenceEvent.getContent().user_id);\n                            if (user) {\n                                user.setPresenceEvent(presenceEvent);\n                            } else {\n                                user = User.createUser(presenceEvent.getContent().user_id, this.client);\n                                user.setPresenceEvent(presenceEvent);\n                                this.client.store.storeUser(user);\n                            }\n                            this.client.emit(ClientEvent.Event, presenceEvent);\n                        });\n\n                    // strip out events which aren't for the given room_id (e.g presence)\n                    // and also ephemeral events (which we're assuming is anything without\n                    // and event ID because the /events API doesn't separate them).\n                    const events = res.chunk\n                        .filter(function (e) {\n                            return e.room_id === peekRoom.roomId && e.event_id;\n                        })\n                        .map(this.client.getEventMapper());\n\n                    await peekRoom.addLiveEvents(events, { addToState: true });\n                    this.peekPoll(peekRoom, res.end);\n                },\n                (err) => {\n                    this.syncOpts.logger.error(\"[%s] Peek poll failed: %s\", peekRoom.roomId, err);\n                    setTimeout(() => {\n                        this.peekPoll(peekRoom, token);\n                    }, 30 * 1000);\n                },\n            );\n    }\n\n    /**\n     * Returns the current state of this sync object\n     * @see MatrixClient#event:\"sync\"\n     */\n    public getSyncState(): SyncState | null {\n        return this.syncState;\n    }\n\n    /**\n     * Returns the additional data object associated with\n     * the current sync state, or null if there is no\n     * such data.\n     * Sync errors, if available, are put in the 'error' key of\n     * this object.\n     */\n    public getSyncStateData(): ISyncStateData | null {\n        return this.syncStateData ?? null;\n    }\n\n    public async recoverFromSyncStartupError(savedSyncPromise: Promise<void> | undefined, error: Error): Promise<void> {\n        // Wait for the saved sync to complete - we send the pushrules and filter requests\n        // before the saved sync has finished so they can run in parallel, but only process\n        // the results after the saved sync is done. Equivalently, we wait for it to finish\n        // before reporting failures from these functions.\n        await savedSyncPromise;\n        const keepaliveProm = this.startKeepAlives();\n        this.updateSyncState(SyncState.Error, { error });\n        await keepaliveProm;\n    }\n\n    private shouldAbortSync(error: MatrixError): boolean {\n        if (error.errcode === \"M_UNKNOWN_TOKEN\") {\n            // The logout already happened, we just need to stop.\n            this.syncOpts.logger.warn(\"Token no longer valid - assuming logout\");\n            this.stop();\n            this.updateSyncState(SyncState.Error, { error });\n            return true;\n        }\n        return false;\n    }\n\n    private getPushRules = async (): Promise<void> => {\n        try {\n            this.syncOpts.logger.debug(\"Getting push rules...\");\n            const result = await this.client.getPushRules();\n            this.syncOpts.logger.debug(\"Got push rules\");\n\n            this.client.pushRules = result;\n        } catch (err) {\n            this.syncOpts.logger.error(\"Getting push rules failed\", err);\n            if (this.shouldAbortSync(<MatrixError>err)) return;\n            // wait for saved sync to complete before doing anything else,\n            // otherwise the sync state will end up being incorrect\n            this.syncOpts.logger.debug(\"Waiting for saved sync before retrying push rules...\");\n            await this.recoverFromSyncStartupError(this.savedSyncPromise, <Error>err);\n            return this.getPushRules(); // try again\n        }\n    };\n\n    private buildDefaultFilter = (): Filter => {\n        const filter = new Filter(this.client.credentials.userId);\n        if (this.client.canSupport.get(Feature.ThreadUnreadNotifications) !== ServerSupport.Unsupported) {\n            filter.setUnreadThreadNotifications(true);\n        }\n        return filter;\n    };\n\n    private prepareLazyLoadingForSync = async (): Promise<void> => {\n        this.syncOpts.logger.debug(\"Prepare lazy loading for sync...\");\n        if (this.client.isGuest()) {\n            this.opts.lazyLoadMembers = false;\n        }\n        if (this.opts.lazyLoadMembers) {\n            this.syncOpts.logger.debug(\"Enabling lazy load on sync filter...\");\n            if (!this.opts.filter) {\n                this.opts.filter = this.buildDefaultFilter();\n            }\n            this.opts.filter.setLazyLoadMembers(true);\n        }\n    };\n\n    private storeClientOptions = async (): Promise<void> => {\n        try {\n            this.syncOpts.logger.debug(\"Storing client options...\");\n            await this.client.storeClientOptions();\n            this.syncOpts.logger.debug(\"Stored client options\");\n        } catch (err) {\n            this.syncOpts.logger.error(\"Storing client options failed\", err);\n            throw err;\n        }\n    };\n\n    private getFilter = async (): Promise<{\n        filterId?: string;\n        filter?: Filter;\n    }> => {\n        this.syncOpts.logger.debug(\"Getting filter...\");\n        let filter: Filter;\n        if (this.opts.filter) {\n            filter = this.opts.filter;\n        } else {\n            filter = this.buildDefaultFilter();\n        }\n\n        let filterId: string;\n        try {\n            filterId = await this.client.getOrCreateFilter(getFilterName(this.client.credentials.userId!), filter);\n        } catch (err) {\n            this.syncOpts.logger.error(\"Getting filter failed\", err);\n            if (this.shouldAbortSync(<MatrixError>err)) return {};\n            // wait for saved sync to complete before doing anything else,\n            // otherwise the sync state will end up being incorrect\n            this.syncOpts.logger.debug(\"Waiting for saved sync before retrying filter...\");\n            await this.recoverFromSyncStartupError(this.savedSyncPromise, <Error>err);\n            return this.getFilter(); // try again\n        }\n        return { filter, filterId };\n    };\n\n    private savedSyncPromise?: Promise<void>;\n\n    /**\n     * Main entry point\n     */\n    public async sync(): Promise<void> {\n        this.running = true;\n        this.abortController = new AbortController();\n\n        globalThis.window?.addEventListener?.(\"online\", this.onOnline, false);\n\n        if (this.client.isGuest()) {\n            // no push rules for guests, no access to POST filter for guests.\n            return this.doSync({});\n        }\n\n        // Pull the saved sync token out first, before the worker starts sending\n        // all the sync data which could take a while. This will let us send our\n        // first incremental sync request before we've processed our saved data.\n        this.syncOpts.logger.debug(\"Getting saved sync token...\");\n        const savedSyncTokenPromise = this.client.store.getSavedSyncToken().then((tok) => {\n            this.syncOpts.logger.debug(\"Got saved sync token\");\n            return tok;\n        });\n\n        this.savedSyncPromise = this.client.store\n            .getSavedSync()\n            .then((savedSync) => {\n                this.syncOpts.logger.debug(`Got reply from saved sync, exists? ${!!savedSync}`);\n                if (savedSync) {\n                    return this.syncFromCache(savedSync);\n                }\n            })\n            .catch((err) => {\n                this.syncOpts.logger.error(\"Getting saved sync failed\", err);\n            });\n\n        // We need to do one-off checks before we can begin the /sync loop.\n        // These are:\n        //   1) We need to get push rules so we can check if events should bing as we get\n        //      them from /sync.\n        //   2) We need to get/create a filter which we can use for /sync.\n        //   3) We need to prepare lazy loading for sync\n        //   4) We need to store the client options\n\n        // Now start the first incremental sync request: this can also\n        // take a while so if we set it going now, we can wait for it\n        // to finish while we process our saved sync data.\n        await this.getPushRules();\n        await this.prepareLazyLoadingForSync();\n        await this.storeClientOptions();\n\n        const { filterId, filter } = await this.getFilter();\n        if (!filter) return; // bail, getFilter failed\n\n        // reset the notifications timeline to prepare it to paginate from\n        // the current point in time.\n        // The right solution would be to tie /sync pagination tokens into\n        // /notifications API somehow.\n        this.client.resetNotifTimelineSet();\n\n        if (!this.currentSyncRequest) {\n            let firstSyncFilter = filterId;\n            const savedSyncToken = await savedSyncTokenPromise;\n\n            if (savedSyncToken) {\n                this.syncOpts.logger.debug(\"Sending first sync request...\");\n            } else {\n                this.syncOpts.logger.debug(\"Sending initial sync request...\");\n                const initialFilter = this.buildDefaultFilter();\n                initialFilter.setDefinition(filter.getDefinition());\n                initialFilter.setTimelineLimit(this.opts.initialSyncLimit!);\n                // Use an inline filter, no point uploading it for a single usage\n                firstSyncFilter = JSON.stringify(initialFilter.getDefinition());\n            }\n\n            // Send this first sync request here so we can then wait for the saved\n            // sync data to finish processing before we process the results of this one.\n            this.currentSyncRequest = this.doSyncRequest({ filter: firstSyncFilter }, savedSyncToken);\n        }\n\n        // Now wait for the saved sync to finish...\n        this.syncOpts.logger.debug(\"Waiting for saved sync before starting sync processing...\");\n        await this.savedSyncPromise;\n        // process the first sync request and continue syncing with the normal filterId\n        return this.doSync({ filter: filterId });\n    }\n\n    /**\n     * Stops the sync object from syncing.\n     */\n    public stop(): void {\n        this.syncOpts.logger.debug(\"SyncApi.stop\");\n        // It is necessary to check for the existance of\n        // globalThis.window AND globalThis.window.removeEventListener.\n        // Some platforms (e.g. React Native) register globalThis.window,\n        // but do not have globalThis.window.removeEventListener.\n        globalThis.window?.removeEventListener?.(\"online\", this.onOnline, false);\n        this.running = false;\n        this.abortController?.abort();\n        if (this.keepAliveTimer) {\n            clearTimeout(this.keepAliveTimer);\n            this.keepAliveTimer = undefined;\n        }\n    }\n\n    /**\n     * Retry a backed off syncing request immediately. This should only be used when\n     * the user <b>explicitly</b> attempts to retry their lost connection.\n     * @returns True if this resulted in a request being retried.\n     */\n    public retryImmediately(): boolean {\n        if (!this.connectionReturnedResolvers) {\n            return false;\n        }\n        this.startKeepAlives(0);\n        return true;\n    }\n    /**\n     * Process a single set of cached sync data.\n     * @param savedSync - a saved sync that was persisted by a store. This\n     * should have been acquired via client.store.getSavedSync().\n     */\n    private async syncFromCache(savedSync: ISavedSync): Promise<void> {\n        this.syncOpts.logger.debug(\"sync(): not doing HTTP hit, instead returning stored /sync data\");\n\n        const nextSyncToken = savedSync.nextBatch;\n\n        // Set sync token for future incremental syncing\n        this.client.store.setSyncToken(nextSyncToken);\n\n        // No previous sync, set old token to null\n        const syncEventData: ISyncStateData = {\n            nextSyncToken,\n            catchingUp: false,\n            fromCache: true,\n        };\n\n        const data: ISyncResponse = {\n            next_batch: nextSyncToken,\n            rooms: savedSync.roomsData,\n            account_data: {\n                events: savedSync.accountData,\n            },\n        };\n\n        try {\n            await this.processSyncResponse(syncEventData, data);\n        } catch (e) {\n            this.syncOpts.logger.error(\"Error processing cached sync\", e);\n        }\n\n        // Don't emit a prepared if we've bailed because the store is invalid:\n        // in this case the client will not be usable until stopped & restarted\n        // so this would be useless and misleading.\n        if (!this.storeIsInvalid) {\n            this.updateSyncState(SyncState.Prepared, syncEventData);\n        }\n    }\n\n    /**\n     * Invoke me to do /sync calls\n     */\n    private async doSync(syncOptions: ISyncOptions): Promise<void> {\n        while (this.running) {\n            const syncToken = this.client.store.getSyncToken();\n\n            let data: ISyncResponse;\n            try {\n                if (!this.currentSyncRequest) {\n                    this.currentSyncRequest = this.doSyncRequest(syncOptions, syncToken);\n                }\n                data = await this.currentSyncRequest;\n            } catch (e) {\n                const abort = await this.onSyncError(<MatrixError>e);\n                if (abort) return;\n                continue;\n            } finally {\n                this.currentSyncRequest = undefined;\n            }\n\n            // set the sync token NOW *before* processing the events. We do this so\n            // if something barfs on an event we can skip it rather than constantly\n            // polling with the same token.\n            this.client.store.setSyncToken(data.next_batch);\n\n            // Reset after a successful sync\n            this.failedSyncCount = 0;\n\n            const syncEventData = {\n                oldSyncToken: syncToken ?? undefined,\n                nextSyncToken: data.next_batch,\n                catchingUp: this.catchingUp,\n            };\n\n            try {\n                await this.processSyncResponse(syncEventData, data);\n            } catch (e) {\n                // log the exception with stack if we have it, else fall back\n                // to the plain description\n                this.syncOpts.logger.error(\"Caught /sync error\", e);\n\n                // Emit the exception for client handling\n                this.client.emit(ClientEvent.SyncUnexpectedError, <Error>e);\n            }\n\n            // Persist after processing as `unsigned` may get mutated\n            // with an `org.matrix.msc4023.thread_id`\n            await this.client.store.setSyncData(data);\n\n            // update this as it may have changed\n            syncEventData.catchingUp = this.catchingUp;\n\n            // emit synced events\n            if (!syncOptions.hasSyncedBefore) {\n                this.updateSyncState(SyncState.Prepared, syncEventData);\n                syncOptions.hasSyncedBefore = true;\n            }\n\n            // tell the crypto module to do its processing. It may block (to do a\n            // /keys/changes request).\n            if (this.syncOpts.cryptoCallbacks) {\n                await this.syncOpts.cryptoCallbacks.onSyncCompleted(syncEventData);\n            }\n\n            // keep emitting SYNCING -> SYNCING for clients who want to do bulk updates\n            this.updateSyncState(SyncState.Syncing, syncEventData);\n\n            if (this.client.store.wantsSave()) {\n                // tell databases that everything is now in a consistent state and can be saved.\n                await this.client.store.save();\n            }\n        }\n\n        if (!this.running) {\n            this.syncOpts.logger.debug(\"Sync no longer running: exiting.\");\n            if (this.connectionReturnedResolvers) {\n                this.connectionReturnedResolvers.reject();\n                this.connectionReturnedResolvers = undefined;\n            }\n            this.updateSyncState(SyncState.Stopped);\n        }\n    }\n\n    private doSyncRequest(syncOptions: ISyncOptions, syncToken: string | null): Promise<ISyncResponse> {\n        const qps = this.getSyncParams(syncOptions, syncToken);\n        return this.client.http.authedRequest<ISyncResponse>(Method.Get, \"/sync\", qps as any, undefined, {\n            localTimeoutMs: qps.timeout + BUFFER_PERIOD_MS,\n            abortSignal: this.abortController?.signal,\n        });\n    }\n\n    private getSyncParams(syncOptions: ISyncOptions, syncToken: string | null): ISyncParams {\n        let timeout = this.opts.pollTimeout!;\n\n        if (this.getSyncState() !== SyncState.Syncing || this.catchingUp) {\n            // unless we are happily syncing already, we want the server to return\n            // as quickly as possible, even if there are no events queued. This\n            // serves two purposes:\n            //\n            // * When the connection dies, we want to know asap when it comes back,\n            //   so that we can hide the error from the user. (We don't want to\n            //   have to wait for an event or a timeout).\n            //\n            // * We want to know if the server has any to_device messages queued up\n            //   for us. We do that by calling it with a zero timeout until it\n            //   doesn't give us any more to_device messages.\n            this.catchingUp = true;\n            timeout = 0;\n        }\n\n        let filter = syncOptions.filter;\n        if (this.client.isGuest() && !filter) {\n            filter = this.getGuestFilter();\n        }\n\n        const qps: ISyncParams = {\n            filter,\n            timeout,\n            \"org.matrix.msc4222.use_state_after\": true,\n        };\n\n        if (this.opts.disablePresence) {\n            qps.set_presence = SetPresence.Offline;\n        } else if (this.presence !== undefined) {\n            qps.set_presence = this.presence;\n        }\n\n        if (syncToken) {\n            qps.since = syncToken;\n        } else {\n            // use a cachebuster for initialsyncs, to make sure that\n            // we don't get a stale sync\n            // (https://github.com/vector-im/vector-web/issues/1354)\n            qps._cacheBuster = Date.now();\n        }\n\n        if ([SyncState.Reconnecting, SyncState.Error].includes(this.getSyncState()!)) {\n            // we think the connection is dead. If it comes back up, we won't know\n            // about it till /sync returns. If the timeout= is high, this could\n            // be a long time. Set it to 0 when doing retries so we don't have to wait\n            // for an event or a timeout before emiting the SYNCING event.\n            qps.timeout = 0;\n        }\n\n        return qps;\n    }\n\n    /**\n     * Specify the set_presence value to be used for subsequent calls to the Sync API.\n     * @param presence - the presence to specify to set_presence of sync calls\n     */\n    public setPresence(presence?: SetPresence): void {\n        this.presence = presence;\n    }\n\n    private async onSyncError(err: MatrixError): Promise<boolean> {\n        if (!this.running) {\n            this.syncOpts.logger.debug(\"Sync no longer running: exiting\");\n            if (this.connectionReturnedResolvers) {\n                this.connectionReturnedResolvers.reject();\n                this.connectionReturnedResolvers = undefined;\n            }\n            this.updateSyncState(SyncState.Stopped);\n            return true; // abort\n        }\n\n        this.syncOpts.logger.error(\"/sync error %s\", err);\n\n        if (this.shouldAbortSync(err)) {\n            return true; // abort\n        }\n\n        this.failedSyncCount++;\n        this.syncOpts.logger.debug(\"Number of consecutive failed sync requests:\", this.failedSyncCount);\n\n        this.syncOpts.logger.debug(\"Starting keep-alive\");\n        // Note that we do *not* mark the sync connection as\n        // lost yet: we only do this if a keepalive poke\n        // fails, since long lived HTTP connections will\n        // go away sometimes and we shouldn't treat this as\n        // erroneous. We set the state to 'reconnecting'\n        // instead, so that clients can observe this state\n        // if they wish.\n        const keepAlivePromise = this.startKeepAlives();\n\n        this.currentSyncRequest = undefined;\n        // Transition from RECONNECTING to ERROR after a given number of failed syncs\n        this.updateSyncState(\n            this.failedSyncCount >= FAILED_SYNC_ERROR_THRESHOLD ? SyncState.Error : SyncState.Reconnecting,\n            { error: err },\n        );\n\n        const connDidFail = await keepAlivePromise;\n\n        // Only emit CATCHUP if we detected a connectivity error: if we didn't,\n        // it's quite likely the sync will fail again for the same reason and we\n        // want to stay in ERROR rather than keep flip-flopping between ERROR\n        // and CATCHUP.\n        if (connDidFail && this.getSyncState() === SyncState.Error) {\n            this.updateSyncState(SyncState.Catchup, {\n                catchingUp: true,\n            });\n        }\n        return false;\n    }\n\n    /**\n     * Process data returned from a sync response and propagate it\n     * into the model objects\n     *\n     * @param syncEventData - Object containing sync tokens associated with this sync\n     * @param data - The response from /sync\n     */\n    private async processSyncResponse(syncEventData: ISyncStateData, data: ISyncResponse): Promise<void> {\n        const client = this.client;\n\n        // data looks like:\n        // {\n        //    next_batch: $token,\n        //    presence: { events: [] },\n        //    account_data: { events: [] },\n        //    device_lists: { changed: [\"@user:server\", ... ]},\n        //    to_device: { events: [] },\n        //    device_one_time_keys_count: { signed_curve25519: 42 },\n        //    rooms: {\n        //      invite: {\n        //        $roomid: {\n        //          invite_state: { events: [] }\n        //        }\n        //      },\n        //      join: {\n        //        $roomid: {\n        //          state: { events: [] },\n        //          timeline: { events: [], prev_batch: $token, limited: true },\n        //          ephemeral: { events: [] },\n        //          summary: {\n        //             m.heroes: [ $user_id ],\n        //             m.joined_member_count: $count,\n        //             m.invited_member_count: $count\n        //          },\n        //          account_data: { events: [] },\n        //          unread_notifications: {\n        //              highlight_count: 0,\n        //              notification_count: 0,\n        //          }\n        //          \"org.matrix.msc4222.state_after\": { events: [] },  // only if \"org.matrix.msc4222.use_state_after\" is true\n        //          msc4354_sticky: { events: [] }, // only if \"org.matrix.msc4354.sticky\" is true\n        //        }\n        //      },\n        //      leave: {\n        //        $roomid: {\n        //          state: { events: [] },\n        //          timeline: { events: [], prev_batch: $token }\n        //        }\n        //      }\n        //    }\n        // }\n\n        // TODO-arch:\n        // - Each event we pass through needs to be emitted via 'event', can we\n        //   do this in one place?\n        // - The isBrandNewRoom boilerplate is boilerplatey.\n\n        // handle presence events (User objects)\n        if (Array.isArray(data.presence?.events)) {\n            data.presence!.events.filter(noUnsafeEventProps)\n                .map(client.getEventMapper())\n                .forEach(function (presenceEvent) {\n                    let user = client.store.getUser(presenceEvent.getSender()!);\n                    if (user) {\n                        user.setPresenceEvent(presenceEvent);\n                    } else {\n                        user = User.createUser(presenceEvent.getSender()!, client);\n                        user.setPresenceEvent(presenceEvent);\n                        client.store.storeUser(user);\n                    }\n                    client.emit(ClientEvent.Event, presenceEvent);\n                });\n        }\n\n        // handle non-room account_data\n        if (Array.isArray(data.account_data?.events)) {\n            const events = data.account_data.events.filter(noUnsafeEventProps).map(client.getEventMapper());\n            const prevEventsMap = events.reduce<Record<string, MatrixEvent | undefined>>((m, c) => {\n                m[c.getType()!] = client.store.getAccountData(c.getType());\n                return m;\n            }, {});\n            client.store.storeAccountDataEvents(events);\n            events.forEach(function (accountDataEvent) {\n                // Honour push rules that come down the sync stream but also\n                // honour push rules that were previously cached. Base rules\n                // will be updated when we receive push rules via getPushRules\n                // (see sync) before syncing over the network.\n                if (accountDataEvent.getType() === EventType.PushRules) {\n                    const rules = accountDataEvent.getContent<IPushRules>();\n                    client.setPushRules(rules);\n                }\n                const prevEvent = prevEventsMap[accountDataEvent.getType()!];\n                client.emit(ClientEvent.AccountData, accountDataEvent, prevEvent);\n                return accountDataEvent;\n            });\n        }\n\n        // handle to-device events\n        if (data.to_device && Array.isArray(data.to_device.events) && data.to_device.events.length > 0) {\n            const toDeviceMessages: IToDeviceEvent[] = data.to_device.events.filter(noUnsafeEventProps);\n\n            let receivedToDeviceMessages: ReceivedToDeviceMessage[];\n            if (this.syncOpts.cryptoCallbacks) {\n                receivedToDeviceMessages =\n                    await this.syncOpts.cryptoCallbacks.preprocessToDeviceMessages(toDeviceMessages);\n            } else {\n                receivedToDeviceMessages = toDeviceMessages.map((rawEvent) =>\n                    // Crypto is not enabled, so we just return the events.\n                    ({\n                        message: rawEvent,\n                        encryptionInfo: null,\n                    }),\n                );\n            }\n\n            processToDeviceMessages(receivedToDeviceMessages, client);\n        } else {\n            // no more to-device events: we can stop polling with a short timeout.\n            this.catchingUp = false;\n        }\n\n        // the returned json structure is a bit crap, so make it into a\n        // nicer form (array) after applying sanity to make sure we don't fail\n        // on missing keys (on the off chance)\n        let inviteRooms: WrappedRoom<IInvitedRoom>[] = [];\n        let joinRooms: WrappedRoom<IJoinedRoom>[] = [];\n        let leaveRooms: WrappedRoom<ILeftRoom>[] = [];\n        let knockRooms: WrappedRoom<IKnockedRoom>[] = [];\n\n        if (data.rooms) {\n            if (data.rooms.invite) {\n                inviteRooms = this.mapSyncResponseToRoomArray(data.rooms.invite);\n            }\n            if (data.rooms.join) {\n                joinRooms = this.mapSyncResponseToRoomArray(data.rooms.join);\n            }\n            if (data.rooms.leave) {\n                leaveRooms = this.mapSyncResponseToRoomArray(data.rooms.leave);\n            }\n            if (data.rooms.knock) {\n                knockRooms = this.mapSyncResponseToRoomArray(data.rooms.knock);\n            }\n        }\n\n        this.notifEvents = [];\n\n        // Handle invites\n        await Promise.all(\n            inviteRooms.map(async (inviteObj) => {\n                const room = inviteObj.room;\n                const stateEvents = this.mapSyncEventsFormat(inviteObj.invite_state, room);\n\n                await this.injectRoomEvents(room, stateEvents, undefined);\n\n                if (inviteObj.isBrandNewRoom) {\n                    room.recalculate();\n                    client.store.storeRoom(room);\n                    client.emit(ClientEvent.Room, room);\n                } else {\n                    // Update room state for invite->reject->invite cycles\n                    room.recalculate();\n                }\n                stateEvents.forEach(function (e) {\n                    client.emit(ClientEvent.Event, e);\n                });\n            }),\n        );\n\n        // Handle joins\n        await Promise.all(\n            joinRooms.map(async (joinObj) => {\n                const room = joinObj.room;\n                const stateEvents = this.mapSyncEventsFormat(joinObj.state, room);\n                const stateAfterEvents = this.mapSyncEventsFormat(joinObj[\"org.matrix.msc4222.state_after\"], room);\n                // Prevent events from being decrypted ahead of time\n                // this helps large account to speed up faster\n                // room::decryptCriticalEvent is in charge of decrypting all the events\n                // required for a client to function properly\n                const timelineEvents = this.mapSyncEventsFormat(joinObj.timeline, room, false);\n                const ephemeralEvents = this.mapSyncEventsFormat(joinObj.ephemeral);\n                const accountDataEvents = this.mapSyncEventsFormat(joinObj.account_data);\n                const stickyEvents = this.mapSyncEventsFormat(joinObj.msc4354_sticky);\n\n                // If state_after is present, this is the events that form the state at the end of the timeline block and\n                // regular timeline events do *not* count towards state. If it's not present, then the state is formed by\n                // the state events plus the timeline events. Note mapSyncEventsFormat returns an empty array if the field\n                // is absent so we explicitly check the field on the original object.\n                const eventsFormingFinalState = joinObj[\"org.matrix.msc4222.state_after\"]\n                    ? stateAfterEvents\n                    : stateEvents.concat(timelineEvents);\n\n                const encrypted = this.isRoomEncrypted(room, eventsFormingFinalState);\n                // We store the server-provided value first so it's correct when any of the events fire.\n                if (joinObj.unread_notifications) {\n                    /**\n                     * We track unread notifications ourselves in encrypted rooms, so don't\n                     * bother setting it here. We trust our calculations better than the\n                     * server's for this case, and therefore will assume that our non-zero\n                     * count is accurate.\n                     * XXX: this is known faulty as the push rule for `.m.room.encrypted` may be disabled so server\n                     * may issue notification counts of 0 which we wrongly trust.\n                     * https://github.com/matrix-org/matrix-spec-proposals/pull/2654 would fix this\n                     *\n                     * @see import(\"./client\").fixNotificationCountOnDecryption\n                     */\n                    if (!encrypted || joinObj.unread_notifications.notification_count === 0) {\n                        // In an encrypted room, if the room has notifications enabled then it's typical for\n                        // the server to flag all new messages as notifying. However, some push rules calculate\n                        // events as ignored based on their event contents (e.g. ignoring msgtype=m.notice messages)\n                        // so we want to calculate this figure on the client in all cases.\n                        room.setUnreadNotificationCount(\n                            NotificationCountType.Total,\n                            joinObj.unread_notifications.notification_count ?? 0,\n                        );\n                    }\n\n                    if (!encrypted || room.getUnreadNotificationCount(NotificationCountType.Highlight) <= 0) {\n                        // If the locally stored highlight count is zero, use the server provided value.\n                        room.setUnreadNotificationCount(\n                            NotificationCountType.Highlight,\n                            joinObj.unread_notifications.highlight_count ?? 0,\n                        );\n                    }\n                }\n\n                const unreadThreadNotifications =\n                    joinObj[UNREAD_THREAD_NOTIFICATIONS.name] ?? joinObj[UNREAD_THREAD_NOTIFICATIONS.altName!];\n                if (unreadThreadNotifications) {\n                    // This mirrors the logic above for rooms: take the *total* notification count from\n                    // the server for unencrypted rooms or is it's zero. Any threads not present in this\n                    // object implicitly have zero notifications, so start by clearing the total counts\n                    // for all such threads.\n                    room.resetThreadUnreadNotificationCountFromSync(Object.keys(unreadThreadNotifications));\n                    for (const [threadId, unreadNotification] of Object.entries(unreadThreadNotifications)) {\n                        if (!encrypted || unreadNotification.notification_count === 0) {\n                            room.setThreadUnreadNotificationCount(\n                                threadId,\n                                NotificationCountType.Total,\n                                unreadNotification.notification_count ?? 0,\n                            );\n                        }\n\n                        const hasNoNotifications =\n                            room.getThreadUnreadNotificationCount(threadId, NotificationCountType.Highlight) <= 0;\n                        if (!encrypted || (encrypted && hasNoNotifications)) {\n                            room.setThreadUnreadNotificationCount(\n                                threadId,\n                                NotificationCountType.Highlight,\n                                unreadNotification.highlight_count ?? 0,\n                            );\n                        }\n                    }\n                } else {\n                    room.resetThreadUnreadNotificationCountFromSync();\n                }\n\n                joinObj.timeline = joinObj.timeline || ({} as ITimeline);\n\n                if (joinObj.isBrandNewRoom) {\n                    // set the back-pagination token. Do this *before* adding any\n                    // events so that clients can start back-paginating.\n                    if (joinObj.timeline.prev_batch !== null) {\n                        room.getLiveTimeline().setPaginationToken(joinObj.timeline.prev_batch, EventTimeline.BACKWARDS);\n                    }\n                } else if (joinObj.timeline.limited) {\n                    let limited = true;\n\n                    // we've got a limited sync, so we *probably* have a gap in the\n                    // timeline, so should reset. But we might have been peeking or\n                    // paginating and already have some of the events, in which\n                    // case we just want to append any subsequent events to the end\n                    // of the existing timeline.\n                    //\n                    // This is particularly important in the case that we already have\n                    // *all* of the events in the timeline - in that case, if we reset\n                    // the timeline, we'll end up with an entirely empty timeline,\n                    // which we'll try to paginate but not get any new events (which\n                    // will stop us linking the empty timeline into the chain).\n                    //\n                    for (let i = timelineEvents.length - 1; i >= 0; i--) {\n                        const eventId = timelineEvents[i].getId()!;\n                        if (room.getTimelineForEvent(eventId)) {\n                            this.syncOpts.logger.debug(`Already have event ${eventId} in limited sync - not resetting`);\n                            limited = false;\n\n                            // we might still be missing some of the events before i;\n                            // we don't want to be adding them to the end of the\n                            // timeline because that would put them out of order.\n                            timelineEvents.splice(0, i);\n\n                            // XXX: there's a problem here if the skipped part of the\n                            // timeline modifies the state set in stateEvents, because\n                            // we'll end up using the state from stateEvents rather\n                            // than the later state from timelineEvents. We probably\n                            // need to wind stateEvents forward over the events we're\n                            // skipping.\n\n                            break;\n                        }\n                    }\n\n                    if (limited) {\n                        room.resetLiveTimeline(\n                            joinObj.timeline.prev_batch,\n                            this.syncOpts.canResetEntireTimeline!(room.roomId)\n                                ? null\n                                : (syncEventData.oldSyncToken ?? null),\n                        );\n\n                        // We have to assume any gap in any timeline is\n                        // reason to stop incrementally tracking notifications and\n                        // reset the timeline.\n                        client.resetNotifTimelineSet();\n                    }\n                }\n\n                // process any crypto events *before* emitting the RoomStateEvent events. This\n                // avoids a race condition if the application tries to send a message after the\n                // state event is processed, but before crypto is enabled, which then causes the\n                // crypto layer to complain.\n\n                if (this.syncOpts.cryptoCallbacks) {\n                    for (const e of eventsFormingFinalState) {\n                        if (e.isState() && e.getType() === EventType.RoomEncryption && e.getStateKey() === \"\") {\n                            await this.syncOpts.cryptoCallbacks.onCryptoEvent(room, e);\n                        }\n                    }\n                }\n\n                // Proactively decrypt state events: normally we decrypt on demand, but for state\n                // events we need them immediately, so we handle them here. Specifically, consumers\n                // (e.g. Element Web) expect state events to be unencrypted upon receipt.\n                for (const ev of timelineEvents.filter((ev) => ev.isState())) {\n                    await this.client.decryptEventIfNeeded(ev);\n                }\n\n                try {\n                    if (\"org.matrix.msc4222.state_after\" in joinObj) {\n                        await this.injectRoomEvents(\n                            room,\n                            undefined,\n                            stateAfterEvents,\n                            timelineEvents,\n                            syncEventData.fromCache,\n                        );\n                    } else {\n                        await this.injectRoomEvents(\n                            room,\n                            stateEvents,\n                            undefined,\n                            timelineEvents,\n                            syncEventData.fromCache,\n                        );\n                    }\n                } catch (e) {\n                    this.syncOpts.logger.error(`Failed to process events on room ${room.roomId}:`, e);\n                }\n\n                // set summary after processing events,\n                // because it will trigger a name calculation\n                // which needs the room state to be up to date\n                if (joinObj.summary) {\n                    room.setSummary(joinObj.summary);\n                }\n\n                // we deliberately don't add ephemeral events to the timeline\n                room.addEphemeralEvents(ephemeralEvents);\n\n                // we deliberately don't add accountData to the timeline\n                room.addAccountData(accountDataEvents);\n\n                // Sticky events primarily come via the `timeline` field, with the\n                // sticky info field marking them as sticky.\n                // If the sync is \"gappy\" (meaning it is skipping events to catch up) then\n                // sticky events will instead come down the sticky section.\n                // This ensures we collect sticky events from both places.\n                const stickyEventsAndStickyEventsFromTheTimeline = stickyEvents.concat(\n                    timelineEvents.filter((e) => e.unstableStickyInfo !== undefined),\n                );\n                // Note: We calculate sticky events before emitting `.Room` as it's nice to have\n                // sticky events calculated and ready to go.\n                room._unstable_addStickyEvents(stickyEventsAndStickyEventsFromTheTimeline);\n\n                room.recalculate();\n                if (joinObj.isBrandNewRoom) {\n                    client.store.storeRoom(room);\n                    client.emit(ClientEvent.Room, room);\n                }\n\n                this.processEventsForNotifs(room, timelineEvents);\n\n                const emitEvent = (e: MatrixEvent): boolean => client.emit(ClientEvent.Event, e);\n                // this fires a couple of times for some events. (eg state events are in the timeline and the state)\n                // should this get a sync section as an additional event emission param (e, syncSection))?\n                stateEvents.forEach(emitEvent);\n                timelineEvents.forEach(emitEvent);\n                ephemeralEvents.forEach(emitEvent);\n                accountDataEvents.forEach(emitEvent);\n                stickyEvents\n                    .filter(\n                        (stickyEvent) =>\n                            // This is highly unlikey, but in the case where a sticky event\n                            // has appeared in the timeline AND the sticky section, we only\n                            // want to emit the event once.\n                            !timelineEvents.some((timelineEvent) => timelineEvent.getId() === stickyEvent.getId()),\n                    )\n                    .forEach(emitEvent);\n                // Decrypt only the last message in all rooms to make sure we can generate a preview\n                // And decrypt all events after the recorded read receipt to ensure an accurate\n                // notification count\n                room.decryptCriticalEvents();\n            }),\n        );\n\n        // Handle leaves (e.g. kicked rooms)\n        await Promise.all(\n            leaveRooms.map(async (leaveObj) => {\n                const room = leaveObj.room;\n                const { timelineEvents, stateEvents, stateAfterEvents } = await this.mapAndInjectRoomEvents(leaveObj);\n                const accountDataEvents = this.mapSyncEventsFormat(leaveObj.account_data);\n\n                room.addAccountData(accountDataEvents);\n\n                room.recalculate();\n                if (leaveObj.isBrandNewRoom) {\n                    client.store.storeRoom(room);\n                    client.emit(ClientEvent.Room, room);\n                }\n\n                this.processEventsForNotifs(room, timelineEvents);\n\n                stateEvents?.forEach(function (e) {\n                    client.emit(ClientEvent.Event, e);\n                });\n                stateAfterEvents?.forEach(function (e) {\n                    client.emit(ClientEvent.Event, e);\n                });\n                timelineEvents.forEach(function (e) {\n                    client.emit(ClientEvent.Event, e);\n                });\n                accountDataEvents.forEach(function (e) {\n                    client.emit(ClientEvent.Event, e);\n                });\n            }),\n        );\n\n        // Handle knocks\n        await Promise.all(\n            knockRooms.map(async (knockObj) => {\n                const room = knockObj.room;\n                const stateEvents = this.mapSyncEventsFormat(knockObj.knock_state, room);\n\n                await this.injectRoomEvents(room, stateEvents, undefined);\n\n                if (knockObj.isBrandNewRoom) {\n                    room.recalculate();\n                    client.store.storeRoom(room);\n                    client.emit(ClientEvent.Room, room);\n                } else {\n                    // Update room state for knock->leave->knock cycles\n                    room.recalculate();\n                }\n                stateEvents.forEach(function (e) {\n                    client.emit(ClientEvent.Event, e);\n                });\n            }),\n        );\n\n        // update the notification timeline, if appropriate.\n        // we only do this for live events, as otherwise we can't order them sanely\n        // in the timeline relative to ones paginated in by /notifications.\n        // XXX: we could fix this by making EventTimeline support chronological\n        // ordering... but it doesn't, right now.\n        if (syncEventData.oldSyncToken && this.notifEvents.length) {\n            this.notifEvents.sort(function (a, b) {\n                return a.getTs() - b.getTs();\n            });\n            this.notifEvents.forEach(function (event) {\n                client.getNotifTimelineSet()?.addLiveEvent(event, { addToState: true });\n            });\n        }\n\n        // Handle device list updates\n        if (data.device_lists) {\n            if (this.syncOpts.cryptoCallbacks) {\n                await this.syncOpts.cryptoCallbacks.processDeviceLists(data.device_lists);\n            } else {\n                // FIXME if we *don't* have a crypto module, we still need to\n                // invalidate the device lists. But that would require a\n                // substantial bit of rework :/.\n            }\n        }\n\n        // Handle one_time_keys_count and unused fallback keys\n        await this.syncOpts.cryptoCallbacks?.processKeyCounts(\n            data.device_one_time_keys_count,\n            data.device_unused_fallback_key_types ?? data[\"org.matrix.msc2732.device_unused_fallback_key_types\"],\n        );\n    }\n\n    /**\n     * Starts polling the connectivity check endpoint\n     * @param delay - How long to delay until the first poll.\n     *        defaults to a short, randomised interval (to prevent\n     *        tight-looping if /versions succeeds but /sync etc. fail).\n     * @returns which resolves once the connection returns\n     */\n    private startKeepAlives(delay?: number): Promise<boolean> {\n        if (delay === undefined) {\n            delay = 2000 + Math.floor(Math.random() * 5000);\n        }\n\n        if (this.keepAliveTimer !== null) {\n            clearTimeout(this.keepAliveTimer);\n        }\n        if (delay > 0) {\n            this.keepAliveTimer = setTimeout(this.pokeKeepAlive.bind(this), delay);\n        } else {\n            this.pokeKeepAlive();\n        }\n        if (!this.connectionReturnedResolvers) {\n            this.connectionReturnedResolvers = Promise.withResolvers();\n        }\n        return this.connectionReturnedResolvers.promise;\n    }\n\n    /**\n     * Make a dummy call to /_matrix/client/versions, to see if the HS is\n     * reachable.\n     *\n     * On failure, schedules a call back to itself. On success, resolves\n     * this.connectionReturnedResolvers.\n     *\n     * @param connDidFail - True if a connectivity failure has been detected. Optional.\n     */\n    private pokeKeepAlive(connDidFail = false): void {\n        if (!this.running) {\n            // we are in a keepAlive, retrying to connect, but the syncronization\n            // was stopped, so we are stopping the retry.\n            clearTimeout(this.keepAliveTimer);\n            if (this.connectionReturnedResolvers) {\n                this.connectionReturnedResolvers.reject(\"SyncApi.stop() was called\");\n                this.connectionReturnedResolvers = undefined;\n            }\n            return;\n        }\n\n        const success = (): void => {\n            clearTimeout(this.keepAliveTimer);\n            if (this.connectionReturnedResolvers) {\n                this.connectionReturnedResolvers.resolve(connDidFail);\n                this.connectionReturnedResolvers = undefined;\n            }\n        };\n\n        this.client.http\n            .request(\n                Method.Get,\n                \"/_matrix/client/versions\",\n                undefined, // queryParams\n                undefined, // data\n                {\n                    prefix: \"\",\n                    localTimeoutMs: 15 * 1000,\n                    abortSignal: this.abortController?.signal,\n                },\n            )\n            .then(\n                () => {\n                    success();\n                },\n                (err) => {\n                    if (err.httpStatus == 400 || err.httpStatus == 404) {\n                        // treat this as a success because the server probably just doesn't\n                        // support /versions: point is, we're getting a response.\n                        // We wait a short time though, just in case somehow the server\n                        // is in a mode where it 400s /versions responses and sync etc.\n                        // responses fail, this will mean we don't hammer in a loop.\n                        this.keepAliveTimer = setTimeout(success, 2000);\n                    } else {\n                        connDidFail = true;\n                        this.keepAliveTimer = setTimeout(\n                            this.pokeKeepAlive.bind(this, connDidFail),\n                            5000 + Math.floor(Math.random() * 5000),\n                        );\n                        // A keepalive has failed, so we emit the\n                        // error state (whether or not this is the\n                        // first failure).\n                        // Note we do this after setting the timer:\n                        // this lets the unit tests advance the mock\n                        // clock when they get the error.\n                        this.updateSyncState(SyncState.Error, { error: err });\n                    }\n                },\n            );\n    }\n\n    private mapSyncResponseToRoomArray<T extends ILeftRoom | IJoinedRoom | IInvitedRoom | IKnockedRoom>(\n        obj: Record<string, T>,\n    ): Array<WrappedRoom<T>> {\n        // Maps { roomid: {stuff}, roomid: {stuff} }\n        // to\n        // [{stuff+Room+isBrandNewRoom}, {stuff+Room+isBrandNewRoom}]\n        const client = this.client;\n        return Object.keys(obj)\n            .filter((k) => !unsafeProp(k))\n            .map((roomId) => {\n                let room = client.store.getRoom(roomId);\n                let isBrandNewRoom = false;\n                if (!room) {\n                    room = this.createRoom(roomId);\n                    isBrandNewRoom = true;\n                }\n                return {\n                    ...obj[roomId],\n                    room,\n                    isBrandNewRoom,\n                };\n            });\n    }\n\n    private mapSyncEventsFormat(\n        obj: IInviteState | ITimeline | IEphemeral | undefined,\n        room?: Room,\n        decrypt = true,\n    ): MatrixEvent[] {\n        if (!obj || !Array.isArray(obj.events)) {\n            return [];\n        }\n        const mapper = this.client.getEventMapper({ decrypt });\n        type TaggedEvent = (IStrippedState | IRoomEvent | IStateEvent | IMinimalEvent) & { room_id?: string };\n        return (obj.events as TaggedEvent[]).filter(noUnsafeEventProps).map(function (e) {\n            if (room) {\n                e.room_id = room.roomId;\n            }\n            return mapper(e);\n        });\n    }\n\n    /**\n     */\n    private resolveInvites(room: Room): void {\n        if (!room || !this.opts.resolveInvitesToProfiles) {\n            return;\n        }\n        const client = this.client;\n        // For each invited room member we want to give them a displayname/avatar url\n        // if they have one (the m.room.member invites don't contain this).\n        room.getMembersWithMembership(KnownMembership.Invite).forEach(function (member) {\n            if (member.requestedProfileInfo) return;\n            member.requestedProfileInfo = true;\n            // try to get a cached copy first.\n            const user = client.getUser(member.userId);\n            let promise;\n            if (user) {\n                promise = Promise.resolve({\n                    avatar_url: user.avatarUrl,\n                    displayname: user.displayName,\n                });\n            } else {\n                promise = client.getProfileInfo(member.userId);\n            }\n            promise.then(\n                function (info) {\n                    // slightly naughty by doctoring the invite event but this means all\n                    // the code paths remain the same between invite/join display name stuff\n                    // which is a worthy trade-off for some minor pollution.\n                    const inviteEvent = member.events.member;\n                    if (inviteEvent?.getContent().membership !== KnownMembership.Invite) {\n                        // between resolving and now they have since joined, so don't clobber\n                        return;\n                    }\n                    inviteEvent.getContent().avatar_url = info.avatar_url;\n                    inviteEvent.getContent().displayname = info.displayname;\n                    // fire listeners\n                    member.setMembershipEvent(inviteEvent, room.currentState);\n                },\n                function (err) {\n                    // OH WELL.\n                },\n            );\n        });\n    }\n\n    private findEncryptionEvent(events?: MatrixEvent[]): MatrixEvent | undefined {\n        return events?.find((e) => e.getType() === EventType.RoomEncryption && e.getStateKey() === \"\");\n    }\n\n    // When processing the sync response we cannot rely on Room.hasEncryptionStateEvent we actually\n    // inject the events into the room object, so we have to inspect the events themselves.\n    private isRoomEncrypted(room: Room, eventsFormingFinalState: MatrixEvent[]): boolean {\n        return room.hasEncryptionStateEvent() || !!this.findEncryptionEvent(eventsFormingFinalState);\n    }\n\n    private async mapAndInjectRoomEvents(wrappedRoom: WrappedRoom<ILeftRoom>): Promise<{\n        timelineEvents: MatrixEvent[];\n        stateEvents?: MatrixEvent[];\n        stateAfterEvents?: MatrixEvent[];\n    }> {\n        const stateEvents = this.mapSyncEventsFormat(wrappedRoom.state, wrappedRoom.room);\n        const stateAfterEvents = this.mapSyncEventsFormat(\n            wrappedRoom[\"org.matrix.msc4222.state_after\"],\n            wrappedRoom.room,\n        );\n        const timelineEvents = this.mapSyncEventsFormat(wrappedRoom.timeline, wrappedRoom.room);\n\n        if (\"org.matrix.msc4222.state_after\" in wrappedRoom) {\n            await this.injectRoomEvents(wrappedRoom.room, undefined, stateAfterEvents, timelineEvents);\n        } else {\n            await this.injectRoomEvents(wrappedRoom.room, stateEvents, undefined, timelineEvents);\n        }\n\n        return { timelineEvents, stateEvents, stateAfterEvents };\n    }\n\n    /**\n     * Injects events into a room's model.\n     * @param stateEventList - A list of state events. This is the state\n     * at the *START* of the timeline list if it is supplied.\n     * @param stateAfterEventList - A list of state events. This is the state\n     * at the *END* of the timeline list if it is supplied.\n     * @param timelineEventList - A list of timeline events, including threaded. Lower index\n     * is earlier in time. Higher index is later.\n     * @param fromCache - whether the sync response came from cache\n     *\n     * No more than one of stateEventList and stateAfterEventList must be supplied. If\n     * stateEventList is supplied, the events in timelineEventList are added to the state\n     * after stateEventList. If stateAfterEventList is supplied, the events in timelineEventList\n     * are not added to the state.\n     */\n    public async injectRoomEvents(\n        room: Room,\n        stateEventList: MatrixEvent[],\n        stateAfterEventList: undefined,\n        timelineEventList?: MatrixEvent[],\n        fromCache?: boolean,\n    ): Promise<void>;\n    public async injectRoomEvents(\n        room: Room,\n        stateEventList: undefined,\n        stateAfterEventList: MatrixEvent[],\n        timelineEventList?: MatrixEvent[],\n        fromCache?: boolean,\n    ): Promise<void>;\n    public async injectRoomEvents(\n        room: Room,\n        stateEventList: MatrixEvent[] | undefined,\n        stateAfterEventList: MatrixEvent[] | undefined,\n        timelineEventList?: MatrixEvent[],\n        fromCache = false,\n    ): Promise<void> {\n        const eitherStateEventList = stateAfterEventList ?? stateEventList!;\n\n        // If there are no events in the timeline yet, initialise it with\n        // the given state events\n        const liveTimeline = room.getLiveTimeline();\n        const timelineWasEmpty = liveTimeline.getEvents().length == 0;\n        if (timelineWasEmpty) {\n            // Passing these events into initialiseState will freeze them, so we need\n            // to compute and cache the push actions for them now, otherwise sync dies\n            // with an attempt to assign to read only property.\n            // XXX: This is pretty horrible and is assuming all sorts of behaviour from\n            // these functions that it shouldn't be. We should probably either store the\n            // push actions cache elsewhere so we can freeze MatrixEvents, or otherwise\n            // find some solution where MatrixEvents are immutable but allow for a cache\n            // field.\n\n            for (const ev of eitherStateEventList) {\n                this.client.getPushActionsForEvent(ev);\n            }\n            liveTimeline.initialiseState(eitherStateEventList, {\n                timelineWasEmpty,\n            });\n        }\n\n        this.resolveInvites(room);\n\n        // recalculate the room name at this point as adding events to the timeline\n        // may make notifications appear which should have the right name.\n        // XXX: This looks suspect: we'll end up recalculating the room once here\n        // and then again after adding events (processSyncResponse calls it after\n        // calling us) even if no state events were added. It also means that if\n        // one of the room events in timelineEventList is something that needs\n        // a recalculation (like m.room.name) we won't recalculate until we've\n        // finished adding all the events, which will cause the notification to have\n        // the old room name rather than the new one.\n        room.recalculate();\n\n        // If the timeline wasn't empty, we process the state events here: they're\n        // defined as updates to the state before the start of the timeline, so this\n        // starts to roll the state forward.\n        // XXX: That's what we *should* do, but this can happen if we were previously\n        // peeking in a room, in which case we obviously do *not* want to add the\n        // state events here onto the end of the timeline. Historically, the js-sdk\n        // has just set these new state events on the old and new state. This seems\n        // very wrong because there could be events in the timeline that diverge the\n        // state, in which case this is going to leave things out of sync. However,\n        // for now I think it;s best to behave the same as the code has done previously.\n        if (!timelineWasEmpty) {\n            // XXX: As above, don't do this...\n            //room.addLiveEvents(stateEventList || []);\n            // Do this instead...\n            room.oldState.setStateEvents(eitherStateEventList);\n            room.currentState.setStateEvents(eitherStateEventList);\n        }\n\n        // Execute the timeline events. If addToState is true the timeline has any state\n        // events in it, this will continue to diverge the current state.\n        // This also needs to be done before running push rules on the events as they need\n        // to be decorated with sender etc.\n        await room.addLiveEvents(timelineEventList || [], {\n            fromCache,\n            timelineWasEmpty,\n            addToState: stateAfterEventList === undefined,\n        });\n        this.client.processBeaconEvents(room, timelineEventList);\n    }\n\n    /**\n     * Takes a list of timelineEvents and adds and adds to notifEvents\n     * as appropriate.\n     * This must be called after the room the events belong to has been stored.\n     *\n     * @param timelineEventList - A list of timeline events. Lower index\n     * is earlier in time. Higher index is later.\n     */\n    private processEventsForNotifs(room: Room, timelineEventList: MatrixEvent[]): void {\n        // gather our notifications into this.notifEvents\n        if (this.client.getNotifTimelineSet()) {\n            for (const event of timelineEventList) {\n                const pushActions = this.client.getPushActionsForEvent(event);\n                if (pushActions?.notify && pushActions.tweaks?.highlight) {\n                    this.notifEvents.push(event);\n                }\n            }\n        }\n    }\n\n    private getGuestFilter(): string {\n        // Dev note: This used to be conditional to return a filter of 20 events maximum, but\n        // the condition never went to the other branch. This is now hardcoded.\n        return \"{}\";\n    }\n\n    /**\n     * Sets the sync state and emits an event to say so\n     * @param newState - The new state string\n     * @param data - Object of additional data to emit in the event\n     */\n    private updateSyncState(newState: SyncState, data?: ISyncStateData): void {\n        const old = this.syncState;\n        this.syncState = newState;\n        this.syncStateData = data;\n        this.client.emit(ClientEvent.Sync, this.syncState, old, data);\n    }\n\n    /**\n     * Event handler for the 'online' event\n     * This event is generally unreliable and precise behaviour\n     * varies between browsers, so we poll for connectivity too,\n     * but this might help us reconnect a little faster.\n     */\n    private onOnline = (): void => {\n        this.syncOpts.logger.debug(\"Browser thinks we are back online\");\n        this.startKeepAlives(0);\n    };\n}\n\n// /!\\ This function is not intended for public use! It's only exported from\n// here in order to share some common logic with sliding-sync-sdk.ts.\nexport function _createAndReEmitRoom(client: MatrixClient, roomId: string, opts: Partial<IStoredClientOpts>): Room {\n    const { timelineSupport } = client;\n\n    const room = new Room(roomId, client, client.getUserId()!, {\n        lazyLoadMembers: opts.lazyLoadMembers,\n        pendingEventOrdering: opts.pendingEventOrdering,\n        timelineSupport,\n    });\n\n    client.reEmitter.reEmit(room, [\n        RoomEvent.Name,\n        RoomEvent.Redaction,\n        RoomEvent.RedactionCancelled,\n        RoomEvent.Receipt,\n        RoomEvent.Tags,\n        RoomEvent.LocalEchoUpdated,\n        RoomEvent.AccountData,\n        RoomEvent.MyMembership,\n        RoomEvent.Timeline,\n        RoomEvent.TimelineReset,\n        RoomStateEvent.Events,\n        RoomStateEvent.Members,\n        RoomStateEvent.NewMember,\n        RoomStateEvent.Update,\n        BeaconEvent.New,\n        BeaconEvent.Update,\n        BeaconEvent.Destroy,\n        BeaconEvent.LivenessChange,\n    ]);\n\n    // We need to add a listener for RoomState.members in order to hook them\n    // correctly.\n    room.on(RoomStateEvent.NewMember, (event, state, member) => {\n        member.user = client.getUser(member.userId) ?? undefined;\n        client.reEmitter.reEmit(member, [\n            RoomMemberEvent.Name,\n            RoomMemberEvent.Typing,\n            RoomMemberEvent.PowerLevel,\n            RoomMemberEvent.Membership,\n        ]);\n    });\n\n    return room;\n}\n\n/**\n * Process a list of (decrypted, where possible) received to-device events.\n *\n * Emits the appropriate {@link ClientEvent.ReceivedToDeviceMessage} event.\n * Also converts the events into `MatrixEvent`s, and emits the now deprecated {@link ClientEvent.ToDeviceEvent} events for compatibility.\n * */\nexport function processToDeviceMessages(toDeviceMessages: ReceivedToDeviceMessage[], client: MatrixClient): void {\n    const cancelledKeyVerificationTxns: string[] = [];\n    toDeviceMessages\n        .map((processedMessage) => {\n            // map is a cheap inline forEach\n            // We want to flag m.key.verification.start events as cancelled\n            // if there's an accompanying m.key.verification.cancel event, so\n            // we pull out the transaction IDs from the cancellation events\n            // so we can flag the verification events as cancelled in the loop\n            // below.\n            if (processedMessage.message.type === \"m.key.verification.cancel\") {\n                const txnId: string = processedMessage.message.content[\"transaction_id\"];\n                if (txnId) {\n                    cancelledKeyVerificationTxns.push(txnId);\n                }\n            }\n\n            // as mentioned above, .map is a cheap inline forEach, so return\n            // the unmodified event.\n            return processedMessage;\n        })\n        .forEach(function (processedEvent) {\n            // For backwards compatibility, we also emit the event as a `MatrixEvent` using `ClientEvent.ToDeviceEvent`.\n            {\n                const toDeviceEvent = processedEvent.message;\n                const content = toDeviceEvent.content;\n                // The message is cloned before being passed to the MatrixEvent constructor, because\n                // the `makeEncrypted` method will mutate the type and content properties of the original message and will interfere\n                // with the emitted event for `ReceivedToDeviceMessage`.\n                const deprecatedCompatibilityEvent = new MatrixEvent(Object.assign({}, toDeviceEvent));\n                if (\n                    toDeviceEvent.type === \"m.key.verification.start\" ||\n                    toDeviceEvent.type === \"m.key.verification.request\"\n                ) {\n                    const txnId = content[\"transaction_id\"];\n                    if (cancelledKeyVerificationTxns.includes(txnId)) {\n                        deprecatedCompatibilityEvent.flagCancelled();\n                    }\n                }\n                if (processedEvent.encryptionInfo) {\n                    // Restore partially the legacy behavior to detect encrypted messages.\n                    // Now `event.isEncrypted()` will return true.\n                    deprecatedCompatibilityEvent.makeEncrypted(\n                        EventType.RoomMessageEncrypted,\n                        { ciphertext: \"\" },\n                        processedEvent.encryptionInfo.senderCurve25519KeyBase64,\n                        \"\",\n                    );\n                }\n\n                client.emit(ClientEvent.ToDeviceEvent, deprecatedCompatibilityEvent);\n            }\n\n            client.emit(ClientEvent.ReceivedToDeviceMessage, processedEvent);\n        });\n}\n","/*\nCopyright 2015, 2016, 2019, 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module.\n */\n\nimport unhomoglyph from \"unhomoglyph\";\nimport promiseRetry from \"p-retry\";\n\nimport { type IEvent, type MatrixEvent } from \"./models/event.ts\";\nimport { M_TIMESTAMP } from \"./@types/location.ts\";\nimport { ReceiptType } from \"./@types/read_receipts.ts\";\nimport { type BaseLogger } from \"./logger.ts\";\n\nconst interns = new Map<string, string>();\n\n/**\n * Internalises a string, reusing a known pointer or storing the pointer\n * if needed for future strings.\n * @param str - The string to internalise.\n * @returns The internalised string.\n */\nexport function internaliseString(str: string): string {\n    // Unwrap strings before entering the map, if we somehow got a wrapped\n    // string as our input. This should only happen from tests.\n    if ((str as unknown) instanceof String) {\n        str = str.toString();\n    }\n\n    // Check the map to see if we can store the value\n    if (!interns.has(str)) {\n        interns.set(str, str);\n    }\n\n    // Return any cached string reference\n    return interns.get(str)!;\n}\n\n/**\n * Encode a dictionary of query parameters.\n * Omits any undefined/null values.\n * @param params - A dict of key/values to encode e.g.\n * `{\"foo\": \"bar\", \"baz\": \"taz\"}`\n * @returns The encoded string e.g. foo=bar&baz=taz\n */\nexport function encodeParams(params: QueryDict, urlSearchParams?: URLSearchParams): URLSearchParams {\n    const searchParams = urlSearchParams ?? new URLSearchParams();\n    for (const [key, val] of Object.entries(params)) {\n        if (val !== undefined && val !== null) {\n            if (Array.isArray(val)) {\n                val.forEach((v) => {\n                    searchParams.append(key, String(v));\n                });\n            } else {\n                searchParams.append(key, String(val));\n            }\n        }\n    }\n    return searchParams;\n}\n\nexport type QueryDict = Record<string, string[] | string | number | boolean | undefined>;\n\n/**\n * Replace a stable parameter with the unstable naming for params\n */\nexport function replaceParam(stable: string, unstable: string, dict: QueryDict): QueryDict {\n    const result = {\n        ...dict,\n        [unstable]: dict[stable],\n    };\n    delete result[stable];\n    return result;\n}\n\n/**\n * Decode a query string in `application/x-www-form-urlencoded` format.\n * @param query - A query string to decode e.g.\n * foo=bar&via=server1&server2\n * @returns The decoded object, if any keys occurred multiple times\n * then the value will be an array of strings, else it will be an array.\n * This behaviour matches Node's qs.parse but is built on URLSearchParams\n * for native web compatibility\n */\nexport function decodeParams(query: string): Record<string, string | string[]> {\n    const o: Record<string, string | string[]> = {};\n    const params = new URLSearchParams(query);\n    for (const key of params.keys()) {\n        const val = params.getAll(key);\n        o[key] = val.length === 1 ? val[0] : val;\n    }\n    return o;\n}\n\n/**\n * Encodes a URI according to a set of template variables. Variables will be\n * passed through encodeURIComponent.\n * @param pathTemplate - The path with template variables e.g. '/foo/$bar'.\n * @param variables - The key/value pairs to replace the template\n * variables with. E.g. `{ \"$bar\": \"baz\" }`.\n * @returns The result of replacing all template variables e.g. '/foo/baz'.\n */\nexport function encodeUri(pathTemplate: string, variables: Record<string, string | null | undefined>): string {\n    for (const key in variables) {\n        if (!variables.hasOwnProperty(key)) {\n            continue;\n        }\n        const value = variables[key];\n        if (value === undefined || value === null) {\n            continue;\n        }\n        pathTemplate = pathTemplate.replace(key, encodeURIComponent(value));\n    }\n    return pathTemplate;\n}\n\n/**\n * The removeElement() method removes the first element in the array that\n * satisfies (returns true) the provided testing function.\n * @param array - The array.\n * @param fn - Function to execute on each value in the array, with the\n * function signature `fn(element, index, array)`. Return true to\n * remove this element and break.\n * @param reverse - True to search in reverse order.\n * @returns True if an element was removed.\n */\nexport function removeElement<T>(array: T[], fn: (t: T, i?: number, a?: T[]) => boolean, reverse?: boolean): boolean {\n    let i: number;\n    if (reverse) {\n        for (i = array.length - 1; i >= 0; i--) {\n            if (fn(array[i], i, array)) {\n                array.splice(i, 1);\n                return true;\n            }\n        }\n    } else {\n        for (i = 0; i < array.length; i++) {\n            if (fn(array[i], i, array)) {\n                array.splice(i, 1);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Checks if the given thing is a function.\n * @param value - The thing to check.\n * @returns True if it is a function.\n */\nexport function isFunction(value: any): boolean {\n    return Object.prototype.toString.call(value) === \"[object Function]\";\n}\n\n/**\n * Checks that the given object has the specified keys.\n * @param obj - The object to check.\n * @param keys - The list of keys that 'obj' must have.\n * @throws If the object is missing keys.\n */\n// note using 'keys' here would shadow the 'keys' function defined above\nexport function checkObjectHasKeys(obj: object, keys: string[]): void {\n    for (const key of keys) {\n        if (!obj.hasOwnProperty(key)) {\n            throw new Error(\"Missing required key: \" + key);\n        }\n    }\n}\n\n/**\n * Deep copy the given object. The object MUST NOT have circular references and\n * MUST NOT have functions.\n * @param obj - The object to deep copy.\n * @returns A copy of the object without any references to the original.\n */\nexport function deepCopy<T>(obj: T): T {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Compare two objects for equality. The objects MUST NOT have circular references.\n *\n * @param x - The first object to compare.\n * @param y - The second object to compare.\n *\n * @returns true if the two objects are equal\n */\nexport function deepCompare(x: any, y: any): boolean {\n    // Inspired by\n    // http://stackoverflow.com/questions/1068834/object-comparison-in-javascript#1144249\n\n    // Compare primitives and functions.\n    // Also check if both arguments link to the same object.\n    if (x === y) {\n        return true;\n    }\n\n    if (typeof x !== typeof y) {\n        return false;\n    }\n\n    // special-case NaN (since NaN !== NaN)\n    if (typeof x === \"number\" && isNaN(x) && isNaN(y)) {\n        return true;\n    }\n\n    // special-case null (since typeof null == 'object', but null.constructor\n    // throws)\n    if (x === null || y === null) {\n        return x === y;\n    }\n\n    // everything else is either an unequal primitive, or an object\n    // XXX: this check has been temporarily tweaked due to issues in the jest test environment,\n    // this will be reverted as part of the migration to vitest\n    if (\n        x.constructor.name !== \"Object\" &&\n        x.constructor.name !== \"RegExp\" &&\n        x.constructor.name !== \"Date\" &&\n        x.constructor.name !== \"Array\"\n    ) {\n        return false;\n    }\n\n    // check they are the same type of object\n    // XXX: this check has been temporarily tweaked due to issues in the jest test environment,\n    // this will be reverted as part of the migration to vitest\n    if (x.prototype !== y.prototype) {\n        return false;\n    }\n\n    // special-casing for some special types of object\n    if (x instanceof RegExp || x instanceof Date) {\n        return x.toString() === y.toString();\n    }\n\n    // the object algorithm works for Array, but it's sub-optimal.\n    if (Array.isArray(x)) {\n        if (x.length !== y.length) {\n            return false;\n        }\n\n        for (let i = 0; i < x.length; i++) {\n            if (!deepCompare(x[i], y[i])) {\n                return false;\n            }\n        }\n    } else {\n        // check that all of y's direct keys are in x\n        for (const p in y) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                return false;\n            }\n        }\n\n        // finally, compare each of x's keys with y\n        for (const p in x) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p) || !deepCompare(x[p], y[p])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Dev note: This returns an array of tuples, but jsdoc doesn't like that. https://github.com/jsdoc/jsdoc/issues/1703\n/**\n * Creates an array of object properties/values (entries) then\n * sorts the result by key, recursively. The input object must\n * ensure it does not have loops. If the input is not an object\n * then it will be returned as-is.\n * @param obj - The object to get entries of\n * @returns The entries, sorted by key.\n */\nexport function deepSortedObjectEntries(obj: any): [string, any][] {\n    if (typeof obj !== \"object\") return obj;\n\n    // Apparently these are object types...\n    if (obj === null || obj === undefined || Array.isArray(obj)) return obj;\n\n    const pairs: [string, any][] = [];\n    for (const [k, v] of Object.entries(obj)) {\n        pairs.push([k, deepSortedObjectEntries(v)]);\n    }\n\n    // lexicographicCompare is faster than localeCompare, so let's use that.\n    pairs.sort((a, b) => lexicographicCompare(a[0], b[0]));\n\n    return pairs;\n}\n\n/**\n * Returns whether the given value is a finite number without type-coercion\n *\n * @param value - the value to test\n * @returns whether or not value is a finite number without type-coercion\n */\nexport function isNumber(value: any): value is number {\n    return typeof value === \"number\" && isFinite(value);\n}\n\n/**\n * Removes zero width chars, diacritics and whitespace from the string\n * Also applies an unhomoglyph on the string, to prevent similar looking chars\n * @param str - the string to remove hidden characters from\n * @returns a string with the hidden characters removed\n */\nexport function removeHiddenChars(str: string): string {\n    if (typeof str === \"string\") {\n        return unhomoglyph(str.normalize(\"NFD\").replace(removeHiddenCharsRegex, \"\"));\n    }\n    return \"\";\n}\n\n/**\n * Removes the direction override characters from a string\n * @returns string with chars removed\n */\nexport function removeDirectionOverrideChars(str: string): string {\n    if (typeof str === \"string\") {\n        return str.replace(/[\\u202d-\\u202e]/g, \"\");\n    }\n    return \"\";\n}\n\nexport function normalize(str: string): string {\n    // Note: we have to match the filter with the removeHiddenChars() because the\n    // function strips spaces and other characters (M becomes RN for example, in lowercase).\n    return (\n        removeHiddenChars(str.toLowerCase())\n            // Strip all punctuation\n            .replace(/[\\\\'!\"#$%&()*+,\\-./:;<=>?@[\\]^_`{|}~\\u2000-\\u206f\\u2e00-\\u2e7f]/g, \"\")\n            // We also doubly convert to lowercase to work around oddities of the library.\n            .toLowerCase()\n    );\n}\n\n// Regex matching bunch of unicode control characters and otherwise misleading/invisible characters.\n// Includes:\n// various width spaces U+2000 - U+200D\n// LTR and RTL marks U+200E and U+200F\n// LTR/RTL and other directional formatting marks U+202A - U+202F\n// Arabic Letter RTL mark U+061C\n// Combining characters U+0300 - U+036F\n// Zero width no-break space (BOM) U+FEFF\n// Blank/invisible characters (U2800, U2062-U2063)\n// eslint-disable-next-line no-misleading-character-class\nconst removeHiddenCharsRegex = /[\\u2000-\\u200F\\u202A-\\u202F\\u0300-\\u036F\\uFEFF\\u061C\\u2800\\u2062-\\u2063\\s]/g;\n\nexport function escapeRegExp(string: string): string {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n/**\n * Converts Matrix glob-style string to a regular expression\n * https://spec.matrix.org/v1.7/appendices/#glob-style-matching\n * @param glob - Matrix glob-style string\n * @returns regular expression\n */\nexport function globToRegexp(glob: string): string {\n    return escapeRegExp(glob).replace(/\\\\\\*/g, \".*\").replace(/\\?/g, \".\");\n}\n\nexport function ensureNoTrailingSlash(url: string): string;\nexport function ensureNoTrailingSlash(url: undefined): undefined;\nexport function ensureNoTrailingSlash(url?: string): string | undefined;\nexport function ensureNoTrailingSlash(url?: string): string | undefined {\n    if (url?.endsWith(\"/\")) {\n        return url.slice(0, -1);\n    } else {\n        return url;\n    }\n}\n\n/**\n * Returns a promise which resolves with a given value after the given number of ms\n */\nexport function sleep<T>(ms: number, value?: T): Promise<T> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms, value);\n    });\n}\n\n/**\n * Utility to log the duration of a promise.\n *\n * @param logger - The logger to log to.\n * @param name - The name of the operation.\n * @param block - The block to execute.\n */\nexport async function logDuration<T>(logger: BaseLogger, name: string, block: () => Promise<T>): Promise<T> {\n    const start = Date.now();\n    try {\n        return await block();\n    } finally {\n        const end = Date.now();\n        logger.debug(`[Perf]: ${name} took ${end - start}ms`);\n    }\n}\n\n/**\n * Utility to log the duration of a synchronous block.\n *\n * @param logger - The logger to log to.\n * @param name - The name of the operation.\n * @param block - The block to execute.\n */\nexport function logDurationSync<T>(logger: BaseLogger, name: string, block: () => T): T {\n    const start = Date.now();\n    try {\n        return block();\n    } finally {\n        const end = Date.now();\n        logger.debug(`[Perf]: ${name} took ${end - start}ms`);\n    }\n}\n\n/**\n * Promise/async version of {@link setImmediate}.\n *\n * Implementation is based on `setTimeout` for wider compatibility.\n * @deprecated Use {@link sleep} instead.\n */\nexport function immediate(): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve));\n}\n\nexport function isNullOrUndefined(val: any): boolean {\n    return val === null || val === undefined;\n}\n\nexport async function promiseMapSeries<T>(\n    promises: Array<T | Promise<T>>,\n    fn: (t: T) => Promise<unknown> | undefined, // if async we don't care about the type as we only await resolution\n): Promise<void> {\n    for (const o of promises) {\n        await fn(await o);\n    }\n}\n\nexport function promiseTry<T>(fn: () => T | Promise<T>): Promise<T> {\n    return Promise.resolve(fn());\n}\n\n// Creates and awaits all promises, running no more than `chunkSize` at the same time\nexport async function chunkPromises<T>(fns: (() => Promise<T>)[], chunkSize: number): Promise<T[]> {\n    const results: T[] = [];\n    for (let i = 0; i < fns.length; i += chunkSize) {\n        results.push(...(await Promise.all(fns.slice(i, i + chunkSize).map((fn) => fn()))));\n    }\n    return results;\n}\n\n/**\n * Retries the function until it succeeds or is interrupted. The given function must return\n * a promise which throws/rejects on error, otherwise the retry will assume the request\n * succeeded. The promise chain returned will contain the successful promise. The given function\n * should always return a new promise.\n * @param promiseFn - The function to call to get a fresh promise instance. Takes an\n * attempt count as an argument, for logging/debugging purposes.\n * @param shouldRetry - Optional function which is called with the error the latest rejection from promiseFn,\n * retrying will ba aborted if this return false.\n * @returns The promise for the retried operation.\n */\nexport function simpleRetryOperation<T>(\n    promiseFn: (attempt: number) => Promise<T>,\n    shouldRetry?: (e: unknown) => boolean,\n): Promise<T> {\n    return promiseRetry(\n        (attempt: number) => {\n            return promiseFn(attempt);\n        },\n        {\n            retries: Infinity,\n            shouldRetry: shouldRetry ? ({ error }): boolean => shouldRetry(error) : undefined,\n            factor: 2,\n            minTimeout: 3000, // ms\n            maxTimeout: 15000, // ms\n        },\n    );\n}\n\n// String averaging inspired by https://stackoverflow.com/a/2510816\n// Dev note: We make the alphabet a string because it's easier to write syntactically\n// than arrays. Thankfully, strings implement the useful parts of the Array interface\n// anyhow.\n\n/**\n * The default alphabet used by string averaging in this SDK. This matches\n * all usefully printable ASCII characters (0x20-0x7E, inclusive).\n */\nexport const DEFAULT_ALPHABET = ((): string => {\n    let str = \"\";\n    for (let c = 0x20; c <= 0x7e; c++) {\n        str += String.fromCharCode(c);\n    }\n    return str;\n})();\n\n/**\n * Pads a string using the given alphabet as a base. The returned string will be\n * padded at the end with the first character in the alphabet.\n *\n * This is intended for use with string averaging.\n * @param s - The string to pad.\n * @param n - The length to pad to.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The padded string.\n */\nexport function alphabetPad(s: string, n: number, alphabet = DEFAULT_ALPHABET): string {\n    return s.padEnd(n, alphabet[0]);\n}\n\n/**\n * Converts a baseN number to a string, where N is the alphabet's length.\n *\n * This is intended for use with string averaging.\n * @param n - The baseN number.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The baseN number encoded as a string from the alphabet.\n */\nexport function baseToString(n: bigint, alphabet = DEFAULT_ALPHABET): string {\n    // Developer note: the stringToBase() function offsets the character set by 1 so that repeated\n    // characters (ie: \"aaaaaa\" in a..z) don't come out as zero. We have to reverse this here as\n    // otherwise we'll be wrong in our conversion. Undoing a +1 before an exponent isn't very fun\n    // though, so we rely on a lengthy amount of `x - 1` and integer division rules to reach a\n    // sane state. This also means we have to do rollover detection: see below.\n\n    const len = BigInt(alphabet.length);\n    if (n <= len) {\n        return alphabet[Number(n) - 1] ?? \"\";\n    }\n\n    let d = n / len;\n    let r = Number(n % len) - 1;\n\n    // Rollover detection: if the remainder is negative, it means that the string needs\n    // to roll over by 1 character downwards (ie: in a..z, the previous to \"aaa\" would be\n    // \"zz\").\n    if (r < 0) {\n        d -= BigInt(Math.abs(r)); // abs() is just to be clear what we're doing. Could also `+= r`.\n        r = Number(len) - 1;\n    }\n\n    return baseToString(d, alphabet) + alphabet[r];\n}\n\n/**\n * Converts a string to a baseN number, where N is the alphabet's length.\n *\n * This is intended for use with string averaging.\n * @param s - The string to convert to a number.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The baseN number.\n */\nexport function stringToBase(s: string, alphabet = DEFAULT_ALPHABET): bigint {\n    const len = BigInt(alphabet.length);\n\n    // In our conversion to baseN we do a couple performance optimizations to avoid using\n    // excess CPU and such. To create baseN numbers, the input string needs to be reversed\n    // so the exponents stack up appropriately, as the last character in the unreversed\n    // string has less impact than the first character (in \"abc\" the A is a lot more important\n    // for lexicographic sorts). We also do a trick with the character codes to optimize the\n    // alphabet lookup, avoiding an index scan of `alphabet.indexOf(reversedStr[i])` - we know\n    // that the alphabet and (theoretically) the input string are constrained on character sets\n    // and thus can do simple subtraction to end up with the same result.\n\n    // Developer caution: we carefully cast to BigInt here to avoid losing precision. We cannot\n    // rely on Math.pow() (for example) to be capable of handling our insane numbers.\n\n    let result = BigInt(0);\n    for (let i = s.length - 1, j = BigInt(0); i >= 0; i--, j++) {\n        const charIndex = s.charCodeAt(i) - alphabet.charCodeAt(0);\n\n        // We add 1 to the char index to offset the whole numbering scheme. We unpack this in\n        // the baseToString() function.\n        result += BigInt(1 + charIndex) * len ** j;\n    }\n    return result;\n}\n\n/**\n * Averages two strings, returning the midpoint between them. This is accomplished by\n * converting both to baseN numbers (where N is the alphabet's length) then averaging\n * those before re-encoding as a string.\n * @param a - The first string.\n * @param b - The second string.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The midpoint between the strings, as a string.\n */\nexport function averageBetweenStrings(a: string, b: string, alphabet = DEFAULT_ALPHABET): string {\n    const padN = Math.max(a.length, b.length);\n    const baseA = stringToBase(alphabetPad(a, padN, alphabet), alphabet);\n    const baseB = stringToBase(alphabetPad(b, padN, alphabet), alphabet);\n    const avg = (baseA + baseB) / BigInt(2);\n\n    // Detect integer division conflicts. This happens when two numbers are divided too close so\n    // we lose a .5 precision. We need to add a padding character in these cases.\n    if (avg === baseA || avg == baseB) {\n        return baseToString(avg, alphabet) + alphabet[0];\n    }\n\n    return baseToString(avg, alphabet);\n}\n\n/**\n * Finds the next string using the alphabet provided. This is done by converting the\n * string to a baseN number, where N is the alphabet's length, then adding 1 before\n * converting back to a string.\n * @param s - The string to start at.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The string which follows the input string.\n */\nexport function nextString(s: string, alphabet = DEFAULT_ALPHABET): string {\n    return baseToString(stringToBase(s, alphabet) + BigInt(1), alphabet);\n}\n\n/**\n * Finds the previous string using the alphabet provided. This is done by converting the\n * string to a baseN number, where N is the alphabet's length, then subtracting 1 before\n * converting back to a string.\n * @param s - The string to start at.\n * @param alphabet - The alphabet to use as a single string.\n * @returns The string which precedes the input string.\n */\nexport function prevString(s: string, alphabet = DEFAULT_ALPHABET): string {\n    return baseToString(stringToBase(s, alphabet) - BigInt(1), alphabet);\n}\n\n/**\n * Compares strings lexicographically as a sort-safe function.\n * @param a - The first (reference) string.\n * @param b - The second (compare) string.\n * @returns Negative if the reference string is before the compare string;\n * positive if the reference string is after; and zero if equal.\n */\nexport function lexicographicCompare(a: string, b: string): number {\n    // Dev note: this exists because I'm sad that you can use math operators on strings, so I've\n    // hidden the operation in this function.\n    if (a < b) {\n        return -1;\n    } else if (a > b) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/**\n * This function is similar to Object.assign() but it assigns recursively and\n * allows you to ignore nullish values from the source\n *\n * @returns the target object\n */\nexport function recursivelyAssign<T1 extends T2, T2 extends Record<string, any>>(\n    target: T1,\n    source: T2,\n    ignoreNullish = false,\n): T1 & T2 {\n    for (const [sourceKey, sourceValue] of Object.entries(source)) {\n        if (target[sourceKey] instanceof Object && sourceValue) {\n            recursivelyAssign(target[sourceKey], sourceValue);\n            continue;\n        }\n        if ((sourceValue !== null && sourceValue !== undefined) || !ignoreNullish) {\n            safeSet(target, sourceKey, sourceValue);\n            continue;\n        }\n    }\n    return target as T1 & T2;\n}\n\nfunction getContentTimestampWithFallback(event: MatrixEvent): number {\n    return M_TIMESTAMP.findIn<number>(event.getContent()) ?? -1;\n}\n\n/**\n * Sort events by their content m.ts property\n * Latest timestamp first\n */\nexport function sortEventsByLatestContentTimestamp(left: MatrixEvent, right: MatrixEvent): number {\n    return getContentTimestampWithFallback(right) - getContentTimestampWithFallback(left);\n}\n\nexport function isSupportedReceiptType(receiptType: string): boolean {\n    return [ReceiptType.Read, ReceiptType.ReadPrivate].includes(receiptType as ReceiptType);\n}\n\n/**\n * Determines whether two maps are equal.\n * @param eq - The equivalence relation to compare values by. Defaults to strict equality.\n */\nexport function mapsEqual<K, V>(x: Map<K, V>, y: Map<K, V>, eq = (v1: V, v2: V): boolean => v1 === v2): boolean {\n    if (x.size !== y.size) return false;\n    for (const [k, v1] of x) {\n        const v2 = y.get(k);\n        if (v2 === undefined || !eq(v1, v2)) return false;\n    }\n    return true;\n}\n\nfunction processMapToObjectValue(value: any): any {\n    if (value instanceof Map) {\n        // Value is a Map. Recursively map it to an object.\n        return recursiveMapToObject(value);\n    } else if (Array.isArray(value)) {\n        // Value is an Array. Recursively map the value (e.g. to cover Array of Arrays).\n        return value.map((v) => processMapToObjectValue(v));\n    } else {\n        return value;\n    }\n}\n\n/**\n * Recursively converts Maps to plain objects.\n * Also supports sub-lists of Maps.\n */\nexport function recursiveMapToObject(map: Map<any, any>): Record<any, any> {\n    const targetMap = new Map();\n\n    for (const [key, value] of map) {\n        targetMap.set(key, processMapToObjectValue(value));\n    }\n\n    return Object.fromEntries(targetMap.entries());\n}\n\nexport function unsafeProp<K extends keyof any | undefined>(prop: K): boolean {\n    return prop === \"__proto__\" || prop === \"prototype\" || prop === \"constructor\";\n}\n\nexport function safeSet<O extends Record<any, any>, K extends keyof O>(obj: O, prop: K, value: O[K]): void {\n    if (unsafeProp(prop)) {\n        throw new Error(\"Trying to modify prototype or constructor\");\n    }\n\n    obj[prop] = value;\n}\n\nexport function noUnsafeEventProps(event: Partial<IEvent>): boolean {\n    return !(unsafeProp(event.room_id) || unsafeProp(event.sender) || unsafeProp(event.event_id));\n}\n\nexport class MapWithDefault<K, V> extends Map<K, V> {\n    public constructor(private createDefault: () => V) {\n        super();\n    }\n\n    /**\n     * Returns the value if the key already exists.\n     * If not, it creates a new value under that key using the ctor callback and returns it.\n     */\n    public getOrCreate(key: K): V {\n        if (!this.has(key)) {\n            this.set(key, this.createDefault());\n        }\n\n        return this.get(key)!;\n    }\n}\n","/*\n * Copyright 2024 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { decodeBase64 } from \"../base64.ts\";\nimport { deriveKeys } from \"./internal/deriveKeys.ts\";\nimport { type AESEncryptedSecretStoragePayload } from \"../@types/AESEncryptedSecretStoragePayload.ts\";\n\n/**\n * Decrypt an AES-encrypted Secret Storage item.\n *\n * @param data - the encrypted data, returned by {@link utils/encryptAESSecretStorageItem.default | encryptAESSecretStorageItem}.\n * @param key - the encryption key to use as an input to the HKDF function which is used to derive the AES key. Must\n *    be the same as provided to {@link utils/encryptAESSecretStorageItem.default | encryptAESSecretStorageItem}.\n * @param name - the name of the secret. Also used as an input to the HKDF operation which is used to derive the AES\n *    key, so again must be the same as provided to {@link utils/encryptAESSecretStorageItem.default | encryptAESSecretStorageItem}.\n */\nexport default async function decryptAESSecretStorageItem(\n    data: AESEncryptedSecretStoragePayload,\n    key: Uint8Array<ArrayBuffer>,\n    name: string,\n): Promise<string> {\n    const [aesKey, hmacKey] = await deriveKeys(key, name);\n\n    const ciphertext = decodeBase64(data.ciphertext);\n\n    if (!(await globalThis.crypto.subtle.verify({ name: \"HMAC\" }, hmacKey, decodeBase64(data.mac), ciphertext))) {\n        throw new Error(`Error decrypting secret ${name}: bad MAC`);\n    }\n\n    const plaintext = await globalThis.crypto.subtle.decrypt(\n        {\n            name: \"AES-CTR\",\n            counter: decodeBase64(data.iv),\n            length: 64,\n        },\n        aesKey,\n        ciphertext,\n    );\n\n    return new TextDecoder().decode(new Uint8Array(plaintext));\n}\n","/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * A list of the spec versions which the js-sdk is compatible with.\n *\n * In practice, this means: when we connect to a server, it must declare support for one of the versions in this list.\n *\n * Note that it does not *necessarily* mean that the js-sdk has good support for all the features in the listed spec\n * versions; only that we should be able to provide a base level of functionality with a server that offers support for\n * any of the listed versions.\n */\nexport const SUPPORTED_MATRIX_VERSIONS = [\"v1.1\", \"v1.2\", \"v1.3\", \"v1.4\", \"v1.5\", \"v1.6\", \"v1.7\", \"v1.8\", \"v1.9\"];\n\n/**\n * The oldest Matrix specification version the js-sdk supports.\n */\nexport const MINIMUM_MATRIX_VERSION = SUPPORTED_MATRIX_VERSIONS[0];\n\n/**\n * The most recent Matrix specification version the js-sdk supports.\n */\nexport const MAXIMUM_MATRIX_VERSION = SUPPORTED_MATRIX_VERSIONS[SUPPORTED_MATRIX_VERSIONS.length - 1];\n","/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017 New Vector Ltd\nCopyright 2019, 2020 The Matrix.org Foundation C.I.C.\nCopyright 2021 - 2022 imon Brandner <simon.bra.ag@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link createNewMatrixCall} for the public API.\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport { parse as parseSdp, write as writeSdp } from \"sdp-transform\";\n\nimport { logger } from \"../logger.ts\";\nimport { checkObjectHasKeys, isNullOrUndefined, recursivelyAssign } from \"../utils.ts\";\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { EventType, type TimelineEvents, ToDeviceMessageId } from \"../@types/event.ts\";\nimport { type RoomMember } from \"../models/room-member.ts\";\nimport { secureRandomString } from \"../randomstring.ts\";\nimport {\n    type MCallReplacesEvent,\n    type MCallAnswer,\n    type MCallInviteNegotiate,\n    type CallCapabilities,\n    SDPStreamMetadataPurpose,\n    type SDPStreamMetadata,\n    SDPStreamMetadataKey,\n    type MCallSDPStreamMetadataChanged,\n    type MCallSelectAnswer,\n    type MCAllAssertedIdentity,\n    type MCallCandidates,\n    type MCallBase,\n    type MCallHangupReject,\n} from \"./callEventTypes.ts\";\nimport { CallFeed } from \"./callFeed.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { EventEmitterEvents, TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { GroupCallUnknownDeviceError } from \"./groupCall.ts\";\nimport { type IScreensharingOpts } from \"./mediaHandler.ts\";\nimport { MatrixError } from \"../http-api/index.ts\";\nimport { type GroupCallStats } from \"./stats/groupCallStats.ts\";\n\ninterface CallOpts {\n    // The room ID for this call.\n    roomId: string;\n    invitee?: string;\n    // The Matrix Client instance to send events to.\n    client: MatrixClient;\n    /**\n     * Whether relay through TURN should be forced.\n     * @deprecated use opts.forceTURN when creating the matrix client\n     * since it's only possible to set this option on outbound calls.\n     */\n    forceTURN?: boolean;\n    // A list of TURN servers.\n    turnServers?: Array<TurnServer>;\n    opponentDeviceId?: string;\n    opponentSessionId?: string;\n    groupCallId?: string;\n}\n\ninterface TurnServer {\n    urls: Array<string>;\n    username?: string;\n    password?: string;\n    ttl?: number;\n}\n\ninterface AssertedIdentity {\n    id: string;\n    displayName: string;\n}\n\nenum MediaType {\n    AUDIO = \"audio\",\n    VIDEO = \"video\",\n}\n\nenum CodecName {\n    OPUS = \"opus\",\n    // add more as needed\n}\n\n// Used internally to specify modifications to codec parameters in SDP\ninterface CodecParamsMod {\n    mediaType: MediaType;\n    codec: CodecName;\n    enableDtx?: boolean; // true to enable discontinuous transmission, false to disable, undefined to leave as-is\n    maxAverageBitrate?: number; // sets the max average bitrate, or undefined to leave as-is\n}\n\nexport enum CallState {\n    Fledgling = \"fledgling\",\n    InviteSent = \"invite_sent\",\n    WaitLocalMedia = \"wait_local_media\",\n    CreateOffer = \"create_offer\",\n    CreateAnswer = \"create_answer\",\n    Connecting = \"connecting\",\n    Connected = \"connected\",\n    Ringing = \"ringing\",\n    Ended = \"ended\",\n}\n\nexport enum CallType {\n    Voice = \"voice\",\n    Video = \"video\",\n}\n\nexport enum CallDirection {\n    Inbound = \"inbound\",\n    Outbound = \"outbound\",\n}\n\nexport enum CallParty {\n    Local = \"local\",\n    Remote = \"remote\",\n}\n\nexport enum CallEvent {\n    Hangup = \"hangup\",\n    State = \"state\",\n    Error = \"error\",\n    Replaced = \"replaced\",\n\n    // The value of isLocalOnHold() has changed\n    LocalHoldUnhold = \"local_hold_unhold\",\n    // The value of isRemoteOnHold() has changed\n    RemoteHoldUnhold = \"remote_hold_unhold\",\n    // backwards compat alias for LocalHoldUnhold: remove in a major version bump\n    HoldUnhold = \"hold_unhold\",\n    // Feeds have changed\n    FeedsChanged = \"feeds_changed\",\n\n    AssertedIdentityChanged = \"asserted_identity_changed\",\n\n    LengthChanged = \"length_changed\",\n\n    DataChannel = \"datachannel\",\n\n    SendVoipEvent = \"send_voip_event\",\n\n    // When the call instantiates its peer connection\n    // For apps that want to access the underlying peer connection, eg for debugging\n    PeerConnectionCreated = \"peer_connection_created\",\n}\n\nexport enum CallErrorCode {\n    /** The user chose to end the call */\n    UserHangup = \"user_hangup\",\n\n    /** An error code when the local client failed to create an offer. */\n    LocalOfferFailed = \"local_offer_failed\",\n    /**\n     * An error code when there is no local mic/camera to use. This may be because\n     * the hardware isn't plugged in, or the user has explicitly denied access.\n     */\n    NoUserMedia = \"no_user_media\",\n\n    /**\n     * Error code used when a call event failed to send\n     * because unknown devices were present in the room\n     */\n    UnknownDevices = \"unknown_devices\",\n\n    /**\n     * Error code used when we fail to send the invite\n     * for some reason other than there being unknown devices\n     */\n    SendInvite = \"send_invite\",\n\n    /**\n     * An answer could not be created\n     */\n    CreateAnswer = \"create_answer\",\n\n    /**\n     * An offer could not be created\n     */\n    CreateOffer = \"create_offer\",\n\n    /**\n     * Error code used when we fail to send the answer\n     * for some reason other than there being unknown devices\n     */\n    SendAnswer = \"send_answer\",\n\n    /**\n     * The session description from the other side could not be set\n     */\n    SetRemoteDescription = \"set_remote_description\",\n\n    /**\n     * The session description from this side could not be set\n     */\n    SetLocalDescription = \"set_local_description\",\n\n    /**\n     * A different device answered the call\n     */\n    AnsweredElsewhere = \"answered_elsewhere\",\n\n    /**\n     * No media connection could be established to the other party\n     */\n    IceFailed = \"ice_failed\",\n\n    /**\n     * The invite timed out whilst waiting for an answer\n     */\n    InviteTimeout = \"invite_timeout\",\n\n    /**\n     * The call was replaced by another call\n     */\n    Replaced = \"replaced\",\n\n    /**\n     * Signalling for the call could not be sent (other than the initial invite)\n     */\n    SignallingFailed = \"signalling_timeout\",\n\n    /**\n     * The remote party is busy\n     */\n    UserBusy = \"user_busy\",\n\n    /**\n     * We transferred the call off to somewhere else\n     */\n    Transferred = \"transferred\",\n\n    /**\n     * A call from the same user was found with a new session id\n     */\n    NewSession = \"new_session\",\n}\n\n/**\n * The version field that we set in m.call.* events\n */\nconst VOIP_PROTO_VERSION = \"1\";\n\n/** The fallback ICE server to use for STUN or TURN protocols. */\nexport const FALLBACK_ICE_SERVER = \"stun:turn.matrix.org\";\n\n/** The length of time a call can be ringing for. */\nconst CALL_TIMEOUT_MS = 60 * 1000; // ms\n/** The time after which we increment callLength */\nconst CALL_LENGTH_INTERVAL = 1000; // ms\n/** The time after which we end the call, if ICE got disconnected */\nconst ICE_DISCONNECTED_TIMEOUT = 30 * 1000; // ms\n/** The time after which we try a ICE restart, if ICE got disconnected */\nconst ICE_RECONNECTING_TIMEOUT = 2 * 1000; // ms\nexport class CallError extends Error {\n    public readonly code: string;\n\n    public constructor(code: CallErrorCode, msg: string, err: Error) {\n        // Still don't think there's any way to have proper nested errors\n        super(msg + \": \" + err);\n\n        this.code = code;\n    }\n}\n\nexport function genCallID(): string {\n    return Date.now().toString() + secureRandomString(16);\n}\n\nfunction getCodecParamMods(isPtt: boolean): CodecParamsMod[] {\n    const mods = [\n        {\n            mediaType: \"audio\",\n            codec: \"opus\",\n            enableDtx: true,\n            maxAverageBitrate: isPtt ? 12000 : undefined,\n        },\n    ] as CodecParamsMod[];\n\n    return mods;\n}\n\ntype CallEventType =\n    | EventType.CallReplaces\n    | EventType.CallAnswer\n    | EventType.CallSelectAnswer\n    | EventType.CallNegotiate\n    | EventType.CallInvite\n    | EventType.CallCandidates\n    | EventType.CallHangup\n    | EventType.CallReject\n    | EventType.CallSDPStreamMetadataChangedPrefix;\n\nexport interface VoipEvent {\n    type: \"toDevice\" | \"sendEvent\";\n    eventType: string;\n    userId?: string;\n    opponentDeviceId?: string;\n    roomId?: string;\n    content: TimelineEvents[CallEventType];\n}\n\n/**\n * These now all have the call object as an argument. Why? Well, to know which call a given event is\n * about you have three options:\n *  1. Use a closure as the callback that remembers what call it's listening to. This can be\n *     a pain because you need to pass the listener function again when you remove the listener,\n *     which might be somewhere else.\n *  2. Use not-very-well-known fact that EventEmitter sets 'this' to the emitter object in the\n *     callback. This doesn't really play well with modern Typescript and eslint and doesn't work\n *     with our pattern of re-emitting events.\n *  3. Pass the object in question as an argument to the callback.\n *\n * Now that we have group calls which have to deal with multiple call objects, this will\n * become more important, and I think methods 1 and 2 are just going to cause issues.\n */\nexport type CallEventHandlerMap = {\n    [CallEvent.DataChannel]: (channel: RTCDataChannel, call: MatrixCall) => void;\n    [CallEvent.FeedsChanged]: (feeds: CallFeed[], call: MatrixCall) => void;\n    [CallEvent.Replaced]: (newCall: MatrixCall, oldCall: MatrixCall) => void;\n    [CallEvent.Error]: (error: CallError, call: MatrixCall) => void;\n    [CallEvent.RemoteHoldUnhold]: (onHold: boolean, call: MatrixCall) => void;\n    [CallEvent.LocalHoldUnhold]: (onHold: boolean, call: MatrixCall) => void;\n    [CallEvent.LengthChanged]: (length: number, call: MatrixCall) => void;\n    [CallEvent.State]: (state: CallState, oldState: CallState, call: MatrixCall) => void;\n    [CallEvent.Hangup]: (call: MatrixCall) => void;\n    [CallEvent.AssertedIdentityChanged]: (call: MatrixCall) => void;\n    /* @deprecated */\n    [CallEvent.HoldUnhold]: (onHold: boolean) => void;\n    [CallEvent.SendVoipEvent]: (event: VoipEvent, call: MatrixCall) => void;\n    [CallEvent.PeerConnectionCreated]: (peerConn: RTCPeerConnection, call: MatrixCall) => void;\n};\n\n// The key of the transceiver map (purpose + media type, separated by ':')\ntype TransceiverKey = string;\n\n// generates keys for the map of transceivers\n// kind is unfortunately a string rather than MediaType as this is the type of\n// track.kind\nfunction getTransceiverKey(purpose: SDPStreamMetadataPurpose, kind: TransceiverKey): string {\n    return purpose + \":\" + kind;\n}\n\nexport class MatrixCall extends TypedEventEmitter<CallEvent, CallEventHandlerMap> {\n    public roomId: string;\n    public callId: string;\n    public invitee?: string;\n    public hangupParty?: CallParty;\n    public hangupReason?: string;\n    public direction?: CallDirection;\n    public ourPartyId: string;\n    public peerConn?: RTCPeerConnection;\n    public toDeviceSeq = 0;\n\n    // whether this call should have push-to-talk semantics\n    // This should be set by the consumer on incoming & outgoing calls.\n    public isPtt = false;\n\n    private _state = CallState.Fledgling;\n    private readonly client: MatrixClient;\n    private readonly forceTURN?: boolean;\n    private readonly turnServers: Array<TurnServer>;\n    // A queue for candidates waiting to go out.\n    // We try to amalgamate candidates into a single candidate message where\n    // possible\n    private candidateSendQueue: Array<RTCIceCandidate> = [];\n    private candidateSendTries = 0;\n    private candidatesEnded = false;\n    private feeds: Array<CallFeed> = [];\n\n    // our transceivers for each purpose and type of media\n    private transceivers = new Map<TransceiverKey, RTCRtpTransceiver>();\n\n    private inviteOrAnswerSent = false;\n    private waitForLocalAVStream = false;\n    private successor?: MatrixCall;\n    private opponentMember?: RoomMember;\n    private opponentVersion?: number | string;\n    // The party ID of the other side: undefined if we haven't chosen a partner\n    // yet, null if we have but they didn't send a party ID.\n    private opponentPartyId: string | null | undefined;\n    private opponentCaps?: CallCapabilities;\n    private iceDisconnectedTimeout?: ReturnType<typeof setTimeout>;\n    private iceReconnectionTimeOut?: ReturnType<typeof setTimeout> | undefined;\n    private inviteTimeout?: ReturnType<typeof setTimeout>;\n    private readonly removeTrackListeners = new Map<MediaStream, () => void>();\n\n    // The logic of when & if a call is on hold is nontrivial and explained in is*OnHold\n    // This flag represents whether we want the other party to be on hold\n    private remoteOnHold = false;\n\n    // the stats for the call at the point it ended. We can't get these after we\n    // tear the call down, so we just grab a snapshot before we stop the call.\n    // The typescript definitions have this type as 'any' :(\n    private callStatsAtEnd?: any[];\n\n    // Perfect negotiation state: https://www.w3.org/TR/webrtc/#perfect-negotiation-example\n    private makingOffer = false;\n    private ignoreOffer = false;\n    private isSettingRemoteAnswerPending = false;\n\n    private responsePromiseChain?: Promise<void>;\n\n    // If candidates arrive before we've picked an opponent (which, in particular,\n    // will happen if the opponent sends candidates eagerly before the user answers\n    // the call) we buffer them up here so we can then add the ones from the party we pick\n    private remoteCandidateBuffer = new Map<string, MCallCandidates[\"candidates\"]>();\n\n    private remoteAssertedIdentity?: AssertedIdentity;\n    private remoteSDPStreamMetadata?: SDPStreamMetadata;\n\n    private callLengthInterval?: ReturnType<typeof setInterval>;\n    private callStartTime?: number;\n\n    private opponentDeviceId?: string;\n    private hasOpponentDeviceInfo?: boolean;\n    private opponentSessionId?: string;\n    public groupCallId?: string;\n\n    // Used to keep the timer for the delay before actually stopping our\n    // video track after muting (see setLocalVideoMuted)\n    private stopVideoTrackTimer?: ReturnType<typeof setTimeout>;\n    // Used to allow connection without Video and Audio. To establish a webrtc connection without media a Data channel is\n    // needed At the moment this property is true if we allow MatrixClient with isVoipWithNoMediaAllowed = true\n    private readonly isOnlyDataChannelAllowed: boolean;\n    private stats: GroupCallStats | undefined;\n\n    /**\n     * Construct a new Matrix Call.\n     * @param opts - Config options.\n     */\n    public constructor(opts: CallOpts) {\n        super();\n\n        this.roomId = opts.roomId;\n        this.invitee = opts.invitee;\n        this.client = opts.client;\n\n        if (!this.client.deviceId) throw new Error(\"Client must have a device ID to start calls\");\n\n        this.forceTURN = opts.forceTURN ?? false;\n        this.ourPartyId = this.client.deviceId;\n        this.opponentDeviceId = opts.opponentDeviceId;\n        this.opponentSessionId = opts.opponentSessionId;\n        this.groupCallId = opts.groupCallId;\n        // Array of Objects with urls, username, credential keys\n        this.turnServers = opts.turnServers || [];\n        if (this.turnServers.length === 0 && this.client.isFallbackICEServerAllowed()) {\n            this.turnServers.push({\n                urls: [FALLBACK_ICE_SERVER],\n            });\n        }\n        for (const server of this.turnServers) {\n            checkObjectHasKeys(server, [\"urls\"]);\n        }\n        this.callId = genCallID();\n        // If the Client provides calls without audio and video we need a datachannel for a webrtc connection\n        this.isOnlyDataChannelAllowed = this.client.isVoipWithNoMediaAllowed;\n    }\n\n    /**\n     * Place a voice call to this room.\n     * @throws If you have not specified a listener for 'error' events.\n     */\n    public async placeVoiceCall(): Promise<void> {\n        await this.placeCall(true, false);\n    }\n\n    /**\n     * Place a video call to this room.\n     * @throws If you have not specified a listener for 'error' events.\n     */\n    public async placeVideoCall(): Promise<void> {\n        await this.placeCall(true, true);\n    }\n\n    /**\n     * Create a datachannel using this call's peer connection.\n     * @param label - A human readable label for this datachannel\n     * @param options - An object providing configuration options for the data channel.\n     */\n    public createDataChannel(label: string, options: RTCDataChannelInit | undefined): RTCDataChannel {\n        const dataChannel = this.peerConn!.createDataChannel(label, options);\n        this.emit(CallEvent.DataChannel, dataChannel, this);\n        return dataChannel;\n    }\n\n    public getOpponentMember(): RoomMember | undefined {\n        return this.opponentMember;\n    }\n\n    public getOpponentDeviceId(): string | undefined {\n        return this.opponentDeviceId;\n    }\n\n    public getOpponentSessionId(): string | undefined {\n        return this.opponentSessionId;\n    }\n\n    public opponentCanBeTransferred(): boolean {\n        return Boolean(this.opponentCaps && this.opponentCaps[\"m.call.transferee\"]);\n    }\n\n    public opponentSupportsDTMF(): boolean {\n        return Boolean(this.opponentCaps && this.opponentCaps[\"m.call.dtmf\"]);\n    }\n\n    public getRemoteAssertedIdentity(): AssertedIdentity | undefined {\n        return this.remoteAssertedIdentity;\n    }\n\n    public get state(): CallState {\n        return this._state;\n    }\n\n    private set state(state: CallState) {\n        const oldState = this._state;\n        this._state = state;\n        this.emit(CallEvent.State, state, oldState, this);\n    }\n\n    public get type(): CallType {\n        // we may want to look for a video receiver here rather than a track to match the\n        // sender behaviour, although in practice they should be the same thing\n        return this.hasUserMediaVideoSender || this.hasRemoteUserMediaVideoTrack ? CallType.Video : CallType.Voice;\n    }\n\n    public get hasLocalUserMediaVideoTrack(): boolean {\n        return !!this.localUsermediaStream?.getVideoTracks().length;\n    }\n\n    public get hasRemoteUserMediaVideoTrack(): boolean {\n        return this.getRemoteFeeds().some((feed) => {\n            return feed.purpose === SDPStreamMetadataPurpose.Usermedia && feed.stream?.getVideoTracks().length;\n        });\n    }\n\n    public get hasLocalUserMediaAudioTrack(): boolean {\n        return !!this.localUsermediaStream?.getAudioTracks().length;\n    }\n\n    public get hasRemoteUserMediaAudioTrack(): boolean {\n        return this.getRemoteFeeds().some((feed) => {\n            return feed.purpose === SDPStreamMetadataPurpose.Usermedia && !!feed.stream?.getAudioTracks().length;\n        });\n    }\n\n    private get hasUserMediaAudioSender(): boolean {\n        return Boolean(this.transceivers.get(getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, \"audio\"))?.sender);\n    }\n\n    private get hasUserMediaVideoSender(): boolean {\n        return Boolean(this.transceivers.get(getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, \"video\"))?.sender);\n    }\n\n    public get localUsermediaFeed(): CallFeed | undefined {\n        return this.getLocalFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Usermedia);\n    }\n\n    public get localScreensharingFeed(): CallFeed | undefined {\n        return this.getLocalFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Screenshare);\n    }\n\n    public get localUsermediaStream(): MediaStream | undefined {\n        return this.localUsermediaFeed?.stream;\n    }\n\n    public get localScreensharingStream(): MediaStream | undefined {\n        return this.localScreensharingFeed?.stream;\n    }\n\n    public get remoteUsermediaFeed(): CallFeed | undefined {\n        return this.getRemoteFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Usermedia);\n    }\n\n    public get remoteScreensharingFeed(): CallFeed | undefined {\n        return this.getRemoteFeeds().find((feed) => feed.purpose === SDPStreamMetadataPurpose.Screenshare);\n    }\n\n    public get remoteUsermediaStream(): MediaStream | undefined {\n        return this.remoteUsermediaFeed?.stream;\n    }\n\n    public get remoteScreensharingStream(): MediaStream | undefined {\n        return this.remoteScreensharingFeed?.stream;\n    }\n\n    private getFeedByStreamId(streamId: string): CallFeed | undefined {\n        return this.getFeeds().find((feed) => feed.stream.id === streamId);\n    }\n\n    /**\n     * Returns an array of all CallFeeds\n     * @returns CallFeeds\n     */\n    public getFeeds(): Array<CallFeed> {\n        return this.feeds;\n    }\n\n    /**\n     * Returns an array of all local CallFeeds\n     * @returns local CallFeeds\n     */\n    public getLocalFeeds(): Array<CallFeed> {\n        return this.feeds.filter((feed) => feed.isLocal());\n    }\n\n    /**\n     * Returns an array of all remote CallFeeds\n     * @returns remote CallFeeds\n     */\n    public getRemoteFeeds(): Array<CallFeed> {\n        return this.feeds.filter((feed) => !feed.isLocal());\n    }\n\n    private async initOpponentCrypto(): Promise<void> {\n        if (!this.opponentDeviceId) return;\n        if (!this.client.getUseE2eForGroupCall()) return;\n        // It's possible to want E2EE and yet not have the means to manage E2EE\n        // ourselves (for example if the client is a RoomWidgetClient)\n        if (!this.client.getCrypto()) {\n            // All we know is the device ID\n            this.hasOpponentDeviceInfo = true;\n            return;\n        }\n        const userId = this.invitee || this.getOpponentMember()?.userId;\n\n        if (!userId) throw new Error(\"Couldn't find opponent user ID to init crypto\");\n\n        // Here we were calling `MatrixClient.crypto.deviceList.downloadKeys` which is not supported by the rust cryptography.\n        this.hasOpponentDeviceInfo = false;\n        throw new GroupCallUnknownDeviceError(userId);\n    }\n\n    /**\n     * Generates and returns localSDPStreamMetadata\n     * @returns localSDPStreamMetadata\n     */\n    private getLocalSDPStreamMetadata(updateStreamIds = false): SDPStreamMetadata {\n        const metadata: SDPStreamMetadata = {};\n        for (const localFeed of this.getLocalFeeds()) {\n            if (updateStreamIds) {\n                localFeed.sdpMetadataStreamId = localFeed.stream.id;\n            }\n\n            metadata[localFeed.sdpMetadataStreamId] = {\n                purpose: localFeed.purpose,\n                audio_muted: localFeed.isAudioMuted(),\n                video_muted: localFeed.isVideoMuted(),\n            };\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns true if there are no incoming feeds,\n     * otherwise returns false\n     * @returns no incoming feeds\n     */\n    public noIncomingFeeds(): boolean {\n        return !this.feeds.some((feed) => !feed.isLocal());\n    }\n\n    private pushRemoteFeed(stream: MediaStream): void {\n        // Fallback to old behavior if the other side doesn't support SDPStreamMetadata\n        if (!this.opponentSupportsSDPStreamMetadata()) {\n            this.pushRemoteFeedWithoutMetadata(stream);\n            return;\n        }\n\n        const userId = this.getOpponentMember()!.userId;\n        const purpose = this.remoteSDPStreamMetadata![stream.id].purpose;\n        const audioMuted = this.remoteSDPStreamMetadata![stream.id].audio_muted;\n        const videoMuted = this.remoteSDPStreamMetadata![stream.id].video_muted;\n\n        if (!purpose) {\n            logger.warn(\n                `Call ${this.callId} pushRemoteFeed() ignoring stream because we didn't get any metadata about it (streamId=${stream.id})`,\n            );\n            return;\n        }\n\n        if (this.getFeedByStreamId(stream.id)) {\n            logger.warn(\n                `Call ${this.callId} pushRemoteFeed() ignoring stream because we already have a feed for it (streamId=${stream.id})`,\n            );\n            return;\n        }\n\n        this.feeds.push(\n            new CallFeed({\n                client: this.client,\n                call: this,\n                roomId: this.roomId,\n                userId,\n                deviceId: this.getOpponentDeviceId(),\n                stream,\n                purpose,\n                audioMuted,\n                videoMuted,\n            }),\n        );\n\n        this.emit(CallEvent.FeedsChanged, this.feeds, this);\n\n        logger.info(\n            `Call ${this.callId} pushRemoteFeed() pushed stream (streamId=${stream.id}, active=${stream.active}, purpose=${purpose})`,\n        );\n    }\n\n    /**\n     * This method is used ONLY if the other client doesn't support sending SDPStreamMetadata\n     */\n    private pushRemoteFeedWithoutMetadata(stream: MediaStream): void {\n        const userId = this.getOpponentMember()!.userId;\n        // We can guess the purpose here since the other client can only send one stream\n        const purpose = SDPStreamMetadataPurpose.Usermedia;\n        const oldRemoteStream = this.feeds.find((feed) => !feed.isLocal())?.stream;\n\n        // Note that we check by ID and always set the remote stream: Chrome appears\n        // to make new stream objects when transceiver directionality is changed and the 'active'\n        // status of streams change - Dave\n        // If we already have a stream, check this stream has the same id\n        if (oldRemoteStream && stream.id !== oldRemoteStream.id) {\n            logger.warn(\n                `Call ${this.callId} pushRemoteFeedWithoutMetadata() ignoring new stream because we already have stream (streamId=${stream.id})`,\n            );\n            return;\n        }\n\n        if (this.getFeedByStreamId(stream.id)) {\n            logger.warn(\n                `Call ${this.callId} pushRemoteFeedWithoutMetadata() ignoring stream because we already have a feed for it (streamId=${stream.id})`,\n            );\n            return;\n        }\n\n        this.feeds.push(\n            new CallFeed({\n                client: this.client,\n                call: this,\n                roomId: this.roomId,\n                audioMuted: false,\n                videoMuted: false,\n                userId,\n                deviceId: this.getOpponentDeviceId(),\n                stream,\n                purpose,\n            }),\n        );\n\n        this.emit(CallEvent.FeedsChanged, this.feeds, this);\n\n        logger.info(\n            `Call ${this.callId} pushRemoteFeedWithoutMetadata() pushed stream (streamId=${stream.id}, active=${stream.active})`,\n        );\n    }\n\n    private pushNewLocalFeed(stream: MediaStream, purpose: SDPStreamMetadataPurpose, addToPeerConnection = true): void {\n        const userId = this.client.getUserId()!;\n\n        // Tracks don't always start off enabled, eg. chrome will give a disabled\n        // audio track if you ask for user media audio and already had one that\n        // you'd set to disabled (presumably because it clones them internally).\n        setTracksEnabled(stream.getAudioTracks(), true);\n        setTracksEnabled(stream.getVideoTracks(), true);\n\n        if (this.getFeedByStreamId(stream.id)) {\n            logger.warn(\n                `Call ${this.callId} pushNewLocalFeed() ignoring stream because we already have a feed for it (streamId=${stream.id})`,\n            );\n            return;\n        }\n\n        this.pushLocalFeed(\n            new CallFeed({\n                client: this.client,\n                roomId: this.roomId,\n                audioMuted: false,\n                videoMuted: false,\n                userId,\n                deviceId: this.getOpponentDeviceId(),\n                stream,\n                purpose,\n            }),\n            addToPeerConnection,\n        );\n    }\n\n    /**\n     * Pushes supplied feed to the call\n     * @param callFeed - to push\n     * @param addToPeerConnection - whether to add the tracks to the peer connection\n     */\n    public pushLocalFeed(callFeed: CallFeed, addToPeerConnection = true): void {\n        if (this.feeds.some((feed) => callFeed.stream.id === feed.stream.id)) {\n            logger.info(\n                `Call ${this.callId} pushLocalFeed() ignoring duplicate local stream (streamId=${callFeed.stream.id})`,\n            );\n            return;\n        }\n\n        this.feeds.push(callFeed);\n\n        if (addToPeerConnection) {\n            for (const track of callFeed.stream.getTracks()) {\n                logger.info(\n                    `Call ${this.callId} pushLocalFeed() adding track to peer connection (id=${track.id}, kind=${track.kind}, streamId=${callFeed.stream.id}, streamPurpose=${callFeed.purpose}, enabled=${track.enabled})`,\n                );\n\n                const tKey = getTransceiverKey(callFeed.purpose, track.kind);\n                if (this.transceivers.has(tKey)) {\n                    // we already have a sender, so we re-use it. We try to re-use transceivers as much\n                    // as possible because they can't be removed once added, so otherwise they just\n                    // accumulate which makes the SDP very large very quickly: in fact it only takes\n                    // about 6 video tracks to exceed the maximum size of an Olm-encrypted\n                    // Matrix event.\n                    const transceiver = this.transceivers.get(tKey)!;\n\n                    transceiver.sender.replaceTrack(track);\n                    // set the direction to indicate we're going to start sending again\n                    // (this will trigger the re-negotiation)\n                    transceiver.direction = transceiver.direction === \"inactive\" ? \"sendonly\" : \"sendrecv\";\n                } else {\n                    // create a new one. We need to use addTrack rather addTransceiver for this because firefox\n                    // doesn't yet implement RTCRTPSender.setStreams()\n                    // (https://bugzilla.mozilla.org/show_bug.cgi?id=1510802) so we'd have no way to group the\n                    // two tracks together into a stream.\n                    const newSender = this.peerConn!.addTrack(track, callFeed.stream);\n\n                    // now go & fish for the new transceiver\n                    const newTransceiver = this.peerConn!.getTransceivers().find((t) => t.sender === newSender);\n                    if (newTransceiver) {\n                        this.transceivers.set(tKey, newTransceiver);\n                    } else {\n                        logger.warn(\n                            `Call ${this.callId} pushLocalFeed() didn't find a matching transceiver after adding track!`,\n                        );\n                    }\n                }\n            }\n        }\n\n        logger.info(\n            `Call ${this.callId} pushLocalFeed() pushed stream (id=${callFeed.stream.id}, active=${callFeed.stream.active}, purpose=${callFeed.purpose})`,\n        );\n\n        this.emit(CallEvent.FeedsChanged, this.feeds, this);\n    }\n\n    /**\n     * Removes local call feed from the call and its tracks from the peer\n     * connection\n     * @param callFeed - to remove\n     */\n    public removeLocalFeed(callFeed: CallFeed): void {\n        const audioTransceiverKey = getTransceiverKey(callFeed.purpose, \"audio\");\n        const videoTransceiverKey = getTransceiverKey(callFeed.purpose, \"video\");\n\n        for (const transceiverKey of [audioTransceiverKey, videoTransceiverKey]) {\n            // this is slightly mixing the track and transceiver API but is basically just shorthand.\n            // There is no way to actually remove a transceiver, so this just sets it to inactive\n            // (or recvonly) and replaces the source with nothing.\n            if (this.transceivers.has(transceiverKey)) {\n                const transceiver = this.transceivers.get(transceiverKey)!;\n                if (transceiver.sender) this.peerConn!.removeTrack(transceiver.sender);\n            }\n        }\n\n        if (callFeed.purpose === SDPStreamMetadataPurpose.Screenshare) {\n            this.client.getMediaHandler().stopScreensharingStream(callFeed.stream);\n        }\n\n        this.deleteFeed(callFeed);\n    }\n\n    private deleteAllFeeds(): void {\n        for (const feed of this.feeds) {\n            if (!feed.isLocal() || !this.groupCallId) {\n                feed.dispose();\n            }\n        }\n\n        this.feeds = [];\n        this.emit(CallEvent.FeedsChanged, this.feeds, this);\n    }\n\n    private deleteFeedByStream(stream: MediaStream): void {\n        const feed = this.getFeedByStreamId(stream.id);\n        if (!feed) {\n            logger.warn(\n                `Call ${this.callId} deleteFeedByStream() didn't find the feed to delete (streamId=${stream.id})`,\n            );\n            return;\n        }\n        this.deleteFeed(feed);\n    }\n\n    private deleteFeed(feed: CallFeed): void {\n        feed.dispose();\n        this.feeds.splice(this.feeds.indexOf(feed), 1);\n        this.emit(CallEvent.FeedsChanged, this.feeds, this);\n    }\n\n    // The typescript definitions have this type as 'any' :(\n    public async getCurrentCallStats(): Promise<any[] | undefined> {\n        if (this.callHasEnded()) {\n            return this.callStatsAtEnd;\n        }\n\n        return this.collectCallStats();\n    }\n\n    private async collectCallStats(): Promise<any[] | undefined> {\n        // This happens when the call fails before it starts.\n        // For example when we fail to get capture sources\n        if (!this.peerConn) return;\n\n        const statsReport = await this.peerConn.getStats();\n        const stats: any[] = [];\n        statsReport.forEach((item) => {\n            stats.push(item);\n        });\n\n        return stats;\n    }\n\n    /**\n     * Configure this call from an invite event. Used by MatrixClient.\n     * @param event - The m.call.invite event\n     */\n    public async initWithInvite(event: MatrixEvent): Promise<void> {\n        const invite = event.getContent<MCallInviteNegotiate>();\n        this.direction = CallDirection.Inbound;\n\n        // make sure we have valid turn creds. Unless something's gone wrong, it should\n        // poll and keep the credentials valid so this should be instant.\n        const haveTurnCreds = await this.client.checkTurnServers();\n        if (!haveTurnCreds) {\n            logger.warn(\n                `Call ${this.callId} initWithInvite() failed to get TURN credentials! Proceeding with call anyway...`,\n            );\n        }\n\n        const sdpStreamMetadata = invite[SDPStreamMetadataKey];\n        if (sdpStreamMetadata) {\n            this.updateRemoteSDPStreamMetadata(sdpStreamMetadata);\n        } else {\n            logger.debug(\n                `Call ${this.callId} initWithInvite() did not get any SDPStreamMetadata! Can not send/receive multiple streams`,\n            );\n        }\n\n        this.peerConn = this.createPeerConnection();\n        this.emit(CallEvent.PeerConnectionCreated, this.peerConn, this);\n        // we must set the party ID before await-ing on anything: the call event\n        // handler will start giving us more call events (eg. candidates) so if\n        // we haven't set the party ID, we'll ignore them.\n        this.chooseOpponent(event);\n        await this.initOpponentCrypto();\n        try {\n            await this.peerConn.setRemoteDescription(invite.offer);\n            logger.debug(`Call ${this.callId} initWithInvite() set remote description: ${invite.offer.type}`);\n            await this.addBufferedIceCandidates();\n        } catch (e) {\n            logger.debug(`Call ${this.callId} initWithInvite() failed to set remote description`, e);\n            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);\n            return;\n        }\n\n        const remoteStream = this.feeds.find((feed) => !feed.isLocal())?.stream;\n\n        // According to previous comments in this file, firefox at some point did not\n        // add streams until media started arriving on them. Testing latest firefox\n        // (81 at time of writing), this is no longer a problem, so let's do it the correct way.\n        //\n        // For example in case of no media webrtc connections like screen share only call we have to allow webrtc\n        // connections without remote media. In this case we always use a data channel. At the moment we allow as well\n        // only data channel as media in the WebRTC connection with this setup here.\n        if (!this.isOnlyDataChannelAllowed && (!remoteStream || remoteStream.getTracks().length === 0)) {\n            logger.error(\n                `Call ${this.callId} initWithInvite() no remote stream or no tracks after setting remote description!`,\n            );\n            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);\n            return;\n        }\n\n        this.state = CallState.Ringing;\n\n        if (event.getLocalAge()) {\n            // Time out the call if it's ringing for too long\n            const ringingTimer = setTimeout(() => {\n                if (this.state == CallState.Ringing) {\n                    logger.debug(`Call ${this.callId} initWithInvite() invite has expired. Hanging up.`);\n                    this.hangupParty = CallParty.Remote; // effectively\n                    this.state = CallState.Ended;\n                    this.stopAllMedia();\n                    if (this.peerConn!.signalingState != \"closed\") {\n                        this.peerConn!.close();\n                    }\n                    this.stats?.removeStatsReportGatherer(this.callId);\n                    this.emit(CallEvent.Hangup, this);\n                }\n            }, invite.lifetime - event.getLocalAge());\n\n            const onState = (state: CallState): void => {\n                if (state !== CallState.Ringing) {\n                    clearTimeout(ringingTimer);\n                    this.off(CallEvent.State, onState);\n                }\n            };\n            this.on(CallEvent.State, onState);\n        }\n    }\n\n    /**\n     * Configure this call from a hangup or reject event. Used by MatrixClient.\n     * @param event - The m.call.hangup event\n     */\n    public initWithHangup(event: MatrixEvent): void {\n        // perverse as it may seem, sometimes we want to instantiate a call with a\n        // hangup message (because when getting the state of the room on load, events\n        // come in reverse order and we want to remember that a call has been hung up)\n        this.state = CallState.Ended;\n    }\n\n    private shouldAnswerWithMediaType(\n        wantedValue: boolean | undefined,\n        valueOfTheOtherSide: boolean,\n        type: \"audio\" | \"video\",\n    ): boolean {\n        if (wantedValue && !valueOfTheOtherSide) {\n            // TODO: Figure out how to do this\n            logger.warn(\n                `Call ${this.callId} shouldAnswerWithMediaType() unable to answer with ${type} because the other side isn't sending it either.`,\n            );\n            return false;\n        } else if (\n            !isNullOrUndefined(wantedValue) &&\n            wantedValue !== valueOfTheOtherSide &&\n            !this.opponentSupportsSDPStreamMetadata()\n        ) {\n            logger.warn(\n                `Call ${this.callId} shouldAnswerWithMediaType() unable to answer with ${type}=${wantedValue} because the other side doesn't support it. Answering with ${type}=${valueOfTheOtherSide}.`,\n            );\n            return valueOfTheOtherSide!;\n        }\n        return wantedValue ?? valueOfTheOtherSide!;\n    }\n\n    /**\n     * Answer a call.\n     */\n    public async answer(audio?: boolean, video?: boolean): Promise<void> {\n        if (this.inviteOrAnswerSent) return;\n        // TODO: Figure out how to do this\n        if (audio === false && video === false) throw new Error(\"You CANNOT answer a call without media\");\n\n        if (!this.localUsermediaStream && !this.waitForLocalAVStream) {\n            const prevState = this.state;\n            const answerWithAudio = this.shouldAnswerWithMediaType(audio, this.hasRemoteUserMediaAudioTrack, \"audio\");\n            const answerWithVideo = this.shouldAnswerWithMediaType(video, this.hasRemoteUserMediaVideoTrack, \"video\");\n\n            this.state = CallState.WaitLocalMedia;\n            this.waitForLocalAVStream = true;\n\n            try {\n                const stream = await this.client.getMediaHandler().getUserMediaStream(answerWithAudio, answerWithVideo);\n                this.waitForLocalAVStream = false;\n                const usermediaFeed = new CallFeed({\n                    client: this.client,\n                    roomId: this.roomId,\n                    userId: this.client.getUserId()!,\n                    deviceId: this.client.getDeviceId() ?? undefined,\n                    stream,\n                    purpose: SDPStreamMetadataPurpose.Usermedia,\n                    audioMuted: false,\n                    videoMuted: false,\n                });\n\n                const feeds = [usermediaFeed];\n\n                if (this.localScreensharingFeed) {\n                    feeds.push(this.localScreensharingFeed);\n                }\n\n                this.answerWithCallFeeds(feeds);\n            } catch (e) {\n                if (answerWithVideo) {\n                    // Try to answer without video\n                    logger.warn(\n                        `Call ${this.callId} answer() failed to getUserMedia(), trying to getUserMedia() without video`,\n                    );\n                    this.state = prevState;\n                    this.waitForLocalAVStream = false;\n                    await this.answer(answerWithAudio, false);\n                } else {\n                    this.getUserMediaFailed(<Error>e);\n                    return;\n                }\n            }\n        } else if (this.waitForLocalAVStream) {\n            this.state = CallState.WaitLocalMedia;\n        }\n    }\n\n    public answerWithCallFeeds(callFeeds: CallFeed[]): void {\n        if (this.inviteOrAnswerSent) return;\n\n        this.queueGotCallFeedsForAnswer(callFeeds);\n    }\n\n    /**\n     * Replace this call with a new call, e.g. for glare resolution. Used by\n     * MatrixClient.\n     * @param newCall - The new call.\n     */\n    public replacedBy(newCall: MatrixCall): void {\n        logger.debug(`Call ${this.callId} replacedBy() running (newCallId=${newCall.callId})`);\n        if (this.state === CallState.WaitLocalMedia) {\n            logger.debug(\n                `Call ${this.callId} replacedBy() telling new call to wait for local media (newCallId=${newCall.callId})`,\n            );\n            newCall.waitForLocalAVStream = true;\n        } else if ([CallState.CreateOffer, CallState.InviteSent].includes(this.state)) {\n            if (newCall.direction === CallDirection.Outbound) {\n                newCall.queueGotCallFeedsForAnswer([]);\n            } else {\n                logger.debug(\n                    `Call ${this.callId} replacedBy() handing local stream to new call(newCallId=${newCall.callId})`,\n                );\n                newCall.queueGotCallFeedsForAnswer(this.getLocalFeeds().map((feed) => feed.clone()));\n            }\n        }\n        this.successor = newCall;\n        this.emit(CallEvent.Replaced, newCall, this);\n        this.hangup(CallErrorCode.Replaced, true);\n    }\n\n    /**\n     * Hangup a call.\n     * @param reason - The reason why the call is being hung up.\n     * @param suppressEvent - True to suppress emitting an event.\n     */\n    public hangup(reason: CallErrorCode, suppressEvent: boolean): void {\n        if (this.callHasEnded()) return;\n\n        logger.debug(`Call ${this.callId} hangup() ending call (reason=${reason})`);\n        this.terminate(CallParty.Local, reason, !suppressEvent);\n        // We don't want to send hangup here if we didn't even get to sending an invite\n        if ([CallState.Fledgling, CallState.WaitLocalMedia].includes(this.state)) return;\n        const content: Omit<MCallHangupReject, \"version\" | \"call_id\" | \"party_id\" | \"conf_id\"> = {};\n        // Don't send UserHangup reason to older clients\n        if ((this.opponentVersion && this.opponentVersion !== 0) || reason !== CallErrorCode.UserHangup) {\n            content[\"reason\"] = reason;\n        }\n        this.sendVoipEvent(EventType.CallHangup, content);\n    }\n\n    /**\n     * Reject a call\n     * This used to be done by calling hangup, but is a separate method and protocol\n     * event as of MSC2746.\n     */\n    public reject(): void {\n        if (this.state !== CallState.Ringing) {\n            throw Error(\"Call must be in 'ringing' state to reject!\");\n        }\n\n        if (this.opponentVersion === 0) {\n            logger.info(\n                `Call ${this.callId} reject() opponent version is less than 1: sending hangup instead of reject (opponentVersion=${this.opponentVersion})`,\n            );\n            this.hangup(CallErrorCode.UserHangup, true);\n            return;\n        }\n\n        logger.debug(\"Rejecting call: \" + this.callId);\n        this.terminate(CallParty.Local, CallErrorCode.UserHangup, true);\n        this.sendVoipEvent(EventType.CallReject, {});\n    }\n\n    /**\n     * Adds an audio and/or video track - upgrades the call\n     * @param audio - should add an audio track\n     * @param video - should add an video track\n     */\n    private async upgradeCall(audio: boolean, video: boolean): Promise<void> {\n        // We don't do call downgrades\n        if (!audio && !video) return;\n        if (!this.opponentSupportsSDPStreamMetadata()) return;\n\n        try {\n            logger.debug(`Call ${this.callId} upgradeCall() upgrading call (audio=${audio}, video=${video})`);\n            const getAudio = audio || this.hasLocalUserMediaAudioTrack;\n            const getVideo = video || this.hasLocalUserMediaVideoTrack;\n\n            // updateLocalUsermediaStream() will take the tracks, use them as\n            // replacement and throw the stream away, so it isn't reusable\n            const stream = await this.client.getMediaHandler().getUserMediaStream(getAudio, getVideo, false);\n            await this.updateLocalUsermediaStream(stream, audio, video);\n        } catch (error) {\n            logger.error(`Call ${this.callId} upgradeCall() failed to upgrade the call`, error);\n            this.emit(\n                CallEvent.Error,\n                new CallError(CallErrorCode.NoUserMedia, \"Failed to get camera access: \", <Error>error),\n                this,\n            );\n        }\n    }\n\n    /**\n     * Returns true if this.remoteSDPStreamMetadata is defined, otherwise returns false\n     * @returns can screenshare\n     */\n    public opponentSupportsSDPStreamMetadata(): boolean {\n        return Boolean(this.remoteSDPStreamMetadata);\n    }\n\n    /**\n     * If there is a screensharing stream returns true, otherwise returns false\n     * @returns is screensharing\n     */\n    public isScreensharing(): boolean {\n        return Boolean(this.localScreensharingStream);\n    }\n\n    /**\n     * Starts/stops screensharing\n     * @param enabled - the desired screensharing state\n     * @param opts - screen sharing options\n     * @returns new screensharing state\n     */\n    public async setScreensharingEnabled(enabled: boolean, opts?: IScreensharingOpts): Promise<boolean> {\n        // Skip if there is nothing to do\n        if (enabled && this.isScreensharing()) {\n            logger.warn(\n                `Call ${this.callId} setScreensharingEnabled() there is already a screensharing stream - there is nothing to do!`,\n            );\n            return true;\n        } else if (!enabled && !this.isScreensharing()) {\n            logger.warn(\n                `Call ${this.callId} setScreensharingEnabled() there already isn't a screensharing stream - there is nothing to do!`,\n            );\n            return false;\n        }\n\n        // Fallback to replaceTrack()\n        if (!this.opponentSupportsSDPStreamMetadata()) {\n            return this.setScreensharingEnabledWithoutMetadataSupport(enabled, opts);\n        }\n\n        logger.debug(`Call ${this.callId} setScreensharingEnabled() running (enabled=${enabled})`);\n        if (enabled) {\n            try {\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n                if (!stream) return false;\n                this.pushNewLocalFeed(stream, SDPStreamMetadataPurpose.Screenshare);\n                return true;\n            } catch (err) {\n                logger.error(`Call ${this.callId} setScreensharingEnabled() failed to get screen-sharing stream:`, err);\n                return false;\n            }\n        } else {\n            const audioTransceiver = this.transceivers.get(\n                getTransceiverKey(SDPStreamMetadataPurpose.Screenshare, \"audio\"),\n            );\n            const videoTransceiver = this.transceivers.get(\n                getTransceiverKey(SDPStreamMetadataPurpose.Screenshare, \"video\"),\n            );\n\n            for (const transceiver of [audioTransceiver, videoTransceiver]) {\n                // this is slightly mixing the track and transceiver API but is basically just shorthand\n                // for removing the sender.\n                if (transceiver && transceiver.sender) this.peerConn!.removeTrack(transceiver.sender);\n            }\n\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream!);\n            this.deleteFeedByStream(this.localScreensharingStream!);\n            return false;\n        }\n    }\n\n    /**\n     * Starts/stops screensharing\n     * Should be used ONLY if the opponent doesn't support SDPStreamMetadata\n     * @param enabled - the desired screensharing state\n     * @param opts - screen sharing options\n     * @returns new screensharing state\n     */\n    private async setScreensharingEnabledWithoutMetadataSupport(\n        enabled: boolean,\n        opts?: IScreensharingOpts,\n    ): Promise<boolean> {\n        logger.debug(\n            `Call ${this.callId} setScreensharingEnabledWithoutMetadataSupport() running (enabled=${enabled})`,\n        );\n        if (enabled) {\n            try {\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n                if (!stream) return false;\n\n                const track = stream.getTracks().find((track) => track.kind === \"video\");\n\n                const sender = this.transceivers.get(\n                    getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, \"video\"),\n                )?.sender;\n\n                sender?.replaceTrack(track ?? null);\n\n                this.pushNewLocalFeed(stream, SDPStreamMetadataPurpose.Screenshare, false);\n\n                return true;\n            } catch (err) {\n                logger.error(\n                    `Call ${this.callId} setScreensharingEnabledWithoutMetadataSupport() failed to get screen-sharing stream:`,\n                    err,\n                );\n                return false;\n            }\n        } else {\n            const track = this.localUsermediaStream?.getTracks().find((track) => track.kind === \"video\");\n            const sender = this.transceivers.get(\n                getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, \"video\"),\n            )?.sender;\n            sender?.replaceTrack(track ?? null);\n\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreensharingStream!);\n            this.deleteFeedByStream(this.localScreensharingStream!);\n\n            return false;\n        }\n    }\n\n    /**\n     * Replaces/adds the tracks from the passed stream to the localUsermediaStream\n     * @param stream - to use a replacement for the local usermedia stream\n     */\n    public async updateLocalUsermediaStream(\n        stream: MediaStream,\n        forceAudio = false,\n        forceVideo = false,\n    ): Promise<void> {\n        const callFeed = this.localUsermediaFeed!;\n        const audioEnabled = forceAudio || (!callFeed.isAudioMuted() && !this.remoteOnHold);\n        const videoEnabled = forceVideo || (!callFeed.isVideoMuted() && !this.remoteOnHold);\n        logger.log(\n            `Call ${this.callId} updateLocalUsermediaStream() running (streamId=${stream.id}, audio=${audioEnabled}, video=${videoEnabled})`,\n        );\n        setTracksEnabled(stream.getAudioTracks(), audioEnabled);\n        setTracksEnabled(stream.getVideoTracks(), videoEnabled);\n\n        // We want to keep the same stream id, so we replace the tracks rather\n        // than the whole stream.\n\n        // Firstly, we replace the tracks in our localUsermediaStream.\n        for (const track of this.localUsermediaStream!.getTracks()) {\n            this.localUsermediaStream!.removeTrack(track);\n            track.stop();\n        }\n        for (const track of stream.getTracks()) {\n            this.localUsermediaStream!.addTrack(track);\n        }\n\n        // Then replace the old tracks, if possible.\n        for (const track of stream.getTracks()) {\n            const tKey = getTransceiverKey(SDPStreamMetadataPurpose.Usermedia, track.kind);\n\n            const transceiver = this.transceivers.get(tKey);\n            const oldSender = transceiver?.sender;\n            let added = false;\n            if (oldSender) {\n                try {\n                    logger.info(\n                        `Call ${this.callId} updateLocalUsermediaStream() replacing track (id=${track.id}, kind=${track.kind}, streamId=${stream.id}, streamPurpose=${callFeed.purpose})`,\n                    );\n                    await oldSender.replaceTrack(track);\n                    // Set the direction to indicate we're going to be sending.\n                    // This is only necessary in the cases where we're upgrading\n                    // the call to video after downgrading it.\n                    transceiver.direction = transceiver.direction === \"inactive\" ? \"sendonly\" : \"sendrecv\";\n                    added = true;\n                } catch (error) {\n                    logger.warn(\n                        `Call ${this.callId} updateLocalUsermediaStream() replaceTrack failed: adding new transceiver instead`,\n                        error,\n                    );\n                }\n            }\n\n            if (!added) {\n                logger.info(\n                    `Call ${this.callId} updateLocalUsermediaStream() adding track to peer connection (id=${track.id}, kind=${track.kind}, streamId=${stream.id}, streamPurpose=${callFeed.purpose})`,\n                );\n\n                const newSender = this.peerConn!.addTrack(track, this.localUsermediaStream!);\n                const newTransceiver = this.peerConn!.getTransceivers().find((t) => t.sender === newSender);\n                if (newTransceiver) {\n                    this.transceivers.set(tKey, newTransceiver);\n                } else {\n                    logger.warn(\n                        `Call ${this.callId} updateLocalUsermediaStream() couldn't find matching transceiver for newly added track!`,\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Set whether our outbound video should be muted or not.\n     * @param muted - True to mute the outbound video.\n     * @returns the new mute state\n     */\n    public async setLocalVideoMuted(muted: boolean): Promise<boolean> {\n        logger.log(`Call ${this.callId} setLocalVideoMuted() running ${muted}`);\n\n        // if we were still thinking about stopping and removing the video\n        // track: don't, because we want it back.\n        if (!muted && this.stopVideoTrackTimer !== undefined) {\n            clearTimeout(this.stopVideoTrackTimer);\n            this.stopVideoTrackTimer = undefined;\n        }\n\n        if (!(await this.client.getMediaHandler().hasVideoDevice())) {\n            return this.isLocalVideoMuted();\n        }\n\n        if (!this.hasUserMediaVideoSender && !muted) {\n            this.localUsermediaFeed?.setAudioVideoMuted(null, muted);\n            await this.upgradeCall(false, true);\n            return this.isLocalVideoMuted();\n        }\n\n        // we may not have a video track - if not, re-request usermedia\n        if (!muted && this.localUsermediaStream!.getVideoTracks().length === 0) {\n            const stream = await this.client.getMediaHandler().getUserMediaStream(true, true);\n            await this.updateLocalUsermediaStream(stream);\n        }\n\n        this.localUsermediaFeed?.setAudioVideoMuted(null, muted);\n\n        this.updateMuteStatus();\n        await this.sendMetadataUpdate();\n\n        // if we're muting video, set a timeout to stop & remove the video track so we release\n        // the camera. We wait a short time to do this because when we disable a track, WebRTC\n        // will send black video for it. If we just stop and remove it straight away, the video\n        // will just freeze which means that when we unmute video, the other side will briefly\n        // get a static frame of us from before we muted. This way, the still frame is just black.\n        // A very small delay is not always enough so the theory here is that it needs to be long\n        // enough for WebRTC to encode a frame: 120ms should be long enough even if we're only\n        // doing 10fps.\n        if (muted) {\n            this.stopVideoTrackTimer = setTimeout(() => {\n                for (const t of this.localUsermediaStream!.getVideoTracks()) {\n                    t.stop();\n                    this.localUsermediaStream!.removeTrack(t);\n                }\n            }, 120);\n        }\n\n        return this.isLocalVideoMuted();\n    }\n\n    /**\n     * Check if local video is muted.\n     *\n     * If there are multiple video tracks, <i>all</i> of the tracks need to be muted\n     * for this to return true. This means if there are no video tracks, this will\n     * return true.\n     * @returns True if the local preview video is muted, else false\n     * (including if the call is not set up yet).\n     */\n    public isLocalVideoMuted(): boolean {\n        return this.localUsermediaFeed?.isVideoMuted() ?? false;\n    }\n\n    /**\n     * Set whether the microphone should be muted or not.\n     * @param muted - True to mute the mic.\n     * @returns the new mute state\n     */\n    public async setMicrophoneMuted(muted: boolean): Promise<boolean> {\n        logger.log(`Call ${this.callId} setMicrophoneMuted() running ${muted}`);\n        if (!(await this.client.getMediaHandler().hasAudioDevice())) {\n            return this.isMicrophoneMuted();\n        }\n\n        if (!muted && (!this.hasUserMediaAudioSender || !this.hasLocalUserMediaAudioTrack)) {\n            await this.upgradeCall(true, false);\n            return this.isMicrophoneMuted();\n        }\n        this.localUsermediaFeed?.setAudioVideoMuted(muted, null);\n        this.updateMuteStatus();\n        await this.sendMetadataUpdate();\n        return this.isMicrophoneMuted();\n    }\n\n    /**\n     * Check if the microphone is muted.\n     *\n     * If there are multiple audio tracks, <i>all</i> of the tracks need to be muted\n     * for this to return true. This means if there are no audio tracks, this will\n     * return true.\n     * @returns True if the mic is muted, else false (including if the call\n     * is not set up yet).\n     */\n    public isMicrophoneMuted(): boolean {\n        return this.localUsermediaFeed?.isAudioMuted() ?? false;\n    }\n\n    /**\n     * @returns true if we have put the party on the other side of the call on hold\n     * (that is, we are signalling to them that we are not listening)\n     */\n    public isRemoteOnHold(): boolean {\n        return this.remoteOnHold;\n    }\n\n    public setRemoteOnHold(onHold: boolean): void {\n        if (this.isRemoteOnHold() === onHold) return;\n        this.remoteOnHold = onHold;\n\n        for (const transceiver of this.peerConn!.getTransceivers()) {\n            // We don't send hold music or anything so we're not actually\n            // sending anything, but sendrecv is fairly standard for hold and\n            // it makes it a lot easier to figure out who's put who on hold.\n            transceiver.direction = onHold ? \"sendonly\" : \"sendrecv\";\n        }\n        this.updateMuteStatus();\n        this.sendMetadataUpdate();\n\n        this.emit(CallEvent.RemoteHoldUnhold, this.remoteOnHold, this);\n    }\n\n    /**\n     * Indicates whether we are 'on hold' to the remote party (ie. if true,\n     * they cannot hear us).\n     * @returns true if the other party has put us on hold\n     */\n    public isLocalOnHold(): boolean {\n        if (this.state !== CallState.Connected) return false;\n\n        let callOnHold = true;\n\n        // We consider a call to be on hold only if *all* the tracks are on hold\n        // (is this the right thing to do?)\n        for (const transceiver of this.peerConn!.getTransceivers()) {\n            const trackOnHold = [\"inactive\", \"recvonly\"].includes(transceiver.currentDirection!);\n\n            if (!trackOnHold) callOnHold = false;\n        }\n\n        return callOnHold;\n    }\n\n    /**\n     * Sends a DTMF digit to the other party\n     * @param digit - The digit (nb. string - '#' and '*' are dtmf too)\n     */\n    public sendDtmfDigit(digit: string): void {\n        for (const sender of this.peerConn!.getSenders()) {\n            if (sender.track?.kind === \"audio\" && sender.dtmf) {\n                sender.dtmf.insertDTMF(digit);\n                return;\n            }\n        }\n\n        throw new Error(\"Unable to find a track to send DTMF on\");\n    }\n\n    private updateMuteStatus(): void {\n        const micShouldBeMuted = this.isMicrophoneMuted() || this.remoteOnHold;\n        const vidShouldBeMuted = this.isLocalVideoMuted() || this.remoteOnHold;\n\n        logger.log(\n            `Call ${this.callId} updateMuteStatus stream ${\n                this.localUsermediaStream!.id\n            } micShouldBeMuted ${micShouldBeMuted} vidShouldBeMuted ${vidShouldBeMuted}`,\n        );\n\n        setTracksEnabled(this.localUsermediaStream!.getAudioTracks(), !micShouldBeMuted);\n        setTracksEnabled(this.localUsermediaStream!.getVideoTracks(), !vidShouldBeMuted);\n    }\n\n    public async sendMetadataUpdate(): Promise<void> {\n        await this.sendVoipEvent(EventType.CallSDPStreamMetadataChangedPrefix, {\n            [SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(),\n        });\n    }\n\n    private gotCallFeedsForInvite(callFeeds: CallFeed[], requestScreenshareFeed = false): void {\n        if (this.successor) {\n            this.successor.queueGotCallFeedsForAnswer(callFeeds);\n            return;\n        }\n        if (this.callHasEnded()) {\n            this.stopAllMedia();\n            return;\n        }\n\n        for (const feed of callFeeds) {\n            this.pushLocalFeed(feed);\n        }\n\n        if (requestScreenshareFeed) {\n            this.peerConn!.addTransceiver(\"video\", {\n                direction: \"recvonly\",\n            });\n        }\n\n        this.state = CallState.CreateOffer;\n\n        logger.debug(`Call ${this.callId} gotUserMediaForInvite() run`);\n        // Now we wait for the negotiationneeded event\n    }\n\n    private async sendAnswer(): Promise<void> {\n        const answerContent = {\n            answer: {\n                sdp: this.peerConn!.localDescription!.sdp,\n                // type is now deprecated as of Matrix VoIP v1, but\n                // required to still be sent for backwards compat\n                type: this.peerConn!.localDescription!.type,\n            },\n            [SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(true),\n        } as MCallAnswer;\n\n        answerContent.capabilities = {\n            \"m.call.transferee\": this.client.supportsCallTransfer,\n            \"m.call.dtmf\": false,\n        };\n\n        // We have just taken the local description from the peerConn which will\n        // contain all the local candidates added so far, so we can discard any candidates\n        // we had queued up because they'll be in the answer.\n        const discardCount = this.discardDuplicateCandidates();\n        logger.info(\n            `Call ${this.callId} sendAnswer() discarding ${discardCount} candidates that will be sent in answer`,\n        );\n\n        try {\n            await this.sendVoipEvent(EventType.CallAnswer, answerContent);\n            // If this isn't the first time we've tried to send the answer,\n            // we may have candidates queued up, so send them now.\n            this.inviteOrAnswerSent = true;\n        } catch (error) {\n            // We've failed to answer: back to the ringing state\n            this.state = CallState.Ringing;\n            if (error instanceof MatrixError && error.event) this.client.cancelPendingEvent(error.event);\n\n            let code = CallErrorCode.SendAnswer;\n            let message = \"Failed to send answer\";\n            if ((<Error>error).name == \"UnknownDeviceError\") {\n                code = CallErrorCode.UnknownDevices;\n                message = \"Unknown devices present in the room\";\n            }\n            this.emit(CallEvent.Error, new CallError(code, message, <Error>error), this);\n            throw error;\n        }\n\n        // error handler re-throws so this won't happen on error, but\n        // we don't want the same error handling on the candidate queue\n        this.sendCandidateQueue();\n    }\n\n    private queueGotCallFeedsForAnswer(callFeeds: CallFeed[]): void {\n        // Ensure only one negotiate/answer event is being processed at a time.\n        if (this.responsePromiseChain) {\n            this.responsePromiseChain = this.responsePromiseChain.then(() => this.gotCallFeedsForAnswer(callFeeds));\n        } else {\n            this.responsePromiseChain = this.gotCallFeedsForAnswer(callFeeds);\n        }\n    }\n\n    // Enables DTX (discontinuous transmission) on the given session to reduce\n    // bandwidth when transmitting silence\n    private mungeSdp(description: RTCSessionDescriptionInit, mods: CodecParamsMod[]): void {\n        // The only way to enable DTX at this time is through SDP munging\n        const sdp = parseSdp(description.sdp!);\n\n        sdp.media.forEach((media) => {\n            const payloadTypeToCodecMap = new Map<number, string>();\n            const codecToPayloadTypeMap = new Map<string, number>();\n            for (const rtp of media.rtp) {\n                payloadTypeToCodecMap.set(rtp.payload, rtp.codec);\n                codecToPayloadTypeMap.set(rtp.codec, rtp.payload);\n            }\n\n            for (const mod of mods) {\n                if (mod.mediaType !== media.type) continue;\n\n                if (!codecToPayloadTypeMap.has(mod.codec)) {\n                    logger.info(\n                        `Call ${this.callId} mungeSdp() ignoring SDP modifications for ${mod.codec} as it's not present.`,\n                    );\n                    continue;\n                }\n\n                const extraConfig: string[] = [];\n                if (mod.enableDtx !== undefined) {\n                    extraConfig.push(`usedtx=${mod.enableDtx ? \"1\" : \"0\"}`);\n                }\n                if (mod.maxAverageBitrate !== undefined) {\n                    extraConfig.push(`maxaveragebitrate=${mod.maxAverageBitrate}`);\n                }\n\n                let found = false;\n                for (const fmtp of media.fmtp) {\n                    if (payloadTypeToCodecMap.get(fmtp.payload) === mod.codec) {\n                        found = true;\n                        fmtp.config += \";\" + extraConfig.join(\";\");\n                    }\n                }\n                if (!found) {\n                    media.fmtp.push({\n                        payload: codecToPayloadTypeMap.get(mod.codec)!,\n                        config: extraConfig.join(\";\"),\n                    });\n                }\n            }\n        });\n        description.sdp = writeSdp(sdp);\n    }\n\n    private async createOffer(): Promise<RTCSessionDescriptionInit> {\n        const offer = await this.peerConn!.createOffer();\n        this.mungeSdp(offer, getCodecParamMods(this.isPtt));\n        return offer;\n    }\n\n    private async createAnswer(): Promise<RTCSessionDescriptionInit> {\n        const answer = await this.peerConn!.createAnswer();\n        this.mungeSdp(answer, getCodecParamMods(this.isPtt));\n        return answer;\n    }\n\n    private async gotCallFeedsForAnswer(callFeeds: CallFeed[]): Promise<void> {\n        if (this.callHasEnded()) return;\n\n        this.waitForLocalAVStream = false;\n\n        for (const feed of callFeeds) {\n            this.pushLocalFeed(feed);\n        }\n\n        this.state = CallState.CreateAnswer;\n\n        let answer: RTCSessionDescriptionInit;\n        try {\n            this.getRidOfRTXCodecs();\n            answer = await this.createAnswer();\n        } catch (err) {\n            logger.debug(`Call ${this.callId} gotCallFeedsForAnswer() failed to create answer: `, err);\n            this.terminate(CallParty.Local, CallErrorCode.CreateAnswer, true);\n            return;\n        }\n\n        try {\n            await this.peerConn!.setLocalDescription(answer);\n\n            // make sure we're still going\n            if (this.callHasEnded()) return;\n\n            this.state = CallState.Connecting;\n\n            // Allow a short time for initial candidates to be gathered\n            await new Promise((resolve) => {\n                setTimeout(resolve, 200);\n            });\n\n            // make sure the call hasn't ended before we continue\n            if (this.callHasEnded()) return;\n\n            this.sendAnswer();\n        } catch (err) {\n            logger.debug(`Call ${this.callId} gotCallFeedsForAnswer() error setting local description!`, err);\n            this.terminate(CallParty.Local, CallErrorCode.SetLocalDescription, true);\n            return;\n        }\n    }\n\n    /**\n     * Internal\n     */\n    private gotLocalIceCandidate = (event: RTCPeerConnectionIceEvent): void => {\n        if (event.candidate) {\n            if (this.candidatesEnded) {\n                logger.warn(`Call ${this.callId} gotLocalIceCandidate() got candidate after candidates have ended!`);\n            }\n\n            logger.debug(`Call ${this.callId} got local ICE ${event.candidate.sdpMid} ${event.candidate.candidate}`);\n\n            if (this.callHasEnded()) return;\n\n            // As with the offer, note we need to make a copy of this object, not\n            // pass the original: that broke in Chrome ~m43.\n            if (event.candidate.candidate === \"\") {\n                this.queueCandidate(null);\n            } else {\n                this.queueCandidate(event.candidate);\n            }\n        }\n    };\n\n    private onIceGatheringStateChange = (event: Event): void => {\n        logger.debug(\n            `Call ${this.callId} onIceGatheringStateChange() ice gathering state changed to ${\n                this.peerConn!.iceGatheringState\n            }`,\n        );\n        if (this.peerConn?.iceGatheringState === \"complete\") {\n            this.queueCandidate(null); // We should leave it to WebRTC to announce the end\n            logger.debug(\n                `Call ${this.callId} onIceGatheringStateChange() ice gathering state complete, set candidates have ended`,\n            );\n        }\n    };\n\n    public async onRemoteIceCandidatesReceived(ev: MatrixEvent): Promise<void> {\n        if (this.callHasEnded()) {\n            //debuglog(\"Ignoring remote ICE candidate because call has ended\");\n            return;\n        }\n\n        const content = ev.getContent<MCallCandidates>();\n        const candidates = content.candidates;\n        if (!candidates) {\n            logger.info(\n                `Call ${this.callId} onRemoteIceCandidatesReceived() ignoring candidates event with no candidates!`,\n            );\n            return;\n        }\n\n        const fromPartyId = content.version === 0 ? null : content.party_id || null;\n\n        if (this.opponentPartyId === undefined) {\n            // we haven't picked an opponent yet so save the candidates\n            if (fromPartyId) {\n                logger.info(\n                    `Call ${this.callId} onRemoteIceCandidatesReceived() buffering ${candidates.length} candidates until we pick an opponent`,\n                );\n                const bufferedCandidates = this.remoteCandidateBuffer.get(fromPartyId) || [];\n                bufferedCandidates.push(...candidates);\n                this.remoteCandidateBuffer.set(fromPartyId, bufferedCandidates);\n            }\n            return;\n        }\n\n        if (!this.partyIdMatches(content)) {\n            logger.info(\n                `Call ${this.callId} onRemoteIceCandidatesReceived() ignoring candidates from party ID ${content.party_id}: we have chosen party ID ${this.opponentPartyId}`,\n            );\n\n            return;\n        }\n\n        await this.addIceCandidates(candidates);\n    }\n\n    /**\n     * Used by MatrixClient.\n     */\n    public async onAnswerReceived(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<MCallAnswer>();\n        logger.debug(`Call ${this.callId} onAnswerReceived() running (hangupParty=${content.party_id})`);\n\n        if (this.callHasEnded()) {\n            logger.debug(`Call ${this.callId} onAnswerReceived() ignoring answer because call has ended`);\n            return;\n        }\n\n        if (this.opponentPartyId !== undefined) {\n            logger.info(\n                `Call ${this.callId} onAnswerReceived() ignoring answer from party ID ${content.party_id}: we already have an answer/reject from ${this.opponentPartyId}`,\n            );\n            return;\n        }\n\n        this.chooseOpponent(event);\n        await this.addBufferedIceCandidates();\n\n        this.state = CallState.Connecting;\n\n        const sdpStreamMetadata = content[SDPStreamMetadataKey];\n        if (sdpStreamMetadata) {\n            this.updateRemoteSDPStreamMetadata(sdpStreamMetadata);\n        } else {\n            logger.warn(\n                `Call ${this.callId} onAnswerReceived() did not get any SDPStreamMetadata! Can not send/receive multiple streams`,\n            );\n        }\n\n        try {\n            this.isSettingRemoteAnswerPending = true;\n            await this.peerConn!.setRemoteDescription(content.answer);\n            this.isSettingRemoteAnswerPending = false;\n            logger.debug(`Call ${this.callId} onAnswerReceived() set remote description: ${content.answer.type}`);\n        } catch (e) {\n            this.isSettingRemoteAnswerPending = false;\n            logger.debug(`Call ${this.callId} onAnswerReceived() failed to set remote description`, e);\n            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);\n            return;\n        }\n\n        // If the answer we selected has a party_id, send a select_answer event\n        // We do this after setting the remote description since otherwise we'd block\n        // call setup on it\n        if (this.opponentPartyId !== null) {\n            try {\n                await this.sendVoipEvent(EventType.CallSelectAnswer, {\n                    selected_party_id: this.opponentPartyId!,\n                });\n            } catch (err) {\n                // This isn't fatal, and will just mean that if another party has raced to answer\n                // the call, they won't know they got rejected, so we carry on & don't retry.\n                logger.warn(`Call ${this.callId} onAnswerReceived() failed to send select_answer event`, err);\n            }\n        }\n    }\n\n    public async onSelectAnswerReceived(event: MatrixEvent): Promise<void> {\n        if (this.direction !== CallDirection.Inbound) {\n            logger.warn(\n                `Call ${this.callId} onSelectAnswerReceived() got select_answer for an outbound call: ignoring`,\n            );\n            return;\n        }\n\n        const selectedPartyId = event.getContent<MCallSelectAnswer>().selected_party_id;\n\n        if (selectedPartyId === undefined || selectedPartyId === null) {\n            logger.warn(\n                `Call ${this.callId} onSelectAnswerReceived() got nonsensical select_answer with null/undefined selected_party_id: ignoring`,\n            );\n            return;\n        }\n\n        if (selectedPartyId !== this.ourPartyId) {\n            logger.info(\n                `Call ${this.callId} onSelectAnswerReceived() got select_answer for party ID ${selectedPartyId}: we are party ID ${this.ourPartyId}.`,\n            );\n            // The other party has picked somebody else's answer\n            await this.terminate(CallParty.Remote, CallErrorCode.AnsweredElsewhere, true);\n        }\n    }\n\n    public async onNegotiateReceived(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<MCallInviteNegotiate>();\n        const description = content.description;\n        if (!description || !description.sdp || !description.type) {\n            logger.info(`Call ${this.callId} onNegotiateReceived() ignoring invalid m.call.negotiate event`);\n            return;\n        }\n        // Politeness always follows the direction of the call: in a glare situation,\n        // we pick either the inbound or outbound call, so one side will always be\n        // inbound and one outbound\n        const polite = this.direction === CallDirection.Inbound;\n\n        // Here we follow the perfect negotiation logic from\n        // https://w3c.github.io/webrtc-pc/#perfect-negotiation-example\n        const readyForOffer =\n            !this.makingOffer && (this.peerConn!.signalingState === \"stable\" || this.isSettingRemoteAnswerPending);\n\n        const offerCollision = description.type === \"offer\" && !readyForOffer;\n\n        this.ignoreOffer = !polite && offerCollision;\n        if (this.ignoreOffer) {\n            logger.info(\n                `Call ${this.callId} onNegotiateReceived() ignoring colliding negotiate event because we're impolite`,\n            );\n            return;\n        }\n\n        const prevLocalOnHold = this.isLocalOnHold();\n\n        const sdpStreamMetadata = content[SDPStreamMetadataKey];\n        if (sdpStreamMetadata) {\n            this.updateRemoteSDPStreamMetadata(sdpStreamMetadata);\n        } else {\n            logger.warn(\n                `Call ${this.callId} onNegotiateReceived() received negotiation event without SDPStreamMetadata!`,\n            );\n        }\n\n        try {\n            this.isSettingRemoteAnswerPending = description.type == \"answer\";\n            await this.peerConn!.setRemoteDescription(description); // SRD rolls back as needed\n            this.isSettingRemoteAnswerPending = false;\n\n            logger.debug(`Call ${this.callId} onNegotiateReceived() set remote description: ${description.type}`);\n\n            if (description.type === \"offer\") {\n                let answer: RTCSessionDescriptionInit;\n                try {\n                    this.getRidOfRTXCodecs();\n                    answer = await this.createAnswer();\n                } catch (err) {\n                    logger.debug(`Call ${this.callId} onNegotiateReceived() failed to create answer: `, err);\n                    this.terminate(CallParty.Local, CallErrorCode.CreateAnswer, true);\n                    return;\n                }\n\n                await this.peerConn!.setLocalDescription(answer);\n                logger.debug(`Call ${this.callId} onNegotiateReceived() create an answer`);\n\n                this.sendVoipEvent(EventType.CallNegotiate, {\n                    lifetime: CALL_TIMEOUT_MS,\n                    description: this.peerConn!.localDescription?.toJSON() as RTCSessionDescription,\n                    [SDPStreamMetadataKey]: this.getLocalSDPStreamMetadata(true),\n                });\n            }\n        } catch (err) {\n            this.isSettingRemoteAnswerPending = false;\n            logger.warn(`Call ${this.callId} onNegotiateReceived() failed to complete negotiation`, err);\n        }\n\n        const newLocalOnHold = this.isLocalOnHold();\n        if (prevLocalOnHold !== newLocalOnHold) {\n            this.emit(CallEvent.LocalHoldUnhold, newLocalOnHold, this);\n            // also this one for backwards compat\n            this.emit(CallEvent.HoldUnhold, newLocalOnHold);\n        }\n    }\n\n    private updateRemoteSDPStreamMetadata(metadata: SDPStreamMetadata): void {\n        this.remoteSDPStreamMetadata = recursivelyAssign(this.remoteSDPStreamMetadata || {}, metadata, true);\n        for (const feed of this.getRemoteFeeds()) {\n            const streamId = feed.stream.id;\n            const metadata = this.remoteSDPStreamMetadata![streamId];\n\n            feed.setAudioVideoMuted(metadata?.audio_muted, metadata?.video_muted);\n            feed.purpose = this.remoteSDPStreamMetadata![streamId]?.purpose;\n        }\n    }\n\n    public onSDPStreamMetadataChangedReceived(event: MatrixEvent): void {\n        const content = event.getContent<MCallSDPStreamMetadataChanged>();\n        const metadata = content[SDPStreamMetadataKey];\n        this.updateRemoteSDPStreamMetadata(metadata);\n    }\n\n    public async onAssertedIdentityReceived(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<MCAllAssertedIdentity>();\n        if (!content.asserted_identity) return;\n\n        this.remoteAssertedIdentity = {\n            id: content.asserted_identity.id,\n            displayName: content.asserted_identity.display_name,\n        };\n        this.emit(CallEvent.AssertedIdentityChanged, this);\n    }\n\n    public callHasEnded(): boolean {\n        // This exists as workaround to typescript trying to be clever and erroring\n        // when putting if (this.state === CallState.Ended) return; twice in the same\n        // function, even though that function is async.\n        return this.state === CallState.Ended;\n    }\n\n    private queueGotLocalOffer(): void {\n        // Ensure only one negotiate/answer event is being processed at a time.\n        if (this.responsePromiseChain) {\n            this.responsePromiseChain = this.responsePromiseChain.then(() => this.wrappedGotLocalOffer());\n        } else {\n            this.responsePromiseChain = this.wrappedGotLocalOffer();\n        }\n    }\n\n    private async wrappedGotLocalOffer(): Promise<void> {\n        this.makingOffer = true;\n        try {\n            // XXX: in what situations do we believe gotLocalOffer actually throws? It appears\n            // to handle most of its exceptions itself and terminate the call. I'm not entirely\n            // sure it would ever throw, so I can't add a test for these lines.\n            // Also the tense is different between \"gotLocalOffer\" and \"getLocalOfferFailed\" so\n            // it's not entirely clear whether getLocalOfferFailed is just misnamed or whether\n            // they've been cross-polinated somehow at some point.\n            await this.gotLocalOffer();\n        } catch (e) {\n            this.getLocalOfferFailed(e as Error);\n            return;\n        } finally {\n            this.makingOffer = false;\n        }\n    }\n\n    private async gotLocalOffer(): Promise<void> {\n        logger.debug(`Call ${this.callId} gotLocalOffer() running`);\n\n        if (this.callHasEnded()) {\n            logger.debug(\n                `Call ${this.callId} gotLocalOffer() ignoring newly created offer because the call has ended\"`,\n            );\n            return;\n        }\n\n        let offer: RTCSessionDescriptionInit;\n        try {\n            this.getRidOfRTXCodecs();\n            offer = await this.createOffer();\n        } catch (err) {\n            logger.debug(`Call ${this.callId} gotLocalOffer() failed to create offer: `, err);\n            this.terminate(CallParty.Local, CallErrorCode.CreateOffer, true);\n            return;\n        }\n\n        try {\n            await this.peerConn!.setLocalDescription(offer);\n        } catch (err) {\n            logger.debug(`Call ${this.callId} gotLocalOffer() error setting local description!`, err);\n            this.terminate(CallParty.Local, CallErrorCode.SetLocalDescription, true);\n            return;\n        }\n\n        if (this.peerConn!.iceGatheringState === \"gathering\") {\n            // Allow a short time for initial candidates to be gathered\n            await new Promise((resolve) => {\n                setTimeout(resolve, 200);\n            });\n        }\n\n        if (this.callHasEnded()) return;\n\n        const eventType = this.state === CallState.CreateOffer ? EventType.CallInvite : EventType.CallNegotiate;\n\n        const content = {\n            lifetime: CALL_TIMEOUT_MS,\n        } as MCallInviteNegotiate;\n\n        if (eventType === EventType.CallInvite && this.invitee) {\n            content.invitee = this.invitee;\n        }\n\n        // clunky because TypeScript can't follow the types through if we use an expression as the key\n        if (this.state === CallState.CreateOffer) {\n            content.offer = this.peerConn!.localDescription?.toJSON() as RTCSessionDescription;\n        } else {\n            content.description = this.peerConn!.localDescription?.toJSON() as RTCSessionDescription;\n        }\n\n        content.capabilities = {\n            \"m.call.transferee\": this.client.supportsCallTransfer,\n            \"m.call.dtmf\": false,\n        };\n\n        content[SDPStreamMetadataKey] = this.getLocalSDPStreamMetadata(true);\n\n        // Get rid of any candidates waiting to be sent: they'll be included in the local\n        // description we just got and will send in the offer.\n        const discardCount = this.discardDuplicateCandidates();\n        logger.info(\n            `Call ${this.callId} gotLocalOffer() discarding ${discardCount} candidates that will be sent in offer`,\n        );\n\n        try {\n            await this.sendVoipEvent(eventType, content);\n        } catch (error) {\n            logger.error(`Call ${this.callId} gotLocalOffer() failed to send invite`, error);\n            if (error instanceof MatrixError && error.event) this.client.cancelPendingEvent(error.event);\n\n            let code = CallErrorCode.SignallingFailed;\n            let message = \"Signalling failed\";\n            if (this.state === CallState.CreateOffer) {\n                code = CallErrorCode.SendInvite;\n                message = \"Failed to send invite\";\n            }\n            if ((<Error>error).name == \"UnknownDeviceError\") {\n                code = CallErrorCode.UnknownDevices;\n                message = \"Unknown devices present in the room\";\n            }\n\n            this.emit(CallEvent.Error, new CallError(code, message, <Error>error), this);\n            this.terminate(CallParty.Local, code, false);\n\n            // no need to carry on & send the candidate queue, but we also\n            // don't want to rethrow the error\n            return;\n        }\n\n        this.sendCandidateQueue();\n        if (this.state === CallState.CreateOffer) {\n            this.inviteOrAnswerSent = true;\n            this.state = CallState.InviteSent;\n            this.inviteTimeout = setTimeout(() => {\n                this.inviteTimeout = undefined;\n                if (this.state === CallState.InviteSent) {\n                    this.hangup(CallErrorCode.InviteTimeout, false);\n                }\n            }, CALL_TIMEOUT_MS);\n        }\n    }\n\n    private getLocalOfferFailed = (err: Error): void => {\n        logger.error(`Call ${this.callId} getLocalOfferFailed() running`, err);\n\n        this.emit(\n            CallEvent.Error,\n            new CallError(CallErrorCode.LocalOfferFailed, \"Failed to get local offer!\", err),\n            this,\n        );\n        this.terminate(CallParty.Local, CallErrorCode.LocalOfferFailed, false);\n    };\n\n    private getUserMediaFailed = (err: Error): void => {\n        if (this.successor) {\n            this.successor.getUserMediaFailed(err);\n            return;\n        }\n\n        logger.warn(`Call ${this.callId} getUserMediaFailed() failed to get user media - ending call`, err);\n\n        this.emit(\n            CallEvent.Error,\n            new CallError(\n                CallErrorCode.NoUserMedia,\n                \"Couldn't start capturing media! Is your microphone set up and does this app have permission?\",\n                err,\n            ),\n            this,\n        );\n        this.terminate(CallParty.Local, CallErrorCode.NoUserMedia, false);\n    };\n\n    private placeCallFailed = (err: Error): void => {\n        if (this.successor) {\n            this.successor.placeCallFailed(err);\n            return;\n        }\n\n        logger.warn(`Call ${this.callId} placeCallWithCallFeeds() failed - ending call`, err);\n\n        this.emit(\n            CallEvent.Error,\n            new CallError(CallErrorCode.IceFailed, \"Couldn't start call! Invalid ICE server configuration.\", err),\n            this,\n        );\n        this.terminate(CallParty.Local, CallErrorCode.IceFailed, false);\n    };\n\n    private onIceConnectionStateChanged = (): void => {\n        if (this.callHasEnded()) {\n            return; // because ICE can still complete as we're ending the call\n        }\n        logger.debug(\n            `Call ${this.callId} onIceConnectionStateChanged() running (state=${this.peerConn?.iceConnectionState}, conn=${this.peerConn?.connectionState})`,\n        );\n\n        // ideally we'd consider the call to be connected when we get media but\n        // chrome doesn't implement any of the 'onstarted' events yet\n        if ([\"connected\", \"completed\"].includes(this.peerConn?.iceConnectionState ?? \"\")) {\n            clearTimeout(this.iceDisconnectedTimeout);\n            this.iceDisconnectedTimeout = undefined;\n            if (this.iceReconnectionTimeOut) {\n                clearTimeout(this.iceReconnectionTimeOut);\n            }\n            this.state = CallState.Connected;\n\n            if (!this.callLengthInterval && !this.callStartTime) {\n                this.callStartTime = Date.now();\n\n                this.callLengthInterval = setInterval(() => {\n                    this.emit(CallEvent.LengthChanged, Math.round((Date.now() - this.callStartTime!) / 1000), this);\n                }, CALL_LENGTH_INTERVAL);\n            }\n        } else if (this.peerConn?.iceConnectionState == \"failed\") {\n            this.candidatesEnded = false;\n            // Firefox for Android does not yet have support for restartIce()\n            // (the types say it's always defined though, so we have to cast\n            // to prevent typescript from warning).\n            if (this.peerConn?.restartIce as (() => void) | null) {\n                this.candidatesEnded = false;\n                logger.debug(\n                    `Call ${this.callId} onIceConnectionStateChanged() ice restart (state=${this.peerConn?.iceConnectionState})`,\n                );\n                this.peerConn!.restartIce();\n            } else {\n                logger.info(\n                    `Call ${this.callId} onIceConnectionStateChanged() hanging up call (ICE failed and no ICE restart method)`,\n                );\n                this.hangup(CallErrorCode.IceFailed, false);\n            }\n        } else if (this.peerConn?.iceConnectionState == \"disconnected\") {\n            this.candidatesEnded = false;\n            this.iceReconnectionTimeOut = setTimeout((): void => {\n                logger.info(\n                    `Call ${this.callId} onIceConnectionStateChanged() ICE restarting because of ICE disconnected, (state=${this.peerConn?.iceConnectionState}, conn=${this.peerConn?.connectionState})`,\n                );\n                if (this.peerConn?.restartIce as (() => void) | null) {\n                    this.candidatesEnded = false;\n                    this.peerConn!.restartIce();\n                }\n                this.iceReconnectionTimeOut = undefined;\n            }, ICE_RECONNECTING_TIMEOUT);\n\n            this.iceDisconnectedTimeout = setTimeout((): void => {\n                logger.info(\n                    `Call ${this.callId} onIceConnectionStateChanged() hanging up call (ICE disconnected for too long)`,\n                );\n                this.hangup(CallErrorCode.IceFailed, false);\n            }, ICE_DISCONNECTED_TIMEOUT);\n            this.state = CallState.Connecting;\n        }\n\n        // In PTT mode, override feed status to muted when we lose connection to\n        // the peer, since we don't want to block the line if they're not saying anything.\n        // Experimenting in Chrome, this happens after 5 or 6 seconds, which is probably\n        // fast enough.\n        if (this.isPtt && [\"failed\", \"disconnected\"].includes(this.peerConn!.iceConnectionState)) {\n            for (const feed of this.getRemoteFeeds()) {\n                feed.setAudioVideoMuted(true, true);\n            }\n        }\n    };\n\n    private onSignallingStateChanged = (): void => {\n        logger.debug(`Call ${this.callId} onSignallingStateChanged() running (state=${this.peerConn?.signalingState})`);\n    };\n\n    private onTrack = (ev: RTCTrackEvent): void => {\n        if (ev.streams.length === 0) {\n            logger.warn(\n                `Call ${this.callId} onTrack() called with streamless track streamless (kind=${ev.track.kind})`,\n            );\n            return;\n        }\n\n        const stream = ev.streams[0];\n        this.pushRemoteFeed(stream);\n\n        if (!this.removeTrackListeners.has(stream)) {\n            const onRemoveTrack = (): void => {\n                if (stream.getTracks().length === 0) {\n                    logger.info(`Call ${this.callId} onTrack() removing track (streamId=${stream.id})`);\n                    this.deleteFeedByStream(stream);\n                    stream.removeEventListener(\"removetrack\", onRemoveTrack);\n                    this.removeTrackListeners.delete(stream);\n                }\n            };\n            stream.addEventListener(\"removetrack\", onRemoveTrack);\n            this.removeTrackListeners.set(stream, onRemoveTrack);\n        }\n    };\n\n    private onDataChannel = (ev: RTCDataChannelEvent): void => {\n        this.emit(CallEvent.DataChannel, ev.channel, this);\n    };\n\n    /**\n     * This method removes all video/rtx codecs from screensharing video\n     * transceivers. This is necessary since they can cause problems. Without\n     * this the following steps should produce an error:\n     *   Chromium calls Firefox\n     *   Firefox answers\n     *   Firefox starts screen-sharing\n     *   Chromium starts screen-sharing\n     *   Call crashes for Chromium with:\n     *       [96685:23:0518/162603.933321:ERROR:webrtc_video_engine.cc(3296)] RTX codec (PT=97) mapped to PT=96 which is not in the codec list.\n     *       [96685:23:0518/162603.933377:ERROR:webrtc_video_engine.cc(1171)] GetChangedRecvParameters called without any video codecs.\n     *       [96685:23:0518/162603.933430:ERROR:sdp_offer_answer.cc(4302)] Failed to set local video description recv parameters for m-section with mid='2'. (INVALID_PARAMETER)\n     */\n    private getRidOfRTXCodecs(): void {\n        // RTCRtpReceiver.getCapabilities and RTCRtpSender.getCapabilities don't seem to be supported on FF before v113\n        if (!RTCRtpReceiver.getCapabilities || !RTCRtpSender.getCapabilities) return;\n\n        const screenshareVideoTransceiver = this.transceivers.get(\n            getTransceiverKey(SDPStreamMetadataPurpose.Screenshare, \"video\"),\n        );\n\n        // setCodecPreferences isn't supported on FF (as of v113)\n        if (!screenshareVideoTransceiver || !screenshareVideoTransceiver.setCodecPreferences) return;\n\n        const recvCodecs = RTCRtpReceiver.getCapabilities(\"video\")!.codecs;\n        const sendCodecs = RTCRtpSender.getCapabilities(\"video\")!.codecs;\n        const codecs = [];\n\n        for (const codec of [...recvCodecs, ...sendCodecs]) {\n            if (codec.mimeType !== \"video/rtx\") {\n                codecs.push(codec);\n                try {\n                    screenshareVideoTransceiver.setCodecPreferences(codecs);\n                } catch (e) {\n                    // Specifically, Chrome around version 125 and Electron 30 (which is Chromium 124) return an H.264 codec in\n                    // the sender's capabilities but throw when you try to set it. Hence... this mess.\n                    // Specifically, that codec is:\n                    // {\n                    //   clockRate: 90000,\n                    //   mimeType: \"video/H264\",\n                    //   sdpFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640034\",\n                    // }\n                    logger.info(\n                        \"Working around buggy WebRTC impl: claimed to support codec but threw when setting codec preferences\",\n                        codec,\n                        e,\n                    );\n                    codecs.pop();\n                }\n            }\n        }\n    }\n\n    private onNegotiationNeeded = async (): Promise<void> => {\n        logger.info(`Call ${this.callId} onNegotiationNeeded() negotiation is needed!`);\n\n        if (this.state !== CallState.CreateOffer && this.opponentVersion === 0) {\n            logger.info(\n                `Call ${this.callId} onNegotiationNeeded() opponent does not support renegotiation: ignoring negotiationneeded event`,\n            );\n            return;\n        }\n\n        this.queueGotLocalOffer();\n    };\n\n    public onHangupReceived = (msg: MCallHangupReject): void => {\n        logger.debug(`Call ${this.callId} onHangupReceived() running`);\n\n        // party ID must match (our chosen partner hanging up the call) or be undefined (we haven't chosen\n        // a partner yet but we're treating the hangup as a reject as per VoIP v0)\n        if (this.partyIdMatches(msg) || this.state === CallState.Ringing) {\n            // default reason is user_hangup\n            this.terminate(CallParty.Remote, msg.reason || CallErrorCode.UserHangup, true);\n        } else {\n            logger.info(\n                `Call ${this.callId} onHangupReceived() ignoring message from party ID ${msg.party_id}: our partner is ${this.opponentPartyId}`,\n            );\n        }\n    };\n\n    public onRejectReceived = (msg: MCallHangupReject): void => {\n        logger.debug(`Call ${this.callId} onRejectReceived() running`);\n\n        // No need to check party_id for reject because if we'd received either\n        // an answer or reject, we wouldn't be in state InviteSent\n\n        const shouldTerminate =\n            // reject events also end the call if it's ringing: it's another of\n            // our devices rejecting the call.\n            [CallState.InviteSent, CallState.Ringing].includes(this.state) ||\n            // also if we're in the init state and it's an inbound call, since\n            // this means we just haven't entered the ringing state yet\n            (this.state === CallState.Fledgling && this.direction === CallDirection.Inbound);\n\n        if (shouldTerminate) {\n            this.terminate(CallParty.Remote, msg.reason || CallErrorCode.UserHangup, true);\n        } else {\n            logger.debug(`Call ${this.callId} onRejectReceived() called in wrong state (state=${this.state})`);\n        }\n    };\n\n    public onAnsweredElsewhere = (msg: MCallAnswer): void => {\n        logger.debug(`Call ${this.callId} onAnsweredElsewhere() running`);\n        this.terminate(CallParty.Remote, CallErrorCode.AnsweredElsewhere, true);\n    };\n\n    /**\n     * @internal\n     */\n    private async sendVoipEvent<K extends keyof Pick<TimelineEvents, CallEventType>>(\n        eventType: K,\n        content: Omit<TimelineEvents[K], \"version\" | \"call_id\" | \"party_id\" | \"conf_id\">,\n    ): Promise<void> {\n        const realContent = {\n            ...content,\n            version: VOIP_PROTO_VERSION,\n            call_id: this.callId,\n            party_id: this.ourPartyId,\n            conf_id: this.groupCallId,\n        } as TimelineEvents[K];\n\n        if (this.opponentDeviceId) {\n            const toDeviceSeq = this.toDeviceSeq++;\n            const content = {\n                ...realContent,\n                device_id: this.client.deviceId,\n                sender_session_id: this.client.getSessionId(),\n                dest_session_id: this.opponentSessionId,\n                seq: toDeviceSeq,\n                [ToDeviceMessageId]: uuidv4(),\n            };\n\n            this.emit(\n                CallEvent.SendVoipEvent,\n                {\n                    type: \"toDevice\",\n                    eventType,\n                    userId: this.invitee || this.getOpponentMember()?.userId,\n                    opponentDeviceId: this.opponentDeviceId,\n                    content,\n                },\n                this,\n            );\n\n            const userId = this.invitee || this.getOpponentMember()!.userId;\n            if (this.client.getUseE2eForGroupCall()) {\n                if (!this.hasOpponentDeviceInfo) {\n                    logger.warn(`Call ${this.callId} sendVoipEvent() failed: we do not have opponentDeviceInfo`);\n                    return;\n                }\n\n                // TODO: Here we were sending the event to the opponent's device as a to-device message with MatrixClient.encryptAndSendToDevice.\n                // However due to the switch to Rust cryptography we need to migrate to the new encryptToDeviceMessages API.\n                throw new Error(\"Unimplemented\");\n            } else {\n                await this.client.sendToDevice(\n                    eventType,\n                    new Map<string, any>([[userId, new Map([[this.opponentDeviceId, content]])]]),\n                );\n            }\n        } else {\n            this.emit(\n                CallEvent.SendVoipEvent,\n                {\n                    type: \"sendEvent\",\n                    eventType,\n                    roomId: this.roomId,\n                    content: realContent,\n                    userId: this.invitee || this.getOpponentMember()?.userId,\n                },\n                this,\n            );\n\n            await this.client.sendEvent(this.roomId!, eventType, realContent);\n        }\n    }\n\n    /**\n     * Queue a candidate to be sent\n     * @param content - The candidate to queue up, or null if candidates have finished being generated\n     *                and end-of-candidates should be signalled\n     */\n    private queueCandidate(content: RTCIceCandidate | null): void {\n        // We partially de-trickle candidates by waiting for `delay` before sending them\n        // amalgamated, in order to avoid sending too many m.call.candidates events and hitting\n        // rate limits in Matrix.\n        // In practice, it'd be better to remove rate limits for m.call.*\n\n        // N.B. this deliberately lets you queue and send blank candidates, which MSC2746\n        // currently proposes as the way to indicate that candidate gathering is complete.\n        // This will hopefully be changed to an explicit rather than implicit notification\n        // shortly.\n        if (content) {\n            this.candidateSendQueue.push(content);\n        } else {\n            this.candidatesEnded = true;\n        }\n\n        // Don't send the ICE candidates yet if the call is in the ringing state: this\n        // means we tried to pick (ie. started generating candidates) and then failed to\n        // send the answer and went back to the ringing state. Queue up the candidates\n        // to send if we successfully send the answer.\n        // Equally don't send if we haven't yet sent the answer because we can send the\n        // first batch of candidates along with the answer\n        if (this.state === CallState.Ringing || !this.inviteOrAnswerSent) return;\n\n        // MSC2746 recommends these values (can be quite long when calling because the\n        // callee will need a while to answer the call)\n        const delay = this.direction === CallDirection.Inbound ? 500 : 2000;\n\n        if (this.candidateSendTries === 0) {\n            setTimeout(() => {\n                this.sendCandidateQueue();\n            }, delay);\n        }\n    }\n\n    // Discard all non-end-of-candidates messages\n    // Return the number of candidate messages that were discarded.\n    // Call this method before sending an invite or answer message\n    private discardDuplicateCandidates(): number {\n        let discardCount = 0;\n        const newQueue: RTCIceCandidate[] = [];\n\n        for (let i = 0; i < this.candidateSendQueue.length; i++) {\n            const candidate = this.candidateSendQueue[i];\n            if (candidate.candidate === \"\") {\n                newQueue.push(candidate);\n            } else {\n                discardCount++;\n            }\n        }\n\n        this.candidateSendQueue = newQueue;\n\n        return discardCount;\n    }\n\n    /*\n     * Transfers this call to another user\n     */\n    public async transfer(targetUserId: string): Promise<void> {\n        // Fetch the target user's global profile info: their room avatar / displayname\n        // could be different in whatever room we share with them.\n        const profileInfo = await this.client.getProfileInfo(targetUserId);\n\n        const replacementId = genCallID();\n\n        const body = {\n            replacement_id: genCallID(),\n            target_user: {\n                id: targetUserId,\n                display_name: profileInfo.displayname,\n                avatar_url: profileInfo.avatar_url,\n            },\n            create_call: replacementId,\n        } as MCallReplacesEvent;\n\n        await this.sendVoipEvent(EventType.CallReplaces, body);\n\n        await this.terminate(CallParty.Local, CallErrorCode.Transferred, true);\n    }\n\n    /*\n     * Transfers this call to the target call, effectively 'joining' the\n     * two calls (so the remote parties on each call are connected together).\n     */\n    public async transferToCall(transferTargetCall: MatrixCall): Promise<void> {\n        const targetUserId = transferTargetCall.getOpponentMember()?.userId;\n        const targetProfileInfo = targetUserId ? await this.client.getProfileInfo(targetUserId) : undefined;\n        const opponentUserId = this.getOpponentMember()?.userId;\n        const transfereeProfileInfo = opponentUserId ? await this.client.getProfileInfo(opponentUserId) : undefined;\n\n        const newCallId = genCallID();\n\n        const bodyToTransferTarget = {\n            // the replacements on each side have their own ID, and it's distinct from the\n            // ID of the new call (but we can use the same function to generate it)\n            replacement_id: genCallID(),\n            target_user: {\n                id: opponentUserId,\n                display_name: transfereeProfileInfo?.displayname,\n                avatar_url: transfereeProfileInfo?.avatar_url,\n            },\n            await_call: newCallId,\n        } as MCallReplacesEvent;\n\n        await transferTargetCall.sendVoipEvent(EventType.CallReplaces, bodyToTransferTarget);\n\n        const bodyToTransferee = {\n            replacement_id: genCallID(),\n            target_user: {\n                id: targetUserId,\n                display_name: targetProfileInfo?.displayname,\n                avatar_url: targetProfileInfo?.avatar_url,\n            },\n            create_call: newCallId,\n        } as MCallReplacesEvent;\n\n        await this.sendVoipEvent(EventType.CallReplaces, bodyToTransferee);\n\n        await this.terminate(CallParty.Local, CallErrorCode.Transferred, true);\n        await transferTargetCall.terminate(CallParty.Local, CallErrorCode.Transferred, true);\n    }\n\n    private async terminate(hangupParty: CallParty, hangupReason: CallErrorCode, shouldEmit: boolean): Promise<void> {\n        if (this.callHasEnded()) return;\n\n        this.hangupParty = hangupParty;\n        this.hangupReason = hangupReason;\n        this.state = CallState.Ended;\n\n        if (this.inviteTimeout) {\n            clearTimeout(this.inviteTimeout);\n            this.inviteTimeout = undefined;\n        }\n        if (this.iceDisconnectedTimeout !== undefined) {\n            clearTimeout(this.iceDisconnectedTimeout);\n            this.iceDisconnectedTimeout = undefined;\n        }\n        if (this.callLengthInterval) {\n            clearInterval(this.callLengthInterval);\n            this.callLengthInterval = undefined;\n        }\n        if (this.stopVideoTrackTimer !== undefined) {\n            clearTimeout(this.stopVideoTrackTimer);\n            this.stopVideoTrackTimer = undefined;\n        }\n\n        for (const [stream, listener] of this.removeTrackListeners) {\n            stream.removeEventListener(\"removetrack\", listener);\n        }\n        this.removeTrackListeners.clear();\n\n        this.callStatsAtEnd = await this.collectCallStats();\n\n        // Order is important here: first we stopAllMedia() and only then we can deleteAllFeeds()\n        this.stopAllMedia();\n        this.deleteAllFeeds();\n\n        if (this.peerConn && this.peerConn.signalingState !== \"closed\") {\n            this.peerConn.close();\n        }\n        this.stats?.removeStatsReportGatherer(this.callId);\n\n        if (shouldEmit) {\n            this.emit(CallEvent.Hangup, this);\n        }\n\n        this.client.callEventHandler!.calls.delete(this.callId);\n    }\n\n    private stopAllMedia(): void {\n        logger.debug(`Call ${this.callId} stopAllMedia() running`);\n\n        for (const feed of this.feeds) {\n            // Slightly awkward as local feed need to go via the correct method on\n            // the MediaHandler so they get removed from MediaHandler (remote tracks\n            // don't)\n            // NB. We clone local streams when passing them to individual calls in a group\n            // call, so we can (and should) stop the clones once we no longer need them:\n            // the other clones will continue fine.\n            if (feed.isLocal() && feed.purpose === SDPStreamMetadataPurpose.Usermedia) {\n                this.client.getMediaHandler().stopUserMediaStream(feed.stream);\n            } else if (feed.isLocal() && feed.purpose === SDPStreamMetadataPurpose.Screenshare) {\n                this.client.getMediaHandler().stopScreensharingStream(feed.stream);\n            } else if (!feed.isLocal()) {\n                logger.debug(`Call ${this.callId} stopAllMedia() stopping stream (streamId=${feed.stream.id})`);\n                for (const track of feed.stream.getTracks()) {\n                    track.stop();\n                }\n            }\n        }\n    }\n\n    private checkForErrorListener(): void {\n        if (this.listeners(EventEmitterEvents.Error).length === 0) {\n            throw new Error(\"You MUST attach an error listener using call.on('error', function() {})\");\n        }\n    }\n\n    private async sendCandidateQueue(): Promise<void> {\n        if (this.candidateSendQueue.length === 0 || this.callHasEnded()) {\n            return;\n        }\n\n        const candidates = this.candidateSendQueue;\n        this.candidateSendQueue = [];\n        ++this.candidateSendTries;\n        const content: Pick<MCallCandidates, \"candidates\"> = {\n            candidates: candidates.map((candidate) => candidate.toJSON()),\n        };\n        if (this.candidatesEnded) {\n            // If there are no more candidates, signal this by adding an empty string candidate\n            content.candidates.push({\n                candidate: \"\",\n            });\n        }\n        logger.debug(`Call ${this.callId} sendCandidateQueue() attempting to send ${candidates.length} candidates`);\n        try {\n            await this.sendVoipEvent(EventType.CallCandidates, content);\n            // reset our retry count if we have successfully sent our candidates\n            // otherwise queueCandidate() will refuse to try to flush the queue\n            this.candidateSendTries = 0;\n\n            // Try to send candidates again just in case we received more candidates while sending.\n            this.sendCandidateQueue();\n        } catch (error) {\n            // don't retry this event: we'll send another one later as we might\n            // have more candidates by then.\n            if (error instanceof MatrixError && error.event) this.client.cancelPendingEvent(error.event);\n\n            // put all the candidates we failed to send back in the queue\n            this.candidateSendQueue.push(...candidates);\n\n            if (this.candidateSendTries > 5) {\n                logger.debug(\n                    `Call ${this.callId} sendCandidateQueue() failed to send candidates on attempt ${this.candidateSendTries}. Giving up on this call.`,\n                    error,\n                );\n\n                const code = CallErrorCode.SignallingFailed;\n                const message = \"Signalling failed\";\n\n                this.emit(CallEvent.Error, new CallError(code, message, <Error>error), this);\n                this.hangup(code, false);\n\n                return;\n            }\n\n            const delayMs = 500 * Math.pow(2, this.candidateSendTries);\n            ++this.candidateSendTries;\n            logger.debug(\n                `Call ${this.callId} sendCandidateQueue() failed to send candidates. Retrying in ${delayMs}ms`,\n                error,\n            );\n            setTimeout(() => {\n                this.sendCandidateQueue();\n            }, delayMs);\n        }\n    }\n\n    /**\n     * Place a call to this room.\n     * @throws if you have not specified a listener for 'error' events.\n     * @throws if have passed audio=false.\n     */\n    public async placeCall(audio: boolean, video: boolean): Promise<void> {\n        if (!audio) {\n            throw new Error(\"You CANNOT start a call without audio\");\n        }\n        this.state = CallState.WaitLocalMedia;\n\n        let callFeed: CallFeed;\n        try {\n            const stream = await this.client.getMediaHandler().getUserMediaStream(audio, video);\n\n            // make sure all the tracks are enabled (same as pushNewLocalFeed -\n            // we probably ought to just have one code path for adding streams)\n            setTracksEnabled(stream.getAudioTracks(), true);\n            setTracksEnabled(stream.getVideoTracks(), true);\n\n            callFeed = new CallFeed({\n                client: this.client,\n                roomId: this.roomId,\n                userId: this.client.getUserId()!,\n                deviceId: this.client.getDeviceId() ?? undefined,\n                stream,\n                purpose: SDPStreamMetadataPurpose.Usermedia,\n                audioMuted: false,\n                videoMuted: false,\n            });\n        } catch (e) {\n            this.getUserMediaFailed(<Error>e);\n            return;\n        }\n\n        try {\n            await this.placeCallWithCallFeeds([callFeed]);\n        } catch (e) {\n            this.placeCallFailed(<Error>e);\n            return;\n        }\n    }\n\n    /**\n     * Place a call to this room with call feed.\n     * @param callFeeds - to use\n     * @throws if you have not specified a listener for 'error' events.\n     * @throws if have passed audio=false.\n     */\n    public async placeCallWithCallFeeds(callFeeds: CallFeed[], requestScreenshareFeed = false): Promise<void> {\n        this.checkForErrorListener();\n        this.direction = CallDirection.Outbound;\n\n        await this.initOpponentCrypto();\n\n        // XXX Find a better way to do this\n        this.client.callEventHandler!.calls.set(this.callId, this);\n\n        // make sure we have valid turn creds. Unless something's gone wrong, it should\n        // poll and keep the credentials valid so this should be instant.\n        const haveTurnCreds = await this.client.checkTurnServers();\n        if (!haveTurnCreds) {\n            logger.warn(\n                `Call ${this.callId} placeCallWithCallFeeds() failed to get TURN credentials! Proceeding with call anyway...`,\n            );\n        }\n\n        // create the peer connection now so it can be gathering candidates while we get user\n        // media (assuming a candidate pool size is configured)\n        this.peerConn = this.createPeerConnection();\n        this.emit(CallEvent.PeerConnectionCreated, this.peerConn, this);\n        this.gotCallFeedsForInvite(callFeeds, requestScreenshareFeed);\n    }\n\n    private createPeerConnection(): RTCPeerConnection {\n        const pc = new window.RTCPeerConnection({\n            iceTransportPolicy: this.forceTURN ? \"relay\" : undefined,\n            iceServers: this.turnServers.length ? this.turnServers : undefined,\n            iceCandidatePoolSize: this.client.iceCandidatePoolSize,\n            bundlePolicy: \"max-bundle\",\n        });\n\n        // 'connectionstatechange' would be better, but firefox doesn't implement that.\n        pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChanged);\n        pc.addEventListener(\"signalingstatechange\", this.onSignallingStateChanged);\n        pc.addEventListener(\"icecandidate\", this.gotLocalIceCandidate);\n        pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n        pc.addEventListener(\"track\", this.onTrack);\n        pc.addEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n        pc.addEventListener(\"datachannel\", this.onDataChannel);\n\n        const opponentMember: RoomMember | undefined = this.getOpponentMember();\n        const opponentMemberId = opponentMember ? opponentMember.userId : \"unknown\";\n        this.stats?.addStatsReportGatherer(this.callId, opponentMemberId, pc);\n        return pc;\n    }\n\n    private partyIdMatches(msg: MCallBase): boolean {\n        // They must either match or both be absent (in which case opponentPartyId will be null)\n        // Also we ignore party IDs on the invite/offer if the version is 0, so we must do the same\n        // here and use null if the version is 0 (woe betide any opponent sending messages in the\n        // same call with different versions)\n        const msgPartyId = msg.version === 0 ? null : msg.party_id || null;\n        return msgPartyId === this.opponentPartyId;\n    }\n\n    // Commits to an opponent for the call\n    // ev: An invite or answer event\n    private chooseOpponent(ev: MatrixEvent): void {\n        // I choo-choo-choose you\n        const msg = ev.getContent<MCallInviteNegotiate | MCallAnswer>();\n\n        logger.debug(`Call ${this.callId} chooseOpponent() running (partyId=${msg.party_id})`);\n\n        this.opponentVersion = msg.version;\n        if (this.opponentVersion === 0) {\n            // set to null to indicate that we've chosen an opponent, but because\n            // they're v0 they have no party ID (even if they sent one, we're ignoring it)\n            this.opponentPartyId = null;\n        } else {\n            // set to their party ID, or if they're naughty and didn't send one despite\n            // not being v0, set it to null to indicate we picked an opponent with no\n            // party ID\n            this.opponentPartyId = msg.party_id || null;\n        }\n        this.opponentCaps = msg.capabilities || ({} as CallCapabilities);\n        this.opponentMember = this.client.getRoom(this.roomId)!.getMember(ev.getSender()!) ?? undefined;\n        if (this.opponentMember) {\n            this.stats?.updateOpponentMember(this.callId, this.opponentMember.userId);\n        }\n    }\n\n    private async addBufferedIceCandidates(): Promise<void> {\n        const bufferedCandidates = this.remoteCandidateBuffer.get(this.opponentPartyId!);\n        if (bufferedCandidates) {\n            logger.info(\n                `Call ${this.callId} addBufferedIceCandidates() adding ${bufferedCandidates.length} buffered candidates for opponent ${this.opponentPartyId}`,\n            );\n            await this.addIceCandidates(bufferedCandidates);\n        }\n        this.remoteCandidateBuffer.clear();\n    }\n\n    private async addIceCandidates(candidates: RTCIceCandidate[] | MCallCandidates[\"candidates\"]): Promise<void> {\n        for (const candidate of candidates) {\n            if (\n                (candidate.sdpMid === null || candidate.sdpMid === undefined) &&\n                (candidate.sdpMLineIndex === null || candidate.sdpMLineIndex === undefined)\n            ) {\n                logger.debug(`Call ${this.callId} addIceCandidates() got remote ICE end-of-candidates`);\n            } else {\n                logger.debug(\n                    `Call ${this.callId} addIceCandidates() got remote ICE candidate (sdpMid=${candidate.sdpMid}, candidate=${candidate.candidate})`,\n                );\n            }\n\n            try {\n                await this.peerConn!.addIceCandidate(candidate);\n            } catch (err) {\n                if (!this.ignoreOffer) {\n                    logger.info(`Call ${this.callId} addIceCandidates() failed to add remote ICE candidate`, err);\n                } else {\n                    logger.debug(\n                        `Call ${this.callId} addIceCandidates() failed to add remote ICE candidate because ignoring offer`,\n                        err,\n                    );\n                }\n            }\n        }\n    }\n\n    public get hasPeerConnection(): boolean {\n        return Boolean(this.peerConn);\n    }\n\n    public initStats(stats: GroupCallStats, peerId = \"unknown\"): void {\n        this.stats = stats;\n        this.stats.start();\n    }\n}\n\nexport function setTracksEnabled(tracks: Array<MediaStreamTrack>, enabled: boolean): void {\n    for (const track of tracks) {\n        track.enabled = enabled;\n    }\n}\n\nexport function supportsMatrixCall(): boolean {\n    // typeof prevents Node from erroring on an undefined reference\n    if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n        // NB. We don't log here as apps try to create a call object as a test for\n        // whether calls are supported, so we shouldn't fill the logs up.\n        return false;\n    }\n\n    // Firefox throws on so little as accessing the RTCPeerConnection when operating in a secure mode.\n    // There's some information at https://bugzilla.mozilla.org/show_bug.cgi?id=1542616 though the concern\n    // is that the browser throwing a SecurityError will brick the client creation process.\n    try {\n        const supported = Boolean(\n            window.RTCPeerConnection ??\n            window.RTCSessionDescription ??\n            window.RTCIceCandidate ??\n            navigator.mediaDevices,\n        );\n        if (!supported) {\n            /* istanbul ignore if */ // Adds a lot of noise to test runs, so disable logging there.\n            if (process.env.NODE_ENV !== \"test\") {\n                logger.error(\"WebRTC is not supported in this browser / environment\");\n            }\n            return false;\n        }\n    } catch (e) {\n        logger.error(\"Exception thrown when trying to access WebRTC\", e);\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * DEPRECATED\n * Use client.createCall()\n *\n * Create a new Matrix call for the browser.\n * @param client - The client instance to use.\n * @param roomId - The room the call is in.\n * @param options - DEPRECATED optional options map.\n * @returns the call or null if the browser doesn't support calling.\n */\nexport function createNewMatrixCall(\n    client: MatrixClient,\n    roomId: string,\n    options?: Pick<CallOpts, \"forceTURN\" | \"invitee\" | \"opponentDeviceId\" | \"opponentSessionId\" | \"groupCallId\">,\n): MatrixCall | null {\n    if (!supportsMatrixCall()) return null;\n\n    const optionsForceTURN = options ? options.forceTURN : false;\n\n    const opts: CallOpts = {\n        client: client,\n        roomId: roomId,\n        invitee: options?.invitee,\n        turnServers: client.getTurnServers(),\n        // call level options\n        forceTURN: client.forceTURN || optionsForceTURN,\n        opponentDeviceId: options?.opponentDeviceId,\n        opponentSessionId: options?.opponentSessionId,\n        groupCallId: options?.groupCallId,\n    };\n    const call = new MatrixCall(opts);\n\n    client.reEmitter.reEmit(call, Object.values(CallEvent));\n\n    return call;\n}\n","/*\nCopyright 2021 imon Brandner <simon.bra.ag@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { SDPStreamMetadataPurpose } from \"./callEventTypes.ts\";\nimport { acquireContext, releaseContext } from \"./audioContext.ts\";\nimport { type MatrixClient } from \"../client.ts\";\nimport { type RoomMember } from \"../models/room-member.ts\";\nimport { logger } from \"../logger.ts\";\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { CallEvent, CallState, type MatrixCall } from \"./call.ts\";\n\nconst POLLING_INTERVAL = 200; // ms\nexport const SPEAKING_THRESHOLD = -60; // dB\nconst SPEAKING_SAMPLE_COUNT = 8; // samples\n\nexport interface ICallFeedOpts {\n    client: MatrixClient;\n    roomId?: string;\n    userId: string;\n    deviceId: string | undefined;\n    stream: MediaStream;\n    purpose: SDPStreamMetadataPurpose;\n    /**\n     * Whether or not the remote SDPStreamMetadata says audio is muted\n     */\n    audioMuted: boolean;\n    /**\n     * Whether or not the remote SDPStreamMetadata says video is muted\n     */\n    videoMuted: boolean;\n    /**\n     * The MatrixCall which is the source of this CallFeed\n     */\n    call?: MatrixCall;\n}\n\nexport enum CallFeedEvent {\n    NewStream = \"new_stream\",\n    MuteStateChanged = \"mute_state_changed\",\n    LocalVolumeChanged = \"local_volume_changed\",\n    VolumeChanged = \"volume_changed\",\n    ConnectedChanged = \"connected_changed\",\n    Speaking = \"speaking\",\n    Disposed = \"disposed\",\n}\n\ntype EventHandlerMap = {\n    [CallFeedEvent.NewStream]: (stream: MediaStream) => void;\n    [CallFeedEvent.MuteStateChanged]: (audioMuted: boolean, videoMuted: boolean) => void;\n    [CallFeedEvent.LocalVolumeChanged]: (localVolume: number) => void;\n    [CallFeedEvent.VolumeChanged]: (volume: number) => void;\n    [CallFeedEvent.ConnectedChanged]: (connected: boolean) => void;\n    [CallFeedEvent.Speaking]: (speaking: boolean) => void;\n    [CallFeedEvent.Disposed]: () => void;\n};\n\nexport class CallFeed extends TypedEventEmitter<CallFeedEvent, EventHandlerMap> {\n    public stream: MediaStream;\n    public sdpMetadataStreamId: string;\n    public userId: string;\n    public readonly deviceId: string | undefined;\n    public purpose: SDPStreamMetadataPurpose;\n    public speakingVolumeSamples: number[];\n\n    private client: MatrixClient;\n    private call?: MatrixCall;\n    private roomId?: string;\n    private audioMuted: boolean;\n    private videoMuted: boolean;\n    private localVolume = 1;\n    private measuringVolumeActivity = false;\n    private audioContext?: AudioContext;\n    private analyser?: AnalyserNode;\n    private frequencyBinCount?: Float32Array<ArrayBuffer>;\n    private speakingThreshold = SPEAKING_THRESHOLD;\n    private speaking = false;\n    private volumeLooperTimeout?: ReturnType<typeof setTimeout>;\n    private _disposed = false;\n    private _connected = false;\n\n    public constructor(opts: ICallFeedOpts) {\n        super();\n\n        this.client = opts.client;\n        this.call = opts.call;\n        this.roomId = opts.roomId;\n        this.userId = opts.userId;\n        this.deviceId = opts.deviceId;\n        this.purpose = opts.purpose;\n        this.audioMuted = opts.audioMuted;\n        this.videoMuted = opts.videoMuted;\n        this.speakingVolumeSamples = new Array(SPEAKING_SAMPLE_COUNT).fill(-Infinity);\n        this.sdpMetadataStreamId = opts.stream.id;\n\n        this.updateStream(null, opts.stream);\n        this.stream = opts.stream; // updateStream does this, but this makes TS happier\n\n        if (this.hasAudioTrack) {\n            this.initVolumeMeasuring();\n        }\n\n        if (opts.call) {\n            opts.call.addListener(CallEvent.State, this.onCallState);\n            this.onCallState(opts.call.state);\n        }\n    }\n\n    public get connected(): boolean {\n        // Local feeds are always considered connected\n        return this.isLocal() || this._connected;\n    }\n\n    private set connected(connected: boolean) {\n        this._connected = connected;\n        this.emit(CallFeedEvent.ConnectedChanged, this.connected);\n    }\n\n    public get hasAudioTrack(): boolean {\n        return this.stream.getAudioTracks().length > 0;\n    }\n\n    private updateStream(oldStream: MediaStream | null, newStream: MediaStream): void {\n        if (newStream === oldStream) return;\n\n        const wasMeasuringVolumeActivity = this.measuringVolumeActivity;\n\n        if (oldStream) {\n            oldStream.removeEventListener(\"addtrack\", this.onAddTrack);\n            this.measureVolumeActivity(false);\n        }\n\n        this.stream = newStream;\n        newStream.addEventListener(\"addtrack\", this.onAddTrack);\n\n        if (this.hasAudioTrack) {\n            this.initVolumeMeasuring();\n            if (wasMeasuringVolumeActivity) this.measureVolumeActivity(true);\n        } else {\n            this.measureVolumeActivity(false);\n        }\n\n        this.emit(CallFeedEvent.NewStream, this.stream);\n    }\n\n    private initVolumeMeasuring(): void {\n        if (!this.hasAudioTrack) return;\n        if (!this.audioContext) this.audioContext = acquireContext();\n\n        this.analyser = this.audioContext.createAnalyser();\n        this.analyser.fftSize = 512;\n        this.analyser.smoothingTimeConstant = 0.1;\n\n        const mediaStreamAudioSourceNode = this.audioContext.createMediaStreamSource(this.stream);\n        mediaStreamAudioSourceNode.connect(this.analyser);\n\n        this.frequencyBinCount = new Float32Array(this.analyser.frequencyBinCount);\n    }\n\n    private onAddTrack = (): void => {\n        this.emit(CallFeedEvent.NewStream, this.stream);\n    };\n\n    private onCallState = (state: CallState): void => {\n        if (state === CallState.Connected) {\n            this.connected = true;\n        } else if (state === CallState.Connecting) {\n            this.connected = false;\n        }\n    };\n\n    /**\n     * Returns callRoom member\n     * @returns member of the callRoom\n     */\n    public getMember(): RoomMember | null {\n        const callRoom = this.client.getRoom(this.roomId);\n        return callRoom?.getMember(this.userId) ?? null;\n    }\n\n    /**\n     * Returns true if CallFeed is local, otherwise returns false\n     * @returns is local?\n     */\n    public isLocal(): boolean {\n        return (\n            this.userId === this.client.getUserId() &&\n            (this.deviceId === undefined || this.deviceId === this.client.getDeviceId())\n        );\n    }\n\n    /**\n     * Returns true if audio is muted or if there are no audio\n     * tracks, otherwise returns false\n     * @returns is audio muted?\n     */\n    public isAudioMuted(): boolean {\n        return this.stream.getAudioTracks().length === 0 || this.audioMuted;\n    }\n\n    /**\n     * Returns true video is muted or if there are no video\n     * tracks, otherwise returns false\n     * @returns is video muted?\n     */\n    public isVideoMuted(): boolean {\n        // We assume only one video track\n        return this.stream.getVideoTracks().length === 0 || this.videoMuted;\n    }\n\n    public isSpeaking(): boolean {\n        return this.speaking;\n    }\n\n    /**\n     * Replaces the current MediaStream with a new one.\n     * The stream will be different and new stream as remote parties are\n     * concerned, but this can be used for convenience locally to set up\n     * volume listeners automatically on the new stream etc.\n     * @param newStream - new stream with which to replace the current one\n     */\n    public setNewStream(newStream: MediaStream): void {\n        this.updateStream(this.stream, newStream);\n    }\n\n    /**\n     * Set one or both of feed's internal audio and video video mute state\n     * Either value may be null to leave it as-is\n     * @param audioMuted - is the feed's audio muted?\n     * @param videoMuted - is the feed's video muted?\n     */\n    public setAudioVideoMuted(audioMuted: boolean | null, videoMuted: boolean | null): void {\n        if (audioMuted !== null) {\n            if (this.audioMuted !== audioMuted) {\n                this.speakingVolumeSamples.fill(-Infinity);\n            }\n            this.audioMuted = audioMuted;\n        }\n        if (videoMuted !== null) this.videoMuted = videoMuted;\n        this.emit(CallFeedEvent.MuteStateChanged, this.audioMuted, this.videoMuted);\n    }\n\n    /**\n     * Starts emitting volume_changed events where the emitter value is in decibels\n     * @param enabled - emit volume changes\n     */\n    public measureVolumeActivity(enabled: boolean): void {\n        if (enabled) {\n            if (!this.analyser || !this.frequencyBinCount || !this.hasAudioTrack) return;\n\n            this.measuringVolumeActivity = true;\n            this.volumeLooper();\n        } else {\n            this.measuringVolumeActivity = false;\n            this.speakingVolumeSamples.fill(-Infinity);\n            this.emit(CallFeedEvent.VolumeChanged, -Infinity);\n        }\n    }\n\n    public setSpeakingThreshold(threshold: number): void {\n        this.speakingThreshold = threshold;\n    }\n\n    private volumeLooper = (): void => {\n        if (!this.analyser) return;\n\n        if (!this.measuringVolumeActivity) return;\n\n        this.analyser.getFloatFrequencyData(this.frequencyBinCount!);\n\n        let maxVolume = -Infinity;\n        for (const volume of this.frequencyBinCount!) {\n            if (volume > maxVolume) {\n                maxVolume = volume;\n            }\n        }\n\n        this.speakingVolumeSamples.shift();\n        this.speakingVolumeSamples.push(maxVolume);\n\n        this.emit(CallFeedEvent.VolumeChanged, maxVolume);\n\n        let newSpeaking = false;\n\n        for (const volume of this.speakingVolumeSamples) {\n            if (volume > this.speakingThreshold) {\n                newSpeaking = true;\n                break;\n            }\n        }\n\n        if (this.speaking !== newSpeaking) {\n            this.speaking = newSpeaking;\n            this.emit(CallFeedEvent.Speaking, this.speaking);\n        }\n\n        this.volumeLooperTimeout = setTimeout(this.volumeLooper, POLLING_INTERVAL);\n    };\n\n    public clone(): CallFeed {\n        const mediaHandler = this.client.getMediaHandler();\n        const stream = this.stream.clone();\n        logger.log(`CallFeed clone() cloning stream (originalStreamId=${this.stream.id}, newStreamId${stream.id})`);\n\n        if (this.purpose === SDPStreamMetadataPurpose.Usermedia) {\n            mediaHandler.userMediaStreams.push(stream);\n        } else {\n            mediaHandler.screensharingStreams.push(stream);\n        }\n\n        return new CallFeed({\n            client: this.client,\n            roomId: this.roomId,\n            userId: this.userId,\n            deviceId: this.deviceId,\n            stream,\n            purpose: this.purpose,\n            audioMuted: this.audioMuted,\n            videoMuted: this.videoMuted,\n        });\n    }\n\n    public dispose(): void {\n        clearTimeout(this.volumeLooperTimeout);\n        this.stream?.removeEventListener(\"addtrack\", this.onAddTrack);\n        this.call?.removeListener(CallEvent.State, this.onCallState);\n        if (this.audioContext) {\n            this.audioContext = undefined;\n            this.analyser = undefined;\n            releaseContext();\n        }\n        this._disposed = true;\n        this.emit(CallFeedEvent.Disposed);\n    }\n\n    public get disposed(): boolean {\n        return this._disposed;\n    }\n\n    private set disposed(value: boolean) {\n        this._disposed = value;\n    }\n\n    public getLocalVolume(): number {\n        return this.localVolume;\n    }\n\n    public setLocalVolume(localVolume: number): void {\n        this.localVolume = localVolume;\n        this.emit(CallFeedEvent.LocalVolumeChanged, localVolume);\n    }\n}\n","import { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { CallFeed, SPEAKING_THRESHOLD } from \"./callFeed.ts\";\nimport { type MatrixClient, type IMyDevice } from \"../client.ts\";\nimport {\n    CallErrorCode,\n    CallEvent,\n    type CallEventHandlerMap,\n    CallState,\n    genCallID,\n    type MatrixCall,\n    setTracksEnabled,\n    createNewMatrixCall,\n    CallError,\n} from \"./call.ts\";\nimport { type RoomMember } from \"../models/room-member.ts\";\nimport { type Room } from \"../models/room.ts\";\nimport { RoomStateEvent } from \"../models/room-state.ts\";\nimport { logger } from \"../logger.ts\";\nimport { ReEmitter } from \"../ReEmitter.ts\";\nimport { SDPStreamMetadataPurpose } from \"./callEventTypes.ts\";\nimport { type MatrixEvent } from \"../models/event.ts\";\nimport { EventType } from \"../@types/event.ts\";\nimport { CallEventHandlerEvent } from \"./callEventHandler.ts\";\nimport { GroupCallEventHandlerEvent } from \"./groupCallEventHandler.ts\";\nimport { type IScreensharingOpts } from \"./mediaHandler.ts\";\nimport { mapsEqual } from \"../utils.ts\";\nimport { GroupCallStats } from \"./stats/groupCallStats.ts\";\nimport {\n    type ByteSentStatsReport,\n    type CallFeedReport,\n    type ConnectionStatsReport,\n    StatsReport,\n    type SummaryStatsReport,\n} from \"./stats/statsReport.ts\";\nimport { SummaryStatsReportGatherer } from \"./stats/summaryStatsReportGatherer.ts\";\nimport { CallFeedStatsReporter } from \"./stats/callFeedStatsReporter.ts\";\nimport { KnownMembership } from \"../@types/membership.ts\";\n\nexport enum GroupCallIntent {\n    Ring = \"m.ring\",\n    Prompt = \"m.prompt\",\n    Room = \"m.room\",\n}\n\nexport enum GroupCallType {\n    Video = \"m.video\",\n    Voice = \"m.voice\",\n}\n\nexport enum GroupCallTerminationReason {\n    CallEnded = \"call_ended\",\n}\n\nexport type CallsByUserAndDevice = Map<string, Map<string, MatrixCall>>;\n\n/**\n * Because event names are just strings, they do need\n * to be unique over all event types of event emitter.\n * Some objects could emit more then one set of events.\n */\nexport enum GroupCallEvent {\n    GroupCallStateChanged = \"group_call_state_changed\",\n    ActiveSpeakerChanged = \"active_speaker_changed\",\n    CallsChanged = \"calls_changed\",\n    UserMediaFeedsChanged = \"user_media_feeds_changed\",\n    ScreenshareFeedsChanged = \"screenshare_feeds_changed\",\n    LocalScreenshareStateChanged = \"local_screenshare_state_changed\",\n    LocalMuteStateChanged = \"local_mute_state_changed\",\n    ParticipantsChanged = \"participants_changed\",\n    Error = \"group_call_error\",\n}\n\nexport type GroupCallEventHandlerMap = {\n    [GroupCallEvent.GroupCallStateChanged]: (newState: GroupCallState, oldState: GroupCallState) => void;\n    [GroupCallEvent.ActiveSpeakerChanged]: (activeSpeaker: CallFeed | undefined) => void;\n    [GroupCallEvent.CallsChanged]: (calls: CallsByUserAndDevice) => void;\n    [GroupCallEvent.UserMediaFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.ScreenshareFeedsChanged]: (feeds: CallFeed[]) => void;\n    [GroupCallEvent.LocalScreenshareStateChanged]: (\n        isScreensharing: boolean,\n        feed?: CallFeed,\n        sourceId?: string,\n    ) => void;\n    [GroupCallEvent.LocalMuteStateChanged]: (audioMuted: boolean, videoMuted: boolean) => void;\n    [GroupCallEvent.ParticipantsChanged]: (participants: Map<RoomMember, Map<string, ParticipantState>>) => void;\n    /**\n     * Fires whenever an error occurs when call.js encounters an issue with setting up the call.\n     * <p>\n     * The error given will have a code equal to either `MatrixCall.ERR_LOCAL_OFFER_FAILED` or\n     * `MatrixCall.ERR_NO_USER_MEDIA`. `ERR_LOCAL_OFFER_FAILED` is emitted when the local client\n     * fails to create an offer. `ERR_NO_USER_MEDIA` is emitted when the user has denied access\n     * to their audio/video hardware.\n     * @param error - The error raised by MatrixCall.\n     * @example\n     * ```\n     * matrixCall.on(\"error\", function(err){\n     *   console.error(err.code, err);\n     * });\n     * ```\n     */\n    [GroupCallEvent.Error]: (error: GroupCallError) => void;\n};\n\nexport enum GroupCallStatsReportEvent {\n    ConnectionStats = \"GroupCall.connection_stats\",\n    ByteSentStats = \"GroupCall.byte_sent_stats\",\n    SummaryStats = \"GroupCall.summary_stats\",\n    CallFeedStats = \"GroupCall.call_feed_stats\",\n}\n\n/**\n * The final report-events that get consumed by client.\n */\nexport type GroupCallStatsReportEventHandlerMap = {\n    [GroupCallStatsReportEvent.ConnectionStats]: (report: GroupCallStatsReport<ConnectionStatsReport>) => void;\n    [GroupCallStatsReportEvent.ByteSentStats]: (report: GroupCallStatsReport<ByteSentStatsReport>) => void;\n    [GroupCallStatsReportEvent.SummaryStats]: (report: GroupCallStatsReport<SummaryStatsReport>) => void;\n    [GroupCallStatsReportEvent.CallFeedStats]: (report: GroupCallStatsReport<CallFeedReport>) => void;\n};\n\nexport enum GroupCallErrorCode {\n    NoUserMedia = \"no_user_media\",\n    UnknownDevice = \"unknown_device\",\n    PlaceCallFailed = \"place_call_failed\",\n}\n\nexport interface GroupCallStatsReport<\n    T extends ConnectionStatsReport | ByteSentStatsReport | SummaryStatsReport | CallFeedReport,\n> {\n    report: T;\n}\n\nexport class GroupCallError extends Error {\n    public code: string;\n\n    public constructor(code: GroupCallErrorCode, msg: string, err?: Error) {\n        // Still don't think there's any way to have proper nested errors\n        if (err) {\n            super(msg + \": \" + err);\n        } else {\n            super(msg);\n        }\n\n        this.code = code;\n    }\n}\n\nexport class GroupCallUnknownDeviceError extends GroupCallError {\n    public constructor(public userId: string) {\n        super(GroupCallErrorCode.UnknownDevice, \"No device found for \" + userId);\n    }\n}\n\nexport class OtherUserSpeakingError extends Error {\n    public constructor() {\n        super(\"Cannot unmute: another user is speaking\");\n    }\n}\n\nexport interface IGroupCallDataChannelOptions {\n    ordered: boolean;\n    maxPacketLifeTime: number;\n    maxRetransmits: number;\n    protocol: string;\n}\n\nexport interface IGroupCallRoomState {\n    \"m.intent\": GroupCallIntent;\n    \"m.type\": GroupCallType;\n    \"m.terminated\"?: GroupCallTerminationReason;\n    \"io.element.ptt\"?: boolean;\n    // TODO: Specify data-channels\n    \"dataChannelsEnabled\"?: boolean;\n    \"dataChannelOptions\"?: IGroupCallDataChannelOptions;\n\n    \"io.element.livekit_service_url\"?: string;\n}\n\nexport interface IGroupCallRoomMemberFeed {\n    purpose: SDPStreamMetadataPurpose;\n}\n\nexport interface IGroupCallRoomMemberDevice {\n    device_id: string;\n    session_id: string;\n    expires_ts: number;\n    feeds: IGroupCallRoomMemberFeed[];\n}\n\nexport interface IGroupCallRoomMemberCallState {\n    \"m.call_id\": string;\n    \"m.foci\"?: string[];\n    \"m.devices\": IGroupCallRoomMemberDevice[];\n}\n\nexport interface IGroupCallRoomMemberState {\n    \"m.calls\": IGroupCallRoomMemberCallState[];\n}\n\nexport enum GroupCallState {\n    LocalCallFeedUninitialized = \"local_call_feed_uninitialized\",\n    InitializingLocalCallFeed = \"initializing_local_call_feed\",\n    LocalCallFeedInitialized = \"local_call_feed_initialized\",\n    Entered = \"entered\",\n    Ended = \"ended\",\n}\n\nexport interface ParticipantState {\n    sessionId: string;\n    screensharing: boolean;\n}\n\ninterface ICallHandlers {\n    onCallFeedsChanged: (feeds: CallFeed[]) => void;\n    onCallStateChanged: (state: CallState, oldState: CallState | undefined) => void;\n    onCallHangup: (call: MatrixCall) => void;\n    onCallReplaced: (newCall: MatrixCall) => void;\n}\n\nconst DEVICE_TIMEOUT = 1000 * 60 * 60; // 1 hour\n\nfunction getCallUserId(call: MatrixCall): string | null {\n    return call.getOpponentMember()?.userId || call.invitee || null;\n}\n\nexport class GroupCall extends TypedEventEmitter<\n    GroupCallEvent | CallEvent | GroupCallStatsReportEvent,\n    GroupCallEventHandlerMap & CallEventHandlerMap & GroupCallStatsReportEventHandlerMap\n> {\n    // Config\n    public activeSpeakerInterval = 1000;\n    public retryCallInterval = 5000;\n    public participantTimeout = 1000 * 15;\n    public pttMaxTransmitTime = 1000 * 20;\n\n    public activeSpeaker?: CallFeed;\n    public localCallFeed?: CallFeed;\n    public localScreenshareFeed?: CallFeed;\n    public localDesktopCapturerSourceId?: string;\n    public readonly userMediaFeeds: CallFeed[] = [];\n    public readonly screenshareFeeds: CallFeed[] = [];\n    public groupCallId: string;\n    public readonly allowCallWithoutVideoAndAudio: boolean;\n\n    private readonly calls = new Map<string, Map<string, MatrixCall>>(); // user_id -> device_id -> MatrixCall\n    private callHandlers = new Map<string, Map<string, ICallHandlers>>(); // user_id -> device_id -> ICallHandlers\n    private activeSpeakerLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallLoopInterval?: ReturnType<typeof setTimeout>;\n    private retryCallCounts: Map<string, Map<string, number>> = new Map(); // user_id -> device_id -> count\n    private reEmitter: ReEmitter;\n    private transmitTimer: ReturnType<typeof setTimeout> | null = null;\n    private participantsExpirationTimer: ReturnType<typeof setTimeout> | null = null;\n    private resendMemberStateTimer: ReturnType<typeof setInterval> | null = null;\n    private initWithAudioMuted = false;\n    private initWithVideoMuted = false;\n    private initCallFeedPromise?: Promise<void>;\n    private _livekitServiceURL?: string;\n\n    private stats: GroupCallStats | undefined;\n    /**\n     * Configure default webrtc stats collection interval in ms\n     * Disable collecting webrtc stats by setting interval to 0\n     */\n    private statsCollectIntervalTime = 0;\n\n    public constructor(\n        private client: MatrixClient,\n        public room: Room,\n        public type: GroupCallType,\n        public isPtt: boolean,\n        public intent: GroupCallIntent,\n        groupCallId?: string,\n        private dataChannelsEnabled?: boolean,\n        private dataChannelOptions?: IGroupCallDataChannelOptions,\n        isCallWithoutVideoAndAudio?: boolean,\n        // this tells the js-sdk not to actually establish any calls to exchange media and just to\n        // create the group call signaling events, with the intention that the actual media will be\n        // handled using livekit. The js-sdk doesn't contain any code to do the actual livekit call though.\n        private useLivekit = false,\n        livekitServiceURL?: string,\n    ) {\n        super();\n        this.reEmitter = new ReEmitter(this);\n        this.groupCallId = groupCallId ?? genCallID();\n        this._livekitServiceURL = livekitServiceURL;\n        this.creationTs =\n            room.currentState.getStateEvents(EventType.GroupCallPrefix, this.groupCallId)?.getTs() ?? null;\n        this.updateParticipants();\n\n        room.on(RoomStateEvent.Update, this.onRoomState);\n        this.on(GroupCallEvent.ParticipantsChanged, this.onParticipantsChanged);\n        this.on(GroupCallEvent.GroupCallStateChanged, this.onStateChanged);\n        this.on(GroupCallEvent.LocalScreenshareStateChanged, this.onLocalFeedsChanged);\n        this.allowCallWithoutVideoAndAudio = !!isCallWithoutVideoAndAudio;\n    }\n\n    private onConnectionStats = (report: ConnectionStatsReport): void => {\n        // Final emit of the summary event, to be consumed by the client\n        this.emit(GroupCallStatsReportEvent.ConnectionStats, { report });\n    };\n\n    private onByteSentStats = (report: ByteSentStatsReport): void => {\n        // Final emit of the summary event, to be consumed by the client\n        this.emit(GroupCallStatsReportEvent.ByteSentStats, { report });\n    };\n\n    private onSummaryStats = (report: SummaryStatsReport): void => {\n        SummaryStatsReportGatherer.extendSummaryReport(report, this.participants);\n        // Final emit of the summary event, to be consumed by the client\n        this.emit(GroupCallStatsReportEvent.SummaryStats, { report });\n    };\n\n    private onCallFeedReport = (report: CallFeedReport): void => {\n        if (this.localCallFeed) {\n            report = CallFeedStatsReporter.expandCallFeedReport(report, [this.localCallFeed], \"from-local-feed\");\n        }\n\n        const callFeeds: CallFeed[] = [];\n        this.forEachCall((call) => {\n            if (call.callId === report.callId) {\n                call.getFeeds().forEach((f) => callFeeds.push(f));\n            }\n        });\n\n        report = CallFeedStatsReporter.expandCallFeedReport(report, callFeeds, \"from-call-feed\");\n        this.emit(GroupCallStatsReportEvent.CallFeedStats, { report });\n    };\n\n    public async create(): Promise<GroupCall> {\n        this.creationTs = Date.now();\n        this.client.groupCallEventHandler!.groupCalls.set(this.room.roomId, this);\n        this.client.emit(GroupCallEventHandlerEvent.Outgoing, this);\n\n        await this.sendCallStateEvent();\n\n        return this;\n    }\n\n    private async sendCallStateEvent(): Promise<void> {\n        const groupCallState: IGroupCallRoomState = {\n            \"m.intent\": this.intent,\n            \"m.type\": this.type,\n            \"io.element.ptt\": this.isPtt,\n            // TODO: Specify data-channels better\n            \"dataChannelsEnabled\": this.dataChannelsEnabled,\n            \"dataChannelOptions\": this.dataChannelsEnabled ? this.dataChannelOptions : undefined,\n        };\n        if (this.livekitServiceURL) {\n            groupCallState[\"io.element.livekit_service_url\"] = this.livekitServiceURL;\n        }\n\n        await this.client.sendStateEvent(this.room.roomId, EventType.GroupCallPrefix, groupCallState, this.groupCallId);\n    }\n\n    public get livekitServiceURL(): string | undefined {\n        return this._livekitServiceURL;\n    }\n\n    public updateLivekitServiceURL(newURL: string): Promise<void> {\n        this._livekitServiceURL = newURL;\n        return this.sendCallStateEvent();\n    }\n\n    private _state = GroupCallState.LocalCallFeedUninitialized;\n\n    /**\n     * The group call's state.\n     */\n    public get state(): GroupCallState {\n        return this._state;\n    }\n\n    private set state(value: GroupCallState) {\n        const prevValue = this._state;\n        if (value !== prevValue) {\n            this._state = value;\n            this.emit(GroupCallEvent.GroupCallStateChanged, value, prevValue);\n        }\n    }\n\n    private _participants = new Map<RoomMember, Map<string, ParticipantState>>();\n\n    /**\n     * The current participants in the call, as a map from members to device IDs\n     * to participant info.\n     */\n    public get participants(): Map<RoomMember, Map<string, ParticipantState>> {\n        return this._participants;\n    }\n\n    private set participants(value: Map<RoomMember, Map<string, ParticipantState>>) {\n        const prevValue = this._participants;\n        const participantStateEqual = (x: ParticipantState, y: ParticipantState): boolean =>\n            x.sessionId === y.sessionId && x.screensharing === y.screensharing;\n        const deviceMapsEqual = (x: Map<string, ParticipantState>, y: Map<string, ParticipantState>): boolean =>\n            mapsEqual(x, y, participantStateEqual);\n\n        // Only update if the map actually changed\n        if (!mapsEqual(value, prevValue, deviceMapsEqual)) {\n            this._participants = value;\n            this.emit(GroupCallEvent.ParticipantsChanged, value);\n        }\n    }\n\n    private _creationTs: number | null = null;\n\n    /**\n     * The timestamp at which the call was created, or null if it has not yet\n     * been created.\n     */\n    public get creationTs(): number | null {\n        return this._creationTs;\n    }\n\n    private set creationTs(value: number | null) {\n        this._creationTs = value;\n    }\n\n    private _enteredViaAnotherSession = false;\n\n    /**\n     * Whether the local device has entered this call via another session, such\n     * as a widget.\n     */\n    public get enteredViaAnotherSession(): boolean {\n        return this._enteredViaAnotherSession;\n    }\n\n    public set enteredViaAnotherSession(value: boolean) {\n        this._enteredViaAnotherSession = value;\n        this.updateParticipants();\n    }\n\n    /**\n     * Executes the given callback on all calls in this group call.\n     * @param f - The callback.\n     */\n    public forEachCall(f: (call: MatrixCall) => void): void {\n        for (const deviceMap of this.calls.values()) {\n            for (const call of deviceMap.values()) f(call);\n        }\n    }\n\n    public getLocalFeeds(): CallFeed[] {\n        const feeds: CallFeed[] = [];\n\n        if (this.localCallFeed) feeds.push(this.localCallFeed);\n        if (this.localScreenshareFeed) feeds.push(this.localScreenshareFeed);\n\n        return feeds;\n    }\n\n    public hasLocalParticipant(): boolean {\n        return (\n            this.participants.get(this.room.getMember(this.client.getUserId()!)!)?.has(this.client.getDeviceId()!) ??\n            false\n        );\n    }\n\n    /**\n     * Determines whether the given call is one that we were expecting to exist\n     * given our knowledge of who is participating in the group call.\n     */\n    private callExpected(call: MatrixCall): boolean {\n        const userId = getCallUserId(call);\n        const member = userId === null ? null : this.room.getMember(userId);\n        const deviceId = call.getOpponentDeviceId();\n        return member !== null && deviceId !== undefined && this.participants.get(member)?.get(deviceId) !== undefined;\n    }\n\n    public async initLocalCallFeed(): Promise<void> {\n        if (this.useLivekit) {\n            logger.info(\"Livekit group call: not starting local call feed.\");\n            return;\n        }\n\n        if (this.state !== GroupCallState.LocalCallFeedUninitialized) {\n            throw new Error(`Cannot initialize local call feed in the \"${this.state}\" state.`);\n        }\n        this.state = GroupCallState.InitializingLocalCallFeed;\n\n        // wraps the real method to serialise calls, because we don't want to try starting\n        // multiple call feeds at once\n        if (this.initCallFeedPromise) return this.initCallFeedPromise;\n\n        try {\n            this.initCallFeedPromise = this.initLocalCallFeedInternal();\n            await this.initCallFeedPromise;\n        } finally {\n            this.initCallFeedPromise = undefined;\n        }\n    }\n\n    private async initLocalCallFeedInternal(): Promise<void> {\n        logger.log(`GroupCall ${this.groupCallId} initLocalCallFeedInternal() running`);\n\n        let stream: MediaStream;\n\n        try {\n            stream = await this.client.getMediaHandler().getUserMediaStream(true, this.type === GroupCallType.Video);\n        } catch (error) {\n            // If is allowed to join a call without a media stream, then we\n            // don't throw an error here. But we need an empty Local Feed to establish\n            // a connection later.\n            if (this.allowCallWithoutVideoAndAudio) {\n                stream = new MediaStream();\n            } else {\n                this.state = GroupCallState.LocalCallFeedUninitialized;\n                throw error;\n            }\n        }\n\n        // The call could've been disposed while we were waiting, and could\n        // also have been started back up again (hello, React 18) so if we're\n        // still in this 'initializing' state, carry on, otherwise bail.\n        if (this._state !== GroupCallState.InitializingLocalCallFeed) {\n            this.client.getMediaHandler().stopUserMediaStream(stream);\n            throw new Error(\"Group call disposed while gathering media stream\");\n        }\n\n        const callFeed = new CallFeed({\n            client: this.client,\n            roomId: this.room.roomId,\n            userId: this.client.getUserId()!,\n            deviceId: this.client.getDeviceId()!,\n            stream,\n            purpose: SDPStreamMetadataPurpose.Usermedia,\n            audioMuted: this.initWithAudioMuted || stream.getAudioTracks().length === 0 || this.isPtt,\n            videoMuted: this.initWithVideoMuted || stream.getVideoTracks().length === 0,\n        });\n\n        setTracksEnabled(stream.getAudioTracks(), !callFeed.isAudioMuted());\n        setTracksEnabled(stream.getVideoTracks(), !callFeed.isVideoMuted());\n\n        this.localCallFeed = callFeed;\n        this.addUserMediaFeed(callFeed);\n\n        this.state = GroupCallState.LocalCallFeedInitialized;\n    }\n\n    public async updateLocalUsermediaStream(stream: MediaStream): Promise<void> {\n        if (this.localCallFeed) {\n            const oldStream = this.localCallFeed.stream;\n            this.localCallFeed.setNewStream(stream);\n            const micShouldBeMuted = this.localCallFeed.isAudioMuted();\n            const vidShouldBeMuted = this.localCallFeed.isVideoMuted();\n            logger.log(\n                `GroupCall ${this.groupCallId} updateLocalUsermediaStream() (oldStreamId=${oldStream.id}, newStreamId=${stream.id}, micShouldBeMuted=${micShouldBeMuted}, vidShouldBeMuted=${vidShouldBeMuted})`,\n            );\n            setTracksEnabled(stream.getAudioTracks(), !micShouldBeMuted);\n            setTracksEnabled(stream.getVideoTracks(), !vidShouldBeMuted);\n            this.client.getMediaHandler().stopUserMediaStream(oldStream);\n        }\n    }\n\n    public async enter(): Promise<void> {\n        if (this.state === GroupCallState.LocalCallFeedUninitialized) {\n            await this.initLocalCallFeed();\n        } else if (this.state !== GroupCallState.LocalCallFeedInitialized) {\n            throw new Error(`Cannot enter call in the \"${this.state}\" state`);\n        }\n\n        logger.log(`GroupCall ${this.groupCallId} enter() running`);\n        this.state = GroupCallState.Entered;\n\n        this.client.on(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n\n        for (const call of this.client.callEventHandler!.calls.values()) {\n            this.onIncomingCall(call);\n        }\n\n        if (!this.useLivekit) {\n            this.retryCallLoopInterval = setInterval(this.onRetryCallLoop, this.retryCallInterval);\n\n            this.activeSpeaker = undefined;\n            this.onActiveSpeakerLoop();\n            this.activeSpeakerLoopInterval = setInterval(this.onActiveSpeakerLoop, this.activeSpeakerInterval);\n        }\n    }\n\n    private dispose(): void {\n        if (this.localCallFeed) {\n            this.removeUserMediaFeed(this.localCallFeed);\n            this.localCallFeed = undefined;\n        }\n\n        if (this.localScreenshareFeed) {\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n        }\n\n        this.client.getMediaHandler().stopAllStreams();\n\n        if (this.transmitTimer !== null) {\n            clearTimeout(this.transmitTimer);\n            this.transmitTimer = null;\n        }\n\n        if (this.retryCallLoopInterval !== undefined) {\n            clearInterval(this.retryCallLoopInterval);\n            this.retryCallLoopInterval = undefined;\n        }\n\n        if (this.participantsExpirationTimer !== null) {\n            clearTimeout(this.participantsExpirationTimer);\n            this.participantsExpirationTimer = null;\n        }\n\n        if (this.state !== GroupCallState.Entered) {\n            return;\n        }\n\n        this.forEachCall((call) => call.hangup(CallErrorCode.UserHangup, false));\n\n        this.activeSpeaker = undefined;\n        clearInterval(this.activeSpeakerLoopInterval);\n\n        this.retryCallCounts.clear();\n        clearInterval(this.retryCallLoopInterval);\n\n        this.client.removeListener(CallEventHandlerEvent.Incoming, this.onIncomingCall);\n        this.stats?.stop();\n    }\n\n    public leave(): void {\n        this.dispose();\n        this.state = GroupCallState.LocalCallFeedUninitialized;\n    }\n\n    public async terminate(emitStateEvent = true): Promise<void> {\n        this.dispose();\n\n        this.room.off(RoomStateEvent.Update, this.onRoomState);\n        this.client.groupCallEventHandler!.groupCalls.delete(this.room.roomId);\n        this.client.emit(GroupCallEventHandlerEvent.Ended, this);\n        this.state = GroupCallState.Ended;\n\n        if (emitStateEvent) {\n            const existingStateEvent = this.room.currentState.getStateEvents(\n                EventType.GroupCallPrefix,\n                this.groupCallId,\n            )!;\n\n            await this.client.sendStateEvent(\n                this.room.roomId,\n                EventType.GroupCallPrefix,\n                {\n                    ...existingStateEvent.getContent(),\n                    \"m.terminated\": GroupCallTerminationReason.CallEnded,\n                },\n                this.groupCallId,\n            );\n        }\n    }\n\n    /*\n     * Local Usermedia\n     */\n\n    public isLocalVideoMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isVideoMuted();\n        }\n\n        return true;\n    }\n\n    public isMicrophoneMuted(): boolean {\n        if (this.localCallFeed) {\n            return this.localCallFeed.isAudioMuted();\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's microphone.\n     * @param muted - Whether to mute the microphone\n     * @returns Whether muting/unmuting was successful\n     */\n    public async setMicrophoneMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !(await this.client.getMediaHandler().hasAudioDevice())) {\n            return false;\n        }\n\n        const sendUpdatesBefore = !muted && this.isPtt;\n\n        // set a timer for the maximum transmit time on PTT calls\n        if (this.isPtt) {\n            // Set or clear the max transmit timer\n            if (!muted && this.isMicrophoneMuted()) {\n                this.transmitTimer = setTimeout(() => {\n                    this.setMicrophoneMuted(true);\n                }, this.pttMaxTransmitTime);\n            } else if (muted && !this.isMicrophoneMuted()) {\n                if (this.transmitTimer !== null) clearTimeout(this.transmitTimer);\n                this.transmitTimer = null;\n            }\n        }\n\n        this.forEachCall((call) => call.localUsermediaFeed?.setAudioVideoMuted(muted, null));\n\n        const sendUpdates = async (): Promise<void> => {\n            const updates: Promise<void>[] = [];\n            this.forEachCall((call) => updates.push(call.sendMetadataUpdate()));\n\n            await Promise.all(updates).catch((e) =>\n                logger.info(\n                    `GroupCall ${this.groupCallId} setMicrophoneMuted() failed to send some metadata updates`,\n                    e,\n                ),\n            );\n        };\n\n        if (sendUpdatesBefore) await sendUpdates();\n\n        if (this.localCallFeed) {\n            logger.log(\n                `GroupCall ${this.groupCallId} setMicrophoneMuted() (streamId=${this.localCallFeed.stream.id}, muted=${muted})`,\n            );\n\n            const hasPermission = await this.checkAudioPermissionIfNecessary(muted);\n\n            if (!hasPermission) {\n                return false;\n            }\n\n            this.localCallFeed.setAudioVideoMuted(muted, null);\n            // I don't believe its actually necessary to enable these tracks: they\n            // are the one on the GroupCall's own CallFeed and are cloned before being\n            // given to any of the actual calls, so these tracks don't actually go\n            // anywhere. Let's do it anyway to avoid confusion.\n            setTracksEnabled(this.localCallFeed.stream.getAudioTracks(), !muted);\n        } else {\n            logger.log(`GroupCall ${this.groupCallId} setMicrophoneMuted() no stream muted (muted=${muted})`);\n            this.initWithAudioMuted = muted;\n        }\n\n        this.forEachCall((call) =>\n            setTracksEnabled(call.localUsermediaFeed!.stream.getAudioTracks(), !muted && this.callExpected(call)),\n        );\n        this.emit(GroupCallEvent.LocalMuteStateChanged, muted, this.isLocalVideoMuted());\n\n        if (!sendUpdatesBefore) await sendUpdates();\n\n        return true;\n    }\n\n    /**\n     * If we allow entering a call without a camera and without video, it can happen that the access rights to the\n     * devices have not yet been queried. If a stream does not yet have an audio track, we assume that the rights have\n     * not yet been checked.\n     *\n     * `this.client.getMediaHandler().getUserMediaStream` clones the current stream, so it only wanted to be called when\n     * not Audio Track exists.\n     * As such, this is a compromise, because, the access rights should always be queried before the call.\n     */\n    private async checkAudioPermissionIfNecessary(muted: boolean): Promise<boolean> {\n        // We needed this here to avoid an error in case user join a call without a device.\n        try {\n            if (!muted && this.localCallFeed && !this.localCallFeed.hasAudioTrack) {\n                const stream = await this.client\n                    .getMediaHandler()\n                    .getUserMediaStream(true, !this.localCallFeed.isVideoMuted());\n                if (stream?.getTracks().length === 0) {\n                    // if case permission denied to get a stream stop this here\n                    /* istanbul ignore next */\n                    logger.log(\n                        `GroupCall ${this.groupCallId} setMicrophoneMuted() no device to receive local stream, muted=${muted}`,\n                    );\n                    return false;\n                }\n            }\n        } catch {\n            /* istanbul ignore next */\n            logger.log(\n                `GroupCall ${this.groupCallId} setMicrophoneMuted() no device or permission to receive local stream, muted=${muted}`,\n            );\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Sets the mute state of the local participants's video.\n     * @param muted - Whether to mute the video\n     * @returns Whether muting/unmuting was successful\n     */\n    public async setLocalVideoMuted(muted: boolean): Promise<boolean> {\n        // hasAudioDevice can block indefinitely if the window has lost focus,\n        // and it doesn't make much sense to keep a device from being muted, so\n        // we always allow muted = true changes to go through\n        if (!muted && !(await this.client.getMediaHandler().hasVideoDevice())) {\n            return false;\n        }\n\n        if (this.localCallFeed) {\n            /* istanbul ignore next */\n            logger.log(\n                `GroupCall ${this.groupCallId} setLocalVideoMuted() (stream=${this.localCallFeed.stream.id}, muted=${muted})`,\n            );\n\n            try {\n                const stream = await this.client.getMediaHandler().getUserMediaStream(true, !muted);\n                await this.updateLocalUsermediaStream(stream);\n                this.localCallFeed.setAudioVideoMuted(null, muted);\n                setTracksEnabled(this.localCallFeed.stream.getVideoTracks(), !muted);\n            } catch {\n                // No permission to video device\n                /* istanbul ignore next */\n                logger.log(\n                    `GroupCall ${this.groupCallId} setLocalVideoMuted() no device or permission to receive local stream, muted=${muted}`,\n                );\n                return false;\n            }\n        } else {\n            logger.log(`GroupCall ${this.groupCallId} setLocalVideoMuted() no stream muted (muted=${muted})`);\n            this.initWithVideoMuted = muted;\n        }\n\n        const updates: Promise<unknown>[] = [];\n        this.forEachCall((call) => updates.push(call.setLocalVideoMuted(muted)));\n        await Promise.all(updates);\n\n        // We setTracksEnabled again, independently from the call doing it\n        // internally, since we might not be expecting the call\n        this.forEachCall((call) =>\n            setTracksEnabled(call.localUsermediaFeed!.stream.getVideoTracks(), !muted && this.callExpected(call)),\n        );\n\n        this.emit(GroupCallEvent.LocalMuteStateChanged, this.isMicrophoneMuted(), muted);\n\n        return true;\n    }\n\n    public async setScreensharingEnabled(enabled: boolean, opts: IScreensharingOpts = {}): Promise<boolean> {\n        if (enabled === this.isScreensharing()) {\n            return enabled;\n        }\n\n        if (enabled) {\n            try {\n                logger.log(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() is asking for screensharing permissions`,\n                );\n                const stream = await this.client.getMediaHandler().getScreensharingStream(opts);\n\n                for (const track of stream.getTracks()) {\n                    const onTrackEnded = (): void => {\n                        this.setScreensharingEnabled(false);\n                        track.removeEventListener(\"ended\", onTrackEnded);\n                    };\n\n                    track.addEventListener(\"ended\", onTrackEnded);\n                }\n\n                logger.log(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() granted screensharing permissions. Setting screensharing enabled on all calls`,\n                );\n\n                this.localDesktopCapturerSourceId = opts.desktopCapturerSourceId;\n                this.localScreenshareFeed = new CallFeed({\n                    client: this.client,\n                    roomId: this.room.roomId,\n                    userId: this.client.getUserId()!,\n                    deviceId: this.client.getDeviceId()!,\n                    stream,\n                    purpose: SDPStreamMetadataPurpose.Screenshare,\n                    audioMuted: false,\n                    videoMuted: false,\n                });\n                this.addScreenshareFeed(this.localScreenshareFeed);\n\n                this.emit(\n                    GroupCallEvent.LocalScreenshareStateChanged,\n                    true,\n                    this.localScreenshareFeed,\n                    this.localDesktopCapturerSourceId,\n                );\n\n                // TODO: handle errors\n                this.forEachCall((call) => call.pushLocalFeed(this.localScreenshareFeed!.clone()));\n\n                return true;\n            } catch (error) {\n                if (opts.throwOnFail) throw error;\n                logger.error(\n                    `GroupCall ${this.groupCallId} setScreensharingEnabled() enabling screensharing error`,\n                    error,\n                );\n                this.emit(\n                    GroupCallEvent.Error,\n                    new GroupCallError(\n                        GroupCallErrorCode.NoUserMedia,\n                        \"Failed to get screen-sharing stream: \",\n                        error as Error,\n                    ),\n                );\n                return false;\n            }\n        } else {\n            this.forEachCall((call) => {\n                if (call.localScreensharingFeed) call.removeLocalFeed(call.localScreensharingFeed);\n            });\n            this.client.getMediaHandler().stopScreensharingStream(this.localScreenshareFeed!.stream);\n            this.removeScreenshareFeed(this.localScreenshareFeed!);\n            this.localScreenshareFeed = undefined;\n            this.localDesktopCapturerSourceId = undefined;\n            this.emit(GroupCallEvent.LocalScreenshareStateChanged, false, undefined, undefined);\n            return false;\n        }\n    }\n\n    public isScreensharing(): boolean {\n        return !!this.localScreenshareFeed;\n    }\n\n    /*\n     * Call Setup\n     *\n     * There are two different paths for calls to be created:\n     * 1. Incoming calls triggered by the Call.incoming event.\n     * 2. Outgoing calls to the initial members of a room or new members\n     *    as they are observed by the RoomState.members event.\n     */\n\n    private onIncomingCall = (newCall: MatrixCall): void => {\n        // The incoming calls may be for another room, which we will ignore.\n        if (newCall.roomId !== this.room.roomId) {\n            return;\n        }\n\n        if (newCall.state !== CallState.Ringing) {\n            logger.warn(\n                `GroupCall ${this.groupCallId} onIncomingCall() incoming call no longer in ringing state - ignoring`,\n            );\n            return;\n        }\n\n        if (!newCall.groupCallId || newCall.groupCallId !== this.groupCallId) {\n            logger.log(\n                `GroupCall ${this.groupCallId} onIncomingCall() ignored because it doesn't match the current group call`,\n            );\n            newCall.reject();\n            return;\n        }\n\n        const opponentUserId = newCall.getOpponentMember()?.userId;\n        if (opponentUserId === undefined) {\n            logger.warn(`GroupCall ${this.groupCallId} onIncomingCall() incoming call with no member - ignoring`);\n            return;\n        }\n\n        if (this.useLivekit) {\n            logger.info(\"Received incoming call whilst in signaling-only mode! Ignoring.\");\n            return;\n        }\n\n        const deviceMap = this.calls.get(opponentUserId) ?? new Map<string, MatrixCall>();\n        const prevCall = deviceMap.get(newCall.getOpponentDeviceId()!);\n\n        if (prevCall?.callId === newCall.callId) return;\n\n        logger.log(\n            `GroupCall ${this.groupCallId} onIncomingCall() incoming call (userId=${opponentUserId}, callId=${newCall.callId})`,\n        );\n\n        if (prevCall) prevCall.hangup(CallErrorCode.Replaced, false);\n        // We must do this before we start initialising / answering the call as we\n        // need to know it is the active call for this user+deviceId and to not ignore\n        // events from it.\n        deviceMap.set(newCall.getOpponentDeviceId()!, newCall);\n        this.calls.set(opponentUserId, deviceMap);\n\n        this.initCall(newCall);\n\n        const feeds = this.getLocalFeeds().map((feed) => feed.clone());\n        if (!this.callExpected(newCall)) {\n            // Disable our tracks for users not explicitly participating in the\n            // call but trying to receive the feeds\n            for (const feed of feeds) {\n                setTracksEnabled(feed.stream.getAudioTracks(), false);\n                setTracksEnabled(feed.stream.getVideoTracks(), false);\n            }\n        }\n        newCall.answerWithCallFeeds(feeds);\n\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /**\n     * Determines whether a given participant expects us to call them (versus\n     * them calling us).\n     * @param userId - The participant's user ID.\n     * @param deviceId - The participant's device ID.\n     * @returns Whether we need to place an outgoing call to the participant.\n     */\n    private wantsOutgoingCall(userId: string, deviceId: string): boolean {\n        const localUserId = this.client.getUserId()!;\n        const localDeviceId = this.client.getDeviceId()!;\n        return (\n            // If a user's ID is less than our own, they'll call us\n            userId >= localUserId &&\n            // If this is another one of our devices, compare device IDs to tell whether it'll call us\n            (userId !== localUserId || deviceId > localDeviceId)\n        );\n    }\n\n    /**\n     * Places calls to all participants that we're responsible for calling.\n     */\n    private placeOutgoingCalls(): void {\n        let callsChanged = false;\n\n        for (const [{ userId }, participantMap] of this.participants) {\n            const callMap = this.calls.get(userId) ?? new Map<string, MatrixCall>();\n\n            for (const [deviceId, participant] of participantMap) {\n                const prevCall = callMap.get(deviceId);\n\n                if (\n                    prevCall?.getOpponentSessionId() !== participant.sessionId &&\n                    this.wantsOutgoingCall(userId, deviceId)\n                ) {\n                    callsChanged = true;\n\n                    if (prevCall !== undefined) {\n                        logger.debug(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() replacing call (userId=${userId}, deviceId=${deviceId}, callId=${prevCall.callId})`,\n                        );\n                        prevCall.hangup(CallErrorCode.NewSession, false);\n                    }\n\n                    const newCall = createNewMatrixCall(this.client, this.room.roomId, {\n                        invitee: userId,\n                        opponentDeviceId: deviceId,\n                        opponentSessionId: participant.sessionId,\n                        groupCallId: this.groupCallId,\n                    });\n\n                    if (newCall === null) {\n                        logger.error(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() failed to create call (userId=${userId}, device=${deviceId})`,\n                        );\n                        callMap.delete(deviceId);\n                    } else {\n                        this.initCall(newCall);\n                        callMap.set(deviceId, newCall);\n\n                        logger.debug(\n                            `GroupCall ${this.groupCallId} placeOutgoingCalls() placing call (userId=${userId}, deviceId=${deviceId}, sessionId=${participant.sessionId})`,\n                        );\n\n                        newCall\n                            .placeCallWithCallFeeds(\n                                this.getLocalFeeds().map((feed) => feed.clone()),\n                                participant.screensharing,\n                            )\n                            .then(() => {\n                                if (this.dataChannelsEnabled) {\n                                    newCall.createDataChannel(\"datachannel\", this.dataChannelOptions);\n                                }\n                            })\n                            .catch((e) => {\n                                logger.warn(\n                                    `GroupCall ${this.groupCallId} placeOutgoingCalls() failed to place call (userId=${userId})`,\n                                    e,\n                                );\n\n                                if (e instanceof CallError && e.code === GroupCallErrorCode.UnknownDevice) {\n                                    this.emit(GroupCallEvent.Error, e);\n                                } else {\n                                    this.emit(\n                                        GroupCallEvent.Error,\n                                        new GroupCallError(\n                                            GroupCallErrorCode.PlaceCallFailed,\n                                            `Failed to place call to ${userId}`,\n                                        ),\n                                    );\n                                }\n\n                                newCall.hangup(CallErrorCode.SignallingFailed, false);\n                                if (callMap.get(deviceId) === newCall) callMap.delete(deviceId);\n                            });\n                    }\n                }\n            }\n\n            if (callMap.size > 0) {\n                this.calls.set(userId, callMap);\n            } else {\n                this.calls.delete(userId);\n            }\n        }\n\n        if (callsChanged) this.emit(GroupCallEvent.CallsChanged, this.calls);\n    }\n\n    /*\n     * Room Member State\n     */\n\n    private getMemberStateEvents(): MatrixEvent[];\n    private getMemberStateEvents(userId: string): MatrixEvent | null;\n    private getMemberStateEvents(userId?: string): MatrixEvent[] | MatrixEvent | null {\n        return userId === undefined\n            ? this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix)\n            : this.room.currentState.getStateEvents(EventType.GroupCallMemberPrefix, userId);\n    }\n\n    private onRetryCallLoop = (): void => {\n        let needsRetry = false;\n\n        for (const [{ userId }, participantMap] of this.participants) {\n            const callMap = this.calls.get(userId);\n            let retriesMap = this.retryCallCounts.get(userId);\n\n            for (const [deviceId, participant] of participantMap) {\n                const call = callMap?.get(deviceId);\n                const retries = retriesMap?.get(deviceId) ?? 0;\n\n                if (\n                    call?.getOpponentSessionId() !== participant.sessionId &&\n                    this.wantsOutgoingCall(userId, deviceId) &&\n                    retries < 3\n                ) {\n                    if (retriesMap === undefined) {\n                        retriesMap = new Map();\n                        this.retryCallCounts.set(userId, retriesMap);\n                    }\n                    retriesMap.set(deviceId, retries + 1);\n                    needsRetry = true;\n                }\n            }\n        }\n\n        if (needsRetry) this.placeOutgoingCalls();\n    };\n\n    private initCall(call: MatrixCall): void {\n        const opponentMemberId = getCallUserId(call);\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot init call without user id\");\n        }\n\n        const onCallFeedsChanged = (): void => this.onCallFeedsChanged(call);\n        const onCallStateChanged = (state: CallState, oldState?: CallState): void =>\n            this.onCallStateChanged(call, state, oldState);\n        const onCallHangup = this.onCallHangup;\n        const onCallReplaced = (newCall: MatrixCall): void => this.onCallReplaced(call, newCall);\n\n        let deviceMap = this.callHandlers.get(opponentMemberId);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.callHandlers.set(opponentMemberId, deviceMap);\n        }\n\n        deviceMap.set(call.getOpponentDeviceId()!, {\n            onCallFeedsChanged,\n            onCallStateChanged,\n            onCallHangup,\n            onCallReplaced,\n        });\n\n        call.on(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.on(CallEvent.State, onCallStateChanged);\n        call.on(CallEvent.Hangup, onCallHangup);\n        call.on(CallEvent.Replaced, onCallReplaced);\n\n        call.isPtt = this.isPtt;\n\n        this.reEmitter.reEmit(call, Object.values(CallEvent));\n\n        call.initStats(this.getGroupCallStats());\n\n        onCallFeedsChanged();\n    }\n\n    private disposeCall(call: MatrixCall, hangupReason: CallErrorCode): void {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot dispose call without user id\");\n        }\n\n        const deviceMap = this.callHandlers.get(opponentMemberId)!;\n        const { onCallFeedsChanged, onCallStateChanged, onCallHangup, onCallReplaced } =\n            deviceMap.get(opponentDeviceId)!;\n\n        call.removeListener(CallEvent.FeedsChanged, onCallFeedsChanged);\n        call.removeListener(CallEvent.State, onCallStateChanged);\n        call.removeListener(CallEvent.Hangup, onCallHangup);\n        call.removeListener(CallEvent.Replaced, onCallReplaced);\n\n        deviceMap.delete(opponentMemberId);\n        if (deviceMap.size === 0) this.callHandlers.delete(opponentMemberId);\n\n        if (call.hangupReason === CallErrorCode.Replaced) {\n            return;\n        }\n\n        const usermediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n\n        if (usermediaFeed) {\n            this.removeUserMediaFeed(usermediaFeed);\n        }\n\n        const screenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n\n        if (screenshareFeed) {\n            this.removeScreenshareFeed(screenshareFeed);\n        }\n    }\n\n    private onCallFeedsChanged = (call: MatrixCall): void => {\n        const opponentMemberId = getCallUserId(call);\n        const opponentDeviceId = call.getOpponentDeviceId()!;\n\n        if (!opponentMemberId) {\n            throw new Error(\"Cannot change call feeds without user id\");\n        }\n\n        const currentUserMediaFeed = this.getUserMediaFeed(opponentMemberId, opponentDeviceId);\n        const remoteUsermediaFeed = call.remoteUsermediaFeed;\n        const remoteFeedChanged = remoteUsermediaFeed !== currentUserMediaFeed;\n\n        const deviceMap = this.calls.get(opponentMemberId);\n        const currentCallForUserDevice = deviceMap?.get(opponentDeviceId);\n        if (currentCallForUserDevice?.callId !== call.callId) {\n            // the call in question is not the current call for this user/deviceId\n            // so ignore feed events from it otherwise we'll remove our real feeds\n            return;\n        }\n\n        if (remoteFeedChanged) {\n            if (!currentUserMediaFeed && remoteUsermediaFeed) {\n                this.addUserMediaFeed(remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && remoteUsermediaFeed) {\n                this.replaceUserMediaFeed(currentUserMediaFeed, remoteUsermediaFeed);\n            } else if (currentUserMediaFeed && !remoteUsermediaFeed) {\n                this.removeUserMediaFeed(currentUserMediaFeed);\n            }\n        }\n\n        const currentScreenshareFeed = this.getScreenshareFeed(opponentMemberId, opponentDeviceId);\n        const remoteScreensharingFeed = call.remoteScreensharingFeed;\n        const remoteScreenshareFeedChanged = remoteScreensharingFeed !== currentScreenshareFeed;\n\n        if (remoteScreenshareFeedChanged) {\n            if (!currentScreenshareFeed && remoteScreensharingFeed) {\n                this.addScreenshareFeed(remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && remoteScreensharingFeed) {\n                this.replaceScreenshareFeed(currentScreenshareFeed, remoteScreensharingFeed);\n            } else if (currentScreenshareFeed && !remoteScreensharingFeed) {\n                this.removeScreenshareFeed(currentScreenshareFeed);\n            }\n        }\n    };\n\n    private onCallStateChanged = (call: MatrixCall, state: CallState, _oldState: CallState | undefined): void => {\n        if (state === CallState.Ended) return;\n\n        const audioMuted = this.localCallFeed!.isAudioMuted();\n\n        if (call.localUsermediaStream && call.isMicrophoneMuted() !== audioMuted) {\n            call.setMicrophoneMuted(audioMuted);\n        }\n\n        const videoMuted = this.localCallFeed!.isVideoMuted();\n\n        if (call.localUsermediaStream && call.isLocalVideoMuted() !== videoMuted) {\n            call.setLocalVideoMuted(videoMuted);\n        }\n\n        const opponentUserId = call.getOpponentMember()?.userId;\n        if (state === CallState.Connected && opponentUserId) {\n            const retriesMap = this.retryCallCounts.get(opponentUserId);\n            retriesMap?.delete(call.getOpponentDeviceId()!);\n            if (retriesMap?.size === 0) this.retryCallCounts.delete(opponentUserId);\n        }\n    };\n\n    private onCallHangup = (call: MatrixCall): void => {\n        if (call.hangupReason === CallErrorCode.Replaced) return;\n\n        const opponentUserId = call.getOpponentMember()?.userId ?? this.room.getMember(call.invitee!)!.userId;\n        const deviceMap = this.calls.get(opponentUserId);\n\n        // Sanity check that this call is in fact in the map\n        if (deviceMap?.get(call.getOpponentDeviceId()!) === call) {\n            this.disposeCall(call, call.hangupReason as CallErrorCode);\n            deviceMap.delete(call.getOpponentDeviceId()!);\n            if (deviceMap.size === 0) this.calls.delete(opponentUserId);\n            this.emit(GroupCallEvent.CallsChanged, this.calls);\n        }\n    };\n\n    private onCallReplaced = (prevCall: MatrixCall, newCall: MatrixCall): void => {\n        const opponentUserId = prevCall.getOpponentMember()!.userId;\n\n        let deviceMap = this.calls.get(opponentUserId);\n        if (deviceMap === undefined) {\n            deviceMap = new Map();\n            this.calls.set(opponentUserId, deviceMap);\n        }\n\n        prevCall.hangup(CallErrorCode.Replaced, false);\n        this.initCall(newCall);\n        deviceMap.set(prevCall.getOpponentDeviceId()!, newCall);\n        this.emit(GroupCallEvent.CallsChanged, this.calls);\n    };\n\n    /*\n     * UserMedia CallFeed Event Handlers\n     */\n\n    public getUserMediaFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.userMediaFeeds.find((f) => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addUserMediaFeed(callFeed: CallFeed): void {\n        this.userMediaFeeds.push(callFeed);\n        callFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private replaceUserMediaFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            (f) => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to replace\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        replacementFeed.measureVolumeActivity(true);\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n    }\n\n    private removeUserMediaFeed(callFeed: CallFeed): void {\n        const feedIndex = this.userMediaFeeds.findIndex(\n            (f) => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find user media feed to remove\");\n        }\n\n        this.userMediaFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.UserMediaFeedsChanged, this.userMediaFeeds);\n\n        if (this.activeSpeaker === callFeed) {\n            this.activeSpeaker = this.userMediaFeeds[0];\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    }\n\n    private onActiveSpeakerLoop = (): void => {\n        let topAvg: number | undefined = undefined;\n        let nextActiveSpeaker: CallFeed | undefined = undefined;\n\n        for (const callFeed of this.userMediaFeeds) {\n            if (callFeed.isLocal() && this.userMediaFeeds.length > 1) continue;\n\n            const total = callFeed.speakingVolumeSamples.reduce(\n                (acc, volume) => acc + Math.max(volume, SPEAKING_THRESHOLD),\n            );\n            const avg = total / callFeed.speakingVolumeSamples.length;\n\n            if (!topAvg || avg > topAvg) {\n                topAvg = avg;\n                nextActiveSpeaker = callFeed;\n            }\n        }\n\n        if (nextActiveSpeaker && this.activeSpeaker !== nextActiveSpeaker && topAvg && topAvg > SPEAKING_THRESHOLD) {\n            this.activeSpeaker = nextActiveSpeaker;\n            this.emit(GroupCallEvent.ActiveSpeakerChanged, this.activeSpeaker);\n        }\n    };\n\n    /*\n     * Screenshare Call Feed Event Handlers\n     */\n\n    public getScreenshareFeed(userId: string, deviceId: string): CallFeed | undefined {\n        return this.screenshareFeeds.find((f) => f.userId === userId && f.deviceId! === deviceId);\n    }\n\n    private addScreenshareFeed(callFeed: CallFeed): void {\n        this.screenshareFeeds.push(callFeed);\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private replaceScreenshareFeed(existingFeed: CallFeed, replacementFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            (f) => f.userId === existingFeed.userId && f.deviceId! === existingFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to replace\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1, replacementFeed);\n\n        existingFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    private removeScreenshareFeed(callFeed: CallFeed): void {\n        const feedIndex = this.screenshareFeeds.findIndex(\n            (f) => f.userId === callFeed.userId && f.deviceId! === callFeed.deviceId,\n        );\n\n        if (feedIndex === -1) {\n            throw new Error(\"Couldn't find screenshare feed to remove\");\n        }\n\n        this.screenshareFeeds.splice(feedIndex, 1);\n\n        callFeed.dispose();\n        this.emit(GroupCallEvent.ScreenshareFeedsChanged, this.screenshareFeeds);\n    }\n\n    /**\n     * Recalculates and updates the participant map to match the room state.\n     */\n    private updateParticipants(): void {\n        const localMember = this.room.getMember(this.client.getSafeUserId());\n        if (!localMember) {\n            // The client hasn't fetched enough of the room state to get our own member\n            // event. This probably shouldn't happen, but sanity check & exit for now.\n            logger.warn(\n                `GroupCall ${this.groupCallId} updateParticipants() tried to update participants before local room member is available`,\n            );\n            return;\n        }\n\n        if (this.participantsExpirationTimer !== null) {\n            clearTimeout(this.participantsExpirationTimer);\n            this.participantsExpirationTimer = null;\n        }\n\n        if (this.state === GroupCallState.Ended) {\n            this.participants = new Map();\n            return;\n        }\n\n        const participants = new Map<RoomMember, Map<string, ParticipantState>>();\n        const now = Date.now();\n        const entered = this.state === GroupCallState.Entered || this.enteredViaAnotherSession;\n        let nextExpiration = Infinity;\n\n        for (const e of this.getMemberStateEvents()) {\n            const member = this.room.getMember(e.getStateKey()!);\n            const content = e.getContent<Record<any, unknown>>();\n            const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n            const call = calls.find((call) => call[\"m.call_id\"] === this.groupCallId);\n            const devices: Record<any, unknown>[] = Array.isArray(call?.[\"m.devices\"]) ? call![\"m.devices\"] : [];\n\n            // Filter out invalid and expired devices\n            let validDevices = devices.filter(\n                (d) =>\n                    typeof d.device_id === \"string\" &&\n                    typeof d.session_id === \"string\" &&\n                    typeof d.expires_ts === \"number\" &&\n                    d.expires_ts > now &&\n                    Array.isArray(d.feeds),\n            ) as unknown as IGroupCallRoomMemberDevice[];\n\n            // Apply local echo for the unentered case\n            if (!entered && member?.userId === this.client.getUserId()!) {\n                validDevices = validDevices.filter((d) => d.device_id !== this.client.getDeviceId()!);\n            }\n\n            // Must have a connected device and be joined to the room\n            if (validDevices.length > 0 && member?.membership === KnownMembership.Join) {\n                const deviceMap = new Map<string, ParticipantState>();\n                participants.set(member, deviceMap);\n\n                for (const d of validDevices) {\n                    deviceMap.set(d.device_id, {\n                        sessionId: d.session_id,\n                        screensharing: d.feeds.some((f) => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                    });\n                    if (d.expires_ts < nextExpiration) nextExpiration = d.expires_ts;\n                }\n            }\n        }\n\n        // Apply local echo for the entered case\n        if (entered) {\n            let deviceMap = participants.get(localMember);\n            if (deviceMap === undefined) {\n                deviceMap = new Map();\n                participants.set(localMember, deviceMap);\n            }\n\n            if (!deviceMap.has(this.client.getDeviceId()!)) {\n                deviceMap.set(this.client.getDeviceId()!, {\n                    sessionId: this.client.getSessionId(),\n                    screensharing: this.getLocalFeeds().some((f) => f.purpose === SDPStreamMetadataPurpose.Screenshare),\n                });\n            }\n        }\n\n        this.participants = participants;\n        if (nextExpiration < Infinity) {\n            this.participantsExpirationTimer = setTimeout(() => this.updateParticipants(), nextExpiration - now);\n        }\n    }\n\n    /**\n     * Updates the local user's member state with the devices returned by the given function.\n     * @param fn - A function from the current devices to the new devices. If it\n     *   returns null, the update will be skipped.\n     * @param keepAlive - Whether the request should outlive the window.\n     */\n    private async updateDevices(\n        fn: (devices: IGroupCallRoomMemberDevice[]) => IGroupCallRoomMemberDevice[] | null,\n        keepAlive = false,\n    ): Promise<void> {\n        const now = Date.now();\n        const localUserId = this.client.getUserId()!;\n\n        const event = this.getMemberStateEvents(localUserId);\n        const content = event?.getContent<Record<any, unknown>>() ?? {};\n        const calls: Record<any, unknown>[] = Array.isArray(content[\"m.calls\"]) ? content[\"m.calls\"] : [];\n\n        let call: Record<any, unknown> | null = null;\n        const otherCalls: Record<any, unknown>[] = [];\n        for (const c of calls) {\n            if (c[\"m.call_id\"] === this.groupCallId) {\n                call = c;\n            } else {\n                otherCalls.push(c);\n            }\n        }\n        if (call === null) call = {};\n\n        const devices: Record<any, unknown>[] = Array.isArray(call[\"m.devices\"]) ? call[\"m.devices\"] : [];\n\n        // Filter out invalid and expired devices\n        const validDevices = devices.filter(\n            (d) =>\n                typeof d.device_id === \"string\" &&\n                typeof d.session_id === \"string\" &&\n                typeof d.expires_ts === \"number\" &&\n                d.expires_ts > now &&\n                Array.isArray(d.feeds),\n        ) as unknown as IGroupCallRoomMemberDevice[];\n\n        const newDevices = fn(validDevices);\n        if (newDevices === null) return;\n\n        const newCalls = [...(otherCalls as unknown as IGroupCallRoomMemberCallState[])];\n        if (newDevices.length > 0) {\n            newCalls.push({\n                ...call,\n                \"m.call_id\": this.groupCallId,\n                \"m.devices\": newDevices,\n            });\n        }\n\n        const newContent: IGroupCallRoomMemberState = { \"m.calls\": newCalls };\n\n        await this.client.sendStateEvent(this.room.roomId, EventType.GroupCallMemberPrefix, newContent, localUserId, {\n            keepAlive,\n        });\n    }\n\n    private async addDeviceToMemberState(): Promise<void> {\n        await this.updateDevices((devices) => [\n            ...devices.filter((d) => d.device_id !== this.client.getDeviceId()!),\n            {\n                device_id: this.client.getDeviceId()!,\n                session_id: this.client.getSessionId(),\n                expires_ts: Date.now() + DEVICE_TIMEOUT,\n                feeds: this.getLocalFeeds().map((feed) => ({ purpose: feed.purpose })),\n                // TODO: Add data channels\n            },\n        ]);\n    }\n\n    private async updateMemberState(): Promise<void> {\n        // Clear the old update interval before proceeding\n        if (this.resendMemberStateTimer !== null) {\n            clearInterval(this.resendMemberStateTimer);\n            this.resendMemberStateTimer = null;\n        }\n\n        if (this.state === GroupCallState.Entered) {\n            // Add the local device\n            await this.addDeviceToMemberState();\n\n            // Resend the state event every so often so it doesn't become stale\n            this.resendMemberStateTimer = setInterval(\n                async () => {\n                    logger.log(`GroupCall ${this.groupCallId} updateMemberState() resending call member state\"`);\n                    try {\n                        await this.addDeviceToMemberState();\n                    } catch (e) {\n                        logger.error(\n                            `GroupCall ${this.groupCallId} updateMemberState() failed to resend call member state`,\n                            e,\n                        );\n                    }\n                },\n                (DEVICE_TIMEOUT * 3) / 4,\n            );\n        } else {\n            // Remove the local device\n            await this.updateDevices(\n                (devices) => devices.filter((d) => d.device_id !== this.client.getDeviceId()!),\n                true,\n            );\n        }\n    }\n\n    /**\n     * Cleans up our member state by filtering out logged out devices, inactive\n     * devices, and our own device (if we know we haven't entered).\n     */\n    public async cleanMemberState(): Promise<void> {\n        const { devices: myDevices } = await this.client.getDevices();\n        const deviceMap = new Map<string, IMyDevice>(myDevices.map((d) => [d.device_id, d]));\n\n        // updateDevices takes care of filtering out inactive devices for us\n        await this.updateDevices((devices) => {\n            const newDevices = devices.filter((d) => {\n                const device = deviceMap.get(d.device_id);\n                return (\n                    device?.last_seen_ts !== undefined &&\n                    !(\n                        d.device_id === this.client.getDeviceId()! &&\n                        this.state !== GroupCallState.Entered &&\n                        !this.enteredViaAnotherSession\n                    )\n                );\n            });\n\n            // Skip the update if the devices are unchanged\n            return newDevices.length === devices.length ? null : newDevices;\n        });\n    }\n\n    private onRoomState = (): void => this.updateParticipants();\n\n    private onParticipantsChanged = (): void => {\n        // Re-run setTracksEnabled on all calls, so that participants that just\n        // left get denied access to our media, and participants that just\n        // joined get granted access\n        this.forEachCall((call) => {\n            const expected = this.callExpected(call);\n            for (const feed of call.getLocalFeeds()) {\n                setTracksEnabled(feed.stream.getAudioTracks(), !feed.isAudioMuted() && expected);\n                setTracksEnabled(feed.stream.getVideoTracks(), !feed.isVideoMuted() && expected);\n            }\n        });\n\n        if (this.state === GroupCallState.Entered && !this.useLivekit) this.placeOutgoingCalls();\n\n        // Update the participants stored in the stats object\n    };\n\n    private onStateChanged = (newState: GroupCallState, oldState: GroupCallState): void => {\n        if (\n            newState === GroupCallState.Entered ||\n            oldState === GroupCallState.Entered ||\n            newState === GroupCallState.Ended\n        ) {\n            // We either entered, left, or ended the call\n            this.updateParticipants();\n            this.updateMemberState().catch((e) =>\n                logger.error(\n                    `GroupCall ${this.groupCallId} onStateChanged() failed to update member state devices\"`,\n                    e,\n                ),\n            );\n        }\n    };\n\n    private onLocalFeedsChanged = (): void => {\n        if (this.state === GroupCallState.Entered) {\n            this.updateMemberState().catch((e) =>\n                logger.error(\n                    `GroupCall ${this.groupCallId} onLocalFeedsChanged() failed to update member state feeds`,\n                    e,\n                ),\n            );\n        }\n    };\n\n    public getGroupCallStats(): GroupCallStats {\n        if (this.stats === undefined) {\n            const userID = this.client.getUserId() || \"unknown\";\n            this.stats = new GroupCallStats(this.groupCallId, userID, this.statsCollectIntervalTime);\n            this.stats.reports.on(StatsReport.CONNECTION_STATS, this.onConnectionStats);\n            this.stats.reports.on(StatsReport.BYTE_SENT_STATS, this.onByteSentStats);\n            this.stats.reports.on(StatsReport.SUMMARY_STATS, this.onSummaryStats);\n            this.stats.reports.on(StatsReport.CALL_FEED_REPORT, this.onCallFeedReport);\n        }\n        return this.stats;\n    }\n\n    public setGroupCallStatsInterval(interval: number): void {\n        this.statsCollectIntervalTime = interval;\n        if (this.stats !== undefined) {\n            this.stats.stop();\n            this.stats.setInterval(interval);\n            if (interval > 0) {\n                this.stats.start();\n            }\n        }\n    }\n}\n","/*\nCopyright 2015, 2016 OpenMarket Ltd\nCopyright 2017 New Vector Ltd\nCopyright 2019, 2020 The Matrix.org Foundation C.I.C.\nCopyright 2021 - 2022 imon Brandner <simon.bra.ag@gmail.com>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { TypedEventEmitter } from \"../models/typed-event-emitter.ts\";\nimport { GroupCallType, GroupCallState } from \"../webrtc/groupCall.ts\";\nimport { logger } from \"../logger.ts\";\nimport { type MatrixClient } from \"../client.ts\";\n\nexport enum MediaHandlerEvent {\n    LocalStreamsChanged = \"local_streams_changed\",\n}\n\nexport type MediaHandlerEventHandlerMap = {\n    [MediaHandlerEvent.LocalStreamsChanged]: () => void;\n};\n\nexport interface IScreensharingOpts {\n    /**\n     * sourceId for Electron DesktopCapturer\n     */\n    desktopCapturerSourceId?: string;\n    audio?: boolean;\n    // For electron screen capture, there are very few options for detecting electron\n    // apart from inspecting the user agent or just trying getDisplayMedia() and\n    // catching the failure, so we do the latter - this flag tells the function to just\n    // throw an error so we can catch it in this case, rather than logging and emitting.\n    throwOnFail?: boolean;\n}\n\nexport interface AudioSettings {\n    autoGainControl: boolean;\n    echoCancellation: boolean;\n    noiseSuppression: boolean;\n}\n\nexport class MediaHandler extends TypedEventEmitter<\n    MediaHandlerEvent.LocalStreamsChanged,\n    MediaHandlerEventHandlerMap\n> {\n    private audioInput?: string;\n    private audioSettings?: AudioSettings;\n    private videoInput?: string;\n    private localUserMediaStream?: MediaStream;\n    public userMediaStreams: MediaStream[] = [];\n    public screensharingStreams: MediaStream[] = [];\n\n    // Promise chain to serialise calls to getMediaStream\n    private getMediaStreamPromise?: Promise<MediaStream>;\n\n    public constructor(private client: MatrixClient) {\n        super();\n    }\n\n    public restoreMediaSettings(audioInput: string, videoInput: string): void {\n        this.audioInput = audioInput;\n        this.videoInput = videoInput;\n    }\n\n    /**\n     * Set an audio input device to use for MatrixCalls\n     * @param deviceId - the identifier for the device\n     * undefined treated as unset\n     */\n    public async setAudioInput(deviceId: string): Promise<void> {\n        logger.info(`MediaHandler setAudioInput() running (deviceId=${deviceId})`);\n\n        if (this.audioInput === deviceId) return;\n\n        this.audioInput = deviceId;\n        await this.updateLocalUsermediaStreams();\n    }\n\n    /**\n     * Set audio settings for MatrixCalls\n     * @param opts - audio options to set\n     */\n    public async setAudioSettings(opts: AudioSettings): Promise<void> {\n        logger.info(`MediaHandler setAudioSettings() running (opts=${JSON.stringify(opts)})`);\n\n        this.audioSettings = Object.assign({}, opts) as AudioSettings;\n        await this.updateLocalUsermediaStreams();\n    }\n\n    /**\n     * Set a video input device to use for MatrixCalls\n     * @param deviceId - the identifier for the device\n     * undefined treated as unset\n     */\n    public async setVideoInput(deviceId: string): Promise<void> {\n        logger.info(`MediaHandler setVideoInput() running (deviceId=${deviceId})`);\n\n        if (this.videoInput === deviceId) return;\n\n        this.videoInput = deviceId;\n        await this.updateLocalUsermediaStreams();\n    }\n\n    /**\n     * Set media input devices to use for MatrixCalls\n     * @param audioInput - the identifier for the audio device\n     * @param videoInput - the identifier for the video device\n     * undefined treated as unset\n     */\n    public async setMediaInputs(audioInput: string, videoInput: string): Promise<void> {\n        logger.log(`MediaHandler setMediaInputs() running (audioInput: ${audioInput} videoInput: ${videoInput})`);\n        this.audioInput = audioInput;\n        this.videoInput = videoInput;\n        await this.updateLocalUsermediaStreams();\n    }\n\n    /*\n     * Requests new usermedia streams and replace the old ones\n     */\n    public async updateLocalUsermediaStreams(): Promise<void> {\n        if (this.userMediaStreams.length === 0) return;\n\n        const callMediaStreamParams: Map<string, { audio: boolean; video: boolean }> = new Map();\n        for (const call of this.client.callEventHandler!.calls.values()) {\n            callMediaStreamParams.set(call.callId, {\n                audio: call.hasLocalUserMediaAudioTrack,\n                video: call.hasLocalUserMediaVideoTrack,\n            });\n        }\n\n        for (const stream of this.userMediaStreams) {\n            logger.log(`MediaHandler updateLocalUsermediaStreams() stopping all tracks (streamId=${stream.id})`);\n            for (const track of stream.getTracks()) {\n                track.stop();\n            }\n        }\n\n        this.userMediaStreams = [];\n        this.localUserMediaStream = undefined;\n\n        for (const call of this.client.callEventHandler!.calls.values()) {\n            if (call.callHasEnded() || !callMediaStreamParams.has(call.callId)) {\n                continue;\n            }\n\n            const { audio, video } = callMediaStreamParams.get(call.callId)!;\n\n            logger.log(\n                `MediaHandler updateLocalUsermediaStreams() calling getUserMediaStream() (callId=${call.callId})`,\n            );\n            const stream = await this.getUserMediaStream(audio, video);\n\n            if (call.callHasEnded()) {\n                continue;\n            }\n\n            await call.updateLocalUsermediaStream(stream);\n        }\n\n        for (const groupCall of this.client.groupCallEventHandler!.groupCalls.values()) {\n            if (!groupCall.localCallFeed) {\n                continue;\n            }\n\n            logger.log(\n                `MediaHandler updateLocalUsermediaStreams() calling getUserMediaStream() (groupCallId=${groupCall.groupCallId})`,\n            );\n            const stream = await this.getUserMediaStream(true, groupCall.type === GroupCallType.Video);\n\n            if (groupCall.state === GroupCallState.Ended) {\n                continue;\n            }\n\n            await groupCall.updateLocalUsermediaStream(stream);\n        }\n\n        this.emit(MediaHandlerEvent.LocalStreamsChanged);\n    }\n\n    public async hasAudioDevice(): Promise<boolean> {\n        try {\n            const devices = await navigator.mediaDevices.enumerateDevices();\n            return devices.filter((device) => device.kind === \"audioinput\").length > 0;\n        } catch (err) {\n            logger.log(`MediaHandler hasAudioDevice() calling navigator.mediaDevices.enumerateDevices with error`, err);\n            return false;\n        }\n    }\n\n    public async hasVideoDevice(): Promise<boolean> {\n        try {\n            const devices = await navigator.mediaDevices.enumerateDevices();\n            return devices.filter((device) => device.kind === \"videoinput\").length > 0;\n        } catch (err) {\n            logger.log(`MediaHandler hasVideoDevice() calling navigator.mediaDevices.enumerateDevices with error`, err);\n            return false;\n        }\n    }\n\n    /**\n     * @param audio - should have an audio track\n     * @param video - should have a video track\n     * @param reusable - is allowed to be reused by the MediaHandler\n     * @returns based on passed parameters\n     */\n    public async getUserMediaStream(audio: boolean, video: boolean, reusable = true): Promise<MediaStream> {\n        // Serialise calls, othertwise we can't sensibly re-use the stream\n        if (this.getMediaStreamPromise) {\n            this.getMediaStreamPromise = this.getMediaStreamPromise.then(() => {\n                return this.getUserMediaStreamInternal(audio, video, reusable);\n            });\n        } else {\n            this.getMediaStreamPromise = this.getUserMediaStreamInternal(audio, video, reusable);\n        }\n\n        return this.getMediaStreamPromise;\n    }\n\n    private async getUserMediaStreamInternal(audio: boolean, video: boolean, reusable: boolean): Promise<MediaStream> {\n        const shouldRequestAudio = audio && (await this.hasAudioDevice());\n        const shouldRequestVideo = video && (await this.hasVideoDevice());\n\n        let stream: MediaStream;\n\n        let canReuseStream = true;\n        if (this.localUserMediaStream) {\n            // This figures out if we can reuse the current localUsermediaStream\n            // based on whether or not the \"mute state\" (presence of tracks of a\n            // given kind) matches what is being requested\n            if (shouldRequestAudio !== this.localUserMediaStream.getAudioTracks().length > 0) {\n                canReuseStream = false;\n            }\n            if (shouldRequestVideo !== this.localUserMediaStream.getVideoTracks().length > 0) {\n                canReuseStream = false;\n            }\n\n            // This code checks that the device ID is the same as the localUserMediaStream stream, but we update\n            // the localUserMediaStream whenever the device ID changes (apart from when restoring) so it's not\n            // clear why this would ever be different, unless there's a race.\n            if (\n                shouldRequestAudio &&\n                this.localUserMediaStream.getAudioTracks()[0]?.getSettings()?.deviceId !== this.audioInput\n            ) {\n                canReuseStream = false;\n            }\n            if (\n                shouldRequestVideo &&\n                this.localUserMediaStream.getVideoTracks()[0]?.getSettings()?.deviceId !== this.videoInput\n            ) {\n                canReuseStream = false;\n            }\n        } else {\n            canReuseStream = false;\n        }\n\n        if (!canReuseStream) {\n            let constraints: MediaStreamConstraints;\n            try {\n                // Not specifying exact for deviceId means switching devices does not always work,\n                // try with exact and fallback to ideal if it fails\n                constraints = this.getUserMediaContraints(shouldRequestAudio, shouldRequestVideo, true);\n                stream = await navigator.mediaDevices.getUserMedia(constraints);\n            } catch (e) {\n                logger.warn(\n                    `MediaHandler getUserMediaStreamInternal() error (e=${e}), retrying without exact deviceId`,\n                );\n                constraints = this.getUserMediaContraints(shouldRequestAudio, shouldRequestVideo, false);\n                stream = await navigator.mediaDevices.getUserMedia(constraints);\n            }\n            logger.log(\n                `MediaHandler getUserMediaStreamInternal() calling getUserMediaStream (streamId=${\n                    stream.id\n                }, shouldRequestAudio=${shouldRequestAudio}, shouldRequestVideo=${shouldRequestVideo}, constraints=${JSON.stringify(\n                    constraints,\n                )})`,\n            );\n\n            for (const track of stream.getTracks()) {\n                const settings = track.getSettings();\n\n                if (track.kind === \"audio\") {\n                    this.audioInput = settings.deviceId!;\n                } else if (track.kind === \"video\") {\n                    this.videoInput = settings.deviceId!;\n                }\n            }\n\n            if (reusable) {\n                this.localUserMediaStream = stream;\n            }\n        } else {\n            stream = this.localUserMediaStream!.clone();\n            logger.log(\n                `MediaHandler getUserMediaStreamInternal() cloning (oldStreamId=${this.localUserMediaStream?.id} newStreamId=${stream.id} shouldRequestAudio=${shouldRequestAudio} shouldRequestVideo=${shouldRequestVideo})`,\n            );\n\n            if (!shouldRequestAudio) {\n                for (const track of stream.getAudioTracks()) {\n                    stream.removeTrack(track);\n                }\n            }\n\n            if (!shouldRequestVideo) {\n                for (const track of stream.getVideoTracks()) {\n                    stream.removeTrack(track);\n                }\n            }\n        }\n\n        if (reusable) {\n            this.userMediaStreams.push(stream);\n        }\n\n        this.emit(MediaHandlerEvent.LocalStreamsChanged);\n\n        return stream;\n    }\n\n    /**\n     * Stops all tracks on the provided usermedia stream\n     */\n    public stopUserMediaStream(mediaStream: MediaStream): void {\n        logger.log(`MediaHandler stopUserMediaStream() stopping (streamId=${mediaStream.id})`);\n        for (const track of mediaStream.getTracks()) {\n            track.stop();\n        }\n\n        const index = this.userMediaStreams.indexOf(mediaStream);\n\n        if (index !== -1) {\n            logger.debug(\n                `MediaHandler stopUserMediaStream() splicing usermedia stream out stream array (streamId=${mediaStream.id})`,\n                mediaStream.id,\n            );\n            this.userMediaStreams.splice(index, 1);\n        }\n\n        this.emit(MediaHandlerEvent.LocalStreamsChanged);\n\n        if (this.localUserMediaStream === mediaStream) {\n            // if we have this stream cahced, remove it, because we've stopped it\n            this.localUserMediaStream = undefined;\n        } else {\n            // If it's not the same stream. remove any tracks from the cached stream that\n            // we have just stopped, and if we do stop any, call the same method on the\n            // cached stream too in order to stop all its tracks (in case they are different)\n            // and un-cache it.\n            for (const track of mediaStream.getTracks()) {\n                if (this.localUserMediaStream?.getTrackById(track.id)) {\n                    this.stopUserMediaStream(this.localUserMediaStream);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @param opts - screensharing stream options\n     * @param reusable - is allowed to be reused by the MediaHandler\n     * @returns based on passed parameters\n     */\n    public async getScreensharingStream(opts: IScreensharingOpts = {}, reusable = true): Promise<MediaStream> {\n        let stream: MediaStream;\n\n        if (this.screensharingStreams.length === 0) {\n            const screenshareConstraints = this.getScreenshareContraints(opts);\n\n            if (opts.desktopCapturerSourceId) {\n                // We are using Electron\n                logger.debug(\n                    `MediaHandler getScreensharingStream() calling getUserMedia() (opts=${JSON.stringify(opts)})`,\n                );\n                stream = await navigator.mediaDevices.getUserMedia(screenshareConstraints);\n            } else {\n                // We are not using Electron\n                logger.debug(\n                    `MediaHandler getScreensharingStream() calling getDisplayMedia() (opts=${JSON.stringify(opts)})`,\n                );\n                stream = await navigator.mediaDevices.getDisplayMedia(screenshareConstraints);\n            }\n        } else {\n            const matchingStream = this.screensharingStreams[this.screensharingStreams.length - 1];\n            logger.log(`MediaHandler getScreensharingStream() cloning (streamId=${matchingStream.id})`);\n            stream = matchingStream.clone();\n        }\n\n        if (reusable) {\n            this.screensharingStreams.push(stream);\n        }\n\n        this.emit(MediaHandlerEvent.LocalStreamsChanged);\n\n        return stream;\n    }\n\n    /**\n     * Stops all tracks on the provided screensharing stream\n     */\n    public stopScreensharingStream(mediaStream: MediaStream): void {\n        logger.debug(`MediaHandler stopScreensharingStream() stopping stream (streamId=${mediaStream.id})`);\n        for (const track of mediaStream.getTracks()) {\n            track.stop();\n        }\n\n        const index = this.screensharingStreams.indexOf(mediaStream);\n\n        if (index !== -1) {\n            logger.debug(`MediaHandler stopScreensharingStream() splicing stream out (streamId=${mediaStream.id})`);\n            this.screensharingStreams.splice(index, 1);\n        }\n\n        this.emit(MediaHandlerEvent.LocalStreamsChanged);\n    }\n\n    /**\n     * Stops all local media tracks\n     */\n    public stopAllStreams(): void {\n        for (const stream of this.userMediaStreams) {\n            logger.log(`MediaHandler stopAllStreams() stopping (streamId=${stream.id})`);\n            for (const track of stream.getTracks()) {\n                track.stop();\n            }\n        }\n\n        for (const stream of this.screensharingStreams) {\n            for (const track of stream.getTracks()) {\n                track.stop();\n            }\n        }\n\n        this.userMediaStreams = [];\n        this.screensharingStreams = [];\n        this.localUserMediaStream = undefined;\n\n        this.emit(MediaHandlerEvent.LocalStreamsChanged);\n    }\n\n    private getUserMediaContraints(audio: boolean, video: boolean, exactDeviceId?: boolean): MediaStreamConstraints {\n        const isWebkit = !!navigator.webkitGetUserMedia;\n        const deviceIdKey = exactDeviceId ? \"exact\" : \"ideal\";\n\n        const audioConstraints: MediaTrackConstraints = {};\n        if (this.audioInput) {\n            audioConstraints.deviceId = { [deviceIdKey]: this.audioInput };\n        }\n        if (this.audioSettings) {\n            audioConstraints.autoGainControl = { ideal: this.audioSettings.autoGainControl };\n            audioConstraints.echoCancellation = { ideal: this.audioSettings.echoCancellation };\n            audioConstraints.noiseSuppression = { ideal: this.audioSettings.noiseSuppression };\n        }\n\n        const videoConstraints: MediaTrackConstraints = {\n            /* We want 640x360.  Chrome will give it only if we ask exactly,\n               FF refuses entirely if we ask exactly, so have to ask for ideal\n               instead\n               XXX: Is this still true?\n             */\n            width: isWebkit ? { exact: 640 } : { ideal: 640 },\n            height: isWebkit ? { exact: 360 } : { ideal: 360 },\n        };\n        if (this.videoInput) {\n            videoConstraints.deviceId = { [deviceIdKey]: this.videoInput };\n        }\n\n        return {\n            audio: audio ? audioConstraints : false,\n            video: video ? videoConstraints : false,\n        };\n    }\n\n    private getScreenshareContraints(opts: IScreensharingOpts): MediaStreamConstraints {\n        const { desktopCapturerSourceId, audio } = opts;\n        if (desktopCapturerSourceId) {\n            return {\n                audio: audio ?? false,\n                video: {\n                    mandatory: {\n                        chromeMediaSource: \"desktop\",\n                        chromeMediaSourceId: desktopCapturerSourceId,\n                    },\n                },\n            };\n        } else {\n            return {\n                audio: audio ?? false,\n                video: true,\n            };\n        }\n    }\n}\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { type ConnectionStatsBandwidth, type ConnectionStatsBitrate, type PacketLoss } from \"./connectionStats.ts\";\nimport { type TransportStats } from \"./transportStats.ts\";\nimport { type Resolution } from \"./media/mediaTrackStats.ts\";\n\nexport enum StatsReport {\n    CONNECTION_STATS = \"StatsReport.connection_stats\",\n    CALL_FEED_REPORT = \"StatsReport.call_feed_report\",\n    BYTE_SENT_STATS = \"StatsReport.byte_sent_stats\",\n    SUMMARY_STATS = \"StatsReport.summary_stats\",\n}\n\n/// ByteSentStatsReport ################################################################################################\nexport interface ByteSentStatsReport extends Map<TrackID, ByteSend> {\n    callId?: string;\n    opponentMemberId?: string;\n    // is a map: `local trackID` => byte send\n}\n\nexport type TrackID = string;\nexport type ByteSend = number;\n\n/// ConnectionStatsReport ##############################################################################################\nexport interface ConnectionStatsReport {\n    callId?: string;\n    opponentMemberId?: string;\n    bandwidth: ConnectionStatsBandwidth;\n    bitrate: ConnectionStatsBitrate;\n    packetLoss: PacketLoss;\n    audioConcealment: Map<TrackID, AudioConcealment>;\n    totalAudioConcealment: AudioConcealment;\n    resolution: ResolutionMap;\n    framerate: FramerateMap;\n    codec: CodecMap;\n    jitter: Map<TrackID, number>;\n    transport: TransportStats[];\n}\n\nexport interface AudioConcealment {\n    concealedAudio: number;\n    totalAudioDuration: number;\n}\n\nexport interface ResolutionMap {\n    local: Map<TrackID, Resolution>;\n    remote: Map<TrackID, Resolution>;\n}\n\nexport interface FramerateMap {\n    local: Map<TrackID, number>;\n    remote: Map<TrackID, number>;\n}\n\nexport interface CodecMap {\n    local: Map<TrackID, string>;\n    remote: Map<TrackID, string>;\n}\n\n/// SummaryStatsReport #################################################################################################\nexport interface SummaryStatsReport {\n    /**\n     * Aggregated the information for percentage of received media\n     *\n     * This measure whether the current user receive data from a call participants.\n     * As soon as a participant sends at least a byte media to this user, this counts as one measurement unit.\n     * The units of measure divided by the total number of participants is a value between 0 and 1.\n     */\n    percentageReceivedMedia: number;\n    percentageReceivedAudioMedia: number;\n    percentageReceivedVideoMedia: number;\n    maxJitter: number;\n    maxPacketLoss: number;\n    percentageConcealedAudio: number;\n    peerConnections: number;\n    opponentUsersInCall?: number;\n    opponentDevicesInCall?: number;\n    diffDevicesToPeerConnections?: number;\n    ratioPeerConnectionToDevices?: number;\n    // Todo: Decide if we want an index (or a timestamp) of this report in relation to the group call, to help differenciate when issues occur and ignore/track initial connection delays.\n}\n\n/// CallFeedReport #####################################################################################################\nexport interface CallFeedReport {\n    callId: string;\n    opponentMemberId: string;\n    transceiver: TransceiverStats[];\n    callFeeds: CallFeedStats[];\n}\n\nexport interface CallFeedStats {\n    stream: string;\n    type: \"remote\" | \"local\";\n    audio: TrackStats | null;\n    video: TrackStats | null;\n    purpose: string;\n    prefix: string;\n    isVideoMuted: boolean;\n    isAudioMuted: boolean;\n}\n\nexport interface TransceiverStats {\n    readonly mid: string;\n    readonly sender: TrackStats | null;\n    readonly receiver: TrackStats | null;\n    readonly direction: string;\n    readonly currentDirection: string;\n}\n\nexport interface TrackStats {\n    readonly id: string;\n    readonly kind: \"audio\" | \"video\";\n    readonly settingDeviceId: string;\n    readonly constrainDeviceId: string;\n    readonly muted: boolean;\n    readonly enabled: boolean;\n    readonly readyState: \"ended\" | \"live\";\n    readonly label: string;\n}\n","const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n\t' A network error occurred.', // Bun (WebKit)\n\t'Network connection lost', // Cloudflare Workers (fetch)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\tconst {message, stack} = error;\n\n\t// Safari 17+ has generic message but no stack for network errors\n\tif (message === 'Load failed') {\n\t\treturn stack === undefined\n\t\t\t// Sentry adds its own stack trace to the fetch error, so also check for that\n\t\t\t|| '__sentry_captured__' in error;\n\t}\n\n\t// Deno network errors start with specific text\n\tif (message.startsWith('error sending request for url')) {\n\t\treturn true;\n\t}\n\n\t// Standard network error messages\n\treturn errorMessages.has(message);\n}\n","import isNetworkError from 'is-network-error';\n\nfunction validateRetries(retries) {\n\tif (typeof retries === 'number') {\n\t\tif (retries < 0) {\n\t\t\tthrow new TypeError('Expected `retries` to be a non-negative number.');\n\t\t}\n\n\t\tif (Number.isNaN(retries)) {\n\t\t\tthrow new TypeError('Expected `retries` to be a valid number or Infinity, got NaN.');\n\t\t}\n\t} else if (retries !== undefined) {\n\t\tthrow new TypeError('Expected `retries` to be a number or Infinity.');\n\t}\n}\n\nfunction validateNumberOption(name, value, {min = 0, allowInfinity = false} = {}) {\n\tif (value === undefined) {\n\t\treturn;\n\t}\n\n\tif (typeof value !== 'number' || Number.isNaN(value)) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be a number${allowInfinity ? ' or Infinity' : ''}.`);\n\t}\n\n\tif (!allowInfinity && !Number.isFinite(value)) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n\t}\n\n\tif (value < min) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n\t}\n}\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst createRetryContext = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\treturn Object.freeze({\n\t\terror,\n\t\tattemptNumber,\n\t\tretriesLeft,\n\t});\n};\n\nfunction calculateDelay(attempt, options) {\n\tconst random = options.randomize ? (Math.random() + 1) : 1;\n\n\tlet timeout = Math.round(random * Math.max(options.minTimeout, 1) * (options.factor ** (attempt - 1)));\n\ttimeout = Math.min(timeout, options.maxTimeout);\n\n\treturn timeout;\n}\n\nasync function onAttemptFailure(error, attemptNumber, options, startTime, maxRetryTime) {\n\tlet normalizedError = error;\n\n\tif (!(normalizedError instanceof Error)) {\n\t\tnormalizedError = new TypeError(`Non-error was thrown: \"${normalizedError}\". You should only throw errors.`);\n\t}\n\n\tif (normalizedError instanceof AbortError) {\n\t\tthrow normalizedError.originalError;\n\t}\n\n\tif (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {\n\t\tthrow normalizedError;\n\t}\n\n\tconst context = createRetryContext(normalizedError, attemptNumber, options);\n\n\t// Always call onFailedAttempt\n\tawait options.onFailedAttempt(context);\n\n\tconst currentTime = Date.now();\n\tif (\n\t\tcurrentTime - startTime >= maxRetryTime\n\t\t|| attemptNumber >= options.retries + 1\n\t\t|| !(await options.shouldRetry(context))\n\t) {\n\t\tthrow normalizedError; // Do not retry, throw the original error\n\t}\n\n\t// Calculate delay before next attempt\n\tconst delayTime = calculateDelay(attemptNumber, options);\n\n\t// Ensure that delay does not exceed maxRetryTime\n\tconst timeLeft = maxRetryTime - (currentTime - startTime);\n\tif (timeLeft <= 0) {\n\t\tthrow normalizedError; // Max retry time exceeded\n\t}\n\n\tconst finalDelay = Math.min(delayTime, timeLeft);\n\n\t// Introduce delay\n\tif (finalDelay > 0) {\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst onAbort = () => {\n\t\t\t\tclearTimeout(timeoutToken);\n\t\t\t\toptions.signal?.removeEventListener('abort', onAbort);\n\t\t\t\treject(options.signal.reason);\n\t\t\t};\n\n\t\t\tconst timeoutToken = setTimeout(() => {\n\t\t\t\toptions.signal?.removeEventListener('abort', onAbort);\n\t\t\t\tresolve();\n\t\t\t}, finalDelay);\n\n\t\t\tif (options.unref) {\n\t\t\t\ttimeoutToken.unref?.();\n\t\t\t}\n\n\t\t\toptions.signal?.addEventListener('abort', onAbort, {once: true});\n\t\t});\n\t}\n\n\toptions.signal?.throwIfAborted();\n}\n\nexport default async function pRetry(input, options = {}) {\n\toptions = {...options};\n\n\tvalidateRetries(options.retries);\n\n\tif (Object.hasOwn(options, 'forever')) {\n\t\tthrow new Error('The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.');\n\t}\n\n\toptions.retries ??= 10;\n\toptions.factor ??= 2;\n\toptions.minTimeout ??= 1000;\n\toptions.maxTimeout ??= Number.POSITIVE_INFINITY;\n\toptions.randomize ??= false;\n\toptions.onFailedAttempt ??= () => {};\n\toptions.shouldRetry ??= () => true;\n\n\t// Validate numeric options and normalize edge cases\n\tvalidateNumberOption('factor', options.factor, {min: 0, allowInfinity: false});\n\tvalidateNumberOption('minTimeout', options.minTimeout, {min: 0, allowInfinity: false});\n\tvalidateNumberOption('maxTimeout', options.maxTimeout, {min: 0, allowInfinity: true});\n\tconst resolvedMaxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n\tvalidateNumberOption('maxRetryTime', resolvedMaxRetryTime, {min: 0, allowInfinity: true});\n\n\t// Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n\tif (!(options.factor > 0)) {\n\t\toptions.factor = 1;\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tlet attemptNumber = 0;\n\tconst startTime = Date.now();\n\n\t// Use validated local value\n\tconst maxRetryTime = resolvedMaxRetryTime;\n\n\twhile (attemptNumber < options.retries + 1) {\n\t\tattemptNumber++;\n\n\t\ttry {\n\t\t\toptions.signal?.throwIfAborted();\n\n\t\t\tconst result = await input(attemptNumber);\n\n\t\t\toptions.signal?.throwIfAborted();\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tawait onAttemptFailure(error, attemptNumber, options, startTime, maxRetryTime);\n\t\t}\n\t}\n\n\t// Should not reach here, but in case it does, throw an error\n\tthrow new Error('Retry attempts exhausted without throwing an error.');\n}\n\nexport function makeRetriable(function_, options) {\n\treturn function (...arguments_) {\n\t\treturn pRetry(() => function_.apply(this, arguments_), options);\n\t};\n}\n","'use strict';\n\n\nvar data = require('./data.json');\n\nfunction escapeRegexp(str) {\n  return str.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n}\n\nvar REPLACE_RE = RegExp(Object.keys(data).map(escapeRegexp).join('|'), 'g');\n\nfunction replace_fn(match) {\n  return data[match];\n}\n\nfunction unhomoglyph(str) {\n  return str.replace(REPLACE_RE, replace_fn);\n}\n\nmodule.exports = unhomoglyph;\n"],"names":["_defineProperty","e","r","t","Object","defineProperty","value","enumerable","configurable","writable","toPrimitive","Symbol","i","call","TypeError","String","Number","toPropertyKey","_typeof","o","iterator","constructor","prototype","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","_loggersByName","defaultLogger","bindMethod","obj","methodName","method","bind","Function","apply","arguments","traceForIE","console","log","trace","realMethod","undefined","replaceLoggingMethods","level","this","getLevel","length","methodFactory","name","debug","levels","SILENT","enableLoggingWhenConsoleArrives","defaultMethodFactory","_level","_loggerName","Logger","factory","inheritedLevel","defaultLevel","userLevel","self","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","cookieName","location","indexOf","exec","slice","clearPersistedLevel","removeItem","normalizeLevel","input","setLevel","persist","setDefaultLevel","resetLevel","enableAll","TRACE","disableAll","rebuild","childName","initialLevel","getLogger","logger","_log","noConflict","getLoggers","PushRuleActionName","TweakName","ConditionKind","PushRuleKind","RuleId","M_BEACON_INFO","UnstableValue","M_BEACON","EventType","RelationType","MsgType","RoomCreateTypeField","RoomType","ToDeviceMessageId","UNSTABLE_MSC3088_PURPOSE","UNSTABLE_MSC3088_ENABLED","UNSTABLE_MSC3089_TREE_SUBTYPE","UNSTABLE_MSC3089_LEAF","UNSTABLE_MSC3089_BRANCH","UNSTABLE_MSC2716_MARKER","MSC3912_RELATION_BASED_REDACTIONS_PROP","UNSTABLE_ELEMENT_FUNCTIONAL_USERS","EVENT_VISIBILITY_CHANGE_TYPE","PUSHER_ENABLED","LOCAL_NOTIFICATION_SETTINGS_PREFIX","UNSIGNED_THREAD_ID_FIELD","UNSIGNED_MEMBERSHIP_FIELD","NamespacedValue","M_ASSET","M_TIMESTAMP","M_LOCATION","Preset","JoinRule","GuestAccess","HistoryVisibility","M_POLL_RESPONSE","M_POLL_END","ReceiptType","MAIN_ROOM_TIMELINE","isSendDelayedEventRequestOpts","opts","parent_delay_id","delay","UpdateDelayedEventAction","SearchOrderBy","UNREAD_THREAD_NOTIFICATIONS","ServerControlledNamespacedValue","M_TOPIC","stable","unstable","Error","altName","names","push","matches","val","findIn","includedIn","arr","included","includes","args","setPreferUnstable","preferUnstable","super","AutoDiscoveryAction","AutoDiscoveryError","AutoDiscovery","fromDiscoveryConfig","wellknown","_hsVersions$raw","clientConfig","state","FAIL_ERROR","error","ERROR_INVALID","base_url","PROMPT","FAIL_PROMPT","Promise","resolve","ERROR_INVALID_HS_BASE_URL","hsUrl","sanitizeWellKnownUrl","hsVersions","fetchWellKnownObject","Array","isArray","raw","ERROR_INVALID_HOMESERVER","hsVersionSet","Set","supportedVersionFound","version","SUPPORTED_MATRIX_VERSIONS","has","ERROR_UNSUPPORTED_HOMESERVER_SPEC_VERSION","SUCCESS","isUrl","failingClientConfig","ERROR_INVALID_IS","ERROR_INVALID_IS_BASE_URL","isResponse","action","ERROR_INVALID_IDENTITY_SERVER","toString","keys","forEach","k","notProps","prop","findClientConfig","domain","domainWithProtocol","reason","IGNORE","getRawClientConfig","_response$raw","response","url","_parsed","parsed","URL","hostname","protocol","port","path","pathname","saferUrl","endsWith","substring","fetch","resource","options","fetchFn","globalThis","setFetchFn","Method","Get","signal","timeoutSignal","status","ERROR_MISSING_WELLKNOWN","err","message","json","ERROR_INVALID_JSON","Invalid","GenericFailure","InvalidHsBaseUrl","InvalidHomeserver","InvalidIsBaseUrl","InvalidIdentityServer","InvalidIs","MissingWellknown","InvalidJson","UnsupportedHomeserverSpecVersion","TURN_CHECK_INTERVAL","PendingEventOrdering","UNSTABLE_MSC4140_DELAYED_EVENTS","UNSTABLE_MSC4354_STICKY_EVENTS","EVENT_ID_PREFIX","ClientEvent","SSO_ACTION_PARAM","MatrixClient","TypedEventEmitter","_opts$logger","_opts$usingExternalCr","_opts$disableVoip","_opts$enableEncrypted","_opts$cryptoCallbacks","TypedReEmitter","Map","PushProcessor","MediaHandler","isInitialSyncComplete","supportsMatrixCall","callEventHandler","start","groupCallEventHandler","off","Sync","startCallEventHandler","matrixRTC","startMatrixRTC","_this$getRooms","unreadRooms","getRooms","filter","room","getUnreadNotificationCount","NotificationCountType","Total","currentUserId","getSafeUserId","fixupNotifications","fixupRoomNotifications","baseUrl","utils","idBaseUrl","identityServer","usingExternalCrypto","store","StubStore","deviceId","sessionId","secureRandomString","userId","credentials","http","MatrixHttpApi","accessToken","refreshToken","tokenRefreshFunction","prefix","ClientPrefix","V3","onlyData","extraParams","queryParams","localTimeoutMs","useAuthorizationHeader","pickleKey","legacyPickleKey","useLivekitForGroupCalls","Boolean","scheduler","setProcessFunction","async","getRoom","eventToSend","getRoomId","EventStatus","SENDING","updatePendingEventStatus","res","sendEventHttpRequest","updatePendingEvent","SENT","event_id","disableVoip","CallEventHandler","GroupCallEventHandler","canSupportVoip","on","MatrixRTCSessionManager","serverCapabilitiesService","ServerCapabilities","timelineSupport","legacyCryptoStore","cryptoStore","verificationMethods","cryptoCallbacks","enableEncryptedStateEvents","forceTURN","iceCandidatePoolSize","supportsCallTransfer","fallbackICEServerAllowed","isVoipWithNoMediaAllowed","useE2eForGroupCall","livekitServiceURL","roomNameGenerator","toDeviceMessageQueue","ToDeviceMessageQueue","MatrixEventEvent","Decrypted","event","cli","_actions$tweaks","ourUserId","getUserId","eventId","getId","findEventById","info","roomId","isThreadEvent","threadRootId","isThreadRoot","hasReadEvent","thread","getThread","hasUserReadEvent","actions","getPushActionsForEvent","tweaks","highlight","newCount","getUnreadCountForEventContext","Highlight","setThreadUnreadNotificationCount","setUnreadNotificationCount","notify","fixNotificationCountOnDecryption","ignoredInvites","IgnoredInvites","_secretStorage","ServerSideSecretStorageImpl","setMaxListeners","newStore","_store","setUserCreator","User","createUser","startClient","clientRunning","storeUser","supportsVoip","checkTurnServersIntervalID","setInterval","checkTurnServers","syncApi","stop","getVersions","threads","list","fwdPagination","doesServerSupportThread","Thread","setServerSideSupport","setServerSideListSupport","setServerSideFwdPaginationSupport","clientOpts","slidingSync","SlidingSyncSdk","buildSyncApiOptions","SyncApi","sync","catch","clientWellKnownPollPeriod","clientWellKnownIntervalID","fetchClientWellKnown","cryptoBackend","canResetEntireTimeline","canResetTimelineCallback","getChild","stopClient","_this$cryptoBackend","_this$syncApi","_this$peekSync","_this$callEventHandle","_this$groupCallEventH","peekSync","stopPeeking","clearInterval","clearStores","promises","deleteAllData","indexedDB","dbname","_args$cryptoDatabaseP","cryptoDatabasePrefix","RUST_SDK_STORE_PREFIX","_args$cryptoDatabaseP2","prom","reject","req","deleteDatabase","onsuccess","_","onerror","warn","onblocked","deleteRustSdkStore","all","then","_this$credentials$use","_this$credentials","getDomain","_this$credentials2","replace","getUserIdLocalpart","_this$credentials$use2","_this$credentials3","split","getDeviceId","getSessionId","getMediaHandler","mediaHandler","setForceTURN","force","setSupportsCallTransfer","support","getUseE2eForGroupCall","createCall","createNewMatrixCall","createGroupCall","type","isPtt","intent","dataChannelsEnabled","dataChannelOptions","getGroupCallForRoom","GroupCall","create","getLivekitServiceURL","setLivekitServiceURL","newURL","waitUntilRoomReadyForGroupCalls","groupCalls","get","getSyncState","_this$syncApi$getSync","_this$syncApi2","getSyncStateData","SyncState","Prepared","Syncing","isGuest","isGuestAccount","setGuest","guest","getScheduler","retryImmediately","_this$syncApi$retryIm","_this$syncApi3","sendQueue","getNotifTimelineSet","notifTimelineSet","setNotifTimelineSet","set","getCapabilities","caps","getCachedCapabilities","fetchCapabilities","initRustCrypto","_args$cryptoDatabaseP3","_this$legacyPickleKey","RustCrypto","rustCrypto","secretStorage","storePrefix","useIndexedDB","storeKey","storePassphrase","storagePassword","legacyMigrationProgressListener","progress","total","emit","CryptoEvent","LegacyCryptoStoreMigrationProgress","setSupportedVerificationMethods","RoomMemberEvent","Membership","onRoomMembership","Event","onLiveEventFromSync","reEmitter","reEmit","VerificationRequestReceived","UserTrustStatusChanged","KeyBackupStatus","KeyBackupSessionsRemaining","KeyBackupFailed","KeyBackupDecryptionKeyCached","KeysChanged","DevicesUpdated","WillUpdateDevices","DehydratedDeviceCreated","DehydratedDeviceUploaded","RehydrationStarted","RehydrationProgress","RehydrationCompleted","RehydrationError","DehydrationKeyCached","DehydratedDeviceRotationError","getCrypto","isRoomEncrypted","hasEncryptionStateEvent","isKeyBackupKeyStored","isStored","makeKeyBackupPath","$roomId","$sessionId","queryData","deleteKeysFromBackup","authedRequest","Delete","getMediaConfig","useAuthenticatedMedia","V1","MediaPrefix","getVisibleRooms","msc3946ProcessDynamicPredecessor","allRooms","visibleRooms","predecessors","findPredecessorRooms","predecessor","delete","from","getUser","getUsers","setAccountData","eventType","content","retryNetworkOperation","setAccountDataRaw","existingData","getAccountData","deepCompare","updatedResolvers","withResolvers","accountDataListener","getType","addListener","AccountData","result","promise","removeListener","$userId","$type","Put","getAccountDataFromServer","getContent","_data","data","errcode","deleteAccountData","msc3391DeleteAccountDataServerSupport","canSupport","Feature","AccountDataDeletion","ServerSupport","Unsupported","Unstable","getIgnoredUsers","IgnoredUserList","setIgnoredUsers","userIds","ignored_users","u","isUserIgnored","joinRoom","roomIdOrAlias","_roomMember$events$me","_roomMember$events$me2","roomMember","getMember","preJoinMembership","membership","inviter","KnownMembership","Invite","events","member","getSender","JSON","stringify","Join","signPromise","inviteSignUrl","searchParams","requestOtherUrl","Post","viaServers","via","server_name","signedInviteObj","third_party_signed","$roomid","room_id","acceptSharedHistory","maybeAcceptKeyBundle","markRoomAsPendingKeyBundle","resolvedRoom","hasMembershipState","createRoom","knockRoom","Knock","$roomIdOrAlias","body","resendEvent","encryptAndSendEvent","cancelPendingEvent","QUEUED","NOT_SENT","ENCRYPTING","eventsBeingEncrypted","removeEventFromQueue","CANCELLED","setRoomName","sendStateEvent","RoomName","setRoomTopic","topic","htmlTopic","ContentHelpers","RoomTopic","getRoomTags","setRoomTag","tagName","metadata","$tag","deleteRoomTag","setRoomAccountData","setPowerLevel","powerLevel","_content","_this$getRoom","currentState","getStateEvents","RoomPowerLevels","getStateEvent","MatrixError","users","user","unstable_createLiveBeacon","beaconInfoContent","unstable_setLiveBeacon","sendEvent","threadIdOrEventType","eventTypeOrContent","contentOrTxnId","txnIdOrVoid","threadId","txnId","startsWith","addThreadRelationIfNeeded","sendCompleteEvent","eventObject","_content$mRelates_to","rel_type","_content$mRelates_to2","_this$getRoom2","isReply","_objectSpread","THREAD_RELATION_TYPE","is_falling_back","_thread$lastReply$get","_thread$lastReply","lastReply","ev","isRelation","delayOpts","queryDict","makeTxnId","localEvent","MatrixEvent","assign","user_id","sender","origin_server_ts","Date","getTime","setThread","Replaced","VisibilityChange","BeforeRedaction","targetId","getAssociatedId","target","getPendingEvents","find","once","LocalEventIdReplaced","updateAssociatedId","setTxnId","setStatus","addPendingEvent","delayOptsOrQuery","queryOpts","cancelled","add","encryptEventIfNeeded","queueEvent","getQueueForEvent","shouldEncryptEventForRoom","encryptEvent","_this$cryptoBackend2","isEncrypted","Reaction","isRedaction","isEncryptionEnabledInRoom","getEncryptedIfNeededEventType","_this$getRoom3","RoomMessageEncrypted","newStatus","queryOrDelayOpts","getTxnId","pathParams","$eventType","getWireType","$stateKey","getStateKey","$txnId","isState","pathTemplate","redacts","$redactsEventId","getWireContent","getUnstableDelayQueryOpts","redactEvent","_eventId","_opts","_opts2","with_rel_types","RelationBasedRedactions","Stable","RoomRedaction","sendMessage","RoomMessage","sendContent","sendTextMessage","_threadId","sendNotice","_threadId2","sendEmoteMessage","_threadId3","sendImageMessage","text","_threadId4","msgtype","Image","sendStickerMessage","_threadId5","Sticker","sendHtmlMessage","htmlBody","_threadId6","sendHtmlNotice","_threadId7","sendHtmlEmote","_threadId8","_unstable_sendDelayedEvent","doesServerSupportUnstableFeature","UnsupportedDelayedEventsEndpointError","_unstable_sendStickyDelayedEvent","stickDuration","UnsupportedStickyEventsEndpointError","_unstable_sendDelayedStateEvent","stateKey","_unstable_sendStickyEvent","_unstable_getDelayedEvents","delayId","fromToken","delay_id","_unstable_updateDelayedEvent","requestOptions","updateScheduledDelayedEventWithActionInBody","_unstable_cancelScheduledDelayedEvent","updateScheduledDelayedEvent","Cancel","_unstable_restartScheduledDelayedEvent","Restart","_unstable_sendScheduledDelayedEvent","Send","$delayId","$action","request","sendReceipt","receiptType","unthreaded","$receiptType","$eventId","fullBody","supportsThreads","thread_id","threadIdForReceipt","addLocalEchoReceipt","sendReadReceipt","Read","hasPendingEvent","setRoomReadMarkers","rmEventId","rrEvent","rpEvent","rrEventId","rpEventId","ReadPrivate","setRoomReadMarkersHttpRequest","sendRtcDecline","notificationEventId","RTCDecline","Reference","getUrlPreview","ts","Math","floor","hash","key","urlPreviewCache","resp","priority","sendTyping","isTyping","timeoutMs","typing","timeout","getRoomUpgradeHistory","verifyLinks","currentRoom","findSuccessorRooms","_room$findPredecessor","ret","seenRoomIDs","predecessorRoomId","findPredecessor","_room$findPredecessor2","predecessorRoom","tombstone","RoomTombstone","splice","tombstoneEvent","successorRoom","_successorRoom$findPr","map","ref","size","invite","_this$cryptoBackend3","shareEncryptedHistory","shareRoomHistoryWithUser","membershipChange","inviteByEmail","email","inviteByThreePid","medium","address","_this$identityServer","identityServerUrl","getIdentityServerUrl","params","id_server","getAccessToken","identityAccessToken","leave","Leave","leaveRoomChain","includeFuture","upgradeHistory","eligibleToLeave","populationResults","doLeave","ban","Ban","forget","deleteRoom","$room_id","removeRoom","DeleteRoom","unban","kick","$membership","forceRecalculate","getPushActions","rule","pushProcessor","actionsAndRuleForEvent","setPushDetails","getPushDetailsForEvent","getPushDetails","setProfileInfo","$info","setDisplayName","displayname","displayName","UserEvent","DisplayName","presence","setAvatarUrl","avatar_url","avatarUrl","AvatarUrl","mxcUrlToHttp","mxcUrl","width","height","resizeMethod","allowDirectLinks","allowRedirects","useAuthentication","getHttpUriForMxc","setSyncPresence","_this$syncApi4","setPresence","getPresence","scrollback","limit","timeToWaitMs","ongoingScrollbacks","errorTs","timeWaitedMs","now","max","oldState","paginationToken","numAdded","sleep","createMessagesRequest","Direction","Backward","_res$end","_res$end2","matrixEvents","chunk","getEventMapper","stateEvents","setUnknownStateEvents","timelineEvents","threadedEvents","unknownRelations","partitionThreadedEvents","processAggregatedTimelineEvents","addEventsToTimeline","getLiveTimeline","processThreadEvents","relations","aggregateChildEvent","end","storeEvents","eventMapperFor","getEventContext","_this$clientOpts","lazyLoadMembers","Filter","LAZY_LOADING_MESSAGES_FILTER","_res$events_after","_res$events_before","_res$state","events_after","events_before","getEventTimeline","timelineSet","_ref","_timelineSet$getTimel","_timelineSet$room$fin","_await$this$getThread","getTimelineForEvent","getThreadTimeline","mapper","reverse","timeline","_res$end3","getState","EventTimeline","BACKWARDS","addTimeline","initialiseState","FORWARDS","findThreadForEvent","liveTimeline","canContain","recurse","RelationsRecursion","hasServerSideSupport","hasServerSideFwdPaginationSupport","_resOlder$next_batch","_resNewer$next_batch","_timelineSet$getTimel2","resOlder","fetchRelations","id","dir","resNewer","Forward","getRelationsThreadFilter","_timelineSet$thread","processEvent","next_batch","originalEvent","fetchRoomEvent","setPaginationToken","_resOlder$next_batch2","eventsNewer","nextBatch","_timelineSet$thread2","getLatestTimeline","threadListType","_res$chunk","createThreadListMessagesRequest","getFilter","_res$chunk2","_this$clientOpts2","_res$chunk3","messagesPath","timelineFilter","_this$clientOpts3","_timelineFilter$getRo","getRoomTimelineFilterComponent","toJSON","ThreadFilterType","All","_this$clientOpts4","include","threadFilterTypeToFilter","_timelineFilter$getRo2","hasServerSideListSupport","FeatureSupport","_res$chunk4","prev_batch","paginateEventTimeline","eventTimeline","isNotifTimeline","getTimelineSet","backwards","token","getPaginationToken","pendingRequest","paginationRequests","_opts$limit","only","next_token","notifications","noUnsafeEventProps","notification","finally","roomState","processThreadRoots","_eventTimeline$getRoo","_eventTimeline$getRoo2","getEventReadUpTo","newToken","_thread$rootEvent","_eventTimeline$getRoo3","rootEvent","it","getServerAggregatedRelation","atEnd","resetNotifTimelineSet","resetLiveTimeline","peekInRoom","_this$peekSync2","peek","setGuestAccess","writePromise","RoomGuestAccess","guest_access","allowJoin","CanJoin","Forbidden","readPromise","allowRead","RoomHistoryVisibility","history_visibility","WorldReadable","requestRegisterEmailToken","clientSecret","sendAttempt","nextLink","requestTokenFromEndpoint","client_secret","send_attempt","next_link","requestRegisterMsisdnToken","phoneCountry","phoneNumber","country","phone_number","requestAdd3pidEmailToken","requestAdd3pidMsisdnToken","requestPasswordEmailToken","requestPasswordMsisdnToken","endpoint","postParams","getRoomPushRule","scope","_this$pushRules$scope","pushRules","rule_id","setRoomMutePushRule","mute","hasDontNotifyRule","roomPushRule","DontNotify","doneResolvers","deletePushRule","RoomSpecific","addPushRule","getPushRules","err2","searchMessageText","roomEvents","search_term","query","search","search_categories","room_events","searchRoomEvents","term","order_by","Recent","event_context","before_limit","after_limit","include_profile","searchResults","_query","results","highlights","processRoomEventsSearch","backPaginateRoomEventsSearch","searchOpts","abortSignal","_roomEvents$results$l","_roomEvents$results","count","hl","resultsLength","sr","SearchResult","fromJson","context","getEvent","getTimeline","setMetadata","syncLeftRooms","syncedLeftRooms","syncLeftRoomsPromise","createFilter","filter_id","storeFilter","filterId","allowCached","$filterId","getOrCreateFilter","filterName","getFilterIdByName","existingId","existingFilter","oldDef","getDefinition","newDef","setFilterIdByName","createdFilter","getOpenIdToken","turnServer","getTurnServers","turnServers","getTurnServersExpiry","turnServersExpiry","pollingTurnServers","credentialsGood","remainingTime","uris","ttl","servers","urls","username","credential","password","TurnServers","httpStatus","TurnServersError","setFallbackICEServerAllowed","allow","isFallbackICEServerAllowed","isSynapseAdministrator","admin","whoisSynapseUser","deactivateSynapseUser","_this$getDomain","clientWellKnownPromise","clientWellKnown","ClientWellKnown","getClientWellKnown","waitForClientWellKnown","storeClientOptions","primTypes","serializableOpts","entries","reduce","_unstable_getSharedRooms","sharedRoomsSupport","mutualRoomsSupport","queryMutualRoomsSupport","rooms","tokenQuery","joined","next_batch_token","_unstable_getRTCTransports","rtc_transports","serverVersionsPromise","serverVersions","buildFeatureSupportMap","isVersionSupported","versions","feature","unstableFeatures","doesServerForceEncryptionForPreset","presetName","versionsPresetName","threadUnstable","threadStable","listUnstable","listStable","fwdPaginationUnstable","fwdPaginationStable","determineFeatureSupport","None","hasLazyLoadMembersEnabled","_this$clientOpts5","setCanResetTimelineCallback","cb","getCanResetTimelineCallback","relationType","_result$next_batch","_result$prev_batch","fetchedEventType","eventResult","allEvents","concat","decryptEventIfNeeded","Replace","prevBatch","generateClientSecret","shouldAttemptDecryption","attemptDecryption","isBeingDecrypted","getDecryptionPromise","termsUrlForService","serviceType","SERVICE_TYPES","IS","getUrl","IdentityPrefix","V2","IM","getHomeserverUrl","stripProto","_this$idBaseUrl","_this$idBaseUrl2","setIdentityServerUrl","setIdBaseUrl","getRefreshToken","_this$http$opts$refre","setAccessToken","isLoggedIn","txnCtr","isUsernameAvailable","available","register","auth","bindThreepids","guestAccessToken","inhibitLogin","session","refresh_token","guest_access_token","inhibit_login","registerRequest","registerGuest","kind","performRefreshRequestWithPrefix","inhibitLogoutEmit","loginFlows","login","loginType","loginRequest","access_token","loginWithPassword","getCasLoginUrl","redirectUrl","getSsoLoginUrl","idpId","href","loginWithToken","logout","abort","deactivateAccount","erase","requestLoginToken","getFallbackAuthUrl","authSessionId","$loginType","_this$identityServer2","invitesNeedingToken","invite_3pid","id_access_token","Experimental","replaceParam","queryString","templatedUrl","$relationType","members","includeMembership","excludeMembership","atEventId","not_membership","at","upgradeRoom","newVersion","additionalCreators","new_version","additional_creators","state_key","encryptStateEventIfNeeded","getWireStateKey","isStateEncryptionEnabledInRoom","roomInitialSync","_limit$toString","FullyRead","getJoinedRooms","getJoinedRoomMembers","publicRooms","_ref2","server","since","_objectWithoutProperties","_excluded","createAlias","alias","$alias","deleteAlias","getLocalAliases","getRoomIdForAlias","getRoomDirectoryVisibility","setRoomDirectoryVisibility","visibility","searchUserDirectory","uploadContent","file","cancelUpload","upload","getCurrentUploads","getProfileInfo","doesServerSupportExtendedProfiles","getExtendedProfileRequestPrefix","getExtendedProfile","getExtendedProfileProperty","$key","setExtendedProfileProperty","deleteExtendedProfileProperty","patchExtendedProfile","profile","Patch","setExtendedProfile","getThreePids","addThreePidOnly","bindThreePid","unbindThreePid","deleteThreePid","setPassword","authDict","newPassword","logoutDevices","new_password","logout_devices","getDevices","getDevice","$device_id","setDeviceDetails","deleteDevice","deleteMultipleDevices","devices","getPushers","pushers","pusher","hasOwnProperty","setPusher","removePusher","pushKey","appId","pushkey","app_id","setLocalNotificationSettings","notificationSettings","rules","setPushRules","rewriteDefaultRules","updateCachedPushRuleKeys","ruleId","$kind","$ruleId","setPushRuleEnabled","enabled","setPushRuleActions","uploadKeysRequest","uploadKeySignatures","downloadKeysForUsers","device_keys","claimOneTimeKeys","keyAlgorithm","queries","safeSet","one_time_keys","getKeyChanges","oldToken","qps","to","uploadDeviceSigningKeys","registerWithIdentityServer","hsOpenIdToken","uri","requestEmailToken","idServerRequest","requestMsisdnToken","submitMsisdnToken","sid","msisdnToken","submitMsisdnTokenOtherUrl","getIdentityHashDetails","identityHashedLookup","addressPairs","hashes","localMapping","addr","p","toLowerCase","med","hashBuffer","sha256","hashed","encodeUnpaddedBase64Url","unhashed","foundAddresses","mxid","plainAddress","lookupThreePid","bulkLookupThreePids","v1results","mapping","originalQuery","threepids","getIdentityAccount","sendToDevice","contentMap","messages","targets","deviceMessages","encryptAndSendToDevice","payload","batch","encryptToDeviceMessages","queueToDevice","queueBatch","getThirdpartyProtocols","getThirdpartyLocation","$protocol","getThirdpartyUser","getTerms","agreeToTerms","termsUrls","headers","Authorization","user_accepts","reportEvent","score","reportRoom","getRoomHierarchy","maxDepth","suggestedOnly","suggested_only","max_depth","unstableCreateFileTree","preset","PrivateChat","power_level_content_override","DEFAULT_TREE_POWER_LEVELS_TEMPLATE","creation_content","Space","initial_state","RoomEncryption","algorithm","MSC3089TreeSpace","unstableGetFileTreeSpace","_purposeEvent$getCont","_createEvent$getConte","getMyMembership","createEvent","RoomCreate","purposeEvent","proxyBaseUrl","pos","clientTimeout","_this$clientOpts6","threadSupport","supportsIntentionalMentions","IntentionalMentions","getRoomSummary","paramOpts","toStartOfTimeline","processThreadedEvents","processBeaconEvents","processPollEvents","whoami","timestampToEvent","timestamp","getAuthMetadata","authMetadata","useStable","issuer","discoverAndValidateOIDCIssuerWellKnown","validateAuthMetadataAndKeys","fromEntries","v","inMainTimelineForReceipt","relationEventId","makeHtmlMessage","Text","format","formatted_body","makeHtmlNotice","Notice","makeHtmlEmote","Emote","makeTextMessage","makeNotice","makeEmoteMessage","makeTopicContent","renderings","isProvided","mimetype","parseBeaconInfoContent","_M_TIMESTAMP$findIn","description","live","asset","assetType","parseBeaconContent","_M_TIMESTAMP$findIn2","OLM_RECOVERY_KEY_PREFIX","encodeRecoveryKey","_base58key$match","buf","Uint8Array","parity","bs58","encode","match","join","DecryptionFailureCode","DeviceIsolationModeKind","AllDevicesIsolationMode","errorOnVerifiedUserProblems","UserVerificationStatus","crossSigningVerified","crossSigningVerifiedBefore","tofu","needsUserApproval","isVerified","isCrossSigningVerified","wasCrossSigningVerified","isTofu","DeviceVerificationStatus","_opts$signedByOwner","_opts$crossSigningVer","_opts$tofu","_opts$localVerified","_opts$trustCrossSigne","signedByOwner","localVerified","trustCrossSignedDevices","ImportRoomKeyStage","CrossSigningKey","EventShieldColour","EventShieldReason","VerificationRequestEvent","VerificationPhase","VerifierEvent","InvalidCryptoStoreState","InvalidCryptoStoreError","TooNew","ClientStoppedError","clientEndpoint","s","setProp","keyNesting","nestedKeys","currentObj","jsonObj","setDefinition","getFilterId","definition","roomFilterJson","roomFilterFields","not_rooms","roomFilter","FilterComponent","roomTimelineFilter","filterRoomTimeline","setTimelineLimit","setUnreadThreadNotifications","_this$definition","_this$definition2","setLazyLoadMembers","setIncludeLeaveRooms","includeLeave","lazy_load_members","FetchHttpApi","_opts$includeFilename","_opts$abortController","_opts$type","_opts$name","includeFilename","abortController","AbortController","contentType","fileName","loaded","uploadResolvers","XMLHttpRequest","xhr","timeoutFn","timeoutTimer","callbacks","onreadystatechange","readyState","DONE","DOMException","statusText","responseText","parseErrorResponse","parse","ConnectionError","onprogress","_opts$progressHandler","progressHandler","open","setRequestHeader","send","addEventListener","filename","removeElement","uploads","elem","getContentUri","base","IndexedDBStoreWorker","postMessage","command","_this$backend","_this$backend2","_this$backend3","_this$backend4","_this$backend5","_this$backend6","_this$backend7","_this$backend8","_this$backend9","_this$backend0","_this$backend1","_this$backend10","_this$backend11","_this$backend12","_this$backend13","_this$backend14","msg","backend","LocalIndexedDBStoreBackend","connect","onClose","isNewlyCreated","clearDatabase","getSavedSync","setSyncData","syncToDatabase","getUserPresenceEvents","getNextBatchToken","getOutOfBandMembers","clearOutOfBandMembers","setOutOfBandMembers","getClientOptions","saveToDeviceBatches","getOldestToDeviceBatch","removeToDeviceBatch","seq","loglevel","logLevel","loggerName","unshift","getPrefixedLogger","prefixLogger","childPrefix","childLogger","DEBUG","LogSpan","parent","DEFAULT_EXPIRE_DURATION","CallMembership","equal","a","b","membershipData","matrixEvent","rtcBackendIdentity","getTs","matrixEventData","computeRtcBackendIdentity","computeRtcIdentityRaw","device_id","memberId","encodeUnpaddedBase64","membershipDataFromMatrixEvent","sessionErrors","rtcErrors","checkSessionsMembershipData","errors","_data$focus_active","call_id","application","focus_active","foci_preferred","every","f","created_ts","checkRtcMembershipData","referenceUserId","_data$sticky_key","slot_id","MXID_PATTERN","sticky_key","msc4354_sticky_key","rel","details","replaceAll","slotId","slotDescriptionToId","callIntent","_this$logger","slotDescription","slotIdToDescription","applicationData","membershipID","_data$membershipID","createdTs","_data$created_ts","getAbsoluteExpiry","_data$expires","expires","getMsUntilExpiry","isExpired","getTransport","oldestMembership","focus_selection","getFocusActive","transports","MembershipManagerEvent","MatrixRTCSessionEvent","DEFAULT_SESSION_MEMBERSHIPS_FOR_SLOT_OPTS","listenForStickyEvents","listenForMemberStateEvents","MatrixRTCSession","membershipStatus","_this$membershipManag","membershipManager","probablyLeft","_this$membershipManag2","_this$membershipManag3","callId","_this$slotDescription","sessionMembershipsForSlot","rootLogger","callMemberEvents","_unstable_getStickyEvents","RTCMembership","callMemberStateEvents","GroupCallMemberPrefix","callMemberStateEvent","some","stickyEvent","collectMembersEvents","callMemberships","memberEvent","quickFilterNonRelevantContents","isValidMembership","computeBackendIdentityAndVerifyMemberEvents","sort","m","sessionForSlot","client","roomSubset","calculateMembershipsOpts","counters","roomEventEncryptionKeysSent","roomEventEncryptionKeysReceived","totals","roomEventEncryptionKeysReceivedTotalAge","ensureRecalculateSessionMembers","added","updated","removed","flatMap","current","previous","recalculateSessionMembers","_this$encryptionManag","oldMemberships","memberships","_this$membershipManag4","_this$membershipManag5","logDurationSync","MembershipsChanged","onRTCSessionMemberUpdate","ownMembership","_this$joinConfig","pendingNotificationToSend","joinConfig","notificationType","sendCallNotify","encryptionManager","onMembershipsUpdate","setExpiryTimer","RoomStateEvent","Members","onRoomMemberUpdate","RoomStickyEventsEvent","Update","onStickyEventUpdate","isJoined","_this$membershipManag6","_this$membershipManag7","_this$membershipManag8","expiryTimeout","clearTimeout","joinRTCSession","ownMembershipIdentity","fociPreferred","multiSfuFocus","_this$joinConfig2","transport","unstableSendStickyEvents","StickyEventMembershipManager","MembershipManager","ProbablyLeft","StatusChanged","DelayIdChanged","useExperimentalToDeviceTransport","statistics","ToDeviceKeyTransport","RTCEncryptionManager","keyBin","encryptionKeyIndex","EncryptionKeyChanged","RoomKeyTransport","EncryptionManager","MembershipManagerError","JoinStateChanged","joinRoomSession","leaveRoomSession","leavePromise","getFocusInUse","getOldestMembership","getActiveFocus","_this$getOldestMember","getConsensusCallIntent","_this$memberships$fin","getFirstCallIntent","updateCallIntent","_this$membershipManag9","_this$membershipManag0","reemitEncryptionKeys","_this$encryptionManag2","getEncryptionKeys","keyRing","keyInfo","keyIndex","soonestExpiry","thisExpiry","setTimeout","parentEventId","user_ids","RTCNotification","sendNotificationEvent","newResult","DidSendCallNotification","errorLegacy","errorNew","recalculateSessionMembersPromise","recalculateSessionMembersDirty","eventKeysCount","_membership$userId","MatrixRTCSessionManagerEvents","refreshRoom","unstableStickyExpiresAt","_this$client$getRooms","roomSessions","Room","onRoom","onEvent","Events","onRoomState","sess","values","clear","getActiveRoomSession","getRoomSession","isNewSession","wasActiveAndKnown","_onRTCSessionMemberUpdate","nowActive","SessionEnded","SessionStarted","Status","isMyMembership","BeaconEvent","isTimestampInDuration","startTimestamp","durationMs","getBeaconInfoIdentifier","Beacon","_latestLocationEvent","LocationUpdate","latestLocationState","setBeaconInfo","isLive","_isLive","identifier","beaconInfoId","beaconInfoOwner","beaconInfoEventType","beaconInfo","_beaconInfo","latestLocationEvent","update","beaconInfoEvent","clearLatestLocation","destroy","livenessWatchTimeout","Destroy","monitorLiveness","checkLiveness","expiryInMs","addLocations","beaconLocationEvents","_validLocationEvents$","sortEventsByLatestContentTimestamp","prevLiveness","LivenessChange","debuglog","DuplicateStrategy","EventTimelineSet","_this$room$relations","_this$room","_room$client","displayPendingEvents","pendingEvents","timelines","_eventIdToTimeline","RelationsContainer","getTimelines","setFilter","setLiveTimeline","eventIdToTimeline","replaceEventId","oldEventId","newEventId","existingTimeline","backPaginationToken","forwardPaginationToken","resetAllTimelines","oldTimeline","newTimeline","forkLive","fork","RoomEvent","TimelineReset","tl","getEvents","addToState","direction","inverseDirection","didUpdate","lastEventWasNew","addEventToTimeline","neighbour","getNeighbouringTimeline","existingIsLive","timelineIsLive","backwardsIsLive","forwardsIsLive","setNeighbouringTimeline","addLiveEvent","duplicateStrategy","fromCache","timelineWasEmpty","tlEvents","j","setEventMetadata","_this$thread","aggregateParentEvent","_this$thread2","eventDebugString","addEvent","liveEvent","Timeline","insertEventIntoTimeline","_this$thread3","_this$thread4","parentEvent","insertIndex","insertEvent","handleRemoteEcho","removeEvent","compareEventOrdering","eventId1","eventId2","timeline1","timeline2","idx1","idx2","idx","evId","difference","shouldLiveInRoom","shouldLiveInThread","eventShouldLiveIn","_this$room2","stateContext","eventTimelineSet","_eventTimelineSet$roo","_eventTimelineSet$roo2","startState","RoomState","endState","toISOString","_this$startState","_this$endState","setStateEvents","forkState","clone","getBaseIndex","baseIndex","startToken","endToken","prevTimeline","nextTimeline","_roomState","getUnfilteredTimelineSet","RoomMember","MESSAGE_VISIBLE","freeze","visible","MAX_STICKY_DURATION_MS","_this$sender","_this$target","affectsSelf","changed","newSender","getSentinelMember","newTarget","forwardLooking","SentinelUpdated","_this$getTs","internaliseString","_event$content","_event$content2","txn_id","age","getAge","localTimestamp","unstableStickyInfo","duration_ttl_ms","min","duration_ms","unstableExtensibleEvent","_ExtensibleEvents$par","_hasCachedExtEv","_cachedExtEv","ExtensibleEvents","getEffectiveEvent","invalidateExtensibleEvent","clearEvent","getDate","getDetails","_this$getDate","getOriginalContent","_this$event$content","_this$clearEvent$cont","_localRedactionEvent","_replacingEvent","_this$_replacingEvent","_this$getWireContent","relatesTo","unsigned","getUnsigned","replyEventId","_this$getWireContent$","_this$getWireContent2","getPrevContent","prev_content","getDirectionalContent","getLocalAge","getMembershipAtEvent","makeEncrypted","cryptoType","cryptoContent","senderCurve25519Key","claimedEd25519Key","decryptionPromise","isDecryptionFailure","_decryptionFailureReason","decryptionFailureReason","isRedacted","crypto","retryDecryption","decryptionLoop","getKeyRequestRecipients","decryptEvent","isRetry","setClearData","detailedError","DecryptionError","detailedString","setClearDataForDecryptionFailure","code","UNKNOWN_ERROR","decryptionResult","_decryptionResult$sen","_decryptionResult$cla","keyForwardedBy","getClearContent","getSenderKey","getKeysClaimed","ed25519","getClaimedEd25519Key","getForwardingCurve25519KeyChain","isKeySourceUntrusted","getKeyForwardingUser","setUnsigned","unmarkLocallyRedacted","redacted_because","markLocallyRedacted","redactionEvent","applyVisibilityEvent","visibilityChange","_visibilityChange$vis","_visibilityChange$rea","change","messageVisibility","makeRedacted","REDACT_KEEP_KEYS","keeps","REDACT_KEEP_CONTENT_MAP","moveAllRelatedToMainTimeline","moveToMainTimeline","_event$getRelation","getRelation","asVisibilityChange","relation","isVisibilityEvent","getRedactionEvent","_this$clearEvent","_this$event$unsigned","_this$clearEvent$unsi","_this$clearEvent2","pushDetails","pushActions","_this$getAge","oldUnsigned","oldId","isSending","replaceLocalEventId","relType","_this$getWireContent3","_this$getWireContent$2","makeReplaced","newEvent","getAssociatedStatus","_this$getUnsigned$mR","replacingEventId","replaceRelation","replacingEvent","replacingEventDate","isFinite","_this$_replacingEvent2","localRedactionEvent","hasAssociation","flagCancelled","_isCancelled","isCancelled","toSnapshot","isEquivalentTo","otherEvent","myProps","deepSortedObjectEntries","theirProps","decrypted","encrypted","stopReEmitting","ThreadEvent","setThreadId","_this$event$msc4354_s","_this$event$unsigned2","msc4354_sticky","msc4354_sticky_duration_ttl_ms","RoomJoinRules","join_rule","events_default","redact","state_default","users_default","scopeToEventTypeMap","PolicyScope","PolicyRuleUser","PolicyRuleRoom","Server","PolicyRuleServer","addRule","entity","getOrCreateTargetRoom","recommendation","PolicyRecommendation","removeRule","addSource","sources","getOrCreateSourceRooms","withIgnoreInvitesPolicies","ignoreInvitesPolicies","getRuleForInvite","policyRooms","senderServer","roomServer","entities","glob","regexp","RegExp","globToRegexp","getIgnoreInvitesPolicies","hasChanges","sourceRooms","getPoliciesAndIgnoreInvitesPolicies","policies","IGNORE_INVITES_ACCOUNT_EVENT_KEY","POLICIES_ACCOUNT_EVENT_TYPE","_this$client$getAccou","hasIgnoreInvitesPolicies","PollEvent","filterResponseRelations","relationEvents","pollEndTimestamp","responseEvents","Poll","matrixClient","undecryptableEventIds","previousCount","undecryptableRelationsCount","undecryptableRelationEventIds","UndecryptableRelations","pollEvent","pollId","endEventId","_this$endEvent","endEvent","isEnded","isFetchingResponses","_isFetchingResponses","getResponses","responses","fetchResponses","onNewRelation","_this$endEvent2","validateEndEvent","refilterResponsesOnEnd","End","MAX_SAFE_INTEGER","countUndecryptableEvents","Responses","_this$endEvent3","_allRelations$nextBat","allRelations","relationsNextBatch","Relations","pollEndEvent","pollCloseTimestamp","_this$endEvent4","getRelations","_this$responses","roomCurrentState","endEventSender","maySendRedactionForEvent","isPollEvent","M_POLL_START","RelationsEvent","altEventTypes","onEventStatus","redactedEvent","Annotation","removeAnnotationFromAggregation","targetEvent","lastReplacement","getLastReplacement","onBeforeRedaction","Redaction","relationEventIds","matchesEventType","targetEventType","altTargetEventTypes","addAnnotationToAggregation","Add","maybeEmitCreated","Remove","eventsForKey","annotationsByKey","sortedAnnotationsByKey","aEvents","eventsFromSender","annotationsBySender","_event$getRelation2","getSortedAnnotationsByKey","getAnnotationsBySender","minTs","last","setTargetEvent","replacement","creationEmitted","RelationsCreated","rawDisplayName","updateModifiedTime","markOutOfBand","_isOutOfBand","isOutOfBand","setMembershipEvent","_event$getDirectional","_event$getDirectional2","oldMembership","disambiguate","selfUserId","strippedDisplayName","removeHiddenChars","LTR_RTL_PATTERN","getUserIdsWithDisplayName","shouldDisambiguate","oldName","removeDirectionOverrideChars","calculateDisplayName","Name","powerLevelEvent","oldPowerLevel","PowerLevel","setTypingEvent","oldTyping","typingList","Typing","modified","getLastModifiedTime","isKicked","getDMInviter","memberContent","inviteSender","prev_sender","is_direct","getAvatarUrl","allowDefault","rawUrl","getMxcAvatarUrl","httpUrl","OobStatus","oobMemberFlags","NotStarted","getRoomVersion","getVersionWarning","getJoinedMemberCount","summaryJoinedMemberCount","joinedMemberCount","getMembers","setJoinedMemberCount","getInvitedMemberCount","summaryInvitedMemberCount","invitedMemberCount","setInvitedMemberCount","getMembersExcept","excludedIds","sentinel","sentinels","hasLiveBeacons","_this$liveBeaconIds","liveBeaconIds","_liveBeaconIds","copy","eventsByStateKey","Finished","_copy$getMember","unknownStateEvents","markerFoundOptions","setBeacon","lastStateEvent","getStateEventMatching","_event$getContent$dis","setStateEvent","updateDisplayNameCache","updateThirdPartyTokenCache","onBeaconLivenessChange","getOrCreateMember","updateMember","creators","getCreators","oldLastModified","pl","powerLevelForUserId","Marker","beacons","beaconByEventIdDict","dict","beacon","processBeaconRelation","beaconInfoEventId","relatedToEventId","NewMember","beaconIdentifier","_event$getRedactionEv","New","BeaconLiveness","_this$events$get$get","_this$events$get","pwrLvlEvent","needsOutOfBandMembers","outOfBandMembersReady","markOutOfBandMembersStarted","InProgress","markOutOfBandMembersFailed","setOutOfBandMember","stateEvent","existingMember","getInviteForThreePidToken","tokenToInvite","_this$displayNameToUs","displayNameToUserIds","mxEvent","maySendEvent","hasSufficientPowerLevelFor","powerLevelsEvent","powerLevels","requiredLevel","isNumber","maySendMessage","maySendEventOfType","mayClientSendStateEvent","stateEventType","maySendStateEvent","_roomMember$powerLeve","eventsLevels","stateDefault","eventsDefault","isSafeInteger","mayTriggerNotifOfType","notifLevelKey","notifLevel","getJoinRule","_joinRuleEvent$getCon","joinRuleEvent","getHistoryVisibility","_historyVisibilityEve","historyVisibilityEvent","Shared","getGuestAccess","_guestAccessEvent$get","guestAccessEvent","predecessorEvent","RoomPredecessor","predecessor_room_id","last_known_event_id","via_servers","third_party_invite","signed","RoomThirdPartyInvite","userIdsToDisplayNames","strippedOldName","existingUserIds","filteredUserIDs","strippedDisplayname","_this$displayNameToUs2","roomVersion","roomCreateEvent","shouldUseHydraForRoomVersion","roomCreateSender","c","Infinity","evContent","isInteger","SAFE_ROOM_VERSIONS","ReadReceipt","myUserId","RoomReceipts","RoomStickyEventsStore","recreateEvent","_this$threadsTimeline","_this$threadsTimeline2","updateThreadRootEvent","threadsTimelineSets","hasCurrentUserParticipated","redactId","stickyEvents","handleRedaction","ex","applyEventAsRedaction","getTimelineSets","toRedact","pendingEventOrdering","Chronological","normalizedName","Receipt","onReceipt","timelineSets","fixUpLegacyTimelineFields","Detached","pendingEventList","decrypt","serializedEvent","membersPromise","createThreadsTimelineSets","_this$client","threadTimelineSetsPromise","createThreadTimelineSet","My","decryptCriticalEvents","readReceiptEventId","readReceiptTimelineIndex","findIndex","decryptionPromises","allSettled","decryptAllEvents","getCreator","_createEvent$getSende","getVersion","getRecommendedVersion","capabilities","versionCap","default","safeVer","RoomVersionStability","checkVersionAgainstCapability","urgent","needsUpgrade","currentVersion","userMayUpgradeRoom","removePendingEvent","savePendingEvents","_this$pendingEventLis","_this$pendingEventLis2","getPendingEvent","_this$pendingEventLis3","_this$pendingEventLis4","getLastActiveTimestamp","MIN_SAFE_INTEGER","getLastLiveEvent","_lastRoomEvent$getTs","_lastThreadEvent$getT","lastRoomEvent","lastThread","getLastThread","lastThreadEvent","getThreads","_threadEvent$getTs","_lastThreadEvent$getT2","threadEvent","_this$selfMembership","selfMembership","me","_this$heroes","getInvitedAndJoinedMemberCount","heroes","guessDMUserId","inviterId","anyMember","getFunctionalMembers","mFunctionalMembers","service_members","getAvatarFallbackMember","_this$heroes2","functionalMembers","nonFunctionalMemberCount","nonFunctionalHeroes","h","hasHeroes","hero","fromMSC4186","heroMember","availableMember","nonFunctionalMembers","availableUser","updateMyMembership","prevMembership","cleanupAfterLeaving","MyMembership","loadMembersFromServer","lastSyncToken","getSyncToken","loadMembers","fromServer","rawMembersEvents","memberEvents","membersLoaded","loadMembersIfNeeded","inMemoryUpdate","recalculate","oobMembers","_m$events$member","clearLoadedMembersIfNeeded","refreshLiveTimeline","liveTimelineBefore","backwardPaginationToken","eventsBefore","mostRecentEventInTimeline","TimelineRefresh","setTimelineNeedsRefresh","previousOldState","previousCurrentState","OldStateUpdated","CurrentStateUpdated","clearNotificationsOnReceipt","threadIds","hasUnthreadedReceipt","receiptGroup","userReceipt","singleReceipt","typedSingleReceipt","getThreadUnreadNotificationCount","_this$getThread","maxHistory","highlightCount","_pushActions$tweaks","timelineNeedsRefresh","getTimelineNeedsRefresh","getRoomUnreadNotificationCount","threadNotification","threadNotifications","_threadNotification$t","_this$notificationCou","notificationCounts","_this$threadNotificat","_this$threadNotificat2","hasThreadUnreadNotification","_notification$highlig","_notification$total","_this$threadNotificat3","_this$threadNotificat4","UnreadNotifications","threadsAggregateNotificationType","_threadNotification$h","_threadNotification$t2","resetThreadUnreadNotificationCountFromSync","exceptThreadIds","notifs","setBumpStamp","bumpStamp","getBumpStamp","setUnread","setSummary","summary","_summary$mHeroes","joinedCount","invitedCount","Summary","setMSC4186SummaryData","setBlacklistUnverifiedDevices","blacklistUnverifiedDevices","getBlacklistUnverifiedDevices","mainUrl","_this$currentState$ge","RoomAvatar","getCanonicalAlias","_this$currentState$ge2","canonicalAlias","RoomCanonicalAlias","getAltAliases","_this$currentState$ge3","altAliases","alt_aliases","_this$threads$get","getJoinedMembers","getMembersWithMembership","getEncryptionTargetMembers","shouldEncryptForInvitedMembers","_ev$getContent","getDefaultRoomName","calculateRoomName","getOrCreateFilteredTimelineSet","prepopulateTimeline","useSyncEvents","filteredTimelineSets","unfilteredLiveTimeline","livePaginationToken","getThreadListFilter","filterType","FILTER_RELATED_BY_REL_TYPES","FILTER_RELATED_BY_SENDERS","currentUserParticipated","createThread","fetchRoomThreads","threadsReady","fetchRoomThreadList","allThreadsFilter","threadRoots","eventA","eventB","threadAMetadata","threadBMetadata","latest_event","latestMyThreadsRootEvent","_this$threadsTimeline3","Ignore","threadRelationship","_this$threadsTimeline4","current_user_participated","NewReply","onThreadReply","onThreadUpdate","onThreadDelete","processPollEvent","maybeDecryptedEvent","poll","polls","updateThreadRootEvents","_timeline$getEvents","roomEvent","clearEventMetadata","removeFilteredTimelineSet","roots","_this$client2","isThreadRelation","_this$findEventById","addThreadedEvents","addEvents","_this$findEventById2","tryApplyRedaction","eventsByThread","_eventsByThread","threadEvents","_this$cachedThreadRea","relatedEvents","getAllChildEventsForEvent","receipts","cachedThreadReadReceipts","initialEventsFetched","currentStateEvent","visibilityEvents","redactVisibilityChangeEvent","processLiveEvent","applyNewVisibilityEvent","applyPendingVisibilityEvents","transaction_id","tid","txnToEvent","addLiveEventOptions","addReceipt","synthesizeReceipt","aggregateNonLiveRelation","LocalEchoUpdated","isEventEncrypted","setPendingEvents","getEventForTxnId","remoteEvent","oldStatus","allowed","ALLOWED_TRANSITIONS","removedEvent","revertRedactionLocalEcho","RedactionCancelled","assertTimelineSetsAreLive","addLiveEvents","findThreadRoots","neighbouringEvents","_eventsByThread$threa","existingEvent","memo","synthetic","roomReceipts","_receipt$thread_id","_this$unthreadedRecei","_this$unthreadedRecei2","receipt","receiptForMainTimeline","receiptDestination","_this$cachedThreadRea2","addReceiptToStructure","lastEvent","oldestThreadedReceiptTs","unthreadedReceipts","addEphemeralEvents","removeEvents","eventIds","removedAny","membershipEvent","invite_room_state","strippedEvent","normalize","RoomSummary","title","addTags","tags","Tags","addAccountData","accountData","getStickyEvents","_unstable_getKeyedStickyEvent","stickyKey","getKeyedStickyEvent","_unstable_getUnkeyedStickyEvent","getUnkeyedStickyEvent","_unstable_addStickyEvents","addStickyEvents","canInvite","getTypeWarning","isSpaceRoom","isCallRoom","UnstableCall","isElementVideoRoom","ElementVideo","RoomNameType","Actual","Generated","subtype","memberNamesToRoomName","EmptyRoom","ignoreRoomNameEvent","_this$currentState$ge4","inviteJoinCount","excludedUserIds","otherNames","otherMembers","collator","Intl","Collator","compare","thirdPartyInvites","thirdPartyNames","display_name","leftNames","visibilityEventsOnOriginalEvent","index","originalEventId","newVisibility","visibilityEvent","getOldestThreadedReceiptTs","getLastUnthreadedReceiptFor","unreadThreads","leftEventId","rightEventId","_this$getLiveTimeline","countWithoutMe","eventMapper","jsonContext","eventsAfter","EventContext","ourEvent","setPaginateToken","rank","_opts$pendingEventOrd","processRootEventPromise","redaction","replyCount","updatePendingReplyCount","_currentUserParticipated","_this$lastEvent","updateThreadMetadata","shouldSendLocalEchoReceipt","onEcho","onRedaction","onLocalEcho","onTimelineReset","onTimelineEvent","processReceipts","fetchRootEvent","eventData","_this$client$canSuppo","_this$getReadReceiptF","oldReceiptEventId","getReadReceiptForUserId","receiptEvent","isNewestReply","addRelatedThreadEvent","fetchEditsWhereNeeded","_this$client$canSuppo2","_this$replayEvents","_this$timelineSet$rel","replayEvents","getRootEventBundledRelationship","processRootEvent","bundledRelationship","_this$lastEvent2","lastPendingEvent","pendingReplyCount","oldLive","newLive","newBackward","oldForward","updateThreadFromRootEvent","initalEventFetchProm","_this$client$canSuppo3","isAnEncryptedThreadMessage","editEvent","_event$event","replyToEvent","_this$lastPendingEven","ignoreSynthesized","isCurrentUser","beforeFirstThreadedReceipt","lastReplyId","readUpToId","unthreadedReceipt","_this$timeline","_ev$getId","_this$lastReply$getTs","_this$lastReply","_this$room$getLastUnt","_this$room$getLastUnt2","_this$lastReply$getTs2","_this$lastReply2","unthreadedReceiptTs","beforeLastUnthreadedReceipt","EventEmitterEvents","EventEmitter","listener","emitPromised","listeners","l","listenerCount","prependListener","prependOnceListener","removeAllListeners","rawListeners","Presence","CurrentlyActive","LastPresenceTs","setPresenceEvent","firstFire","eventsToFire","currently_active","currentlyActive","status_msg","presenceStatusMsg","lastActiveAgo","last_active_ago","lastPresenceTs","eventToFire","setRawDisplayName","oldUrl","getLastActiveTs","OAuthGrantType","DeviceAuthorization","InvalidTokenError","isRecord","requiredStringProperty","wellKnown","optionalStringProperty","optionalStringArrayProperty","requiredArrayValue","array","validateAuthMetadata","OidcError","OpSupport","AuthorizationCode","isValid","secureRandomBase64Url","len","getRandomValues","chars","randomValueCutoff","entropyBuffer","entropyBufferPos","randomByte","secureRandomStringFrom","UPPERCASE","SECRET_STORAGE_ALGORITHM_V1_AES","accountDataAdapter","getDefaultKeyId","_defaultKey$key","defaultKey","setDefaultKeyId","keyId","newValue","addKey","passphrase","iv","mac","calculateKeyCheck","getKey","hasKey","checkKey","trimTrailingEquals","secret","defaultKeyId","encryption","getSecretStorageKey","encrypt","secretInfo","encInfo","ciphertext","decryption","returned","privateKey","encryptAESSecretStorageItem","decryptAESSecretStorageItem","charCodeAt","clearTimeouts","refreshTimeout","howLong","random","retryTimeout","SlidingSyncState","ExtensionState","SlidingSyncEvent","ReceiptAccumulator","MapWithDefault","setUnthreaded","unthreadedReadReceipts","setThreaded","threadedReadReceipts","getOrCreate","allUnthreaded","allThreaded","receiptsForThread","consumeEphemeralEvents","isSupportedReceiptType","buildAccumulatedReceiptEvent","receiptEventContent","receiptData","recursiveMapToObject","Category","SyncAccumulator","maxTimelineEntries","accumulate","syncResponse","fromDatabase","accumulateRooms","accumulateAccountData","account_data","accumulateRoom","knock","category","knockRooms","accumulateInviteState","accumulateKnockState","inviteRooms","accumulateJoinState","joinRooms","invite_state","currentData","hasAdded","knock_state","_data$ephemeral","_data$state","_data$orgMatrixMsc","_data$timeline","_data$msc4354_sticky","_currentState","_timeline","_accountData","_unreadNotifications","_unreadThreadNotifications","_summary","_receipts","_stickyEvents","unread_notifications","_sum$HEROES_KEY","_sum$JOINED_COUNT_KEY","_sum$INVITED_COUNT_KE","HEROES_KEY","INVITED_COUNT_KEY","JOINED_COUNT_KEY","acc","sum","ephemeral","limited","setState","_data$timeline$prev_b","transformedEvent","_e$unsigned","_localTs","expiresTs","getJSON","forDatabase","_roomData$_stickyEven","roomData","roomJson","evType","msgData","rollBackState","timelineEvent","prevStateEvent","deepCopy","accData","roomsData","eventMap","MSC2716_ROOM_VERSIONS","getFilterName","suffix","SetPresence","defaultClientOpts","initialSyncLimit","resolveInvitesToProfiles","pollTimeout","defaultSyncApiOpts","syncOpts","_roomId","shouldAbortSync","recoverFromSyncStartupError","savedSyncPromise","ThreadUnreadNotifications","buildDefaultFilter","startKeepAlives","_createAndReEmitRoom","markerEvent","onMarkerStateEvent","HistoryImportedWithinTimeline","_data$rooms","leaveRooms","mapSyncResponseToRoomArray","leaveObj","isBrandNewRoom","mapAndInjectRoomEvents","storeRoom","processEventsForNotifs","_this$_peekRoom","_peekRoom","_this$_peekRoom2","oldStateEvents","presenceEvent","resolveInvites","peekPoll","peekRoom","_this$abortController","syncState","_this$syncStateData","syncStateData","keepaliveProm","updateSyncState","_globalThis$window","_globalThis$window$ad","running","onOnline","doSync","savedSyncTokenPromise","getSavedSyncToken","tok","savedSync","syncFromCache","prepareLazyLoadingForSync","currentSyncRequest","firstSyncFilter","savedSyncToken","initialFilter","doSyncRequest","_globalThis$window2","_globalThis$window2$r","_this$abortController2","removeEventListener","keepAliveTimer","connectionReturnedResolvers","nextSyncToken","setSyncToken","syncEventData","catchingUp","processSyncResponse","storeIsInvalid","syncOptions","syncToken","onSyncError","failedSyncCount","oldSyncToken","SyncUnexpectedError","hasSyncedBefore","onSyncCompleted","wantsSave","save","Stopped","_this$abortController3","getSyncParams","getGuestFilter","disablePresence","set_presence","Offline","_cacheBuster","Reconnecting","keepAlivePromise","Catchup","_data$presence","_data$account_data","_this$syncOpts$crypto","_data$device_unused_f","prevEventsMap","storeAccountDataEvents","accountDataEvent","PushRules","prevEvent","to_device","toDeviceMessages","receivedToDeviceMessages","preprocessToDeviceMessages","rawEvent","encryptionInfo","processToDeviceMessages","notifEvents","inviteObj","mapSyncEventsFormat","injectRoomEvents","_joinObj$UNREAD_THREA","joinObj","stateAfterEvents","ephemeralEvents","accountDataEvents","eventsFormingFinalState","_joinObj$unread_notif","_joinObj$unread_notif2","notification_count","highlight_count","unreadThreadNotifications","unreadNotification","_unreadNotification$n","hasNoNotifications","_unreadNotification$h","_syncEventData$oldSyn","onCryptoEvent","stickyEventsAndStickyEventsFromTheTimeline","emitEvent","knockObj","_client$getNotifTimel","device_lists","processDeviceLists","processKeyCounts","device_one_time_keys_count","device_unused_fallback_key_types","pokeKeepAlive","connDidFail","_this$abortController4","success","unsafeProp","requestedProfileInfo","inviteEvent","findEncryptionEvent","wrappedRoom","stateEventList","stateAfterEventList","timelineEventList","eitherStateEventList","newState","old","_client$getUser","cancelledKeyVerificationTxns","processedMessage","processedEvent","toDeviceEvent","deprecatedCompatibilityEvent","senderCurve25519KeyBase64","ToDeviceEvent","ReceivedToDeviceMessage","interns","str","encodeParams","urlSearchParams","URLSearchParams","append","encodeUri","variables","fn","checkObjectHasKeys","x","y","isNaN","pairs","lexicographicCompare","unhomoglyph","removeHiddenCharsRegex","escapeRegExp","string","ensureNoTrailingSlash","ms","logDuration","block","isNullOrUndefined","promiseMapSeries","promiseTry","simpleRetryOperation","promiseFn","shouldRetry","promiseRetry","attempt","retries","factor","minTimeout","maxTimeout","DEFAULT_ALPHABET","fromCharCode","alphabetPad","n","alphabet","padEnd","baseToString","BigInt","_alphabet","d","abs","stringToBase","charIndex","averageBetweenStrings","padN","baseA","baseB","avg","nextString","prevString","recursivelyAssign","source","ignoreNullish","sourceKey","sourceValue","getContentTimestampWithFallback","left","right","mapsEqual","eq","v1","v2","processMapToObjectValue","targetMap","createDefault","aesKey","hmacKey","deriveKeys","decodeBase64","subtle","verify","plaintext","counter","TextDecoder","decode","CallState","CallType","CallDirection","CallParty","CallEvent","CallErrorCode","CALL_TIMEOUT_MS","CallError","genCallID","getCodecParamMods","mediaType","codec","enableDtx","maxAverageBitrate","getTransceiverKey","purpose","MatrixCall","_opts$forceTURN","Fledgling","candidate","candidatesEnded","sdpMid","callHasEnded","queueCandidate","_this$peerConn","peerConn","iceGatheringState","LocalOfferFailed","terminate","Local","successor","getUserMediaFailed","NoUserMedia","placeCallFailed","IceFailed","_this$peerConn2","_this$peerConn3","_this$peerConn$iceCon","_this$peerConn4","_this$peerConn5","_this$peerConn8","iceConnectionState","connectionState","iceDisconnectedTimeout","iceReconnectionTimeOut","Connected","callLengthInterval","callStartTime","LengthChanged","round","_this$peerConn6","_this$peerConn7","restartIce","hangup","_this$peerConn9","_this$peerConn0","_this$peerConn1","Connecting","feed","getRemoteFeeds","setAudioVideoMuted","_this$peerConn10","signalingState","streams","track","stream","pushRemoteFeed","removeTrackListeners","onRemoveTrack","getTracks","deleteFeedByStream","DataChannel","channel","CreateOffer","opponentVersion","queueGotLocalOffer","partyIdMatches","Ringing","Remote","UserHangup","party_id","opponentPartyId","InviteSent","Inbound","AnsweredElsewhere","invitee","ourPartyId","opponentDeviceId","opponentSessionId","groupCallId","isOnlyDataChannelAllowed","placeVoiceCall","placeCall","placeVideoCall","createDataChannel","label","dataChannel","getOpponentMember","opponentMember","getOpponentDeviceId","getOpponentSessionId","opponentCanBeTransferred","opponentCaps","opponentSupportsDTMF","getRemoteAssertedIdentity","remoteAssertedIdentity","_state","State","hasUserMediaVideoSender","hasRemoteUserMediaVideoTrack","Video","Voice","hasLocalUserMediaVideoTrack","_this$localUsermediaS","localUsermediaStream","getVideoTracks","_feed$stream","SDPStreamMetadataPurpose","Usermedia","hasLocalUserMediaAudioTrack","_this$localUsermediaS2","getAudioTracks","hasRemoteUserMediaAudioTrack","_feed$stream2","hasUserMediaAudioSender","_this$transceivers$ge","transceivers","_this$transceivers$ge2","localUsermediaFeed","getLocalFeeds","localScreensharingFeed","Screenshare","_this$localUsermediaF","localScreensharingStream","_this$localScreenshar","remoteUsermediaFeed","remoteScreensharingFeed","remoteUsermediaStream","_this$remoteUsermedia","remoteScreensharingStream","_this$remoteScreensha","getFeedByStreamId","streamId","getFeeds","feeds","isLocal","initOpponentCrypto","_this$getOpponentMemb","hasOpponentDeviceInfo","GroupCallUnknownDeviceError","getLocalSDPStreamMetadata","updateStreamIds","localFeed","sdpMetadataStreamId","audio_muted","isAudioMuted","video_muted","isVideoMuted","noIncomingFeeds","opponentSupportsSDPStreamMetadata","pushRemoteFeedWithoutMetadata","remoteSDPStreamMetadata","audioMuted","videoMuted","CallFeed","FeedsChanged","active","_this$feeds$find","oldRemoteStream","pushNewLocalFeed","addToPeerConnection","setTracksEnabled","pushLocalFeed","callFeed","tKey","transceiver","replaceTrack","addTrack","newTransceiver","getTransceivers","removeLocalFeed","audioTransceiverKey","videoTransceiverKey","transceiverKey","removeTrack","stopScreensharingStream","deleteFeed","deleteAllFeeds","dispose","getCurrentCallStats","callStatsAtEnd","collectCallStats","statsReport","getStats","stats","item","initWithInvite","_this$feeds$find2","sdpStreamMetadata","SDPStreamMetadataKey","updateRemoteSDPStreamMetadata","createPeerConnection","PeerConnectionCreated","chooseOpponent","setRemoteDescription","offer","addBufferedIceCandidates","SetRemoteDescription","remoteStream","ringingTimer","_this$stats","hangupParty","Ended","stopAllMedia","close","removeStatsReportGatherer","Hangup","lifetime","onState","initWithHangup","shouldAnswerWithMediaType","wantedValue","valueOfTheOtherSide","answer","audio","video","inviteOrAnswerSent","waitForLocalAVStream","WaitLocalMedia","prevState","answerWithAudio","answerWithVideo","_this$client$getDevic","getUserMediaStream","answerWithCallFeeds","callFeeds","queueGotCallFeedsForAnswer","replacedBy","newCall","Outbound","suppressEvent","sendVoipEvent","CallHangup","CallReject","upgradeCall","getAudio","getVideo","updateLocalUsermediaStream","isScreensharing","setScreensharingEnabled","setScreensharingEnabledWithoutMetadataSupport","audioTransceiver","videoTransceiver","getScreensharingStream","_this$localUsermediaS3","_this$transceivers$ge4","_this$transceivers$ge3","forceAudio","forceVideo","audioEnabled","remoteOnHold","videoEnabled","oldSender","setLocalVideoMuted","muted","_this$localUsermediaF3","_this$localUsermediaF2","stopVideoTrackTimer","hasVideoDevice","isLocalVideoMuted","updateMuteStatus","sendMetadataUpdate","_this$localUsermediaF4","_this$localUsermediaF5","setMicrophoneMuted","_this$localUsermediaF6","hasAudioDevice","isMicrophoneMuted","_this$localUsermediaF7","_this$localUsermediaF8","isRemoteOnHold","setRemoteOnHold","onHold","RemoteHoldUnhold","isLocalOnHold","callOnHold","currentDirection","sendDtmfDigit","digit","getSenders","_sender$track","dtmf","insertDTMF","micShouldBeMuted","vidShouldBeMuted","CallSDPStreamMetadataChangedPrefix","gotCallFeedsForInvite","requestScreenshareFeed","addTransceiver","sendAnswer","answerContent","sdp","localDescription","discardCount","discardDuplicateCandidates","CallAnswer","SendAnswer","UnknownDevices","sendCandidateQueue","responsePromiseChain","gotCallFeedsForAnswer","mungeSdp","mods","parseSdp","media","payloadTypeToCodecMap","codecToPayloadTypeMap","rtp","mod","extraConfig","found","fmtp","config","writeSdp","createOffer","createAnswer","CreateAnswer","getRidOfRTXCodecs","setLocalDescription","SetLocalDescription","onRemoteIceCandidatesReceived","candidates","fromPartyId","addIceCandidates","bufferedCandidates","remoteCandidateBuffer","onAnswerReceived","isSettingRemoteAnswerPending","CallSelectAnswer","selected_party_id","onSelectAnswerReceived","selectedPartyId","onNegotiateReceived","polite","readyForOffer","makingOffer","offerCollision","ignoreOffer","prevLocalOnHold","_localDescription","CallNegotiate","newLocalOnHold","LocalHoldUnhold","HoldUnhold","_streamId","onSDPStreamMetadataChangedReceived","onAssertedIdentityReceived","asserted_identity","AssertedIdentityChanged","wrappedGotLocalOffer","gotLocalOffer","getLocalOfferFailed","CallInvite","_localDescription2","_localDescription3","SignallingFailed","SendInvite","inviteTimeout","InviteTimeout","RTCRtpReceiver","RTCRtpSender","screenshareVideoTransceiver","setCodecPreferences","recvCodecs","codecs","sendCodecs","mimeType","pop","realContent","conf_id","_this$getOpponentMemb2","toDeviceSeq","sender_session_id","dest_session_id","uuidv4","SendVoipEvent","_this$getOpponentMemb3","candidateSendQueue","candidateSendTries","newQueue","transfer","targetUserId","profileInfo","replacementId","replacement_id","target_user","create_call","CallReplaces","Transferred","transferToCall","transferTargetCall","_transferTargetCall$g","_this$getOpponentMemb4","targetProfileInfo","opponentUserId","transfereeProfileInfo","newCallId","bodyToTransferTarget","await_call","bodyToTransferee","hangupReason","shouldEmit","_this$stats2","calls","stopUserMediaStream","checkForErrorListener","CallCandidates","delayMs","pow","_this$client$getDevic2","placeCallWithCallFeeds","_this$stats3","pc","RTCPeerConnection","iceTransportPolicy","iceServers","bundlePolicy","onIceConnectionStateChanged","onSignallingStateChanged","gotLocalIceCandidate","onIceGatheringStateChange","onTrack","onNegotiationNeeded","onDataChannel","opponentMemberId","addStatsReportGatherer","_getMember","_this$stats4","updateOpponentMember","sdpMLineIndex","addIceCandidate","hasPeerConnection","initStats","peerId","tracks","_window$RTCPeerConnec","RTCSessionDescription","RTCIceCandidate","mediaDevices","optionsForceTURN","SPEAKING_THRESHOLD","CallFeedEvent","NewStream","connected","analyser","measuringVolumeActivity","getFloatFrequencyData","frequencyBinCount","maxVolume","volume","speakingVolumeSamples","shift","VolumeChanged","newSpeaking","speakingThreshold","speaking","Speaking","volumeLooperTimeout","volumeLooper","fill","updateStream","hasAudioTrack","initVolumeMeasuring","onCallState","_connected","ConnectedChanged","oldStream","newStream","wasMeasuringVolumeActivity","onAddTrack","measureVolumeActivity","audioContext","acquireContext","createAnalyser","fftSize","smoothingTimeConstant","createMediaStreamSource","Float32Array","_callRoom$getMember","callRoom","isSpeaking","setNewStream","MuteStateChanged","setSpeakingThreshold","threshold","userMediaStreams","screensharingStreams","_this$stream","_this$call","releaseContext","_disposed","Disposed","disposed","getLocalVolume","localVolume","setLocalVolume","LocalVolumeChanged","GroupCallIntent","GroupCallType","GroupCallTerminationReason","GroupCallEvent","GroupCallStatsReportEvent","GroupCallErrorCode","GroupCallError","UnknownDevice","GroupCallState","DEVICE_TIMEOUT","getCallUserId","_call$getOpponentMemb","isCallWithoutVideoAndAudio","useLivekit","_room$currentState$ge","_room$currentState$ge2","report","ConnectionStats","ByteSentStats","SummaryStatsReportGatherer","extendSummaryReport","participants","SummaryStats","localCallFeed","CallFeedStatsReporter","expandCallFeedReport","forEachCall","CallFeedStats","LocalCallFeedUninitialized","_newCall$getOpponentM","_this$calls$get","deviceMap","prevCall","initCall","callExpected","CallsChanged","needsRetry","participantMap","callMap","retriesMap","retryCallCounts","participant","_retriesMap$get","_retriesMap","wantsOutgoingCall","placeOutgoingCalls","currentUserMediaFeed","getUserMediaFeed","remoteFeedChanged","currentCallForUserDevice","addUserMediaFeed","replaceUserMediaFeed","removeUserMediaFeed","currentScreenshareFeed","getScreenshareFeed","addScreenshareFeed","replaceScreenshareFeed","removeScreenshareFeed","_oldState","_call$getOpponentMemb2","_call$getOpponentMemb3","_call$getOpponentMemb4","disposeCall","topAvg","nextActiveSpeaker","userMediaFeeds","activeSpeaker","ActiveSpeakerChanged","updateParticipants","expected","Entered","updateMemberState","ReEmitter","_livekitServiceURL","creationTs","GroupCallPrefix","ParticipantsChanged","onParticipantsChanged","GroupCallStateChanged","onStateChanged","LocalScreenshareStateChanged","onLocalFeedsChanged","allowCallWithoutVideoAndAudio","GroupCallEventHandlerEvent","Outgoing","sendCallStateEvent","groupCallState","updateLivekitServiceURL","prevValue","_participants","participantStateEqual","screensharing","deviceMapsEqual","_creationTs","enteredViaAnotherSession","_enteredViaAnotherSession","localScreenshareFeed","hasLocalParticipant","_this$participants$ge","_this$participants$ge2","_this$participants$ge3","initLocalCallFeed","InitializingLocalCallFeed","initCallFeedPromise","initLocalCallFeedInternal","MediaStream","initWithAudioMuted","initWithVideoMuted","LocalCallFeedInitialized","enter","CallEventHandlerEvent","Incoming","onIncomingCall","retryCallLoopInterval","onRetryCallLoop","retryCallInterval","onActiveSpeakerLoop","activeSpeakerLoopInterval","activeSpeakerInterval","localDesktopCapturerSourceId","stopAllStreams","transmitTimer","participantsExpirationTimer","emitStateEvent","existingStateEvent","CallEnded","sendUpdatesBefore","pttMaxTransmitTime","_call$localUsermediaF","sendUpdates","updates","checkAudioPermissionIfNecessary","LocalMuteStateChanged","onTrackEnded","desktopCapturerSourceId","throwOnFail","localUserId","localDeviceId","callsChanged","_this$calls$get2","NewSession","PlaceCallFailed","getMemberStateEvents","onCallFeedsChanged","onCallStateChanged","onCallHangup","onCallReplaced","callHandlers","getGroupCallStats","usermediaFeed","screenshareFeed","UserMediaFeedsChanged","existingFeed","replacementFeed","feedIndex","screenshareFeeds","ScreenshareFeedsChanged","localMember","entered","nextExpiration","validDevices","session_id","expires_ts","updateDevices","keepAlive","_event$getContent","otherCalls","newDevices","newCalls","newContent","addDeviceToMemberState","resendMemberStateTimer","cleanMemberState","myDevices","device","last_seen_ts","userID","GroupCallStats","statsCollectIntervalTime","reports","StatsReport","CONNECTION_STATS","onConnectionStats","BYTE_SENT_STATS","onByteSentStats","SUMMARY_STATS","onSummaryStats","CALL_FEED_REPORT","onCallFeedReport","setGroupCallStatsInterval","interval","MediaHandlerEvent","restoreMediaSettings","audioInput","videoInput","setAudioInput","updateLocalUsermediaStreams","setAudioSettings","audioSettings","setVideoInput","setMediaInputs","callMediaStreamParams","localUserMediaStream","groupCall","LocalStreamsChanged","enumerateDevices","reusable","getMediaStreamPromise","getUserMediaStreamInternal","shouldRequestAudio","shouldRequestVideo","canReuseStream","_this$localUserMediaS","_this$localUserMediaS2","getSettings","_this$localUserMediaS3","constraints","getUserMediaContraints","getUserMedia","settings","mediaStream","_this$localUserMediaS4","getTrackById","screenshareConstraints","getScreenshareContraints","getDisplayMedia","matchingStream","exactDeviceId","isWebkit","webkitGetUserMedia","deviceIdKey","audioConstraints","autoGainControl","ideal","echoCancellation","noiseSuppression","videoConstraints","exact","mandatory","chromeMediaSource","chromeMediaSourceId","objectToString","errorMessages","isNetworkError","stack","validateNumberOption","allowInfinity","AbortError","originalError","onAttemptFailure","attemptNumber","startTime","maxRetryTime","normalizedError","retriesLeft","createRetryContext","onFailedAttempt","currentTime","delayTime","randomize","calculateDelay","timeLeft","finalDelay","onAbort","timeoutToken","unref","throwIfAborted","pRetry","validateRetries","hasOwn","POSITIVE_INFINITY","resolvedMaxRetryTime","REPLACE_RE","replace_fn","module","exports"],"ignoreList":[],"sourceRoot":""}